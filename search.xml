<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深度学习入门</title>
      <link href="/2024/01/21/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"/>
      <url>/2024/01/21/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>安装anaconda后，使用conda指令创建pytorch环境：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda create -n pytorch python=3.8.18</span><br><span class="line"></span><br><span class="line">创建完毕后，使用命令激活/关闭环境：</span><br><span class="line">conda activate pytorch</span><br><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><img src="/Users/donn/Library/Application Support/typora-user-images/image-20240123093149437.png" alt="image-20240123093149437" style="zoom:50%;" /><p>在pytorch命令行环境下安装pytorch：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(pytorch) donn@Macc ~ % pip3 install torch torchvision torchaudio</span><br></pre></td></tr></table></figure><p>测试是否安装完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.进入python环境</span><br><span class="line">2.import torch 若未报错，则说明安装成功</span><br></pre></td></tr></table></figure><p>tensorboard使用：</p><p>–方便地用于记录训练过程中各个阶段的输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir=logs --port=6007       </span><br></pre></td></tr></table></figure><p>安装opencv：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure><p>获取numpy类型的图像：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">image_path = <span class="string">&quot;dataset/train/ants_image/0013035.jpg&quot;</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">img = Image.<span class="built_in">open</span>(image_path)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(img))</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;PIL.JpegImagePlugin.JpegImageFile&#x27;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img_array = np.array(img)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(img_array))</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.ndarray&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>transforms结构及用法：</p><p><u>就是一个封装了对图片进行操作的工具库</u></p><p>​transforms.py工具箱：</p><ul><li>totensor</li><li>resize</li><li>……</li></ul><p>tensor数据类型：</p><p>​tensor数据类型含有神经网络中需要的各种参数</p><p>如何读取Numpy型图像数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">cv_img = cv2.imread(img_path)</span><br></pre></td></tr></table></figure><p>读取PIL类型图像数据实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_dir, label_dir</span>):</span><br><span class="line">        self.root_dir = root_dir</span><br><span class="line">        self.label_dir = label_dir</span><br><span class="line">        self.path = os.path.join(self.root_dir, self.label_dir)</span><br><span class="line">        self.img_path = os.listdir(self.path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        img_name = self.img_path[idx]</span><br><span class="line">        img_item_path = os.path.join(self.root_dir, self.label_dir, img_name)</span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_item_path)</span><br><span class="line">        label = self.label_dir</span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.img_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root_dir = <span class="string">&quot;dataset/train&quot;</span></span><br><span class="line">ants_label_dir = <span class="string">&quot;ants_image&quot;</span></span><br><span class="line">bees_label_dir = <span class="string">&quot;bees_image&quot;</span></span><br><span class="line">ants_dataset = MyData(root_dir, ants_label_dir)</span><br><span class="line">bees_dataset = MyData(root_dir, bees_label_dir)</span><br><span class="line">train_dataset = ants_dataset + bees_dataset</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="常见的transforms："><a href="#常见的transforms：" class="headerlink" title="常见的transforms："></a>常见的transforms：</h2><h4 id="Normalize"><a href="#Normalize" class="headerlink" title="Normalize:"></a>Normalize:</h4><p>归一化操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># output[channel] = (input[channel] - mean[channel]) / std[channel]</span></span><br><span class="line"><span class="comment"># print(img_tensor[0][0][0])</span></span><br><span class="line">trans_norm = transforms.Normalize([<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>], [<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>])</span><br><span class="line">img_norm = trans_norm(img_tensor)</span><br><span class="line"><span class="comment"># print(img_norm[0][0][0])</span></span><br><span class="line">writer.add_image(<span class="string">&quot;Normalize&quot;</span>, img_norm, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="Resize："><a href="#Resize：" class="headerlink" title="Resize："></a>Resize：</h4><p>缩放，<strong>输入为PIL数据类型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Resize</span></span><br><span class="line"><span class="built_in">print</span>(img.size)</span><br><span class="line">trans_resize = transforms.Resize((<span class="number">512</span>, <span class="number">512</span>))</span><br><span class="line">img_resize = trans_resize(img)</span><br><span class="line">img_resize = trans_totensor(img_resize)</span><br><span class="line">writer.add_image(<span class="string">&quot;Resize&quot;</span>, img_resize, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(img_resize)</span><br></pre></td></tr></table></figure><h4 id="Compose："><a href="#Compose：" class="headerlink" title="Compose："></a>Compose：</h4><p>等比缩放(锁定长宽比)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Compose</span></span><br><span class="line">trans_resize_2 = transforms.Resize(<span class="number">256</span>)</span><br><span class="line">trans_compose = transforms.Compose([trans_resize_2, trans_totensor])</span><br><span class="line">img_resize_2 = trans_compose(img)</span><br><span class="line">writer.add_image(<span class="string">&quot;Resize&quot;</span>, img_resize_2, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>总结用法：</p><ul><li>使用时先看源码，关注方法输入和输出的数据类型<ul><li>不知道返回值数据类型时，print试试或者debug看看参数</li></ul></li><li>多看官方文档</li><li>关注方法需要的参数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu安装yum</title>
      <link href="/2023/12/20/ubuntu%E5%AE%89%E8%A3%85yum/"/>
      <url>/2023/12/20/ubuntu%E5%AE%89%E8%A3%85yum/</url>
      
        <content type="html"><![CDATA[<h3 id="ubuntu安装yum"><a href="#ubuntu安装yum" class="headerlink" title="ubuntu安装yum"></a>ubuntu安装yum</h3><p>最近搞了一台服务器，自己折腾的时候用到了yum，发现使用apt-get下载yum时一直报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@iZbp1cml7iso80jlaxx2uZ:/tjy# apt-get install yum</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree... Done</span><br><span class="line">Reading state information... Done</span><br><span class="line">E: Unable to locate package yum</span><br></pre></td></tr></table></figure><p>网上搜了半天，解决方案无非是：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get upgrade</span><br></pre></td></tr></table></figure><p>但是根据我的实际情况，更新apt的库后没有用</p><p>最终解决方案：</p><ol><li>备份sources.list文件</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.backup</span><br></pre></td></tr></table></figure><ol start="2"><li>修改源</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>​进入vim后</p><ul><li><p>进入Normal模式（按Esc键）。</p></li><li><p>输入ggdG并按Enter键。这将会从当前光标位置开始到文件的最后行都被删除。</p></li><li><p>删除过后，我们先查看服务器的ubuntu版本</p></li><li><p>进入<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">清华镜像源</a>获取镜像内容，</p><ul><li><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20231220143915710.png" alt="image-20231220143915710"></p></li><li><p>选好ubuntu版本后复制框中内容至&#x2F;etc&#x2F;apt&#x2F;sources.list</p></li><li><p>在&#x2F;etc&#x2F;apt&#x2F;sources.list的第一行再加入：</p><ul><li><pre><code class="sh">deb http://archive.ubuntu.com/ubuntu/ trusty main universe restricted multiverse<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在我的机子上，sources.list内容如下：</span><br><span class="line"></span><br><span class="line">  ```sh</span><br><span class="line">  deb http://archive.ubuntu.com/ubuntu/ trusty main universe restricted multiverse</span><br><span class="line">  # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">  deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line">  # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line">  deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line">  # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line">  deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line">  # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line">  </span><br><span class="line">  deb http://security.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line">  # deb-src http://security.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line">  </span><br><span class="line">  # 预发布软件源，不建议启用</span><br><span class="line">  # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="line">  # # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li><li><p>最后输入”:wq”再回车就修改完毕了</p></li></ul><ol start="3"><li>修改过后，需要从新的源加载</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><ol start="4"><li>之后我们再安装yum：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install yum</span><br></pre></td></tr></table></figure><p>这时候我遇到了报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@iZbp1cmlu7iso80jlaxx2uZ:/etc/apt<span class="comment"># sudo apt-get install yum</span></span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree... Done</span><br><span class="line">Reading state information... Done</span><br><span class="line">E: Unable to locate package yum</span><br><span class="line">root@iZbp1cmlu7iso80jlaxx2uZ:/etc/apt<span class="comment"># sudo apt-key adv –keyserver keyserver.ubuntu.com –recv-keys 40976EAF437D05B5</span></span><br><span class="line">Warning: apt-key is deprecated. Manage keyring files <span class="keyword">in</span> trusted.gpg.d instead (see apt-key(8)).</span><br><span class="line">Executing: /tmp/apt-key-gpghome.J976Sq2yFx/gpg.1.sh –keyserver keyserver.ubuntu.com –recv-keys 40976EAF437D05B5</span><br><span class="line">gpg: WARNING: no <span class="built_in">command</span> supplied.  Trying to guess what you mean ...</span><br><span class="line">usage: gpg [options] [filename]</span><br><span class="line">root@iZbp1cmlu7iso80jlaxx2uZ:/etc/apt<span class="comment"># sudo apt-key adv –keyserver keyserver.ubuntu.com –recv-keys 3B4FE6ACC0B21F32</span></span><br><span class="line">Warning: apt-key is deprecated. Manage keyring files <span class="keyword">in</span> trusted.gpg.d instead (see apt-key(8)).</span><br><span class="line">Executing: /tmp/apt-key-gpghome.1L1qF3G0X7/gpg.1.sh –keyserver keyserver.ubuntu.com –recv-keys 3B4FE6ACC0B21F32</span><br><span class="line">gpg: WARNING: no <span class="built_in">command</span> supplied.  Trying to guess what you mean ...</span><br><span class="line">usage: gpg [options] [filename]</span><br></pre></td></tr></table></figure><p>从报错提示可看出 没有指定的公钥，执行命令安装指定的公钥即可</p><ol start="5"><li><strong>安装公钥</strong>(后8位即可代表公钥)：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --recv-keys --keyserver keyserver.Ubuntu.com 437D05B5</span><br><span class="line">sudo apt-key adv --recv-keys --keyserver keyserver.Ubuntu.com C0B21F32</span><br></pre></td></tr></table></figure><ol start="6"><li>安装公钥后，重新加载apt库</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get upgrade</span><br></pre></td></tr></table></figure><p>出现了以下警告：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The following packages have unmet dependencies:</span><br><span class="line"> python3-six : Breaks: libpython-stdlib (&lt; 2.7.18) but 2.7.5-5ubuntu3 is to be installed</span><br><span class="line">               Breaks: python-minimal (&lt; 2.7.18) but 2.7.5-5ubuntu3 is to be installed</span><br><span class="line"> python3-yaml : Breaks: libpython-stdlib (&lt; 2.7.18) but 2.7.5-5ubuntu3 is to be installed</span><br><span class="line">                Breaks: python-minimal (&lt; 2.7.18) but 2.7.5-5ubuntu3 is to be installed</span><br><span class="line">E: Error, pkgProblemResolver::Resolve generated breaks, this may be caused by held packages.</span><br></pre></td></tr></table></figure><ol start="7"><li><p>我们根据提示安装所需即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libpython-stdlib</span><br><span class="line">sudo apt install python-minimal</span><br></pre></td></tr></table></figure></li><li><p>最后，终于安装成功！</p></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install yum</span><br></pre></td></tr></table></figure><p>成果展示：</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20231220144907106.png" alt="image-20231220144907106" style="zoom:50%;" /><h3 id="后续问题："><a href="#后续问题：" class="headerlink" title="后续问题："></a>后续问题：</h3><p>安装好yum后，尝试使用yum安装一些应用，结果报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@iZbp1cmlu7iso80jlaxx2uZ:/tjy<span class="comment"># yum -y install mlocate</span></span><br><span class="line">There are no enabled repos.</span><br><span class="line"> Run <span class="string">&quot;yum repolist all&quot;</span> to see the repos you have.</span><br><span class="line"> You can <span class="built_in">enable</span> repos with yum-config-manager --<span class="built_in">enable</span> &lt;repo&gt;</span><br><span class="line">root@iZbp1cmlu7iso80jlaxx2uZ:/tjy<span class="comment"># yum repolist all</span></span><br><span class="line">repolist: 0</span><br></pre></td></tr></table></figure><p>这是因为我们没有repo文件….</p><p>其实Linux系统基本上分为两大类:</p><p>RedHat系列：Redhat、Centos、Fedora等</p><ul><li>使用 <code>yum</code> 命令安装软件包</li></ul><p>Debian系列：Debian、Ubuntu等</p><ul><li>使用 <code>apt-get</code> 命令安装软件包</li></ul><p>⚠️因此由于<code>Ubuntu</code>属于<code>Debian系列</code>中直接用<code>apt-get</code>进行软件包下载即可，至于在Ubuntu中安装yum则是一个十分愚蠢的操作，这真的给本人好好上了一课。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统原理学习</title>
      <link href="/2023/10/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/10/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="硬件结构："><a href="#硬件结构：" class="headerlink" title="硬件结构："></a>硬件结构：</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 原理学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习</title>
      <link href="/2023/09/28/Docker%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/09/28/Docker%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>基本概念：</p><p>镜像：</p><p>容器：</p><p>仓库：</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8新特性学习</title>
      <link href="/2023/09/21/java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/09/21/java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/enhancements.html#javase8">Java8官方文档</a></p><h1 id="Lambda表达式："><a href="#Lambda表达式：" class="headerlink" title="Lambda表达式："></a>Lambda表达式：</h1><h3 id="Lambda表达式语法基础："><a href="#Lambda表达式语法基础：" class="headerlink" title="Lambda表达式语法基础："></a>Lambda表达式语法基础：</h3><p>​关键运算符： <code>-&gt;</code> (箭头操作符或Lambda 操作符)</p><p>格式：Lambda 表达式参数列表 -&gt; Lambda 表达式中所需要执行的功能，即Lambda 体</p><p><strong>语法格式一：无参数，无返回值。</strong></p><p>​    () -&gt;System.out.println(“Hello”);</p><p><strong>语法格式二：有一个参数，并且无返回值。</strong></p><p>​    (e) -&gt; System.out.println(e);</p><p><strong>语法格式三：若只有一个参数，参数的小括号可以省略。</strong></p><p>​    e -&gt; System.out.println(e);</p><p><strong>语法格式四：有两个以上的参数，又返回值，有多条执行语句。</strong></p><p>​    (x,y)-&gt; {</p><p>​      System.out.println(“Lambda”);</p><p>​      return Integer.compare(x,y);</p><p>​    };</p><p><strong>语法格式五：如果有两个以上的参数，又返回值，只有一条执行语句，Lambda 体的大括号和return可以省略。</strong></p><p>​    Comparator<Integer>con&#x3D;(x,y)-&gt;Integer.compare(x,y);</p><p><strong>语法格式六：Lambda表达式的参数列表的数据类型可以省略不写，因为JVM编译器可以通过上下文推断出数据类型，即“类型推断”。</strong></p><p>​    (Integer x,Integery)-&gt;Integer.compare(x,y);</p><h1 id="函数式接口："><a href="#函数式接口：" class="headerlink" title="函数式接口："></a>函数式接口：</h1><p>Lambda表达式函数式接口的使用情景：</p><p>函数式接口：只定义一个抽象方法的接口</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用案例</span></span><br><span class="line">Comparator&lt;Integer&gt; cmp = (o1, o2) -&gt; o2 - o1;</span><br></pre></td></tr></table></figure><h1 id="Stream："><a href="#Stream：" class="headerlink" title="Stream："></a>Stream：</h1><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p><p>我们通常对<code>数组</code>、<code>集合</code>等数据进行stream操作</p><ol><li><p>在进行流操作前，我们需要将这些数据流化，即data.stream()</p></li><li><p>得到数据的流对象后，我们才能使用Stream中的API对其进行操作！</p><p>以下是一些常用的API：</p><ul><li><p><strong>map</strong></p><p>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 获取对应的平方数</span></span><br><span class="line">List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure></li><li><p><strong>filter</strong></p><p>filter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤出空字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line"><span class="comment">// 获取空字符串的数量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure></li><li><p><strong>limit</strong></p><p>limit 方法用于获取指定数量的流。 以下代码片段使用 limit 方法打印出 10 条数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li><li><p><strong>sorted</strong></p><p>sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>综合例子🌰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;People&gt; <span class="title function_">createPeople</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">1</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;Zlan&quot;</span>, <span class="number">0</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;Clerk&quot;</span>, <span class="number">0</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;Don&quot;</span>, <span class="number">1</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;Eric&quot;</span>, <span class="number">0</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;People&gt; people = createPeople();</span><br><span class="line">  List&lt;String&gt; name = people.stream()</span><br><span class="line">          .filter(o1 -&gt; o1.getSex() == <span class="number">0</span>)</span><br><span class="line">          .map(o1 -&gt; o1.getName().toUpperCase())</span><br><span class="line">          .sorted(Comparator.reverseOrder())</span><br><span class="line">          .limit(<span class="number">2</span>)</span><br><span class="line">          .collect(Collectors.toList());</span><br><span class="line">  System.out.println(name);</span><br></pre></td></tr></table></figure><p>本文为小白作者对java8新特性中的Lambda表达式以及Stream相关API的粗浅了解，仅仅介绍了一些常见的用法，详细的用法以及底层实现原理并未深究，</p><p>参考文章：</p><ul><li><a href="https://developer.aliyun.com/article/1113942?accounttraceid=a69383829bf74e65a0a1ee91fd532b96ceru">Java 8 新特性</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发编程</title>
      <link href="/2023/09/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/09/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA并发编程"><a href="#JAVA并发编程" class="headerlink" title="JAVA并发编程"></a>JAVA并发编程</h1><h3 id="synchronize的作用范围："><a href="#synchronize的作用范围：" class="headerlink" title="synchronize的作用范围："></a>synchronize的作用范围：</h3><ul><li><strong>修饰实例方法:</strong> 对当前<u>对象实例加锁</u>，<u>进入同步代码前要获得当前对象实例的锁</u></li><li><strong>修饰静态方法:</strong> 也就是给当前<u>类加锁</u>，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。**<u>🌟所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的</u><strong>，不会发生互斥现象，</strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁**。</li><li><strong>修饰代码块:</strong> 指定加锁<u>对象</u>，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>synchronize 可以锁住类，也可以锁住类的某个对象，二者相互独立，不冲突。</p><h3 id="深入理解volatile关键字："><a href="#深入理解volatile关键字：" class="headerlink" title="深入理解volatile关键字："></a>深入理解volatile关键字：</h3><h4 id="知识预备：可见性和原子性"><a href="#知识预备：可见性和原子性" class="headerlink" title="知识预备：可见性和原子性"></a>知识预备：可见性和原子性</h4><ul><li><strong>原子性</strong>：<u>一次只允许一个线程持有某个特定的锁，一次就只有一个线程能够使用共享数据</u>。</li><li><strong>可见性</strong>：必须<u>确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的</u> 。</li></ul><h4 id="volatile能够保证可见性："><a href="#volatile能够保证可见性：" class="headerlink" title="volatile能够保证可见性："></a>volatile能够保证可见性：</h4><p>​一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的</p><h4 id="而不能保证原子性："><a href="#而不能保证原子性：" class="headerlink" title="而不能保证原子性："></a>而不能保证原子性：</h4><p>​不能保证<code>volatile</code>变量复合操作的原子性，因为同一实现可以有多个线程对变量进行修改。</p><p>一个例子说明体现volatile的可见性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileVisibilityExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程A修改flag的值为true</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread A sets flag to true&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程B检查flag的值，如果为true则输出消息</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                <span class="comment">// 循环等待，直到flag的值变为true</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread B detects flag is now true&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">VolatileVisibilityExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileVisibilityExample</span>();</span><br><span class="line">        example.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指令重排序："><a href="#指令重排序：" class="headerlink" title="指令重排序："></a>指令重排序：</h4><p>​指令重排序可以优化代码的执行顺序，但不能改变变量的最终结果。</p><p>​<strong>比如：</strong>对一个变量的两次写操作的相对位置不能改变，若改变了的话，就导致最终的结果也发生改变了。。。</p><p>例子🌰：<u>单例模式双重检查方式为什么要给单例属性添加volatile修饰？</u></p><p>new 关键字创建对象不是原⼦操作，创建⼀个对象会经历下⾯的步骤：</p><ol><li>在堆内存开辟内存空间</li><li>调⽤构造⽅法，初始化对象</li><li>引⽤变量指向堆内存空间</li></ol><p>​为了提⾼性能，编译器和处理器常常会对既定的代码执⾏顺序进⾏指令重排序，从源码到最终执⾏指令会经历如下流程：</p><ul><li>源码编译器优化重排序指令级并⾏重排序内存系统重排序最终执⾏指令序列所以经过**<u>指令重排序</u><strong>之后，创建对象的执⾏顺序可能为 1 2 3 或者 1 3 2 ，因此当某个线程在乱序运⾏ 1 3 2 指令的时候，引⽤变量指向堆内存空间，这个对象不为 null，但是没有初始化，其他线程有可能这个时候进⼊了 getInstance 的第⼀个 if(instance &#x3D;&#x3D; null) 判断不为 nulll ，导致</strong>错误使⽤了没有初始化的⾮ null 实例**，这样的话就会出现异常，这个就是著名的</li><li>DCL 失效问题。</li><li>当我们在引⽤变量上⾯添加 volatile 关键字以后，会通过在创建对象指令的前后添加内存屏障来禁⽌指令重排序，就可以避免这个问题，⽽且对volatile 修饰的变量的修改对其他任何线程都是可⻅的。</li></ul><h3 id="ThreadLocal学习"><a href="#ThreadLocal学习" class="headerlink" title="ThreadLocal学习:"></a>ThreadLocal学习:</h3><p>​<a href="https://juejin.cn/post/7166202551782604837?searchId=20230911163742D2E0FFFACF74510D0A74#heading-10">好文推荐</a></p><p>​ThreadLocal:顾名思义，线程的“本地变量”</p><p>​这种变量在多线程环境下访问(通过get和set方法访问)时能够保证各个线程的变量相对独立于其他线程内的变量，不同线程之间不会相互干扰，这种变量在线程的生命周期内起作用，<strong>减少同一个线程内多个函数或组件之间一些公共变量传递的复杂度。</strong></p><p>​<strong>set 方法：</strong></p><p>通过当前线程对象 thread 获取该 thread 所维护的 ThreadLocalMap，如果 ThreadLocalMap 不为 null，则以 ThreadLocal 实例为 key，值为 value 的键值对存入 ThreadLocalMap，若 ThreadLocalMap 为 null 的话，就新建 ThreadLocalMap，然后再以 ThreadLocal 为键，值为 value 的键值对存入即可。</p><p>​<strong>get 方法：</strong></p><p>通过当前线程 thread 实例获取到它所维护的 ThreadLocalMap，然后以当前 ThreadLocal 实例为 key 获取该 map 中的键值对（Entry），如果 Entry 不为 null 则返回 Entry 的 value。如果获取 ThreadLocalMap 为 null 或者 Entry 为 null 的话，就以当前 ThreadLocal 为 Key，value 为 null 存入 map 后，并返回 null。</p><p>使用实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="comment">//创建ThreadLocal对象, 做成public static.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Object&gt; threadLocal1 = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Object&gt; threadLocal2 = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Task 是线程类 -&gt; 内部类 / 线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">            <span class="type">Pig</span> <span class="variable">pig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pig</span>();</span><br><span class="line">            <span class="comment">//给threadLocal1 对象放入set dog , 隔山打牛</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Task 放入了 dog= &quot;</span> + dog);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                解读:</span></span><br><span class="line"><span class="comment">                public void set(T value) &#123;</span></span><br><span class="line"><span class="comment">                    //1. 获取当前线程, 关联到当前线程!</span></span><br><span class="line"><span class="comment">                    Thread t = Thread.currentThread();</span></span><br><span class="line"><span class="comment">                    //2. 通过线程对象, 获取到ThreadLocalMap</span></span><br><span class="line"><span class="comment">                    //   ThreadLocalMap 类型 ThreadLocal.ThreadLocalMap</span></span><br><span class="line"><span class="comment">                    ThreadLocalMap map = getMap(t);</span></span><br><span class="line"><span class="comment">                    //3. 如果map不为null, 将数据(dog,pig..) 放入map </span></span><br><span class="line"><span class="comment">                    -key:threadLocal value:存放的数据</span></span><br><span class="line"><span class="comment">                    //从这个源码我们已然看出一个threadlocal只能关联一个数据，如果你set, 就会替换</span></span><br><span class="line"><span class="comment">                    //4. 如果map为null, 就创建一个和当前线程关联的ThreadLocalMap, 并且该数据放入</span></span><br><span class="line"><span class="comment">                    if (map != null)</span></span><br><span class="line"><span class="comment">                        map.set(this, value);</span></span><br><span class="line"><span class="comment">                    else</span></span><br><span class="line"><span class="comment">                        createMap(t, value);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            threadLocal1.set(dog);</span><br><span class="line">            <span class="comment">//threadLocal1.set(pig);//替换</span></span><br><span class="line">            threadLocal2.set(pig);<span class="comment">//这个数据就会threadLocal2关联，并且都被当前Thread管理</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Task 在run 方法中 线程=&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">T1Service</span>().update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>()).start();<span class="comment">//主线程启动一个新的线程,注意不是主线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建static修饰的 ThreadLocal 对象于运行线程的类中，</p><p>线程 Thread t 维护一个属性：(每个线程都有一个不同的HashMap)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 对象的实例数据</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p> 它是一个HashMap，里面的Entry的结构为(key, value) —&gt; (线程id， 值)</p><p>🌟一个线程所在的类可以有多个<strong>ThreadLocal</strong>对象，每个threadLocal对象都会**<u>在线程维护的threadLocals中以键的形式存在</u>**。</p><h3 id="ReentrantLock-和-AQS："><a href="#ReentrantLock-和-AQS：" class="headerlink" title="ReentrantLock 和 AQS："></a>ReentrantLock 和 AQS：</h3><h4 id="1-什么是AQS？"><a href="#1-什么是AQS？" class="headerlink" title="1.什么是AQS？"></a>1.什么是AQS？</h4><p>​AQS 中使用的是 CLH 变体队列</p><h5 id="1-1什么是CLH队列？"><a href="#1-1什么是CLH队列？" class="headerlink" title="1.1什么是CLH队列？"></a>1.1什么是CLH队列？</h5><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230911112324020.png" alt="image-20230911112324020"></p><ul><li>CLH：是 <strong>单向链表实现的队列</strong>。申请线程只在本地变量上自旋，<strong>它不断轮询前驱的状态</strong>，如果发现 <strong>前驱节点释放了锁就结束自旋。</strong><ul><li>CLH 队列是一个<u>单向链表</u>，保持 FIFO 先进先出的队列特性</li><li>通过 tail 尾节点（原子引用）来构建队列，总是指向最后一个节点</li><li>未获得锁节点会进行<strong>自旋</strong>，而不是切换线程状态</li><li>并发高时性能较差，因为未获得锁节点不断轮训前驱节点的状态来查看是否获得锁</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230911143653012.png" alt="image-20230911143653012"></p><p>相比于 CLH 队列而言，AQS 中的 CLH 变体等待队列拥有以下特性</p><ol><li>AQS 中队列是个<strong>双向链表</strong>，也是 FIFO 先进先出的特性</li><li>通过 Head、Tail 头尾两个节点来组成队列结构，通过 volatile 修饰保证可见性</li><li>Head 指向节点为已获得锁的节点，是一个虚拟节点，节点本身不持有具体线程</li><li>获取不到同步状态，会将节点进行<strong>自旋</strong>获取锁，自旋一定次数失败后会将线程阻塞，相对于 CLH 队列性能较好</li></ol><p><strong>当前线程获取锁失败时，ReentrantLock首先再tryAcquire()一下，tryAcquire失败，则AQS会将当前线程以及等待状态等信息构造成为一个节点（Node对象）并将其加入AQS中，同时会阻塞当前线程。</strong></p><h4 id="2-条件队列与阻塞队列："><a href="#2-条件队列与阻塞队列：" class="headerlink" title="2.条件队列与阻塞队列："></a>2.条件队列与阻塞队列：</h4><p>​<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230911162425877.png" alt="image-20230911162425877"></p><ul><li>条件队列和阻塞队列的节点，都是 Node 的实例，因为条件队列的节点是需要转移到阻塞队列中去的；</li><li>我们知道一个 ReentrantLock 实例可以通过多次调用 newCondition() 来产生多个 Condition 实例，这里对应 condition1 和 condition2。注意，ConditionObject 只有两个属性 firstWaiter 和 lastWaiter；</li><li>每个 condition 有一个关联的<strong>条件队列</strong>，如线程 1 调用 <code>condition1.await()</code> 方法即可将当前线程 1 包装成 Node 后加入到条件队列中，然后阻塞在这里，不继续往下执行，**<u>条件队列是一个单向链表</u>**；</li><li>🌟调用<code>condition1.signal()</code> 触发一次唤醒，此时唤醒的是队头，会将condition1 对应的<strong>条件队列</strong>的 firstWaiter（队头） 移到<strong>阻塞队列的队尾</strong>，等待获取锁，获取锁后 await 方法才能返回，继续往下执行。</li></ul><h3 id="线程池："><a href="#线程池：" class="headerlink" title="线程池："></a>线程池：</h3><h4 id="线程池参数："><a href="#线程池参数：" class="headerlink" title="线程池参数："></a>线程池参数：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment"> * parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment"> *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment"> *        pool</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment"> *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment"> *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment"> *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment"> *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory the factory to use when the executor</span></span><br><span class="line"><span class="comment"> *        creates a new thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler the handler to use when execution is blocked拒绝策略</span></span><br><span class="line"><span class="comment"> *        because the thread bounds and queue capacities are reached</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if one of the following holds: 不合法参数值异常</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> workQueue&#125;空指针异常</span></span><br><span class="line"><span class="comment"> *         or &#123;<span class="doctag">@code</span> threadFactory&#125; or &#123;<span class="doctag">@code</span> handler&#125; is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, //核心线程数</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize, //最大线程数</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime, //空闲线程存活时间</span></span><br><span class="line"><span class="params">                          TimeUnit unit, //存活时间单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, //任务的阻塞队列</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory, //新线程的产生方式</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler //拒绝策略)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.acc = System.getSecurityManager() == <span class="literal">null</span> ?</span><br><span class="line">            <span class="literal">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="向线程池中添加任务："><a href="#向线程池中添加任务：" class="headerlink" title="向线程池中添加任务："></a>向线程池中添加任务：</h4><p>ThreadPoolExecutor.execute(Runnable command)方法，即可向线程池内添加一个任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executes the given task sometime in the future.  The task</span></span><br><span class="line"><span class="comment"> * may execute in a new thread or in an existing pooled thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the task cannot be submitted for execution, either because this</span></span><br><span class="line"><span class="comment"> * executor has been shutdown or because its capacity has been reached,</span></span><br><span class="line"><span class="comment"> * the task is handled by the current &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command the task to execute</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException at discretion of</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;, if the task</span></span><br><span class="line"><span class="comment"> *         cannot be accepted for execution</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> command&#125; is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//获取当前线程池的状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"><span class="comment">//若当前线程数量小于corePoolSize，则创建一个新的线程</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//判断当前线程是否处于运行状态，且写入任务阻塞队列是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"><span class="comment">//再次获取线程状态进行双重检查；如果线程变成非运行状态，则从阻塞队列移除任务；</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line"><span class="comment">//执行拒绝策略</span></span><br><span class="line">            reject(command);</span><br><span class="line"><span class="comment">//若当前线程池为空，则新建一个线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//当前线程为非运行状态并且尝试新建线程，若失败则执行拒绝策略。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关闭线程池："><a href="#关闭线程池：" class="headerlink" title="关闭线程池："></a>关闭线程池：</h4><ul><li>**shutdown()**： 执行后停止接受新任务，会把队列的任务执行完毕。</li><li>**shutdownNow()**： 执行后停止接受新任务，但会中断所有的任务（不管是否正在执行中），将线程池状态变为 STOP状态。</li></ul><h4 id="拒绝策略："><a href="#拒绝策略：" class="headerlink" title="拒绝策略："></a>拒绝策略：</h4><ul><li>第一种拒绝策略是 AbortPolicy，这种拒绝策略在拒绝任务时，会直接<u><strong>抛出一个类型为 RejectedExecutionException 的 RuntimeException，让你感知到任务被拒绝了，于是你便可以根据业务逻辑选择重试或者放弃提交等策略。</strong></u></li><li>第二种拒绝策略是 DiscardPolicy，这种拒绝策略正如它的名字所描述的一样，<u><strong>当新任务被提交后直接被丢弃掉，也不会给你任何的通知，相对而言存在一定的风险，因为我们提交的时候根本不知道这个任务会被丢弃，可能造成数据丢失</strong></u>。</li><li>第三种拒绝策略是 DiscardOldestPolicy，如果线程池没被关闭且没有能力执行，则会<u><strong>丢弃任务队列中的头结点，通常是存活时间最长的任务</strong></u>，这种策略与第二种不同之处在于它丢弃的不是最新提交的，而是队列中存活时间最长的，这样就可以腾出空间给新提交的任务，但同理它也存在一定的数据丢失风险。</li><li>第四种拒绝策略是 CallerRunsPolicy，调用者执行，相对而言它就比较完善了，当有新任务提交后，如果线程池没被关闭且没有能力执行，则<u><strong>把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务</strong></u>。这样做主要有两点好处。<ul><li>第一点新提交的任务不会被丢弃，这样也就不会造成业务损失。</li><li>第二点好处是，由于谁提交任务谁就要负责执行任务，这样提交任务的线程就得负责执行任务，而执行任务又是比较耗时的，在这段期间，提交任务的线程被占用，也就不会再提交新的任务，减缓了任务提交的速度，相当于是一个负反馈。在此期间，线程池中的线程也可以充分利用这段时间来执行掉一部分任务，腾出一定的空间，相当于是给了线程池一定的缓冲期。</li></ul></li></ul><h2 id="读书笔记整理"><a href="#读书笔记整理" class="headerlink" title="读书笔记整理"></a>读书笔记整理</h2><p>本章节是该网站文章的读书笔记：<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2078%20%E8%AE%B2-%E5%AE%8C/">https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2078%20%E8%AE%B2-%E5%AE%8C/</a></p><h3 id="3-1-JAVA线程实现-x2F-创建方式"><a href="#3-1-JAVA线程实现-x2F-创建方式" class="headerlink" title="3.1.JAVA线程实现&#x2F;创建方式"></a>3.1.JAVA线程实现&#x2F;创建方式</h3><ul><li><p>1.实现<strong>Runnable</strong>接口中的<strong>run</strong>方法</p><ul><li>然后只要把实现run方法的对象实例传入Thread类中即可</li></ul></li><li><p>2.继承Thread类</p><ul><li>继承Thread类，重写run方法……</li></ul></li><li><p>3.线程池创建线程</p><ul><li><p>线程池创建线程源码：</p></li><li><pre><code class="java">static class DefaultThreadFactory implements ThreadFactory &#123;    DefaultThreadFactory() &#123;        SecurityManager s = System.getSecurityManager();        group = (s != null) ? s.getThreadGroup() :            Thread.currentThread().getThreadGroup();        namePrefix = &quot;pool-&quot; +            poolNumber.getAndIncrement() +            &quot;-thread-&quot;;    &#125;    public Thread newThread(Runnable r) &#123;        Thread t = new Thread(group, r,                    namePrefix + threadNumber.getAndIncrement(),0);        if (t.isDaemon())            t.setDaemon(false);        if (t.getPriority() != Thread.NORM_PRIORITY)            t.setPriority(Thread.NORM_PRIORITY);        return t;    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 本质上还是通过 new Thread() 创建线程</span><br><span class="line"></span><br><span class="line">- 4.有返回值的 Callable 创建线程</span><br><span class="line"></span><br><span class="line">  - 源码：</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    class CallableTask implements Callable&lt;Integer&gt; &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Integer call() throws Exception &#123;</span><br><span class="line">            return new Random().nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //创建线程池         执行器(Executor)中有许多构造线程池的静态工厂方法，可以构造各种线程池</span><br><span class="line">    ExecutorService service = Executors.newFixedThreadPool(10);</span><br><span class="line">    //提交任务，并用 Future提交返回结果</span><br><span class="line">    Future&lt;Integer&gt; future = service.submit(new CallableTask());</span><br></pre></td></tr></table></figure></code></pre></li><li><p>第 4 种线程创建方式是通过有返回值的 Callable 创建线程，<u>Runnable 创建线程是无返回值的，而 Callable 和与之相关的 Future、FutureTask，它们可以把线程执行的结果作为返回值返回</u>，如代码所示，实现了 Callable 接口，并且给它的泛型设置成 Integer，然后它会返回一个随机数。</p></li><li><p>但是，无论是 Callable 还是 FutureTask，<u>它们首先和 Runnable 一样，都是一个任务，是需要被执行的，而不是说它们本身就是线程。</u>它们可以放到线程池中执行，如代码所示， <u><strong>submit() 方法把任务放到线程池中，并由线程池创建线程，不管用什么方法，最终都是靠线程来执行的，而子线程的创建方式仍脱离不了最开始讲的两种基本方式，也就是实现 Runnable 接口和继承 Thread 类。</strong></u></p></li></ul></li><li><p>其他创建线程的方法同样也离不开实现 Runnable 接口和继承 Thread 类！</p></li></ul><h4 id="⚠️本质上，线程创建方式只有一种-———-gt-构造一个thread类"><a href="#⚠️本质上，线程创建方式只有一种-———-gt-构造一个thread类" class="headerlink" title="⚠️本质上，线程创建方式只有一种 ———&gt; 构造一个thread类"></a>⚠️本质上，线程创建方式只有一种 ———&gt; 构造一个thread类</h4><p>​然后通过：1.传给Runnable接口中target「target执行 target.run()」</p><p>​   2.继承Thread重写的run方法</p><p>​这两种方式来把想让线程执行的代码传入！</p><h4 id="为什么实现-Runnable-接口比继承-Thread-类实现线程要好？"><a href="#为什么实现-Runnable-接口比继承-Thread-类实现线程要好？" class="headerlink" title="为什么实现 Runnable 接口比继承 Thread 类实现线程要好？"></a>为什么实现 Runnable 接口比继承 Thread 类实现线程要好？</h4><ol><li><p>从代码的架构考虑，实际上，Runnable 里只有一个 run() 方法，它定义了需要执行的内容，在这种情况下，实现了 Runnable 与 Thread 类的解耦，Thread 类负责线程启动和属性设置等内容，权责分明。</p></li><li><p>在某些情况下可以提高性能，<u>使用继承 Thread 类方式，每次执行一次任务，都需要新建一个独立的线程，执行完任务后线程走到生命周期的尽头被销毁，如果还想执行这个任务，就必须再新建一个继承了 Thread 类的类</u>，如果此时执行的内容比较少，比如只是在 run() 方法里简单打印一行文字，那么它所带来的开销并不大，相比于整个线程从开始创建到执行完毕被销毁，这一系列的操作比 run() 方法打印文字本身带来的开销要大得多，相当于捡了芝麻丢了西瓜，得不偿失。如果我们<u><strong>使用实现 Runnable 接口的方式，就可以把任务直接传入线程池，使用一些固定的线程来完成任务，不需要每次新建销毁线程，大大降低了性能开销。</strong></u></p></li><li><p>Java 语言不支持双继承，如果我们的类一旦继承了 Thread 类，那么它后续就没有办法再继承其他的类，<strong>不方便类的拓展</strong></p></li></ol><h3 id="3-2-如何正确停止线程"><a href="#3-2-如何正确停止线程" class="headerlink" title="3.2.如何正确停止线程"></a>3.2.如何正确停止线程</h3><p>本节我们将讨论 如何正确停止一个线程？以及为什么用 volatile 标记位的停止方法是错误的？</p><p>正常情况下，我们会让线程自动运行到其结束为止。</p><p>但是如果中途出了意外情况我们又该怎么办呢？</p><p>​在这种情况下，即将停止的线程在很多业务场景下仍然很有价值。尤其是我们想写一个健壮性很好，能够安全应对各种场景的程序时，正确停止线程就显得格外重要。但是Java 并没有提供简单易用，能够直接安全停止线程的能力。</p><h4 id="3-2-1-使用interrupt停止线程"><a href="#3-2-1-使用interrupt停止线程" class="headerlink" title="3.2.1.使用interrupt停止线程"></a>3.2.1.使用interrupt停止线程</h4><p>​对于 Java 而言，最正确的停止线程的方式是使用 interrupt。但 interrupt 仅仅起到通知被停止线程的作用。被通知的线程会考虑自身工作情况()，选择立即停止、一段时间后停止或不停止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.lang.Thread类中的相关方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//向线程发送中断请求，线程的中断状态将被设置为true，此时如果线程已经被sleep方法调用阻塞，将会抛出InterruptedException异常</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//测试当前进程是否被中断——静态方法——会将当前线程的中断状态重制为false！！！</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//测试当前进程是否被中断————不会改变线程的中断状态！</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//返回当前正在执行的线程的Thread对象</span></span><br><span class="line"><span class="keyword">static</span> Thread <span class="title function_">currentThread</span><span class="params">()</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//==============================使用interrupt停止线程==============================</span></span><br><span class="line"><span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; more work to <span class="keyword">do</span>) &#123;</span><br><span class="line">  <span class="keyword">do</span> more work</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们一旦调用某个线程的 interrupt() 之后，这个线程的<strong>中断标记位</strong>就会被设置成 true。每个线程都有这样的标记位，当线程执行时，应该定期检查这个标记位，<u>如果标记位被设置成 true，就说明有程序想终止该线程。</u></p><p>实例🌰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//🌟这里说明了 线程能够通过 isInterrupted() 方法得知终端标记位的状态</span></span><br><span class="line">      <span class="comment">//🌟然后再由程序员编写中断标记位为true/false时的逻辑！</span></span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; count &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;count = &quot;</span> + count++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">StopThread</span>());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-sleep-期间能否感受到中断？"><a href="#3-2-2-sleep-期间能否感受到中断？" class="headerlink" title="3.2.2.sleep 期间能否感受到中断？"></a>3.2.2.sleep 期间能否感受到中断？</h4><p>——如果 sleep、wait 等可以让线程进入阻塞的方法使线程休眠了，而处于休眠中的线程被中断，那么线程是可以感受到中断信号的，并且会抛出一个 InterruptedException 异常，同时清除中断信号，将中断标记位设置成 false。这样一来就不用担心长时间休眠中线程感受不到中断了，因为即便线程还在休眠，仍然能够响应中断通知，并抛出异常。</p><p><u>因此如果我们需要对此情况进行处理，我们需要对InterruptedException异常进行捕获，而不是检查中断状态</u></p><p>🌟如果我们想让线程的调用者察觉到⬆️上面情况的发生，有2种方式：</p><ul><li>(方法1)：catch InterruptedException异常后，将中断状态再次设置为true(在try-catch中处理异常会实际上还是在同一class中处理，耦合度高，不建议使用，因此推荐下面的方法)</li><li>(方法2)：🌟**<u>throw InterruptedException 异常即可，调用者再try-catch即可捕获异常</u>**</li></ul><p>⚠️注意：我们在实际开发中不能盲目吞掉中断，<u>如果不在方法签名中声明，也不在 catch 语句块中再次恢复中断(方法1)，而是在 catch 中不作处理(方法2)，我们称这种行为是“屏蔽了中断请求”</u>。如果我们盲目地屏蔽了中断请求，会导致中断信号被完全忽略，最终导致线程无法正确停止。</p><h4 id="3-2-3-为什么用-volatile-标记位的停止方法是错误的"><a href="#3-2-3-为什么用-volatile-标记位的停止方法是错误的" class="headerlink" title="3.2.3.为什么用 volatile 标记位的停止方法是错误的?"></a>3.2.3.为什么用 volatile 标记位的停止方法是错误的?</h4><h5 id="3-2-3-1-常见的错误停止方法"><a href="#3-2-3-1-常见的错误停止方法" class="headerlink" title="3.2.3.1.常见的错误停止方法"></a>3.2.3.1.常见的错误停止方法</h5><p>​首先，我们来看几种停止线程的错误方法。比如 stop()，suspend() 和 resume()，这些方法已经被 Java 直接标记为 @Deprecated。如果再调用这些方法，IDE 会友好地提示，我们不应该再使用它们了。但为什么它们不能使用了呢？</p><ol><li><p>stop() 会直接把线程停止，这样就<u>没有给线程足够的时间来处理想要在停止前保存数据的逻辑</u>，任务戛然而止，会导致出现数据完整性等问题。</p></li><li><p>对于suspend() 和 resume() 而言，它们的问题在于如果线程调用 suspend()，它并不会释放锁，就开始进入休眠，但此时有可能仍持有锁，这样就<u>容易导致死锁问题</u>，因为这把锁在线程被 resume() 之前，是不会被释放的。</p></li></ol><h5 id="3-2-3-2volatile标记位停止线程"><a href="#3-2-3-2volatile标记位停止线程" class="headerlink" title="3.2.3.2volatile标记位停止线程"></a>3.2.3.2volatile标记位停止线程</h5><p>volatile 这种方法在某些特殊的情况下，比如线程被长时间阻塞的情况，就无法及时感受中断，所以 volatile 是不够全面的停止线程的方法。</p><p><strong><u>线程被长时间阻塞：因为你是根据volatile变量的值的情况去判断是否停止进程，但是如果你在哪阻塞了，即使那个变量改变了也没用，volatile标记位在程序运行到对该变量进行判断的语句时才对线程产生影响</u></strong></p><h3 id="3-3-线程是如何在-6-种状态之间转换的？"><a href="#3-3-线程是如何在-6-种状态之间转换的？" class="headerlink" title="3.3.线程是如何在 6 种状态之间转换的？"></a>3.3.线程是如何在 6 种状态之间转换的？</h3><p>线程可以有以下6种状态：</p><table><thead><tr><th>New(新建)</th><th>Runnable(可运行)</th><th>Blocked(阻塞)</th><th>Waiting(等待)</th><th>Time waiting(计时等待)</th><th>Terminated(终止)</th></tr></thead></table><h4 id="3-3-1-new"><a href="#3-3-1-new" class="headerlink" title="3.3.1.new"></a>3.3.1.new</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230802141435013.png" alt="image-20230802141435013"></p><p>New 表示线程被创建但尚未启动的状态：当我们用 new Thread() 新建一个线程时，<u>如果线程没有开始运行 start() 方法，所以也没有开始执行 run() 方法里面的代码，那么此时它的状态就是 New</u>。而一旦线程调用了 start()，它的状态就会从 New 变成 Runnable，也就是状态转换图中中间的这个大方框里的内容。</p><h4 id="3-3-2-Runnable"><a href="#3-3-2-Runnable" class="headerlink" title="3.3.2.Runnable"></a>3.3.2.Runnable</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230802141522535.png" alt="image-20230802141522535"></p><p>Java 中的 <u>Runable 状态对应操作系统线程状态中的两种状态</u>，分<strong>别是 Running 和 Ready，</strong>也就是说，Java 中处于 Runnable 状态的线程有可能正在执行，也有可能没有正在执行，正在等待被分配 CPU 资源。</p><p>所以，如果一个正在运行的线程是 Runnable 状态，当它运行到任务的一半时，执行该线程的 CPU 被调度去做其他事情，导致该线程暂时不运行，它的状态依然不变，还是 Runnable，因为它有可能随时被调度回来继续执行任务。</p><h4 id="3-3-3-阻塞"><a href="#3-3-3-阻塞" class="headerlink" title="3.3.3.阻塞"></a>3.3.3.阻塞</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230802141714716.png" alt="image-20230802141714716"></p><h5 id="3-3-3-1Blocked"><a href="#3-3-3-1Blocked" class="headerlink" title="3.3.3.1Blocked"></a>3.3.3.1Blocked</h5><p>​<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230802141755358.png" alt="image-20230802141755358"></p><p>首先来看最简单的 Blocked，从箭头的流转方向可以看出，从 Runnable 状态进入 Blocked 状态只有一种可能，就是进入 synchronized 保护的代码时<u>没有抢到 monitor 锁</u>，无论是进入 synchronized 代码块，还是 synchronized 方法，都是一样。</p><p>我们再往右看，当处于 Blocked 的线程<u>抢到 monitor 锁</u>，就会从 Blocked 状态回到Runnable 状态。</p><h5 id="3-3-3-2-Waiting"><a href="#3-3-3-2-Waiting" class="headerlink" title="3.3.3.2.Waiting"></a>3.3.3.2.Waiting</h5><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230802141903651.png" alt="image-20230802141903651"></p><p>我们再看看 Waiting 状态，线程进入 Waiting 状态有三种可能性。</p><ol><li>没有设置 Timeout 参数的 Object.wait() 方法。</li><li>没有设置 Timeout 参数的 Thread.join() 方法。</li><li>LockSupport.park() 方法。</li></ol><p>刚才强调过，Blocked 仅仅针对 synchronized monitor 锁，可是在 Java 中还有很多其他的锁，比如 ReentrantLock，如果线程在获取这种锁时没有抢到该锁就会进入 Waiting 状态，因为本质上它执行了 LockSupport.park() 方法，所以会进入 Waiting 状态。同样，Object.wait() 和 Thread.join() 也会让线程进入 Waiting 状态。</p><p><strong><u>Blocked 与 Waiting 的区别是 Blocked 在等待其他线程释放 monitor 锁，而 Waiting 则是在等待某个条件，比如 join 的线程执行完毕，或者是 notify()&#x2F;notifyAll() 。</u></strong></p><h5 id="3-3-3-3-TimedWaiting"><a href="#3-3-3-3-TimedWaiting" class="headerlink" title="3.3.3.3.TimedWaiting"></a>3.3.3.3.TimedWaiting</h5><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230802142019403.png" alt="image-20230802142019403"></p><p>在 Waiting 上面是 Timed Waiting 状态，这两个状态是非常相似的，<u><strong>区别仅在于有没有时间限制</strong></u>，Timed Waiting 会等待超时，由系统自动唤醒，或者在超时前被唤醒信号唤醒。</p><p>以下情况会让线程进入 Timed Waiting 状态。</p><ol><li>设置了时间参数的 Thread.sleep(long millis) 方法；</li><li>设置了时间参数的 Object.wait(long timeout) 方法；</li><li>设置了时间参数的 Thread.join(long millis) 方法；</li><li>设置了时间参数的 LockSupport.parkNanos(long nanos) 方法和 LockSupport.parkUntil(long deadline) 方法。</li></ol><h4 id="3-3-4-Terminated"><a href="#3-3-4-Terminated" class="headerlink" title="3.3.4.Terminated"></a>3.3.4.Terminated</h4><ul><li>run() 方法执行完毕，线程正常退出。</li><li>出现一个没有捕获的异常，终止了 run() 方法，最终导致意外终止。</li></ul><h4 id="3-3-5-线程状态转换"><a href="#3-3-5-线程状态转换" class="headerlink" title="3.3.5.线程状态转换"></a>3.3.5.线程状态转换</h4><ul><li>Blocked 状态进入 Runnable 状态，要求线程获取 monitor 锁</li><li>Waiting 状态流转到其他状态则比较特殊，因为首先 Waiting 是不限时的，也就是说无论过了多长时间它都<u>不会主动恢复</u>。<ul><li><strong>只有当执行了 LockSupport.unpark()，或者 join 的线程运行结束，或者被中断时才可以进入 Runnable 状态。</strong></li><li><strong>如果其他线程调用 notify() 或 notifyAll()来唤醒它，它会直接进入 Blocked 状态，这是为什么呢？因为唤醒 Waiting 线程的线程如果调用 notify() 或 notifyAll()，要求必须首先持有该 monitor 锁，所以处于 Waiting 状态的线程被唤醒时拿不到该锁，就会进入 Blocked 状态，直到执行了 notify()&#x2F;notifyAll() 的唤醒它的线程执行完毕并释放 monitor 锁，才可能轮到它去抢夺这把锁，如果它能抢到，就会从 Blocked 状态回到 Runnable 状态。</strong></li></ul></li><li>Timed Waiting 状态同理，只不过是在规定时间范围内与Waiting相同</li></ul><h3 id="3-4-wait、notify、notifyAll-方法的使用注意事项？"><a href="#3-4-wait、notify、notifyAll-方法的使用注意事项？" class="headerlink" title="3.4.wait、notify、notifyAll 方法的使用注意事项？"></a>3.4.wait、notify、notifyAll 方法的使用注意事项？</h3><h4 id="3-4-1为什么-wait-必须在-synchronized-保护的同步代码中使用？"><a href="#3-4-1为什么-wait-必须在-synchronized-保护的同步代码中使用？" class="headerlink" title="3.4.1为什么 wait 必须在 synchronized 保护的同步代码中使用？"></a>3.4.1为什么 wait 必须在 synchronized 保护的同步代码中使用？</h4><p>​考虑下述情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BlockingQueue</span> &#123;</span><br><span class="line">    Queue&lt;String&gt; buffer = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">give</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        buffer.add(data);</span><br><span class="line">        notify();  <span class="comment">// Since someone may be waiting in take</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (buffer.isEmpty()) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能确保 notify 方法永远不会在 buffer.isEmpty 和 wait 方法之间被调用，如果真这样发生了，程序就会一直被wait而不背唤醒。</p><h4 id="3-4-2-为什么-wait-x2F-notify-x2F-notifyAll-被定义在-Object-类中，而-sleep-定义在-Thread-类中？"><a href="#3-4-2-为什么-wait-x2F-notify-x2F-notifyAll-被定义在-Object-类中，而-sleep-定义在-Thread-类中？" class="headerlink" title="3.4.2.为什么 wait&#x2F;notify&#x2F;notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？"></a>3.4.2.为什么 wait&#x2F;notify&#x2F;notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？</h4><ol><li>因为 Java 中<u>每个对象都有一把称之为 monitor 监视器的锁</u>，由于每个对象都可以上锁，这就要求在对象头中有一个用来保存锁信息的位置。这个锁是对象级别的，而非线程级别的，wait&#x2F;notify&#x2F;notifyAll 也都是锁级别的操作，它们的锁属于对象，所以把它们定义在 Object 类中是最合适，因为 Object 类是所有对象的父类。</li><li>因为如果把 wait&#x2F;notify&#x2F;notifyAll 方法定义在 Thread 类中，会带来很大的局限性，比如一个线程可能持有多把锁，以便实现相互配合的复杂逻辑，假设此时 wait 方法定义在 Thread 类中，如何实现让一个线程持有多把锁呢？又如何明确线程等待的是哪把锁呢？既然我们是让当前线程去等待某个对象的锁，自然应该通过操作对象来实现，而不是操作线程。</li></ol><h4 id="3-4-5-wait-x2F-notify-和-sleep-方法的异同？"><a href="#3-4-5-wait-x2F-notify-和-sleep-方法的异同？" class="headerlink" title="3.4.5.wait&#x2F;notify 和 sleep 方法的异同？"></a>3.4.5.wait&#x2F;notify 和 sleep 方法的异同？</h4><h5 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h5><ol><li>它们都可以让线程阻塞。</li><li>它们都可以响应 interrupt 中断：在等待的过程中如果收到中断信号，都可以进行响应，并抛出 InterruptedException 异常。</li></ol><h5 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h5><ol><li><u><strong>wait 方法必须在 synchronized 保护的代码中使用</strong></u>，而 sleep 方法并没有这个要求。</li><li>在同步代码中<strong>执行 sleep 方法时，并不会释放 monitor 锁</strong>，但<u>执行 wait 方法时会主动释放 monitor 锁</u>。</li><li>sleep 方法中会要求必须定义一个时间，<u>时间到期后会主动恢复</u>，而对于没有参数的 wait 方法而言，意味着永久等待，直到被中断或被唤醒才能恢复，它并<u>不会主动恢复</u>。</li><li>wait&#x2F;notify 是 Object 类的方法，而 sleep 是 Thread 类的方法。</li></ol><h3 id="3-5-三类线程安全问题"><a href="#3-5-三类线程安全问题" class="headerlink" title="3.5.三类线程安全问题"></a>3.5.三类线程安全问题</h3><h4 id="什么是线程安全？"><a href="#什么是线程安全？" class="headerlink" title="什么是线程安全？"></a>什么是线程安全？</h4><ul><li>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行问题，也不需要进行额外的同步，而调用这个对象的行为都可以获得正确的结果，那这个对象便是线程安全的。</li><li>如果某个对象是线程安全的，那么对于使用者而言，在使用时就不需要考虑方法间的协调问题，比如不需要考虑不能同时写入或读写不能并行的问题，也不需要考虑任何额外的同步问题，比如不需要额外自己加 synchronized 锁，那么它才是线程安全的，可以看出对线程安全的定义还是非常苛刻的。</li></ul><h4 id="三种典型的线程安全问题"><a href="#三种典型的线程安全问题" class="headerlink" title="三种典型的线程安全问题"></a>三种典型的线程安全问题</h4><ol><li>运行结果错误；</li><li>发布和初始化导致线程安全问题；</li><li>活跃性问题。</li></ol><h5 id="3-1-运行结果错误"><a href="#3-1-运行结果错误" class="headerlink" title="3.1.运行结果错误"></a>3.1.运行结果错误</h5><ul><li>多线程同时操作一个变量导致的运行结果错误]</li><li>是因为在多线程下，CPU 的调度是以<strong>时间片为单位</strong>进行分配的，每个线程都可以得到一定量的时间片。但如果线程拥有的时间片耗尽，它将会被暂停执行并让出 CPU 资源给其他线程，这样就有可能发生线程安全问题。比如 i++ 操作，表面上看只是一行代码，但实际上它并不是一个原子操作，它的执行步骤主要分为三步，而且在每步操作之间都有可能被打断。</li></ul><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230803190731854.png" alt="image-20230803190731854" style="zoom: 33%;" /><h5 id="3-2-发布和初始化导致线程安全问题"><a href="#3-2-发布和初始化导致线程安全问题" class="headerlink" title="3.2.发布和初始化导致线程安全问题"></a>3.2.发布和初始化导致线程安全问题</h5><ul><li>我们创建对象并进行发布和初始化供其他类或对象使用是常见的操作，但如果我们操作的时间或地点不对，就可能导致线程安全问题。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WrongInit</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, String&gt; students;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WrongInit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                students = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                students.put(<span class="number">1</span>, <span class="string">&quot;王小美&quot;</span>);</span><br><span class="line">                students.put(<span class="number">2</span>, <span class="string">&quot;钱二宝&quot;</span>);</span><br><span class="line">                students.put(<span class="number">3</span>, <span class="string">&quot;周三&quot;</span>);</span><br><span class="line">                students.put(<span class="number">4</span>, <span class="string">&quot;赵四&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;Integer, String&gt; <span class="title function_">getStudents</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> students;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">WrongInit</span> <span class="variable">multiThreadsError6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WrongInit</span>();</span><br><span class="line">        System.out.println(multiThreadsError6.getStudents().get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中 创建multiThreadsError6对象后立刻就试图输出student的信息，而实际上此时线程可能还没启动完毕，导致空指针异常！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line">at lesson6.WrongInit.main(WrongInit.java:32)</span><br></pre></td></tr></table></figure><h5 id="3-3-活跃性问题"><a href="#3-3-活跃性问题" class="headerlink" title="3.3.活跃性问题"></a>3.3.活跃性问题</h5><ul><li>死锁<ul><li>……</li></ul></li><li>活锁<ul><li>活锁与死锁非常相似，也是程序一直等不到结果，但对比于死锁，活锁是活的，什么意思呢？因为<u>正在运行的线程并没有阻塞，它始终在运行中，却一直得不到结果。</u></li><li>举一个例子，假设有一个消息队列，队列里放着各种各样需要被处理的消息，而某个消息由于自身被写错了导致不能被正确处理，执行时会报错，可是队列的重试机制会重新把它放在队列头进行优先重试处理，但这个消息本身无论被执行多少次，都无法被正确处理，每次报错后又会被放到队列头进行重试，周而复始，最终导致线程一直处于忙碌状态，但程序始终得不到结果，便发生了活锁问题</li></ul></li><li>饥饿<ul><li>饥饿是指线程需要某些资源时始终得不到，尤其是CPU 资源，就会导致线程一直不能运行而产生的问题。在 Java 中有线程优先级的概念，Java 中优先级分为 1 到 10，1 最低，10 最高。如果我们把某个线程的优先级设置为 1，这是最低的优先级，在这种情况下，这个线程就<u>有可能始终分配不到 CPU 资源</u>，而导致长时间无法运行。或者是某个线程始终持有某个文件的锁，而其他线程想要修改文件就必须先获取锁，这样想要修改文件的线程就会陷入饥饿，长时间不能运行。</li></ul></li></ul><h3 id="3-6-哪些场景需要额外注意线程安全问题？"><a href="#3-6-哪些场景需要额外注意线程安全问题？" class="headerlink" title="3.6.哪些场景需要额外注意线程安全问题？"></a>3.6.哪些场景需要额外注意线程安全问题？</h3><h4 id="3-6-1-访问共享变量或资源"><a href="#3-6-1-访问共享变量或资源" class="headerlink" title="3.6.1.访问共享变量或资源"></a>3.6.1.访问共享变量或资源</h4><p>​典型的场景有访问共享对象的属性，访问 static 静态变量，访问共享的缓存，等等。因为这些信息不仅会被一个线程访问到，还有可能被多个线程同时访问，那么就<u><strong>有可能在并发读写的情况下发生线程安全问题</strong></u>。比如我们上一课时讲过的多线程同时 i++ 的例子</p><h4 id="3-6-2-依赖时序的操作"><a href="#3-6-2-依赖时序的操作" class="headerlink" title="3.6.2.依赖时序的操作"></a>3.6.2.依赖时序的操作</h4><p>​如果我们<u>操作的正确性是依赖时序</u>的，而在多线程的情况下<u>又不能保障执行的顺序和我们预想的一致</u>，这个时候就会发生线程安全问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如多个线程同时访问以下代码：</span></span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">    x = <span class="number">7</span> * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6-3-不同数据之间存在绑定关系"><a href="#3-6-3-不同数据之间存在绑定关系" class="headerlink" title="3.6.3.不同数据之间存在绑定关系"></a>3.6.3.不同数据之间存在<u>绑定关系</u></h4><p>​有时候，我们的不同数据之间是成组出现的，存在着相互对应或绑定的关系，<u><strong>最典型的就是 IP 和端口号</strong></u>。有时候我们更换了 IP，往往需要同时更换端口号，如果没有把这两个操作绑定在一起，就有可能出现单独更换了 IP 或端口号的情况，而此时信息如果已经对外发布，信息获取方就有可能获取一个错误的 IP 与端口绑定情况，这时就发生了线程安全问题。在这种情况下，我们也同样需要保障操作的原子性。</p><h4 id="3-6-4-对方没有声明自己是线程安全的"><a href="#3-6-4-对方没有声明自己是线程安全的" class="headerlink" title="3.6.4.对方没有声明自己是线程安全的"></a>3.6.4.对方没有声明自己是线程安全的</h4><p>我们使用其他类时，如果对方没有声明自己是线程安全的，那么这种情况下对其他类进行多线程的并发操作，就有可能会发生线程安全问题。</p><p>如：ArrayList如果我们把 ArrayList 用在了多线程的场景，需要在外部手动用 synchronized 等方式保证并发安全。</p><h3 id="3-7-为什么多线程会带来性能问题？"><a href="#3-7-为什么多线程会带来性能问题？" class="headerlink" title="3.7.为什么多线程会带来性能问题？"></a>3.7.为什么多线程会带来性能问题？</h3><h4 id="3-7-1什么是性能问题？"><a href="#3-7-1什么是性能问题？" class="headerlink" title="3.7.1什么是性能问题？"></a>3.7.1什么是性能问题？</h4><p>使用多线程的最大目的不就是为了提高性能吗？让多个线程同时工作，加快程序运行速度，为什么反而会带来性能问题呢？这是<u>因为单线程程序是独立工作的，不需要与其他线程进行交互，但多线程之间则需要调度以及合作，调度与合作就会带来性能开销从而产生性能问题。</u></p><h4 id="3-7-2-为什么多线程会带来性能问题？"><a href="#3-7-2-为什么多线程会带来性能问题？" class="headerlink" title="3.7.2.为什么多线程会带来性能问题？"></a>3.7.2.为什么多线程会带来性能问题？</h4><p>分为以下两个方面：</p><h5 id="🌟调度开销："><a href="#🌟调度开销：" class="headerlink" title="🌟调度开销："></a>🌟调度开销：</h5><ul><li>⚠️上下文切换：<ul><li>首先，我们看一下线程调度，在实际开发中，线程数往往是大于 CPU 核心数的，比如 CPU 核心数可能是 8 核、16 核，等等，但线程数可能达到成百上千个。这种情况下，操作系统就会按照一定的调度算法，给每个线程分配时间片，让每个线程都有机会得到运行。而在进行调度时就会引起上下文切换，上下文切换会挂起当前正在执行的线程并保存当前的状态，然后寻找下一处即将恢复执行的代码，唤醒下一个线程，以此类推，反复执行。但上下文切换带来的开销是比较大的，假设我们的任务内容非常短，比如只进行简单的计算，那么就有可能发生我们上下文切换带来的性能开销比执行线程本身内容带来的开销还要大的情况。</li></ul></li><li>⚠️缓存失效：<ul><li>由于程序有很大概率会再次访问刚才访问过的数据，所以为了加速整个程序的运行，会使用缓存，这样我们在使用相同数据时就可以很快地获取数据。可一旦进行了线程调度，切换到其他线程，CPU就会去执行不同的代码，原有的缓存就很可能失效了，需要重新缓存新的数据，这也会造成一定的开销，所以线程调度器为了避免频繁地发生上下文切换，<u><strong>通常会给被调度到的线程设置最小的执行时间，也就是只有执行完这段时间之后，才可能进行下一次的调度，由此减少上下文切换的次数。</strong></u></li></ul></li></ul><h5 id="🌟协作开销："><a href="#🌟协作开销：" class="headerlink" title="🌟协作开销："></a>🌟协作开销：</h5><p>—-维护共享数据的开销</p><ul><li>除了线程调度之外，线程协作同样也有可能带来性能问题。<u>因为线程之间如果有共享数据，为了避免数据错乱，为了保证线程安全，就有可能禁止编译器和 CPU 对其进行重排序等优化</u>，也可能出于同步的目的，反复把线程工作内存的数据 flush 到主存中，然后再从主内存 refresh 到其他线程的工作内存中，等等。这些问题在单线程中并不存在，但在多线程中为了确保数据的正确性，就不得不采取上述方法，因为线程安全的优先级要比性能优先级更高，这也间接降低了我们的性能。</li></ul><h3 id="3-8-使用线程池比手动创建线程好在哪里？"><a href="#3-8-使用线程池比手动创建线程好在哪里？" class="headerlink" title="3.8.使用线程池比手动创建线程好在哪里？"></a>3.8.使用线程池比手动创建线程好在哪里？</h3><h4 id="3-8-1-为什么要使用线程池？"><a href="#3-8-1-为什么要使用线程池？" class="headerlink" title="3.8.1.为什么要使用线程池？"></a>3.8.1.为什么要使用线程池？</h4><p>没有线程池的时候，每发布一个任务就需要创建一个新的线程，这样在任务少时是没有问题的，当任务数很多时，比如任务量到达了10000，就需要创建10000个线程来应对任务。而 J<u>ava 程序中的线程与操作系统中的线程是一一对应</u>的，此时假设线程中的任务需要一定的耗时才能够完成，便会产生很大的系统开销与资源浪费。</p><h5 id="不使用线程池的问题："><a href="#不使用线程池的问题：" class="headerlink" title="不使用线程池的问题："></a>不使用线程池的问题：</h5><ol><li>第一点，<u>反复创建线程系统开销比较大</u>，每个线程创建和销毁都需要时间，<u>如果任务比较简单，那么就有可能导致创建和销毁线程消耗的资源比线程执行任务本身消耗的资源还要大。</u></li><li>第二点，过多的线程会<strong>占用过多的内存等资源</strong>，还会<strong>带来过多的上下文切换</strong>，同时还会<strong>导致系统不稳定</strong>。(如上一小节所说———上下文切换的开销 + 缓存失效)</li></ol><h4 id="3-8-2-线程池解决问题思路："><a href="#3-8-2-线程池解决问题思路：" class="headerlink" title="3.8.2.线程池解决问题思路："></a>3.8.2.线程池解决问题思路：</h4><ul><li><p>针对反复创建线程开销大的问题，<u>线程池用一些固定的线程一直保持工作状态并反复执行任务。</u></p></li><li><p>针对过多线程占用太多内存资源的问题，解决思路更直接，<u>线程池会根据需要创建线程，控制线程的总数量，避免占用过多内存资源。</u></p></li></ul><h4 id="3-8-3-如何使用线程池"><a href="#3-8-3-如何使用线程池" class="headerlink" title="3.8.3.如何使用线程池?"></a>3.8.3.如何使用线程池?</h4><p>​执行器(Executor)中有许多构造线程池的静态工厂方法，可以构造各种线程池。</p><p>​具体使用方法上面已经说清楚了，保证线程数不超过某值，请求多了就排队排起来。</p><h4 id="3-8-4-使用线程池的好处："><a href="#3-8-4-使用线程池的好处：" class="headerlink" title="3.8.4.使用线程池的好处："></a>3.8.4.使用线程池的好处：</h4><ol><li>第一点，线程池可以解决线程生命周期的系统开销问题，同时还可以加快响应速度。<u>因为线程池中的线程是可以复用的，我们只用少量的线程去执行大量的任务，这就大大减小了线程生命周期的开销。</u>而且线程通常不是等接到任务后再临时创建，而是已经创建好时刻准备执行任务，这样就消除了线程创建所带来的延迟，<u>提升了响应速度</u>，增强了用户体验。</li><li>第二点，线程池可以统筹内存和 CPU 的使用，避免资源使用不当。<u>线程池会根据配置和任务数量灵活地控制线程数量，不够的时候就创建，太多的时候就回收，避免线程过多导致内存溢出，或线程太少导致 CPU 资源浪费，达到了一个完美的平衡。</u></li><li>第三点，线程池可以统一管理资源。比如线程池可以统一管理任务队列和线程，可以统一开始或结束任务，比单个线程逐一处理任务要更方便、更易于管理，同时也有利于数据统计，比如我们可以很方便地统计出已经执行过的任务的数量。</li></ol><h3 id="3-9-线程池的各个参数的含义？"><a href="#3-9-线程池的各个参数的含义？" class="headerlink" title="3.9.线程池的各个参数的含义？"></a>3.9.线程池的各个参数的含义？</h3><h4 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230804151715352.png" alt="image-20230804151715352" style="zoom:50%;" /><h4 id="🌟线程池中线程创建的时机："><a href="#🌟线程池中线程创建的时机：" class="headerlink" title="🌟线程池中线程创建的时机："></a>🌟线程池中线程创建的时机：</h4><p> ![image-20230804151848748](&#x2F;Users&#x2F;donn&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230804151848748.png)</p><h4 id="3-9-1-corePoolSize-与-maximumPoolSize"><a href="#3-9-1-corePoolSize-与-maximumPoolSize" class="headerlink" title="3.9.1.corePoolSize 与 maximumPoolSize"></a>3.9.1.corePoolSize 与 maximumPoolSize</h4><p>​⚠️通过上面的流程图，我们了解了 corePoolSize 和 maximumPoolSize 的具体含义，corePoolSize 指的是核心线程数，线程池初始化时线程数默认为 0，当有新的任务提交后，会创建新线程执行任务，如果不做特殊设置，此后线程数通常不会再小于 corePoolSize ，因为它们是核心线程，即便未来可能没有可执行的任务也不会被销毁。随着任务量的增加，在任务队列满了之后，线程池会进一步创建新线程，最多可以达到 maximumPoolSize 来应对任务多的场景，如果未来线程有空闲，大于 corePoolSize 的线程会被合理回收。所以正常情况下，线程池中的线程数量会处在 corePoolSize 与 maximumPoolSize 的闭区间内。</p><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ul><li>线程池希望保持较少的线程数，并且只有在负载变得很大时才增加线程。</li><li>线程池只有在任务队列填满时才创建多于 corePoolSize 的线程，如果使用的是无界队列（例如 LinkedBlockingQueue），那么由于队列不会满，所以线程数不会超过 corePoolSize。</li><li>通过设置 corePoolSize 和 maximumPoolSize 为相同的值，就可以创建固定大小的线程池。</li><li>通过设置 maximumPoolSize 为很高的值，例如 Integer.MAX_VALUE，就可以允许线程池创建任意多的线程。</li></ul><h4 id="3-9-2-keepAliveTime-时间单位"><a href="#3-9-2-keepAliveTime-时间单位" class="headerlink" title="3.9.2.keepAliveTime+时间单位"></a>3.9.2.keepAliveTime+时间单位</h4><p>—-在空闲期销毁过多(超过核心线程数)的线程</p><p>第三个参数是 keepAliveTime + 时间单位，<u>当线程池中线程数量多于核心线程数时，而此时又没有任务可做，线程池就会检测线程的 keepAliveTime，如果超过规定的时间，无事可做的线程就会被销毁，以便减少内存的占用和资源消耗。</u>如果后期任务又多了起来，线程池也会根据规则重新创建线程，所以这是一个可伸缩的过程，比较灵活，我们也可以用 setKeepAliveTime 方法动态改变 keepAliveTime 的参数值。</p><h4 id="3-9-3-ThreadFactory"><a href="#3-9-3-ThreadFactory" class="headerlink" title="3.9.3.ThreadFactory"></a>3.9.3.ThreadFactory</h4><p>第四个参数是 ThreadFactory，ThreadFactory 实际上是一个线程工厂，它的作用是生产线程以便执行任务。我们可以选择使用默认的线程工厂，创建的线程都会在同一个线程组，并拥有一样的优先级，且都不是守护线程，我们也可以选择自己定制线程工厂，以方便给线程自定义命名，不同的线程池内的线程通常会根据具体业务来定制不同的线程名。</p><h4 id="3-9-4-workQueue-和-Handler"><a href="#3-9-4-workQueue-和-Handler" class="headerlink" title="3.9.4.workQueue 和 Handler"></a>3.9.4.workQueue 和 Handler</h4><p>最后两个参数是 workQueue 和 Handler，它们分别对应阻塞队列和任务拒绝策略，在后面的课时会对它们进行详细展开讲解。</p><h3 id="3-10-线程池有哪-4-种拒绝策略？"><a href="#3-10-线程池有哪-4-种拒绝策略？" class="headerlink" title="3.10.线程池有哪 4 种拒绝策略？"></a>3.10.线程池有哪 4 种拒绝策略？</h3><h4 id="3-10-1-线程池拒绝任务的时机："><a href="#3-10-1-线程池拒绝任务的时机：" class="headerlink" title="3.10.1.线程池拒绝任务的时机："></a>3.10.1.线程池拒绝任务的时机：</h4><p>新建线程池时可以指定它的任务拒绝策略，以便在必要的时候按照我们的策略来拒绝任务，那么拒绝任务的时机是什么呢？线程池会在以下两种情况下会**<u>拒绝新提交的任务。</u>**</p><ul><li>第一种情况是当我们<u>调用 shutdown 等方法关闭线程池后</u>，即便此时可能线程池内部依然有没执行完的任务正在执行，但是由于线程池已经关闭，此时如果再向线程池内提交任务，就会遭到拒绝。</li><li>第二种情况是线程池没有能力继续处理新提交的任务，也就是<u>工作已经非常饱和的时候</u>。</li></ul><h4 id="3-10-2-线程池拒绝任务的策略："><a href="#3-10-2-线程池拒绝任务的策略：" class="headerlink" title="3.10.2.线程池拒绝任务的策略："></a>3.10.2.线程池拒绝任务的策略：</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230804154232936.png" alt="image-20230804154232936"></p><ul><li>第一种拒绝策略是 AbortPolicy，这种拒绝策略在拒绝任务时，会直接<u><strong>抛出一个类型为 RejectedExecutionException 的 RuntimeException，让你感知到任务被拒绝了，于是你便可以根据业务逻辑选择重试或者放弃提交等策略。</strong></u></li><li>第二种拒绝策略是 DiscardPolicy，这种拒绝策略正如它的名字所描述的一样，<u><strong>当新任务被提交后直接被丢弃掉，也不会给你任何的通知，相对而言存在一定的风险，因为我们提交的时候根本不知道这个任务会被丢弃，可能造成数据丢失</strong></u>。</li><li>第三种拒绝策略是 DiscardOldestPolicy，如果线程池没被关闭且没有能力执行，则会<u><strong>丢弃任务队列中的头结点，通常是存活时间最长的任务</strong></u>，这种策略与第二种不同之处在于它丢弃的不是最新提交的，而是队列中存活时间最长的，这样就可以腾出空间给新提交的任务，但同理它也存在一定的数据丢失风险。</li><li>第四种拒绝策略是 CallerRunsPolicy，相对而言它就比较完善了，当有新任务提交后，如果线程池没被关闭且没有能力执行，则<u><strong>把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务</strong></u>。这样做主要有两点好处。<ul><li>第一点新提交的任务不会被丢弃，这样也就不会造成业务损失。</li><li>第二点好处是，由于谁提交任务谁就要负责执行任务，这样提交任务的线程就得负责执行任务，而执行任务又是比较耗时的，在这段期间，提交任务的线程被占用，也就不会再提交新的任务，减缓了任务提交的速度，相当于是一个负反馈。在此期间，线程池中的线程也可以充分利用这段时间来执行掉一部分任务，腾出一定的空间，相当于是给了线程池一定的缓冲期。</li></ul></li></ul><h3 id="3-11-有哪-6-种常见的线程池？什么是-Java8-的-ForkJoinPool？"><a href="#3-11-有哪-6-种常见的线程池？什么是-Java8-的-ForkJoinPool？" class="headerlink" title="3.11.有哪 6 种常见的线程池？什么是 Java8 的 ForkJoinPool？"></a>3.11.有哪 6 种常见的线程池？什么是 Java8 的 ForkJoinPool？</h3><h4 id="3-11-1-FixedThreadPool"><a href="#3-11-1-FixedThreadPool" class="headerlink" title="3.11.1.FixedThreadPool"></a>3.11.1.FixedThreadPool</h4><p>​它的核心线程数和最大线程数相同！</p><h4 id="3-11-2-CachedThreadPool"><a href="#3-11-2-CachedThreadPool" class="headerlink" title="3.11.2.CachedThreadPool"></a>3.11.2.CachedThreadPool</h4><p>​可以称作可缓存线程池，它的特点在于<u>线程数是几乎可以无限增加的</u>（实际最大可以达到 Integer.MAX_VALUE，为 2^31-1，这个数非常大，所以基本不可能达到），<u><strong>而当线程闲置时还可以对线程进行回收。</strong></u>也就是说该线程池的线程数量不是固定不变的，当然它也有一个用于存储提交任务的队列，但这个队列是 SynchronousQueue，队列的容量为0，实际不存储任何任务，它只负责对任务进行中转和传递，所以效率比较高。</p><h4 id="3-11-3-ScheduledThreadPool"><a href="#3-11-3-ScheduledThreadPool" class="headerlink" title="3.11.3.ScheduledThreadPool"></a>3.11.3.ScheduledThreadPool</h4><p>​它支持定时或周期性执行任务。比如每隔 10 秒钟执行一次任务</p><h4 id="3-11-4-SingleThreadExecutor"><a href="#3-11-4-SingleThreadExecutor" class="headerlink" title="3.11.4.SingleThreadExecutor"></a>3.11.4.SingleThreadExecutor</h4><p>​它会使用唯一的线程去执行任务，原理和 FixedThreadPool 是一样的，只不过这里线程只有一个，如果线程在执行任务的过程中发生异常，线程池也会重新创建一个线程来执行后续的任务。这种线程池由于只有一个线程，所以非常适合用于所有任务都需要按被提交的顺序依次执行的场景，而前几种线程池不一定能够保障任务的执行顺序等于被提交的顺序，因为它们是多线程并行执行的。</p><h4 id="3-11-5-SingleThreadScheduledExecutor"><a href="#3-11-5-SingleThreadScheduledExecutor" class="headerlink" title="3.11.5.SingleThreadScheduledExecutor"></a>3.11.5.SingleThreadScheduledExecutor</h4><p>​它只是将 <u>ScheduledThreadPool</u> 的核心线程数设置为了 1。</p><h4 id="3-11-6-ForkJoinPool"><a href="#3-11-6-ForkJoinPool" class="headerlink" title="3.11.6.ForkJoinPool"></a>3.11.6.ForkJoinPool</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230804160403936.png" alt="image-20230804160403936" style="zoom: 33%;" /><p>用一张全景图来描述 ForkJoinPool 线程池的内部结构，你可以看到 ForkJoinPool 线程池和其他线程池很多地方都是一样的，但重点区别在于它每个线程都有一个自己的双端队列来存储分裂出来的子任务。ForkJoinPool 非常适合用于递归的场景，例如树的遍历、最优路径搜索等场景。</p><h3 id="3-12-线程池常用的阻塞队列有哪些？"><a href="#3-12-线程池常用的阻塞队列有哪些？" class="headerlink" title="3.12.线程池常用的阻塞队列有哪些？"></a>3.12.线程池常用的阻塞队列有哪些？</h3><p>线程池的内部结构主要由四部分组成：</p><ul><li>第一部分是<strong>线程池管理器</strong>，它主要负责管理线程池的创建、销毁、添加任务等管理操作，它是整个线程池的管家。</li><li>第二部分是<strong>工作线程</strong>，也就是图中的线程 t0~t9，这些线程勤勤恳恳地从任务队列中获取任务并执行。</li><li>第三部分是<strong>任务队列</strong>，作为一种缓冲机制，线程池会把当下没有处理的任务放入任务队列中，由于多线程同时从任务队列中获取任务是并发场景，此时就需要任务队列满足线程安全的要求，所以线程池中任务队列采用 BlockingQueue 来保障线程安全。</li><li>第四部分是<strong>任务</strong>，任务要求实现统一的接口，以便工作线程可以处理和执行。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230804161223490.png" alt="image-20230804161223490"></p><h4 id="3-12-1-LinkedBlockingQueue"><a href="#3-12-1-LinkedBlockingQueue" class="headerlink" title="3.12.1.LinkedBlockingQueue"></a>3.12.1.LinkedBlockingQueue</h4><p>–对应的线程池大小固定，需要无限的队列</p><p>对于 FixedThreadPool 和 SingleThreadExector 而言，它们使用的阻塞队列是容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue，可以认为是<u>无界队列</u>。由于 FixedThreadPool 线程池的线程数是固定的，所以没有办法增加特别多的线程来处理任务，这时就需要 <u><strong>LinkedBlockingQueue 这样一个没有容量限制的阻塞队列来存放任务</strong></u>。这里需要注意，由于线程池的任务队列永远不会放满，所以线程池只会创建核心线程数量的线程，所以此时的最大线程数对线程池来说没有意义，因为并不会触发生成多于核心线程数的线程。</p><h4 id="3-12-2-SynchronousQueue"><a href="#3-12-2-SynchronousQueue" class="headerlink" title="3.12.2.SynchronousQueue"></a>3.12.2.SynchronousQueue</h4><p>–对应的线程池大小无限，所以也不需要能存放任务的队列(<strong>SynchronousQueue 本身并不存储任务，而是对任务直接进行转发</strong>)</p><p>第二种阻塞队列是 SynchronousQueue，对应的线程池是 CachedThreadPool。线程池 CachedThreadPool 的最大线程数是 Integer 的最大值，可以理解为线程数是可以无限扩展的。CachedThreadPool 和上一种线程池 FixedThreadPool 的情况恰恰相反，<strong>FixedThreadPool 的情况是阻塞队列的容量是无限的</strong>，<u><strong>而这里 CachedThreadPool 是线程数可以无限扩展</strong></u>，所以 CachedThreadPool 线程池并不需要一个任务队列来存储任务，因为一旦有任务被提交就直接转发给线程或者创建新线程来执行，而不需要另外保存它们。</p><p>我们自己创建使用 SynchronousQueue 的线程池时，如果不希望任务被拒绝，那么就需要注意设置最大线程数要尽可能大一些，以免发生任务数大于最大线程数时，没办法把任务放到队列中也没有足够线程来执行任务的情况。</p><h4 id="3-12-3-DelayedWorkQueue"><a href="#3-12-3-DelayedWorkQueue" class="headerlink" title="3.12.3.DelayedWorkQueue"></a>3.12.3.DelayedWorkQueue</h4><p>第三种阻塞队列是DelayedWorkQueue，它对应的线程池分别是 ScheduledThreadPool 和 SingleThreadScheduledExecutor，这两种<u>线程池的最大特点就是可以延迟执行任务</u>，比如说一定时间后执行任务或是每隔一定的时间执行一次任务。<u><strong>DelayedWorkQueue 的特点是内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构。</strong></u>之所以线程池 ScheduledThreadPool 和 SingleThreadScheduledExecutor 选择 DelayedWorkQueue，是因为它们本身正是基于时间执行任务的，<u>而延迟队列正好可以把任务按时间进行排序，方便任务的执行。</u></p><h3 id="3-13-为什么不应该自动创建线程池？"><a href="#3-13-为什么不应该自动创建线程池？" class="headerlink" title="3.13.为什么不应该自动创建线程池？"></a>3.13.为什么不应该自动创建线程池？</h3><p>因为上述的线程池中，<u>要么线程没有约束，可以无限多；要么队列没有约束，可以无限大；</u></p><p>当面对难于处理的大量任务时：</p><ul><li><p>要么<u>线程创建得太多</u>，导致最终超过了操作系统的上限而无法创建新线程，或者导致内存不足。</p></li><li><p>要么<u>队列中堆积的任务太多</u>，最终大量堆积的任务会占用大量内存，并发生 OOM ，也就是OutOfMemoryError，这几乎会影响到整个程序，会造成很严重的后果。</p></li></ul><h3 id="3-14合适的线程数量是多少？CPU-核心数和线程数的关系？"><a href="#3-14合适的线程数量是多少？CPU-核心数和线程数的关系？" class="headerlink" title="3.14合适的线程数量是多少？CPU 核心数和线程数的关系？"></a>3.14合适的线程数量是多少？CPU 核心数和线程数的关系？</h3><p>我们调整线程池中的线程数量的最主要的目的是为了<u>充分并合理地使用 CPU 和内存等资源</u>，从而最大限度地提高程序的性能</p><h4 id="CPU-密集型任务"><a href="#CPU-密集型任务" class="headerlink" title="CPU 密集型任务"></a>CPU 密集型任务</h4><p><em><u>—不能来太多，因为这些任务一旦执行，那么会一直使用CPU，任务多了的话CPU很快就不够用了。</u></em></p><p>​首先，我们来看 CPU 密集型任务，比如加密、解密、压缩、计算等一系列需要大量耗费 CPU 资源的任务。</p><p>​对于这样的任务<u>最佳的线程数为 CPU 核心数的 1~2 倍</u>，如果设置过多的线程数，实际上并不会起到很好的效果。此时假设我们设置的线程数量是 CPU 核心数的 2 倍以上，因**<u>为计算任务非常重，会占用大量的 CPU 资源，所以这时 CPU 的每个核心工作基本都是满负荷的，而我们又设置了过多的线程，每个线程都想去利用 CPU 资源来执行自己的任务，这就会造成不必要的上下文切换，此时线程数的增多并没有让性能提升，反而由于线程数量过多会导致性能下降。</u>**</p><p>针对这种情况，我们最好还要同时考虑在同一台机器上还有哪些其他会占用过多 CPU 资源的程序在运行，然后对资源使用做整体的平衡。</p><h4 id="耗时-IO-型任务"><a href="#耗时-IO-型任务" class="headerlink" title="耗时 IO 型任务"></a>耗时 IO 型任务</h4><p><em><u>—可以多来点，因为这些任务不会一直占用CPU，多来点才能最大限度使用cpu</u></em></p><p>第二种任务是耗时 IO 型，比如<u>数据库、文件的读写，网络通信等任务</u>，这种任务的特点是<u>并不会特别消耗 CPU 资源，但是 IO 操作很耗时，总体会占用比较多的时间。</u><strong><u>对于这种任务最大线程数一般会大于 CPU 核心数很多倍，因为 IO 读写速度相比于 CPU 的速度而言是比较慢的，如果我们设置过少的线程数，就可能导致 CPU 资源的浪费。而如果我们设置更多的线程数，那么当一部分线程正在等待 IO 的时候，它们此时并不需要 CPU 来计算，那么另外的线程便可以利用 CPU 去执行其他的任务，互不影响，这样的话在任务队列中等待的任务就会减少，可以更好地利用资源。</u></strong></p><h3 id="3-15-如何根据实际需要，定制自己的线程池？"><a href="#3-15-如何根据实际需要，定制自己的线程池？" class="headerlink" title="3.15.如何根据实际需要，定制自己的线程池？"></a>3.15.如何根据实际需要，定制自己的线程池？</h3><h4 id="核心线程数"><a href="#核心线程数" class="headerlink" title="核心线程数:"></a>核心线程数:</h4><p>​线程的平均工作时间所占比例越高，就需要越少的线程；线程的平均等待时间所占比例越高，就需要越多的线程。</p><h4 id="最大线程数："><a href="#最大线程数：" class="headerlink" title="最大线程数："></a>最大线程数：</h4><p>​对于最大线程数而言，如果我们执行的任务类型不是固定的，比如可能一段时间是 CPU 密集型，另一段时间是 IO 密集型，或是同时有两种任务相互混搭。那么在这种情况下，<u><strong>我们可以把最大线程数设置成核心线程数的几倍，以便应对任务突发情况。</strong></u></p><p>​更好的办法是<u><strong>用不同的线程池执行不同类型的任务，让任务按照类型区分开，而不是混杂在一起，</strong></u>这样就可以按照上一课时估算的线程数或经过压测得到的结果来设置合理的线程数了，达到更好的性能。</p><h4 id="阻塞队列："><a href="#阻塞队列：" class="headerlink" title="阻塞队列："></a>阻塞队列：</h4><p>​有一种常用的阻塞队列叫 ArrayBlockingQueue，它也经常被用于线程池中，这种阻塞队列内部是用数组实现的，在新建对象的时候要求传入容量值，且后期不能扩容，所以 ArrayBlockingQueue 的最大的特点就是容量是有限的。</p><p>​<u>这样一来，如果任务队列放满了任务，而且线程数也已经达到了最大值，线程池根据规则就会拒绝新提交的任务，这样一来就可能会产生一定的数据丢失。但相比于无限增加任务或者线程数导致内存不足，进而导致程序崩溃，数据丢失还是要更好一些的，如果我们使用了 ArrayBlockingQueue 这种阻塞队列，再加上我们限制了最大线程数量，就可以非常有效地防止资源耗尽的情况发生。</u>此时的队列容量大小和 maxPoolSize 是一个 trade-off，如果<u><strong>我们使用容量更大的队列和更小的最大线程数，就可以减少上下文切换带来的开销，但也可能因此降低整体的吞吐量；如果我们的任务是 IO 密集型，则可以选择稍小容量的队列和更大的最大线程数，这样整体的效率就会更高，不过也会带来更多的上下文切换。</strong></u></p><h4 id="线程工厂："><a href="#线程工厂：" class="headerlink" title="线程工厂："></a>线程工厂：</h4><p>​对于线程工厂 threadFactory 这个参数，我们可以使用默认的 defaultThreadFactory，也可以传入自定义的有额外能力的线程工厂，因为<u>我们可能有多个线程池，而不同的线程池之间有必要通过不同的名字来进行区分，所以可以传入能根据业务信息进行命名的线程工厂，以便后续<strong>可以根据线程名区分不同的业务进而快速定位问题代码</strong>。</u></p><h4 id="拒绝策略：-1"><a href="#拒绝策略：-1" class="headerlink" title="拒绝策略："></a>拒绝策略：</h4><p>除了之前说的：返回异常、直接丢弃、丢弃最早的节点、谁提交任务谁执行</p><p>还可以还可以通过<u><strong>实现 RejectedExecutionHandler 接口来实现自己的拒绝策略</strong></u>，在接口中我们需要实现 rejectedExecution 方法，在 rejectedExecution 方法中，执行例如打印日志、暂存任务、重新执行等自定义的拒绝策略，以便满足业务需求。</p><h3 id="3-16-如何正确地关闭线程池？shutdown-和-shutdownNow-的区别？"><a href="#3-16-如何正确地关闭线程池？shutdown-和-shutdownNow-的区别？" class="headerlink" title="3.16.如何正确地关闭线程池？shutdown 和 shutdownNow 的区别？"></a>3.16.如何正确地关闭线程池？shutdown 和 shutdownNow 的区别？</h3><h4 id="3-16-1-shutdown"><a href="#3-16-1-shutdown" class="headerlink" title="3.16.1.shutdown()"></a>3.16.1.shutdown()</h4><p>第一种方法叫作 shutdown()，它可以<u>安全地关闭一个线程池</u>，调用 shutdown() 方法之后线程池并不是立刻就被关闭，因为这时线程池中可能还有很多任务正在被执行，或是任务队列中有大量正在等待被执行的任务，调用 shutdown() 方法后线程池会在执行完正在执行的任务和队列中等待的任务后才彻底关闭。但这并不代表 shutdown() 操作是没有任何效果的，调用 shutdown() 方法后如果还有新的任务被提交，线程池则会根据拒绝策略直接拒绝后续新提交的任务。</p><h4 id="3-16-2-isShutdown"><a href="#3-16-2-isShutdown" class="headerlink" title="3.16.2.isShutdown()"></a>3.16.2.isShutdown()</h4><p>第二个方法叫作 isShutdown()，它可以返回 true 或者 false 来判断线程池是否已经开始了关闭工作，也就是是否执行了 shutdown 或者 shutdownNow 方法。这里需要注意，<u><strong>如果调用 isShutdown() 方法的返回的结果为 true 并不代表线程池此时已经彻底关闭了，这仅仅代表线程池开始了关闭的流程，也就是说，此时可能线程池中依然有线程在执行任务，队列里也可能有等待被执行的任务。</strong></u></p><h4 id="3-16-3-isTerminated"><a href="#3-16-3-isTerminated" class="headerlink" title="3.16.3.isTerminated()"></a>3.16.3.isTerminated()</h4><p>第三种方法叫作 isTerminated()，这个方法可以检测线程池是否真正“终结”了，这不仅代表线程池已关闭，同时代表线程池中的所有任务都已经都执行完毕了，因为我们刚才说过，调用 shutdown 方法之后，线程池会继续执行里面未完成的任务，不仅包括线程正在执行的任务，还包括正在任务队列中等待的任务。比如此时已经调用了 shutdown 方法，但是有一个线程依然在执行任务，那么此时调用 isShutdown 方法返回的是 true ，而调用 isTerminated 方法返回的便是 false ，因为线程池中还有任务正在在被执行，线程池并没有真正“终结”。直到所有任务都执行完毕了，调用 isTerminated() 方法才会返回 true，这表示线程池已关闭并且线程池内部是空的，所有剩余的任务都执行完毕了。</p><h4 id="3-16-4-awaitTermination"><a href="#3-16-4-awaitTermination" class="headerlink" title="3.16.4.awaitTermination()"></a>3.16.4.awaitTermination()</h4><p>第四个方法叫作 awaitTermination()，它本身并不是用来关闭线程池的，而是主要用来判断线程池状态的。比如我们给 awaitTermination 方法传入的参数是 10 秒，那么它就会陷入 10 秒钟的等待，直到发生以下三种情况之一：</p><ol><li>等待期间（包括进入等待状态之前）线程池已关闭并且所有已提交的任务（包括正在执行的和队列中等待的）都执行完毕，相当于线程池已经“终结”了，方法便会返回 true；</li><li>等待超时时间到后，第一种线程池“终结”的情况始终未发生，方法返回 false；</li><li>等待期间线程被中断，方法会抛出 InterruptedException 异常。</li></ol><p>也就是说，调用 awaitTermination 方法后当前线程会尝试等待一段指定的时间，如果在等待时间内，线程池已关闭并且内部的任务都执行完毕了，也就是说线程池真正“终结”了，那么方法就返回 true，否则超时返回 fasle。</p><p>我们则可以根据 awaitTermination() 返回的布尔值来判断下一步应该执行的操作。</p><h4 id="3-16-5-shutdownNow"><a href="#3-16-5-shutdownNow" class="headerlink" title="3.16.5.shutdownNow()"></a>3.16.5.shutdownNow()</h4><p>最后一个方法是 shutdownNow()，也是 5 种方法里功能最强大的，它与第一种 shutdown 方法不同之处在于名字中多了一个单词 Now，也就是表示立刻关闭的意思。在执行 shutdownNow 方法之后，<u><strong>首先会给所有线程池中的线程发送 interrupt 中断信号，尝试中断这些任务的执行，然后会将任务队列中正在等待的所有任务转移到一个 List 中并返回，我们可以根据返回的任务 List 来进行一些补救的操作。</strong></u></p><h3 id="3-17-线程池实现“线程复用”的原理"><a href="#3-17-线程池实现“线程复用”的原理" class="headerlink" title="3.17.线程池实现“线程复用”的原理"></a>3.17.线程池实现“线程复用”的原理</h3><p>我们知道线程池会使用固定数量或可变数量的线程来执行任务，但无论是固定数量或可变数量的线程，其线程数量都远远小于任务数量，面对这种情况线程池可以通过线程复用让同一个线程去执行不同的任务，那么线程复用背后的原理是什么呢？</p><p>线程池可以把线程和任务进行解耦，线程归线程，任务归任务，摆脱了之前通过 Thread 创建线程时的一个线程必须对应一个任务的限制。在线程池中，同一个线程可以从 BlockingQueue 中不断提取新任务来执行，其核心原理在于<u><strong>线程池对 Thread 进行了封装，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程去执行一个“循环任务”，在这个“循环任务”中，不停地检查是否还有任务等待被执行，如果有则直接去执行这个任务，也就是调用任务的 run 方法，把 run 方法当作和普通方法一样的地位去调用，相当于把每个任务的 run() 方法串联了起来，所以线程数量并不增加。</strong></u></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123; </span><br><span class="line">  <span class="comment">//execute 方法中通过 if 语句判断 command ，也就是 Runnable 任务是否等于 null，如果为 null 就抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">  <span class="comment">//addWorker 方法的主要作用是在线程池中创建一个线程并执行第一个参数传入的任务，它的第二个参数是个布尔值，如果布尔值传入 true 代表增加线程时判断当前线程是否少于 corePoolSize，小于则增加新线程，大于等于则不增加；同理，如果传入 false 代表增加线程时判断当前线程是否少于 maxPoolSize，小于则增加新线程，大于等于则不增加，所以这里的布尔值的含义是以核心线程数为界限还是以最大线程数为界限进行是否新增线程的判断。addWorker() 方法如果返回 true 代表添加成功，如果返回 false 代表添加失败。</span></span><br><span class="line">  <span class="comment">//现有线程数小于线程池核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; </span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>)) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125; </span><br><span class="line">  <span class="comment">//运行到此处说明 现有线程数 &gt;= 线程池核心线程数</span></span><br><span class="line">  <span class="comment">//线程池是running状态 &amp;&amp; 能把任务放进队列中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) </span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) </span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//运行到此处说明 不是running状态 || 线程数&gt;=核心线程数 并且 任务队列满</span></span><br><span class="line">  <span class="comment">//那么以最大队线程数为标准创建线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>)) </span><br><span class="line">      <span class="comment">//还是无法创建，则拒绝</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-18-你知道哪几种锁？分别有什么特点？"><a href="#3-18-你知道哪几种锁？分别有什么特点？" class="headerlink" title="3.18.你知道哪几种锁？分别有什么特点？"></a>3.18.你知道哪几种锁？分别有什么特点？</h3><p>根据<u>分类标准</u>我们把锁分为以下 7 大类别，分别是：</p><ul><li>偏向锁&#x2F;轻量级锁&#x2F;重量级锁；</li><li>可重入锁&#x2F;非可重入锁；</li><li>共享锁&#x2F;独占锁；</li><li>公平锁&#x2F;非公平锁；</li><li>悲观锁&#x2F;乐观锁；</li><li>自旋锁&#x2F;非自旋锁；</li><li>可中断锁&#x2F;不可中断锁。</li></ul><h4 id="3-18-1-偏向锁-x2F-轻量级锁-x2F-重量级锁"><a href="#3-18-1-偏向锁-x2F-轻量级锁-x2F-重量级锁" class="headerlink" title="3.18.1.偏向锁&#x2F;轻量级锁&#x2F;重量级锁"></a>3.18.1.偏向锁&#x2F;轻量级锁&#x2F;重量级锁</h4><ul><li>偏向锁</li></ul><p>如果自始至终，对于这把锁都不存在竞争，那么其实就没必要上锁，只需要打个标记就行了，这就是偏向锁的思想。一个对象被初始化后，还没有任何线程来获取它的锁时，那么它就是可偏向的，<u>当有第一个线程来访问它并尝试获取锁的时候，它就将这个线程记录下来，以后如果尝试获取锁的线程正是偏向锁的拥有者，就可以直接获得锁，开销很小，性能最好。</u></p><ul><li>轻量级锁</li></ul><p>JVM 开发者发现在很多情况下，synchronized 中的代码是被多个线程交替执行的，而不是同时执行的，也就是说并不存在实际的竞争，或者是只有短时间的锁竞争，用 CAS 就可以解决，这种情况下，用完全互斥的重量级锁是没必要的。轻量级锁是指当锁原来是偏向锁的时候，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过自旋(一段时间&#x2F;一定次数反复请求)的形式尝试获取锁，而不会陷入阻塞。</p><ul><li>重量级锁</li></ul><p>重量级锁是互斥锁，它是利用操作系统的同步机制实现的，所以开销相对比较大。当多个线程直接有实际竞争，且锁竞争时间长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。重量级锁会让其他申请却拿不到锁的线程进入阻塞状态。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%2078%20%e8%ae%b2-%e5%ae%8c/assets/CgpOIF35yCGAGFBbAAAO9n9VgTQ034.png" alt="img"></p><p>你可以发现锁升级的路径：无锁→偏向锁→轻量级锁→重量级锁。</p><p>综上所述，偏向锁性能最好，可以避免执行 CAS 操作。而轻量级锁利用自旋和 CAS 避免了重量级锁带来的线程阻塞和唤醒，性能中等。重量级锁则会把获取不到锁的线程阻塞，性能最差。</p><h4 id="3-18-2-可重入锁-x2F-非可重入锁"><a href="#3-18-2-可重入锁-x2F-非可重入锁" class="headerlink" title="3.18.2.可重入锁&#x2F;非可重入锁"></a>3.18.2.可重入锁&#x2F;非可重入锁</h4><p>​第 2 个分类是可重入锁和非可重入锁。<u>可重入锁指的是线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁</u>。同理，不可重入锁指的是虽然线程当前持有了这把锁，但是如果想再次获取这把锁，也必须要先释放锁后才能再次尝试获取。</p><p>​对于可重入锁而言，最典型的就是 ReentrantLock 了，正如它的名字一样，reentrant 的意思就是可重入，它也是 Lock 接口最主要的一个实现类。</p><h4 id="3-18-3-共享锁-x2F-独占锁"><a href="#3-18-3-共享锁-x2F-独占锁" class="headerlink" title="3.18.3.共享锁&#x2F;独占锁"></a>3.18.3.共享锁&#x2F;独占锁</h4><p>​共享锁指的是我们同一把锁可以被多个线程同时获得，而独占锁指的就是，这把锁只能同时被一个线程获得。我们的读写锁，就最好地诠释了共享锁和独占锁的理念。读写锁中的读锁，是共享锁，而写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。</p><h4 id="3-18-4-公平锁-x2F-非公平锁"><a href="#3-18-4-公平锁-x2F-非公平锁" class="headerlink" title="3.18.4.公平锁&#x2F;非公平锁"></a>3.18.4.公平锁&#x2F;非公平锁</h4><p>​公平锁的公平的含义在于如果线程现在拿不到这把锁，那么线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有<u>先来先得</u>的意思。而非公平锁就不那么“完美”了，它会在一定情况下，忽略掉已经在排队的线程，<u>发生插队现象</u>。</p><h4 id="3-18-5-悲观锁-x2F-乐观锁"><a href="#3-18-5-悲观锁-x2F-乐观锁" class="headerlink" title="3.18.5.悲观锁&#x2F;乐观锁"></a>3.18.5.悲观锁&#x2F;乐观锁</h4><p>​悲观锁的概念是在获取资源之前，必须先拿到锁，<u>以便达到“独占”的状态</u>，当前线程在操作资源的时候，其他线程由于不能拿到锁，所以其他线程不能来影响我。</p><p>​而乐观锁恰恰相反，它并不要求在获取资源前拿到锁，也不会锁住资源；相反，<u>乐观锁利用 CAS 理念，在不独占资源的情况下，完成了对资源的修改。</u></p><h4 id="3-18-6-自旋锁-x2F-非自旋锁"><a href="#3-18-6-自旋锁-x2F-非自旋锁" class="headerlink" title="3.18.6.自旋锁&#x2F;非自旋锁"></a>3.18.6.自旋锁&#x2F;非自旋锁</h4><p>​自旋锁的理念是如果线程现在拿不到锁，<u>并不直接陷入阻塞或者释放 CPU 资源，而是开始利用循环，不停地尝试获取锁，这个循环过程被形象地比喻为“自旋”</u>，就像是线程在“自我旋转”。相反，非自旋锁的理念就是没有自旋的过程，如果<u>拿不到锁就直接放弃</u>，或者进行其他的处理逻辑，例如去排队、陷入阻塞等。</p><h4 id="3-18-7-可中断锁-x2F-不可中断锁"><a href="#3-18-7-可中断锁-x2F-不可中断锁" class="headerlink" title="3.18.7.可中断锁&#x2F;不可中断锁"></a>3.18.7.可中断锁&#x2F;不可中断锁</h4><p>​在 Java 中，synchronized 关键字修饰的锁代表的是不可中断锁，<u>一旦线程申请了锁，就没有回头路了，只能等到拿到锁以后才能进行其他的逻辑处理</u>。</p><p>​而我们的 ReentrantLock 是一种典型的可中断锁，例如使用 lockInterruptibly 方法在获取锁的过程中，<u><strong>突然不想获取了，那么也可以在中断之后去做其他的事情，不需要一直傻等到获取到锁才离开。</strong></u></p><h3 id="3-19-悲观锁与乐观锁"><a href="#3-19-悲观锁与乐观锁" class="headerlink" title="3.19.悲观锁与乐观锁"></a>3.19.悲观锁与乐观锁</h3><ul><li>悲观锁：synchronized 关键字和 Lock 接口</li></ul><p>Java 中悲观锁的实现包括 synchronized 关键字和 Lock 相关类等，我们以 Lock 接口为例，例如 Lock 的实现类 ReentrantLock，类中的 lock() 等方法就是执行加锁，而 unlock() 方法是执行解锁。处理资源之前必须要先加锁并拿到锁，等到处理完了之后再解开锁，这就是非常典型的悲观锁思想。</p><ul><li>乐观锁：原子类</li></ul><p>乐观锁的典型案例就是原子类，例如 AtomicInteger 在更新数据时，就使用了乐观锁的思想，多个线程可以同时操作同一个原子变量。</p><ul><li>大喜大悲：数据库</li></ul><p>数据库中同时拥有悲观锁和乐观锁的思想。例如，我们如果在 MySQL 选择 <strong>select for update</strong> 语句，那就是<u>悲观锁</u>，在提交之前不允许第三方来修改该数据，这当然会造成一定的性能损耗，在高并发的情况下是不可取的。</p><p>相反，我们可以利用<strong>一个版本 version 字段在数据库中实现乐观锁</strong>。在获取及修改数据时都不需要加锁，但是我们在获取完数据并计算完毕，准备更新数据时，会检查版本号和获取数据时的版本号是否一致，如果一致就直接更新，如果不一致，说明计算期间已经有其他线程修改过这个数据了，那我就可以选择重新获取数据，重新计算，然后再次尝试更新数据。</p><h4 id="两种锁各自的使用场景"><a href="#两种锁各自的使用场景" class="headerlink" title="两种锁各自的使用场景"></a>两种锁各自的使用场景</h4><p>悲观锁适合用于**<u>并发写入多、临界区代码复杂、竞争激烈等场景</u>**，这种场景下悲观锁可以避免大量的无用的反复尝试等消耗。</p><p>乐观锁适用于大部分是读取，少部分是修改的场景，也适合虽然读写都很多，但是<u>并发并不激烈的场景</u>。在这些场景下，乐观锁不加锁的特点能让性能大幅提高。</p><h3 id="3-20-如何看到-synchronized-背后的“monitor-锁”？"><a href="#3-20-如何看到-synchronized-背后的“monitor-锁”？" class="headerlink" title="3.20.如何看到 synchronized 背后的“monitor 锁”？"></a>3.20.如何看到 synchronized 背后的“monitor 锁”？</h3><h4 id="获取和释放-monitor-锁的时机"><a href="#获取和释放-monitor-锁的时机" class="headerlink" title="获取和释放 monitor 锁的时机"></a>获取和释放 monitor 锁的时机</h4><p>我们都知道，最简单的同步方式就是利用 synchronized 关键字来修饰代码块或者修饰一个方法，那么这部分被保护的代码，在同一时刻就最多只有一个线程可以运行，而 synchronized 的背后正是利用 monitor 锁实现的。</p><p>​所以首先我们来看下获取和释放 monitor 锁的时机，<u>每个 Java 对象都可以用作一个实现同步的锁，这个锁也被称为内置锁或 monitor 锁</u>，获得 monitor 锁的唯一途径就是进入由这个锁保护的同步代码块或同步方法，线程在进入被 synchronized 保护的代码块之前，会自动获取锁，并且无论是正常路径退出，还是通过抛出异常退出，在退出的时候都会自动释放锁。</p><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    method body</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价⬇️</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.intrinsicLock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        method body</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.intrinsicLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种写法中，进入 method 方法后，立刻添加内置锁，并且用 try 代码块把方法保护起来，最后用 finally 释放这把锁，这里的 intrinsicLock 就是 monitor 锁。</p><h4 id="synchronized-修饰的代码块："><a href="#synchronized-修饰的代码块：" class="headerlink" title="synchronized 修饰的代码块："></a>synchronized 修饰的代码块：</h4><p>利用monitorenter与monitorexit指令实现：</p><h5 id="monitorenter："><a href="#monitorenter：" class="headerlink" title="monitorenter："></a>monitorenter：</h5><p>执行 monitorenter 的线程尝试获得 monitor 的所有权，会发生以下这三种情况之一：</p><p>a. 如果该 monitor 的计数为 0，则线程获得该 monitor 并将其计数设置为 1。然后，该线程就是这个 monitor 的所有者。</p><p>b. 如果线程已经拥有了这个 monitor ，则它将重新进入，并且累加计数。</p><p>c. 如果其他线程已经拥有了这个 monitor，那个这个线程就会被阻塞，直到这个 monitor 的计数变成为 0，代表这个 monitor 已经被释放了，于是当前这个线程就会再次尝试获取这个 monitor。</p><h5 id="monitorexit："><a href="#monitorexit：" class="headerlink" title="monitorexit："></a>monitorexit：</h5><p>monitorexit 的作用是将 monitor 的计数器减 1，直到减为 0 为止。代表这个 monitor 已经被释放了，已经没有任何线程拥有它了，也就代表着解锁，所以，其他正在等待这个 monitor 的线程，此时便可以再次尝试获取这个 monitor 的所有权。</p><h4 id="synchronized-修饰的方法："><a href="#synchronized-修饰的方法：" class="headerlink" title="synchronized 修饰的方法："></a>synchronized 修饰的方法：</h4><p>——利用flag实现</p><p>​会有一个 ACC_SYNCHRONIZED 标志。当某个线程要访问某个方法的时候，会首先检查方法是否有 ACC_SYNCHRONIZED 标志，如果有则需要先获得 monitor 锁，然后才能开始执行方法，方法执行之后再释放 monitor 锁。</p><h3 id="3-21-synchronized-和-Lock-孰优孰劣，如何选择？"><a href="#3-21-synchronized-和-Lock-孰优孰劣，如何选择？" class="headerlink" title="3.21.synchronized 和 Lock 孰优孰劣，如何选择？"></a>3.21.synchronized 和 Lock 孰优孰劣，如何选择？</h3><p>synchronized不够灵活并只能被一个线程拥有，但是：</p><ol><li>如果能不用最好既不使用 Lock 也不使用 synchronized。因为在许多情况下你可以使用 java.util.concurrent 包中的机制，它会为你处理所有的加锁和解锁操作，也就是推荐优先使用工具类来加解锁。</li><li>如果 synchronized 关键字适合你的程序， 那么请尽量使用它，这样可以减少编写代码的数量，减少出错的概率。因为一旦忘记在 finally 里 unlock，代码可能会出很大的问题，而使用 synchronized 更安全。</li><li>如果特别需要 Lock 的特殊功能，比如尝试获取锁、可中断、超时功能等，才使用 Lock。</li></ol><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%2078%20%e8%ae%b2-%e5%ae%8c/23%20Lock%20%e6%9c%89%e5%93%aa%e5%87%a0%e4%b8%aa%e5%b8%b8%e7%94%a8%e6%96%b9%e6%b3%95%ef%bc%9f%e5%88%86%e5%88%ab%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8%ef%bc%9f.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%2078%20%e8%ae%b2-%e5%ae%8c/23%20Lock%20%e6%9c%89%e5%93%aa%e5%87%a0%e4%b8%aa%e5%b8%b8%e7%94%a8%e6%96%b9%e6%b3%95%ef%bc%9f%e5%88%86%e5%88%ab%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8%ef%bc%9f.md</a></p><p>参考资料：</p><ul><li><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2078%20%E8%AE%B2-%E5%AE%8C/">https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2078%20%E8%AE%B2-%E5%AE%8C/</a></p></li><li><p><a href="https://juejin.cn/post/6896278031317663751">https://juejin.cn/post/6896278031317663751</a></p></li><li><p><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2">https://javadoop.com/post/AbstractQueuedSynchronizer-2</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL高可用</title>
      <link href="/2023/09/09/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
      <url>/2023/09/09/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL高可用："><a href="#MySQL高可用：" class="headerlink" title="MySQL高可用："></a>MySQL高可用：</h1><h3 id="读写分离："><a href="#读写分离：" class="headerlink" title="读写分离："></a>读写分离：</h3><p>​<u>在<strong>读多写少</strong>的情景下，给数据库添加缓存往往不能起到很好的效果：因为在大量的读请求下，缓存的命中率不高，很多请求会 <strong>穿透</strong> 缓存，最终打到数据库上。</u></p><p>​比如在“订单中心”这样的场景中，每个用户的订单都不同，除非全量缓存数据库订单信息（又会带来架构的复杂度），不然缓存的命中率依旧很低。</p><h4 id="MySQL-主从复制的原理："><a href="#MySQL-主从复制的原理：" class="headerlink" title="MySQL 主从复制的原理："></a>MySQL 主从复制的原理：</h4><p>​将mysql拆分成主库、从库，通过主从复制实现数据同步。</p><h5 id="三个步骤："><a href="#三个步骤：" class="headerlink" title="三个步骤："></a>三个步骤：</h5><ul><li><strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据。<ul><li>MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。</li></ul></li><li><strong>同步 Binlog</strong>：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。<ul><li>从库会创建一个专门的 I&#x2F;O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。</li></ul></li><li><strong>回放 Binlog</strong>：回放 binlog，并更新存储数据。<ul><li>从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。</li></ul></li></ul><p>⚠️当然，<strong>从库过多也不是一味的好</strong>，因为主库将 binlog 传输到每一个从库时都需要创建一个 log dump 线程来处理复制的请求，从库过多会导致主库的资源消耗增加，并且也会受限于主库的带宽而减慢传输速度。</p><h4 id="MySQL-主从复制还有哪些模型？"><a href="#MySQL-主从复制还有哪些模型？" class="headerlink" title="MySQL 主从复制还有哪些模型？"></a>MySQL 主从复制还有哪些模型？</h4><ul><li><strong>同步复制</strong>：事务线程要等待所有从库的复制成功响应。</li><li><strong>异步复制</strong>：事务线程完全不等待从库的复制成功响应。</li><li><strong>半同步复制</strong>：MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。</li></ul><h4 id="在系统设计上有哪些方案可以解决主从复制的延迟问题？"><a href="#在系统设计上有哪些方案可以解决主从复制的延迟问题？" class="headerlink" title="在系统设计上有哪些方案可以解决主从复制的延迟问题？"></a>在系统设计上有哪些方案可以解决主从复制的延迟问题？</h4><h5 id="1-使用数据冗余："><a href="#1-使用数据冗余：" class="headerlink" title="1.使用数据冗余："></a>1.使用数据冗余：</h5><p>​对于刚更新完主库后的数据的查询，主库直接自己发一条包含更新信息的数据给业务端，这样就不需要查询从库了。</p><h5 id="2-使用缓存解决："><a href="#2-使用缓存解决：" class="headerlink" title="2.使用缓存解决："></a>2.使用缓存解决：</h5><p>​主库刚更新的同时将数据写入redis缓存中</p><p><u>以上两种方法可能会导致数据不一致的情况(A想更，B想更，B更新，A更新)，需要<strong>分布式锁</strong>的协助</u></p><h5 id="3-直接查询主库："><a href="#3-直接查询主库：" class="headerlink" title="3.直接查询主库："></a>3.直接查询主库：</h5><p>​该方案在使用时一定要谨慎，你要提前明确查询的数据量不大，不然会出现主库写请求锁行，影响读请求的执行，最终对主库造成比较大的压力。</p><h3 id="分库分表："><a href="#分库分表：" class="headerlink" title="分库分表："></a>分库分表：</h3><p>​原则：能不分表分库就不要分表分库，这是最后的手段！</p><h4 id="🌳垂直划分："><a href="#🌳垂直划分：" class="headerlink" title="🌳垂直划分："></a>🌳垂直划分：</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ol><li>为了避免 IO 争抢并减少锁表的几率，查看详情的用户与商品信息浏览互不影响</li><li>充分发挥热门数据的操作效率，商品信息的操作的高效率不会被商品描述的低效率所拖累</li></ol><h5 id="拆分原则："><a href="#拆分原则：" class="headerlink" title="拆分原则："></a>拆分原则：</h5><ol><li>把不常用的字段单独放在一张表</li><li>把text，blob等大字段拆分出来放在附表中</li><li>经常组合查询的列放在一张表中</li></ol><p>​<u>将一张表的数据，根据场景切分成多张表，本质是由于前期抽象不足，需要将业务数据进一步拆分。</u></p><p>​如果一张表中一些记录为热点，常被访问，但是一些数据很少被查询，就可以根据访问频次进行垂直分表。</p><p>​可以把一些不常用的列划分到新表中，减少原表的大小。</p><h4 id="🌊水平划分："><a href="#🌊水平划分：" class="headerlink" title="🌊水平划分："></a>🌊水平划分：</h4><p>​水平分表本质是<u>将一张大表拆成多个结构相同的子表</u>。</p><p>分片算法(路由规则)：</p><ul><li><p>范围分片</p><ul><li>根据时间、某关键字的范围</li><li>以上两种方式容易产生热点问题，但是扩展时比较方便</li></ul></li><li><p>hash分片</p><ul><li>hash(最简单的，可以对分片数进行取余)</li><li><strong>哈希取模的路由方式能够使数据访问均匀，但是不便于扩展(因为改了hash函数，那么每个库里的数据可能需要移动)</strong></li></ul></li><li><p>查表法(自定义)</p><ul><li>查表则是人为地构建每条记录与分片的映射关系</li></ul></li><li><p>🌟hash取模 + 范围</p><ul><li>先根据字段的hash值确定该记录在哪个数据库中，在每个数据库中再根据id的范围进行分表</li><li><u>这种方式避免了单纯基于数据范围可能出现的热点存储，并且在后期扩展时，可以直接增加对应的扩展表，避免了复杂的数据迁移工作。</u></li></ul></li></ul><h5 id="根据关键字划分："><a href="#根据关键字划分：" class="headerlink" title="根据关键字划分："></a>根据关键字划分：</h5><p>​某关键字列相同的记录被放在同一表中</p><h6 id="例子🌰："><a href="#例子🌰：" class="headerlink" title="例子🌰："></a>例子🌰：</h6><p>​user_score表可以用user_id这个关键字来分表的：使用user_id mod 10，即可把user_score表分为10个小表，小表的名字为user_score_{user_id%10} 这种形式。</p><h6 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h6><p>​这种方案<u>适用于按关键字查询频繁的场景</u>，关键字相同的数据，必须落在同张表，不然要是有列表分页查询，就会很麻烦。</p><h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><p>​不足之处在于，**<u>可能有比较多的大客户落在同一张表，分表数据不均匀</u>**。假设在我们的场景，支持代理机构注册一个用户id，多个学生可以使用同一个用户id参加考试，那么某个用户的数据量有可能非常大。</p><h5 id="根据大小划分："><a href="#根据大小划分：" class="headerlink" title="根据大小划分："></a>根据大小划分：</h5><p>​比如每200w记录，就自动生成一张新表。</p><h6 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h6><p>​大小均匀，性能可控。这里建议每个分表不超过500万行数据，这样对数据库造成的压力不会太大；适用于流水记账等场景。</p><h6 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h6><p>​如果查询的场景与某个关键字有关，那么本方案就有比较大的局限性，不知道关键字 &#x3D; xxx的记录横跨了多少表。</p><h5 id="根据时间划分："><a href="#根据时间划分：" class="headerlink" title="根据时间划分："></a>根据时间划分：</h5><p>​这种方案适用于数据和时间成关联，热度也跟时间成关联的场景。</p><h6 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h6><p>​思路简单，且很容易清理掉旧数据，整个表能自动变冷。</p><h6 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h6><p>​缺点在于业务初期，对业务量的预估，会存在难度：可能一开始月表绰绰有余，后期随着业务量突飞猛进，一个月都有千万条甚至上亿条数据，此时又得进行拆分。另外，用该方案时一定要注意时间分割的节点，会不会造成有相关联的数据出现不一致。</p><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><h5 id="各种方式的特点："><a href="#各种方式的特点：" class="headerlink" title="各种方式的特点："></a>各种方式的特点：</h5><ul><li><strong>垂直分表：</strong> 可以把一个宽表的字段按<u>访问频次</u>、<u>是否是大字段</u>的原则拆分为多个表，这样既能使业务清晰，还能提升部分性能。拆分后，尽量从业务角度避免联查，否则性能方面将得不偿失。</li><li><strong>垂直分库：</strong> 可以把多个表<u>按业务耦合松紧归类</u>，分别存放在不同的库，这些库可以分布在不同服务器，从而使访问压力被多服务器负载，大大提升性能，同时能<strong>提高整体架构的业务清晰度</strong>，不同的业务库可根据自身情况定制优化方案。但是它需要解决跨库带来的所有复杂问题。</li><li><strong>水平分库：</strong> 可以把一个表的数据(按数据行)分到多个不同的库，每个库只有这个表的部分数据，这些库可以分布在不同服务器，从而使访问压力被多服务器负载，大大提升性能。它不仅需要解决跨库带来的所有复杂问题，还要解决数据路由的问题。</li><li><strong>水平分表：</strong> 可以把一个表的数据(按数据行)分到多个同一个数据库的多张表中，每个表只有这个表的部分数据，这样做能小幅提升性能，它仅仅作为水平分库的一个补充优化。</li></ul><p>​</p><h5 id="🌟通过分库、分表的根源来分析何时分库、何时分表："><a href="#🌟通过分库、分表的根源来分析何时分库、何时分表：" class="headerlink" title="🌟通过分库、分表的根源来分析何时分库、何时分表："></a>🌟通过分库、分表的根源来分析何时分库、何时分表：</h5><h6 id="第一，是数据量太大查询慢的问题。"><a href="#第一，是数据量太大查询慢的问题。" class="headerlink" title="第一，是数据量太大查询慢的问题。"></a>第一，是<u>数据量太大</u>查询慢的问题。</h6><p>​因为MySQL在执行事务时需要对表进行锁定，以确保数据的一致性和完整性。然而，当数据量过大时，锁定整个表可能会导致事务执行时间过长，从而降低系统的性能和响应速度。</p><p>​<strong>解决查询慢，只要减少每次查询的数据总量就可以了，也就是说，分表就可以解决问题</strong>。(<u>将结果union即可</u>)</p><h6 id="第二，是为了应对高并发的问题。-写多读少的情况"><a href="#第二，是为了应对高并发的问题。-写多读少的情况" class="headerlink" title="第二，是为了应对高并发的问题。(写多读少的情况)"></a>第二，是为了<u>应对高并发</u>的问题。(写多读少的情况)</h6><p>​应对高并发的思想我们之前也说过，一个数据库实例撑不住，就把并发请求分散到多个实例中去，所以，<strong>解决高并发的问题是需要分库的</strong>。</p><p>总结来说：<strong>数据量大，就分表；并发高，就分库</strong>。</p><h5 id="分库分表带来的问题："><a href="#分库分表带来的问题：" class="headerlink" title="分库分表带来的问题："></a>分库分表带来的问题：</h5><h6 id="1-分布式事务问题"><a href="#1-分布式事务问题" class="headerlink" title="1 分布式事务问题"></a>1 分布式事务问题</h6><p>​由于分库分表把数据分布在不同库甚至不同服务器，不可避免会带来**<u>分布式事务问题</u>**。</p><h6 id="2-跨节点-JOIN-查询问题"><a href="#2-跨节点-JOIN-查询问题" class="headerlink" title="2 跨节点 JOIN 查询问题"></a>2 跨节点 JOIN 查询问题</h6><p>​如果业务数据查询的 SQL 存在多表关联查询，在分库分表情况下，SQL 无法正常执行。我们需要调整 SQL：先查询主表数据，再通过主表数据 id 查询从表数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">solution：</span><br><span class="line">​通常，我们会冗余表或冗余字段来优化跨库 JOIN 查询。对于一些基础表，例如商品信息表，我们可以在每一个订单分库中复制一张基础表，避免跨库 JOIN 查询。而对于一两个字段的查询，我们也可以将少量字段冗余在表中，从而避免 JOIN 查询，也就避免了跨库 JOIN 查询。</span><br></pre></td></tr></table></figure><h6 id="3-跨节点分页、排序函数"><a href="#3-跨节点分页、排序函数" class="headerlink" title="3 跨节点分页、排序函数"></a>3 跨节点分页、排序函数</h6><p>​跨节点多库进行查询时，<strong>limit</strong> 分页、<strong>order by</strong> 排序等问题，就变得比较复杂了。需要先在不同的节点中将数据进行排序并返回，然后将不同节点返回的结果集进行汇总和再次排序。</p><h6 id="4-全局主键-ID-问题"><a href="#4-全局主键-ID-问题" class="headerlink" title="4 全局主键 ID 问题"></a>4 全局主键 ID 问题</h6><p>​在分库分表环境中，由于表中数据同时保存在不同数据库中，主键值平时使用的自增长将无用武之地，某个分区数据库生成的 ID 无法保证全局唯一。因此需要单独设计全局主键，以避免跨库主键重复问题。</p><h6 id="5-公共表"><a href="#5-公共表" class="headerlink" title="5 公共表"></a>5 公共表</h6><p>​参数表、数据字典表等都是数据量较小，变动少的公共表，属于高频联合查询的依赖表。分库分表后，我们需要将这类表在每个数据库都保存一份，所有对公共表的更新操作都同时发送到所有分库执行。</p><h6 id="6-扩容问题"><a href="#6-扩容问题" class="headerlink" title="6 扩容问题"></a>6 扩容问题</h6><p>​随着用户的订单量增加，根据用户 ID Hash 取模的分表中，数据量也在逐渐累积。此时，我们需要考虑动态增加表，一旦动态增加表了，就会涉及到数据迁移问题。</p><p>​我们在最开始设计表数据量时，尽量使用 2 的倍数来设置表数量。当我们需要扩容时，也同样按照 2 的倍数来扩容，这种方式可以减少数据的迁移量。</p><h4 id="分表的实现方案："><a href="#分表的实现方案：" class="headerlink" title="分表的实现方案："></a>分表的实现方案：</h4><h5 id="公共包实现"><a href="#公共包实现" class="headerlink" title="公共包实现"></a>公共包实现</h5><p>​本地依赖包，即将分表逻辑写在公共的代码库里，每个需要调用服务的客户方都集成该公共包，就接入了自动分表的能力。</p><h5 id="中间件实现"><a href="#中间件实现" class="headerlink" title="中间件实现"></a>中间件实现</h5><p>​可以是服务级别的中间件，有自己独立的进程，通过该进程来调用数据库，这样分表逻辑就是中心化，完全可控的，代理服务就属于这类。如**<u>Mycat、ShardingSphere</u>**</p><p>​</p><h4 id="如何针对现有表做拆分，即扩容："><a href="#如何针对现有表做拆分，即扩容：" class="headerlink" title="如何针对现有表做拆分，即扩容："></a>如何针对现有表做拆分，即扩容：</h4><pre><code>1. 双写读老阶段：通过中间件，对write sql同时进行两次转发，也就是双写，保持新数据一致，同时开始历史数据拷贝。本阶段建议施行一周；1. 双写双读阶段：采用灰度策略，一部分流量读老表，一部分流量读新表，读新表的部分在一开始，还可以同时多读一次老表数据，进行比对检查，观察无误后，随着时间慢慢切量到新表。本阶段建议施行至少两周；1. 双写读新阶段：此时基本已经稳定，可以只读新表，为了安全保证，建议还是多双写一段时间，防止有问题遗漏。本阶段建议周期一个月；1. 写新读新阶段：此时已经完成了分表的迁移，老表数据可以做个冷备。</code></pre><h3 id="分布式ID："><a href="#分布式ID：" class="headerlink" title="分布式ID："></a>分布式ID：</h3><p>分布式id需要具有的特性</p><ol><li><strong>全局唯一性</strong> ： 不能出现重复的 ID 号，既然是唯一标识，这是最基本的要求。</li><li><strong>趋势递增</strong> ： 在 MySQL InnoDB 引擎中使用的是聚集索引，由于多数 RDBMS 使用 B-tree 的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。</li><li><strong>单调递增</strong> ： 保证下一个 ID 一定大于上一个 ID，例如事务版本号、IM 增量消息、排序等特殊需求。</li><li><strong>信息安全</strong> ： 如果 ID 是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定 URL 即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要 ID 无规则、不规则。</li></ol><h4 id="1-UUID："><a href="#1-UUID：" class="headerlink" title="1.UUID："></a>1.UUID：</h4><p>​Java中的UUID类可以生成UUID，几种不同的生成方式分别根据 基于随机数、时间、名称等方式生成UUID</p><p>​</p><h5 id="优点：-4"><a href="#优点：-4" class="headerlink" title="优点："></a>优点：</h5><p>​通过本地生成，没有经过网络 I&#x2F;O，性能较高。</p><h5 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h5><ul><li><strong>长度过长</strong> - UUID 太长，16 字节 128 位，通常以 36 长度的字符串表示，很多场景不适用。例如：Mysql 官方明确建议主键越短越好，36 个字符长度的 UUID 不符合要求。</li><li><strong>信息不安全</strong> - 基于 MAC 地址生成 UUID 的算法可能会造成 MAC 地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。</li><li><strong>无序性</strong> - 不能生成递增有序的数字。这对于一些特定场景不利。例如：MySQL InnoDB 存储引擎使用 B+ 树存储索引数据，而主键也是一种索引。<u>索引数据在 B+ 树中是有序排列的。UUID 的无序性可能会引起数据位置频繁变动，严重影响性能。</u></li></ul><h4 id="2-数据库方案生成键"><a href="#2-数据库方案生成键" class="headerlink" title="2.数据库方案生成键"></a>2.数据库方案生成键</h4><p>​再开一个数据表，利用其自增键实现分布式id</p><p>可以使用比如 MySQL 的自增键，Oracle 的自增序列等。当然，也可以考虑是用 Redis 这样的 Nosql，甚至 ZooKeeper 去生成键。</p><p>例🌰：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20231010134746596.png" alt="image-20231010134746596"></p><h5 id="优点：-5"><a href="#优点：-5" class="headerlink" title="优点："></a>优点：</h5><ul><li>非常<u>简单</u>，利用现有的功能实现，<u>成本小</u></li><li><u>有序递增</u></li><li><u>方便排序和分页</u></li></ul><h5 id="缺点：-4"><a href="#缺点：-4" class="headerlink" title="缺点："></a>缺点：</h5><ul><li><p>强依赖第三方存储，如果第三方存储非高可用系统，<u><strong>若出现丢失数据的情况，就可能出现重复生成 ID 的问题。</strong></u></p></li><li><p>生成 ID 性能<u>瓶颈依赖于第三方存储的性能</u>。</p></li><li><p>增加了对第三方存储运维的成本。</p></li></ul><h4 id="3-雪花算法"><a href="#3-雪花算法" class="headerlink" title="3.雪花算法"></a>3.雪花算法</h4><p>​<strong>生成一个 <code>64 bit</code> 的整数</strong></p><p>​根据时间戳、序列位计算得，在分布式环境可以认为是总体有序的，这就保证了对索引字段的插入的高效性。</p><h5 id="键的组成-默认情况-："><a href="#键的组成-默认情况-：" class="headerlink" title="键的组成(默认情况)："></a>键的组成(默认情况)：</h5><ul><li><strong>符号位(1bit)</strong></li></ul><p>​预留的符号位，恒为零。</p><ul><li><p><strong>时间戳位(41bit)</strong></p><p>根据距离 2016 年 11 月 1 日零点 的时间以毫秒数计算而得</p></li><li><p><strong>工作进程位(10bit)</strong></p><p>该标志在 Java 进程内是唯一的，如果是分布式应用部署应保证每个工作进程的 id 是不同的。该值默认为 0，可通过属性设置。</p></li><li><p><strong>序列号位(12bit)</strong></p><p>该序列是用来在同一个毫秒内生成不同的 ID。如果在这个毫秒内生成的数量超过 4096(2 的 12 次幂)，那么生成器会等待到下个毫秒继续生成。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230916154529588.png" alt="image-20230916154529588"></p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>生成的 ID 都是趋势递增的。</li><li>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成 ID 的性能也是非常高的。</li><li>可以根据自身业务特性分配 bit 位，非常灵活。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li><u>强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。</u></li></ul><h5 id="处理时钟回拨问题："><a href="#处理时钟回拨问题：" class="headerlink" title="处理时钟回拨问题："></a>处理时钟回拨问题：</h5><p>​用当前时间和上一次的时间进行判断，如果当前时间小于上一次的时间那么肯定是发生了回拨。普通的算法会直接抛出异常，这里我们可以对其进行优化，一般分为两个情况:</p><ul><li>如果时间回拨时间较短，比如配置 <code>5ms</code> 以内，那么可以直接等待一定的时间，让机器的时间追上来。</li><li>如果时间的回拨时间较长，我们不能接受这么长的阻塞等待，那么又有两个策略:<ul><li>直接拒绝，抛出异常。打日志，通知 RD 时钟回滚。</li><li>利用扩展位。上面我们讨论过，不同业务场景位数可能用不到那么多比特位，那么我们可以把扩展位数利用起来。比如：当这个时间回拨比较长的时候，我们可以不需要等待，直接在扩展位加 1。两位的扩展位允许我们有三次大的时钟回拨，一般来说就够了，如果其超过三次我们还是选择抛出异常，打日志。</li></ul></li></ul><p><strong>美团</strong>提供了一种分布式 ID 解决方案 Leaf，其本质可以视为<u>数据库分段+服务缓存 ID</u>。</p><h4 id="4-1Leaf-segment数据库方案"><a href="#4-1Leaf-segment数据库方案" class="headerlink" title="4.1Leaf-segment数据库方案"></a>4.1Leaf-segment数据库方案</h4><p>​<u>相较于传统的数据库方案，Leaf-segment数据库方案每次给每个业务传输一个segment的自增id(具体一个segment中id的数量可自定义)，相较于原来的取一个id就要查询、修改一次db，如今用完segment中提供的id后才会再次访问db，获取新的segment</u></p><h6 id="官方解释："><a href="#官方解释：" class="headerlink" title="官方解释："></a>官方解释：</h6><p>​原来获取ID每次都需要写数据库，现在只需要把step设置得足够大，比如1000。那么只有当1000个号被消耗完了之后才会去重新读写一次数据库。读写数据库的频率从1减小到了1&#x2F;step</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-------------+--------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> Field       <span class="operator">|</span> Type         <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span>           <span class="operator">|</span> Extra                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> biz_tag     <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">128</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span>                   <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> max_id      <span class="operator">|</span> <span class="type">bigint</span>(<span class="number">20</span>)   <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="number">1</span>                 <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> step        <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>)      <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">desc</span>        <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">256</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> update_time <span class="operator">|</span> <span class="type">timestamp</span>    <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="operator">|</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+--------------+------+-----+-------------------+-----------------------------</span></span><br><span class="line">biz_tag用来区分业务，(每种业务应当有自己独有的自增id)</span><br><span class="line">max_id表示该biz_tag目前所被分配的ID号段的最大值，</span><br><span class="line">step表示每次分配的号段长度。(决定了segment的大小)</span><br></pre></td></tr></table></figure><h6 id="架构示意图："><a href="#架构示意图：" class="headerlink" title="架构示意图："></a>架构示意图：</h6><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230916163456886.png" alt="image-20230916163456886"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Begin</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> max_id<span class="operator">=</span>max_id<span class="operator">+</span>step <span class="keyword">WHERE</span> biz_tag<span class="operator">=</span>xxx</span><br><span class="line"><span class="keyword">SELECT</span> tag, max_id, step <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> biz_tag<span class="operator">=</span>xxx</span><br><span class="line"><span class="keyword">Commit</span></span><br></pre></td></tr></table></figure><h6 id="优点：-6"><a href="#优点：-6" class="headerlink" title="优点："></a>优点：</h6><ul><li>Leaf服务可以很方便的线性扩展，性能完全能够支撑大多数业务场景。</li><li>ID号码是趋势递增的8byte的64位数字，满足上述数据库存储的主键要求。</li><li>容灾性高：Leaf服务内部有号段缓存，即使DB宕机，短时间内Leaf仍能正常对外提供服务。</li><li>可以自定义max_id的大小，非常方便业务从原有的ID方式上迁移过来。</li></ul><h6 id="缺点：-5"><a href="#缺点：-5" class="headerlink" title="缺点："></a>缺点：</h6><ul><li><ol><li>ID号码不够随机，能够泄露发号数量的信息，不太安全。</li></ol></li><li><ol start="2"><li>TP999数据波动大，当号段使用完之后还是会hang在更新数据库的I&#x2F;O上，tg999数据会出现偶尔的尖刺。<ul><li>通俗版本：当一个segment用完，在请求下一个segment期间，会阻塞线程</li></ul></li></ol></li><li><ol start="3"><li>DB宕机会造成整个系统不可用。</li></ol></li></ul><h5 id="4-1-2-Leaf-segment数据库方案的-双buffer优化"><a href="#4-1-2-Leaf-segment数据库方案的-双buffer优化" class="headerlink" title="4.1.2 Leaf-segment数据库方案的 双buffer优化"></a>4.1.2 Leaf-segment数据库方案的 <u>双buffer优化</u></h5><p>​对于 缺点2 做了一些优化</p><p>​我们希望DB取号段的过程能够做到无阻塞，不需要在DB取号段的时候阻塞请求线程，即当<u>号段消费到某个点时就异步的把下一个号段加载到内存中。而不需要等到号段用尽的时候才去更新号段。</u></p><p>架构图：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230916164536591.png" alt="image-20230916164536591"></p><p>采用双buffer的方式，Leaf服务内部有两个号段缓存区segment。**<u>当前号段已下发10%时，如果下一个号段未更新，则另启一个更新线程去更新下一个号段。当前号段全部下发完后，如果下个号段准备好了则切换到下个号段为当前segment接着下发，循环往复。</u>**</p><ul><li>每个biz-tag都有消费速度监控，通常推荐segment长度设置为服务高峰期发号QPS的600倍（10分钟），这样即使DB宕机，Leaf仍能持续发号10-20分钟不受影响。</li><li>每次请求来临时都会判断下个号段的状态，从而更新此号段，所以偶尔的网络抖动不会影响下个号段的更新。</li></ul><h5 id="4-1-3-Leaf-高可用容灾"><a href="#4-1-3-Leaf-高可用容灾" class="headerlink" title="4.1.3 Leaf 高可用容灾"></a>4.1.3 Leaf 高可用容灾</h5><p>​暂不深入，放架构图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230916165133518.png" alt="image-20230916165133518"></p><h4 id="4-2Leaf-snowflake方案"><a href="#4-2Leaf-snowflake方案" class="headerlink" title="4.2Leaf-snowflake方案"></a>4.2Leaf-snowflake方案</h4><p>​Leaf-segment方案可以生成趋势递增的ID，同时ID号是可计算的，不适用于订单ID生成场景，比如竞对在两天中午12点分别下单，通过订单id号相减就能大致计算出公司一天的订单量，这个是不能忍受的。面对这一问题，我们提供了 Leaf-snowflake方案。</p><p>​大体类似雪花算法，用到了ZooKeeper，笔者暂时没有学过ZooKeeper，故不深究，留个坑！</p><p>*数据迁移：</p><p>*分布式事务</p><p>*分布式锁</p><p>*高可用</p><p>*分布式数据库</p><p>本博客对以下文章有参考借鉴，十分感谢这些作者的文章🙏：</p><ul><li><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2">架构设计面试精讲</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5ODU2ODczMQ==&mid=2247483759&idx=1&sn=517652050f22e8309a58bd33d250fe74&chksm=c061c61bf7164f0defd8d784110230600b9f686785dd76bff5b047cae824fc0fdf2c771c27b7&token=1429342161&lang=zh_CN#rd">分库分表</a></p></li><li><p><a href="https://www.extlight.com/2021/04/13/5%E5%88%86%E9%92%9F%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/">5分钟带你了解数据库分库分表</a></p></li><li><p><a href="https://zq99299.github.io/note-book/back-end-storage/03/01.html">MySQL 存储海量数据的最后一招：分库分表</a></p></li><li><p><a href="https://dunwu.github.io/blog/pages/3ae455/">分布式 ID 基本原理</a></p></li><li><p><a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf——美团点评分布式ID生成系统</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 高可用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis原理学习</title>
      <link href="/2023/08/15/Redis%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/08/15/Redis%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis数据结构："><a href="#Redis数据结构：" class="headerlink" title="Redis数据结构："></a>Redis数据结构：</h2><p>参考文章：</p><ul><li><a href="https://javaguide.cn/database/redis/redis-common-blocking-problems-summary.html#aof-%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E9%98%BB%E5%A1%9E">javaguide Redis相关部分</a></li><li><a href="https://xiaolincoding.com/redis/data_struct/data_struct.html">redis 数据结构</a></li></ul><h3 id="🌟redis对象与数据结构的关系图："><a href="#🌟redis对象与数据结构的关系图：" class="headerlink" title="🌟redis对象与数据结构的关系图："></a>🌟redis对象与数据结构的关系图：</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230925105926664.png" alt="image-20230925105926664"></p><h3 id="redisObject结构："><a href="#redisObject结构：" class="headerlink" title="redisObject结构："></a>redisObject结构：</h3><p>​redis的每个value<strong>底层是由 <code>redisObject</code>指向具体的数据结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LRU_BITS 24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">  <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">  <span class="type">unsigned</span> lru:LRU_BITS;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> refcount;</span><br><span class="line">  <span class="type">void</span> *ptr;</span><br><span class="line">&#125;robj;</span><br></pre></td></tr></table></figure><p><strong>type</strong>：是哪种Redlis对象</p><p><strong>encoding</strong> ： 表示用哪种底层编码，用OBJECT ENCODING [key] 可以看到对应的编码方式</p><p><strong>Iru</strong>：记录对象访问信息，用于内存淘汰。</p><p><strong>refcount</strong>：引用计数，用来描述有多少个指针，指向该对象</p><p><strong>ptr</strong>：内容指针，指向实际内容</p><h4 id="其中：-ptr指向各种数据结构对象内容"><a href="#其中：-ptr指向各种数据结构对象内容" class="headerlink" title="其中：*ptr指向各种数据结构对象内容"></a>其中：*ptr指向各种数据结构对象内容</h4><ul><li><strong>5 种基础数据结构</strong>：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）</li></ul><h3 id="SDS："><a href="#SDS：" class="headerlink" title="SDS："></a>SDS：</h3><p>由于在C中：</p><ol><li>计算字符串长度需要遍历字符串数组，直到遇到 ‘ \0 ’ ,因此时间复杂度为O(n)；</li><li>字符串的结尾是以 “\0” 字符标识，字符串里面不能包含有 “\0” 字符，因此不能保存二进制数据；</li><li>字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止；</li></ol><p>由于获取字符串长度、修改字符串内容的操作理应频繁，为了提升性能，在redis中，自定义了一个SDS的字符串结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line"><span class="type">uint8_t</span> len;</span><br><span class="line"><span class="type">uint8_t</span> alloc;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> flags;</span><br><span class="line"><span class="type">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>len</strong>：字符串长度</p><p>​<strong>alloc</strong>：分配给字符数组的空间长度</p><p>​<strong>flags</strong>：表示是哪种sdshdr分类，有sdshdr5、sdshdr8、sdshdr16、sdshdr32、sdshdr64等多种类型，它们的主要<strong>区别就在于，它们数据结构中的 len 和 alloc 成员变量的数据类型不同</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例🌰</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len;</span><br><span class="line">    <span class="type">uint16_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len;</span><br><span class="line">    <span class="type">uint32_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags;</span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​**buf[]**：存数据的char数组，不仅可以保存字符串，也可以保存二进制数据。</p><p>这样，就可以通过查询len，从而在O(1)的时间下查询得string的长度，</p><p>并且，由于有alloc - len大小的预留空间，可以为后续追加数据留余地。</p><h4 id="SDS扩容机制简述："><a href="#SDS扩容机制简述：" class="headerlink" title="SDS扩容机制简述："></a>SDS扩容机制简述：</h4><ul><li>如果所需的 sds 长度<strong>小于 1 MB</strong>，那么最后的扩容是按照<strong>翻倍扩容</strong>来执行的，即 2 倍的newlen</li><li>如果所需的 sds 长度<strong>超过 1 MB</strong>，那么最后的扩容长度应该是 newlen <strong>+ 1MB</strong>。</li></ul><h3 id="链表："><a href="#链表：" class="headerlink" title="链表："></a>链表：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redis中，链表的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">//后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//节点的值</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">不过，Redis 在 listNode 结构体基础上又封装了 <span class="built_in">list</span> 这个数据结构，这样操作起来会更方便，链表结构如下：</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">//链表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//链表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值比较函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">//链表节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>list 结构为链表提供了链表头指针 head、链表尾节点 tail、链表节点数量 len、以及可以自定义实现的 dup、free、match 函数。</p><p><strong>其实就是简单的链表结构：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230920160330614.png" alt="image-20230920160330614"></p><p>优点：</p><p>​略</p><p>缺点：</p><ul><li>链表每个节点之间的内存都是不连续的，意味着<strong>无法很好利用 CPU 缓存</strong>。能很好利用 CPU 缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用 CPU 缓存来加速访问。</li><li>还有一点，保存一个链表节点的值都<u>需要一个链表节点结构头</u>的分配，<strong>内存开销较大</strong>。</li></ul><h3 id="压缩列表-早期版本使用-："><a href="#压缩列表-早期版本使用-：" class="headerlink" title="压缩列表(早期版本使用)："></a>压缩列表(早期版本使用)：</h3><p><strong><u>—-核心思想：根据数据大小和类型进行不同的空间大小分配的设计思想</u></strong></p><p>​Redis 3.0 的 List 对象在数据量比较少的情况下，会采用「压缩列表」作为底层数据结构的实现，它的优势是节省内存空间，并且是内存紧凑型的数据结构。</p><p>​特点：不仅<strong>可以利用 CPU 缓存</strong>，而且会<strong>针对不同长度的数据，进行相应编码</strong>，这种方法可以有效地节省内存开销。</p><p>因此，Redis 对象（List 对象、Hash 对象、Zset 对象）包含的<strong>元素数量较少</strong>，或者元素值不大的情况才会使用压缩列表作为底层数据结构。</p><h4 id="压缩列表结构设计："><a href="#压缩列表结构设计：" class="headerlink" title="压缩列表结构设计："></a>压缩列表结构设计：</h4><p>​<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230920170011757.png" alt="image-20230920170011757" style="zoom:50%;" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ziplist</span>&lt;</span>T&gt; &#123;</span><br><span class="line">    int32 zlbytes;</span><br><span class="line">    int32 zltail_offset;</span><br><span class="line">    int16 zllength;</span><br><span class="line">    T[] entries;</span><br><span class="line">    int8 zlend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><em><strong>zlbytes</strong></em>：整个压缩列表占用的字节数，占4Byte</li><li><em><strong>zltail_offset</strong></em>：最后一个元素距离压缩列表起始位置的偏移量，<strong>用于快速定位到最后一个元素</strong>，占4Byte</li><li><em><strong>zllen</strong></em>：压缩列表的元素个数，占2Byte</li><li><em><strong>entries</strong></em>：压缩列表的元素，可以包含多个节点，每个节点可以保存一个字节数组或者一个整数值</li><li><em><strong>zlend</strong></em>：压缩列表结束标志，值等于 0xFF，占1Byte</li></ul><h4 id="压缩列表的节点结构："><a href="#压缩列表的节点结构：" class="headerlink" title="压缩列表的节点结构："></a>压缩列表的<u>节点</u>结构：</h4><ul><li><em><strong>prevlen</strong></em>，记录了「前一个节点」的<strong>长度</strong>，<u>目的是为了实现从后向前遍历</u>；</li><li><em><strong>encoding</strong></em>，记录了当前节点实际数据的「<strong>类型和长度</strong>」，类型主要有两种：字符串和整数。</li><li><em><strong>data</strong></em>，记录了当前节点的实际数据，类型和长度都由 <code>encoding</code> 决定；</li></ul><h5 id="prevlen长度："><a href="#prevlen长度：" class="headerlink" title="prevlen长度："></a>prevlen长度：</h5><p>压缩列表里的每个节点中的 prevlen 属性都记录了「前一个节点的长度」，而且 **<u>prevlen 属性的空间大小跟前一个节点长度值有关</u>**，比如：</p><ul><li>如果<strong>前一个节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用 <strong>1 字节的空间</strong>来保存这个长度值；</li><li>如果<strong>前一个节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用 <strong>5 字节的空间</strong>来保存这个长度值；</li></ul><h5 id="encoding长度："><a href="#encoding长度：" class="headerlink" title="encoding长度："></a>encoding长度：</h5><p>当我们往压缩列表中插入数据时，压缩列表就会根据数据类型是字符串还是整数，以及数据的大小，会使用不同空间大小的 prevlen 和 encoding 这两个元素里保存的信息，<strong>这种根据数据大小和类型进行不同的空间大小分配的设计思想，正是 Redis 为了节省内存而采用的</strong>。</p><ul><li>如果<strong>当前节点的数据是整数</strong>，则 encoding 会使用 <strong>1 字节的空间</strong>进行编码，也就是 encoding 长度为 1 字节。通过 encoding 确认了整数类型，就可以确认整数数据的实际大小了，比如如果 encoding 编码确认了数据是 int16 整数，那么 data 的长度就是 int16 的大小。</li><li>如果<strong>当前节点的数据是字符串，根据字符串的长度大小</strong>，encoding 会使用 <strong>1 字节&#x2F;2字节&#x2F;5字节的空间</strong>进行编码，encoding 编码的前两个 bit 表示数据的类型，后续的其他 bit 标识字符串数据的实际长度，即 data 的长度。</li></ul><h4 id="压缩列表的特性："><a href="#压缩列表的特性：" class="headerlink" title="压缩列表的特性："></a>压缩列表的特性：</h4><p>​在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段（zllen）的长度直接定位，复杂度是 O(1)。而<strong>查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素</strong>。</p><h4 id="压缩列表的缺点："><a href="#压缩列表的缺点：" class="headerlink" title="压缩列表的缺点："></a>压缩列表的缺点：</h4><h5 id="连锁更新："><a href="#连锁更新：" class="headerlink" title="连锁更新："></a><a href="https://xiaolincoding.com/redis/data_struct/data_struct.html#%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0">连锁更新</a>：</h5><p>​假如已知的各个节点的长度都为250～253，然后在表头节点的左边添加一个长度&gt;&#x3D;254的节点，由于表头节点的prevlen字段的长度默认为1字节，需要扩容到5字节，这就会导致表头节点的长度也 &gt;&#x3D; 254，导致第二个节点的prevlen也需要扩容……(直到影响了所有的节点)</p><p>空间扩展操作需要重新分配内存，因此<strong>连锁更新一旦发生，就会导致压缩列表占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能</strong>。</p><p>所以说，<strong>虽然压缩列表紧凑型的内存布局能节省内存开销，但是如果保存的元素数量增加了，或是元素变大了，会导致内存重新分配，最糟糕的是会有「连锁更新」的问题</strong>。</p><p>因此，<strong>压缩列表只会用于保存的节点数量不多的场景</strong>，只要节点数量足够小，即使发生连锁更新，也是能接受的。</p><p>虽说如此，Redis 针对压缩列表在设计上的不足，在后来的版本中，新增设计了两种数据结构：quicklist（Redis 3.2 引入） 和 listpack（Redis 5.0 引入）。这两种数据结构的设计目标，就是尽可能地保持压缩列表节省内存的优势，同时解决压缩列表的「连锁更新」的问题。</p><h3 id="hash表："><a href="#hash表：" class="headerlink" title="hash表："></a>hash表：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;  </span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="comment">//该哈希表已有的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">  <span class="comment">//两个Hash表，交替使用，用于rehash(扩容)操作</span></span><br><span class="line">    dictht ht[<span class="number">2</span>]; </span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中 table 为 dictEntry[] 数组，每个dictEntry的结构如下⬇️：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">//键值对中的键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//键值对中的值</span></span><br><span class="line">  <span class="comment">//键值对中的值可以是一个指向实际值的指针，或者是一个无符号的 64 位整数或有符号的 64 位整数或double 类的值。这么做的好处是可以节省内存空间，因为当「值」是整数或浮点数时，就可以将值的数据内嵌在 dictEntry 结构里，无需再用一个指针指向实际的值，从而节省了内存空间。</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">//指向下一个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>结构跟java中的HashMap很像，故不做过多介绍</p><p><strong>唯一需要强调的就是</strong>：hashmap中的每个dictEntry中，如果存储的是<u>一个无符号的 64 位整数或有符号的 64 位整数或double 类的值</u>，那么就可以将数据直接写在dictEntry中的union结构体中，无需使用其他存储的结构而只是使用一个字段，节省了空间！</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230921102950618.png" alt="image-20230921102950618"></p><p>​</p><h4 id="hash冲突："><a href="#hash冲突：" class="headerlink" title="hash冲突："></a>hash冲突：</h4><p>​与jdk1.7中hashmap一样，**<u>使用链式hash存储</u>**。</p><h4 id="rehash："><a href="#rehash：" class="headerlink" title="rehash："></a>rehash：</h4><p>​rehash指：hash表的扩容操作</p><p>​触发 rehash 操作的条件，主要有两个：</p><ul><li><strong>当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。</strong></li><li><strong>当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。</strong></li></ul><h4 id="常规rehash操作："><a href="#常规rehash操作：" class="headerlink" title="常规rehash操作："></a>常规rehash操作：</h4><p>​rehash 操作，其过程分为三步：(有点像新生代垃圾回收。。。)</p><ul><li>给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍；</li><li>将「哈希表 1 」的数据迁移到「哈希表 2」 中；</li><li>迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230921104216278.png" alt="image-20230921104216278"></p><p>这个过程看起来简单，但是其实第二步很有问题，<strong>如果「哈希表 1 」的数据量非常大，那么在迁移至「哈希表 2 」的时候，因为会涉及大量的数据拷贝，此时可能会对 Redis 造成阻塞，无法服务其他请求</strong>。</p><h4 id="渐进式-rehash操作："><a href="#渐进式-rehash操作：" class="headerlink" title="渐进式 rehash操作："></a>渐进式 rehash操作：</h4><p>​为了避免 rehash 在数据迁移过程中，因拷贝数据的耗时，影响 Redis 性能的情况，所以 Redis 采用了<strong>渐进式 rehash</strong>，也就是<u>将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移。</u></p><p>​渐进式 rehash 步骤如下：</p><ul><li><p>给「哈希表 2」 分配空间；</p></li><li><p><strong>在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上</strong>；</p></li><li><p>随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。</p></li><li><p>⚠️在进行渐进式 rehash 的过程中，会有两个哈希表，所以在渐进式 rehash 进行期间，哈希表元素的删除、查找、更新等操作都会在这两个哈希表进行。</p></li><li><p>⚠️在渐进式 rehash 进行期间，新增一个 key-value 时，会被保存到「哈希表 2 」里面，而「哈希表 1」 则不再进行任何添加操作，这样保证了「哈希表 1 」的 key-value 数量只会减少，随着 rehash 操作的完成，最终「哈希表 1 」就会变成空表</p></li></ul><h3 id="整数集合："><a href="#整数集合：" class="headerlink" title="整数集合："></a>整数集合：</h3><p>​整数集合是 Set 对象的底层实现之一。当一个 Set 对象只包含整数值元素，并且元素数量不大时，就会使用整数集这个数据结构作为底层实现。</p><p>整数集合本质上是一块连续内存空间，它的结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">//编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>其中的 contents[]数组 的数据类型根据encoding 属性值，encoding 属性值是什么，content数组类型就是什么。</p><h4 id="整数集合的升级操作："><a href="#整数集合的升级操作：" class="headerlink" title="整数集合的升级操作："></a>整数集合的升级操作：</h4><h5 id="详细定义："><a href="#详细定义：" class="headerlink" title="详细定义："></a>详细定义：</h5><p>​整数集合会有一个升级规则，就是当我们将一个新元素加入到整数集合里面，如果新元素的类型（int32_t）比整数集合现有所有元素的类型（int16_t）都要长时，整数集合需要先进行升级，也就是按新元素的类型（int32_t）扩展 contents 数组的空间大小，然后才能将新元素加入到整数集合里，当然升级的过程中，也要维持整数集合的有序性。</p><p>扩容过程：</p><pre><code>1. 在原本空间的基础上开辟需要的空间 需要新增的空间 = n * 新的大小 - (n - 1) * 原本大小2. 从后往前依次将每个元素扩容，如图：</code></pre><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230921110447679.png" alt="image-20230921110447679" style="zoom:50%;" /><p>整数集合升级机制的优点是：如果一直添加小元素(如 int16_t)，就会使用16位存储一个元素，直到有存储更大的数据类型的需求时才会升级，能够**<u>节省内存资源(按需开辟内存空间)</u>**</p><p>整数集合<strong>不支持降级操作</strong>，一旦对数组进行了升级，就会一直保持升级后的状态。</p><h3 id="跳表："><a href="#跳表：" class="headerlink" title="跳表："></a>跳表：</h3><p>​Redis 只有 Zset(sorted set) 对象的底层实现用到了跳表，跳表的优势是能支持平均 O(logN) 复杂度的节点查找。</p><p>​zset 结构体里有两个数据结构：一个是跳表(for 范围查询)，一个是哈希表(for 单点查询)。这样的好处是既能进行高效的范围查询，也能进行高效单点查询。**<u>Zset 对象在执行数据插入或是数据更新的过程中，会依次在跳表和哈希表中插入或更新相应的数据，从而保证了跳表和哈希表中记录的信息一致。</u>**</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">  <span class="comment">//hash表</span></span><br><span class="line">    dict *dict;</span><br><span class="line">  <span class="comment">//跳表</span></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230921141533670.png" alt="image-20230921141533670"></p><h4 id="跳表结构体："><a href="#跳表结构体：" class="headerlink" title="跳表结构体："></a>跳表结构体：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">  <span class="comment">//跳表的头尾节点，便于在O(1)时间复杂度内访问跳表的头节点和尾节点；</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">  <span class="comment">//跳表的长度，便于在O(1)时间复杂度获取跳表节点的数量；</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">  <span class="comment">//跳表的最大层数，便于在O(1)时间复杂度获取跳表中层高最大的那个节点的层数量；</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><h4 id="跳表的节点结构："><a href="#跳表的节点结构：" class="headerlink" title="跳表的节点结构："></a>跳表的节点结构：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//Zset 对象的元素值</span></span><br><span class="line">    sds ele;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//元素权重值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//后向指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//节点的level数组，保存每层上的前向指针和跨度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">      <span class="comment">//指向下一个跳表节点的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">//元素之间的跨度</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><p>其中，span(跨度)用于查找排名为k的元素</p><h4 id="跳表节点查询过程"><a href="#跳表节点查询过程" class="headerlink" title="跳表节点查询过程"></a>跳表节点查询过程</h4><p>查找一个跳表节点的过程时，跳表会<strong>从头节点的最高层开始</strong>，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：</p><ul><li>如果当前节点的权重「小于」要查找的权重(也就是score)时，跳表就会访问该层上的下一个节点。</li><li>如果当前节点的权重「等于」要查找的权重时，并且当前节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。</li></ul><p>如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230921142002848.png" alt="image-20230921142002848"></p><h4 id="跳表节点层数设置："><a href="#跳表节点层数设置：" class="headerlink" title="跳表节点层数设置："></a>跳表节点层数设置：</h4><p>​跳表的相邻两层的节点数量的比例会影响跳表的查询性能。</p><p>​**跳表的相邻两层的节点数量最理想的比例是 2:1，查找复杂度可以降低到 O(logN)**。</p><p>​但是2:1的节点数量比值不易维护，如果采用新增节点或者删除节点时，来调整跳表节点以维持比例的方法的话，会带来额外的开销。</p><p>redis使用一种巧妙的方法：</p><ul><li><strong>跳表在创建节点的时候，随机生成每个节点的层数</strong>，并没有严格维持相邻两层的节点数量比例为 2 : 1 的情况。</li><li>具体的做法是，<strong>跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</strong>。</li></ul><h4 id="为什么用跳表而不用平衡树？"><a href="#为什么用跳表而不用平衡树？" class="headerlink" title="为什么用跳表而不用平衡树？"></a>为什么用跳表而不用平衡树？</h4><ul><li><strong>从内存占用上来比较，跳表比平衡树更灵活一些</strong>。平衡树每个节点包含 2 个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为 1&#x2F;(1-p)，具体取决于参数 p 的大小。如果像 Redis里的实现一样，取 p&#x3D;1&#x2F;4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。</li><li><strong>在做<u>范围查找</u>的时候，跳表比平衡树操作要简单</strong>。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在跳表上进行范围查找就非常简单，只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现。</li><li><strong>从算法实现难度上来比较，跳表比平衡树要简单得多</strong>。平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而跳表的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li></ul><h4 id="为什么用跳表而不像innodb中使用B-树？"><a href="#为什么用跳表而不像innodb中使用B-树？" class="headerlink" title="为什么用跳表而不像innodb中使用B+树？"></a>为什么用跳表而不像innodb中使用B+树？</h4><ul><li>实现简单：跳表是一个相对简单的数据结构，实现起来比B+树要简单。它不需要像B+树那样需要复杂的平衡操作（如旋转、合并等），因此代码实现也相对较简单。</li><li>内存占用少：跳表相对于B+树来说，在相同有序集合的情况下，占用的内存更少。跳表不需要存储额外的索引，仅使用一级索引即可，而B+树需要存储多层索引。</li><li>查询效率高：虽然B+树在大规模数据上的查询效率更高，但在实际的使用场景中，有序集合的规模通常不会很大，而跳表在小规模数据上的查询效率更高。<ul><li>并且，虽然跳表的层数通常情况下会大于B+树，但是由于redis数据存储于内存中，不会像mysql一样读取元素时还需要花费IO时间，所以快表又轻又快，当然好啦。</li></ul></li><li>简单的分布算法：在分布式环境下，跳表的划分和排序算法相对来说较为简单，不需要复杂的分割和合并操作，可以更轻松地实现和维护分布式的有序集合。</li></ul><h3 id="quicklist："><a href="#quicklist：" class="headerlink" title="quicklist："></a>quicklist：</h3><p>​在 Redis 3.0 之前，List 对象的底层数据结构是双向链表或者压缩列表。然后在 Redis 3.2 的时候，List 对象的底层改由 quicklist 数据结构实现。</p><p>简单来说quicklist为 双向链表+压缩列表的组合！</p><p>​<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230921151653568.png" alt="image-20230921151653568" style="zoom:50%;" /></p><p>quicklist<strong>通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。</strong></p><p>在向 quicklist 添加一个元素的时候，不会像普通的链表那样，直接新建一个链表节点。而是会<u>检查插入位置的压缩列表是否能容纳该元素，如果能容纳就直接保存到 quicklistNode 结构里的压缩列表，如果不能容纳，才会新建一个新的 quicklistNode 结构。</u></p><p>quicklist 会控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来规避潜在的连锁更新的风险，但是这并没有完全解决连锁更新的问题。</p><h3 id="listpack："><a href="#listpack：" class="headerlink" title="listpack："></a>listpack：</h3><p>​是压缩表的新版本实现方式</p><p>​因为原来版本的压缩列表中<strong>记录了前一个节点长度，即prevlen字段</strong>(设置这个字段是为了实现节点从后往前遍历)，会因为前一个节点长度 &gt;&#x3D; 254而产生连锁更新的隐患，在listpack中，取消了这一字段，因此消除了这一隐患。</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230921151534614.png" alt="image-20230921151534614"></p><p><code>listpack</code>采用了一种逆序遍历的方式来使节点能够从后往前访问。主要通过逆序遍历listpack，通过listpack的结尾标识来得到前面节点的长度，从而实现逆序遍历：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在`listpack`中，每个节点的末尾都会有一个字节，用于指示当前节点的类型。如果该字节大于等于240，它将作为一个特殊字节，表示当前节点是列表中的一个稀疏值或哨兵节点。对于正常的列表项节点，该字节的取值范围是0到239。</span><br><span class="line"></span><br><span class="line">逆序遍历`listpack`中的节点，可以通过以下步骤进行：</span><br><span class="line"></span><br><span class="line">1. 获取`listpack`的总长度 `total_length`。</span><br><span class="line">2. 从 `total_length - 1` 开始，按照字节递减的方式依次处理每个节点。</span><br><span class="line">3. 如果遇到一个特殊字节（大于等于240），则表示当前节点是一个稀疏值或哨兵节点，可以根据情况进行处理。</span><br><span class="line">4. 如果遇到一个正常的列表项节点（字节值在0到239之间），则解析出节点的数据，并按照相应的长度进行处理。</span><br></pre></td></tr></table></figure><h2 id="Redis数据各类型底层实现："><a href="#Redis数据各类型底层实现：" class="headerlink" title="Redis数据各类型底层实现："></a>Redis数据各类型底层实现：</h2><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/%E6%9C%AA%E5%91%BD%E5%90%8D.png" alt="未命名"></p><h3 id="String："><a href="#String：" class="headerlink" title="String："></a>String：</h3><p>​<u>String最大为512MB</u></p><h4 id="String的三种编码方式："><a href="#String的三种编码方式：" class="headerlink" title="String的三种编码方式："></a>String的三种编码方式：</h4><h5 id="1-int："><a href="#1-int：" class="headerlink" title="1. int："></a>1. int：</h5><p>​当string的value执行自增等数据操作时，会自动转换成int类型。</p><ul><li><u>int只能存整数，小数等会以字符串形式保存</u></li></ul><h5 id="2-embstr："><a href="#2-embstr：" class="headerlink" title="2. embstr："></a>2. embstr：</h5><p>​当字符串长度 &lt;&#x3D; 设定阈值字节时，使用embstr编码</p><h5 id="3-raw："><a href="#3-raw：" class="headerlink" title="3. raw："></a>3. raw：</h5><p>​当字符串长度 &gt; 设定阈值字节时，使用raw编码</p><p>· 阈值：redis3.2之前为39字节；redis3.2之后为44字节</p><p>❓为什么阈值是44B？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Redis是使用jemalloc内存分配器，Redis以64字节为阈值区分大小字符串。所以EMBSTR的边界数值，其实是受64这个阈值影响。redis对象占用的内存大小由redisObject和sdshdr这两部分组成，redisObject 16字节，sdshdr中已分配、已申请、标记三个字段固定占了3个字节，&#x27;\0&#x27;占了一个字节，</span><br><span class="line">能存放的数据就是 64- (16+4） = 44 B</span><br></pre></td></tr></table></figure><h4 id="string底层构造："><a href="#string底层构造：" class="headerlink" title="string底层构造："></a>string底层构造：</h4><p>EMBSTR和RAW都是由redisObject和SDS两个结构组成，它们的差异在于：</p><ul><li>EMBSTR下redisObject 和 SDS是连续的内存，</li><li>RAW编码下redisObject 和 SDS的内存是分开的。</li></ul><p>EMBSTR优点是redisObject和SDS两个结构可以一次性分配空间，缺点在于如果重新分配空间，整体都需要再分配，所以EMBSTR设计为只读，任何写操作之后EMBSTR都会变成RAW，理念是发生过修改的字符串通常会认为是易变的。</p><p>随着我们的操作，编码可能会转换：</p><p>INT-&gt; RAW： 当存的内容不再是整数，或者大小超过了long的时候；</p><p>EMBSTR-&gt;RAW：任何写操作之后EMBSTR都会变成RAW；</p><h3 id="List："><a href="#List：" class="headerlink" title="List："></a>List：</h3><p>​–List 类型的底层数据结构是由<strong>双向链表或压缩列表</strong>实现的：</p><ul><li>如果列表的元素个数小于 <code>512</code> 个（默认值，可由 <code>list-max-ziplist-entries</code> 配置），列表每个元素的值都小于 <code>64</code> 字节（默认值，可由 <code>list-max-ziplist-value</code> 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li><li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li></ul><p>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 <u>quicklist</u> 实现了，替代了双向链表和压缩列表</strong>。</p><p>​</p><h3 id="Hash："><a href="#Hash：" class="headerlink" title="Hash："></a>Hash：</h3><p>​–Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p><ul><li>如果哈希类型元素个数小于 <code>512</code> 个（默认值，可由 <code>hash-max-ziplist-entries</code> 配置），所有值小于 <code>64</code> 字节（默认值，可由 <code>hash-max-ziplist-value</code> 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构；</li><li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的 底层数据结构。</li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 <u>listpack</u> 数据结构来实现了</strong>。</p><h3 id="Set："><a href="#Set：" class="headerlink" title="Set："></a>Set：</h3><p>​–Set 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p><ul><li>如果集合中的元素都是整数且元素个数小于 <code>512</code> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li><li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li></ul><h3 id="Zset："><a href="#Zset：" class="headerlink" title="Zset："></a>Zset：</h3><p>​–Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p><ul><li>如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li><li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</strong></p><h3 id="Redis-存储对象信息是用-Hash-还是-String"><a href="#Redis-存储对象信息是用-Hash-还是-String" class="headerlink" title="Redis 存储对象信息是用 Hash 还是 String"></a>Redis 存储对象信息是用 Hash 还是 String</h3><h4 id="String：-1"><a href="#String：-1" class="headerlink" title="String："></a>String：</h4><p>由于 Redis 的字符串是动态字符串，可以修改，内部结构类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。</p><p>如果此时将此用户信息的某个属性值修改，再存到 Redis 中，Redis 是不需要重新分配空间的</p><p>​</p><h4 id="Hash：-1"><a href="#Hash：-1" class="headerlink" title="Hash："></a>Hash：</h4><p>Hash 结构也可以存储用户信息，不过是<u>对每个字段单独存储，因此可以在查询时获取部分字段的信息，节省网络流量</u>。</p><p>but 处理类中属性为别的引用对象的嵌套的情况时比较复杂。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>建议是大部分情况下使用 String 存储就好，毕竟在存储具有多层嵌套的对象时方便很多，占用的空间也比 Hash 小。当我们需要存储一个特别大的对象时，而且在大多数情况中只需要访问该对象少量的字段时，可以考虑使用 Hash。</p><h3 id="RDB与AOF"><a href="#RDB与AOF" class="headerlink" title="RDB与AOF"></a>RDB与AOF</h3><p>RDB为快照</p><p>AOF记录每条指令</p><ul><li>Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。</li><li>不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。</li><li>如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。</li></ul><h3 id="Redis阻塞的原因："><a href="#Redis阻塞的原因：" class="headerlink" title="Redis阻塞的原因："></a>Redis阻塞的原因：</h3><ol><li><p>执行时间复杂度 O(n)以上的命令，如：</p><ul><li><p>KEYS ：会返回所有符合规则的 key。</p></li><li><p>HGETALL：会返回一个 Hash 中所有的键值对。</p></li><li><p>LRANGE：会返回 List 中指定范围内的元素。</p></li><li><p>SMEMBERS：返回 Set 中的所有元素。</p></li><li><p>SINTER&#x2F;SUNION&#x2F;SDIFF：计算多个 Set 的交集&#x2F;并集&#x2F;差集。</p></li></ul></li><li><p>使用save命令生成RDB快照</p><ul><li><code>save</code> : 同步保存操作，会阻塞 Redis 主线程；</li><li><code>bgsave</code> : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，<strong>默认选项</strong>。</li></ul></li><li><p>AOF阻塞</p><ol><li><p>日志记录阻塞：</p><ul><li>因为AOF 记录日志是在 Redis 主线程中进行</li></ul></li><li><p>刷盘阻塞：</p><ul><li>AOF日志从 AOF缓冲区-&gt;内核缓冲区时，需要调用write函数，(主线程调用 <code>write</code> 函数时也会被阻塞)</li></ul></li><li><p>AOF重写阻塞：</p><ul><li>fork 出一条子线程来将文件重写，在执行 <code>BGREWRITEAOF</code> 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子线程创建新 AOF 文件期间，记录服务器执行的所有写命令。</li><li>当子线程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。</li><li>最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</li></ul><p>阻塞就是出现在第 2 步的过程中，将缓冲区中新数据写到新文件的过程中会产生<strong>阻塞</strong>。</p></li></ol></li><li><p>大Key</p></li></ol><ul><li>客户端超时阻塞：由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li><li>引发网络阻塞：每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li><li>阻塞工作线程：如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li></ul><ol start="5"><li><p>清空数据库</p></li><li><p>集群扩容</p></li><li><p>内存交换</p></li><li><p>CPU竞争</p></li><li><p>网络延迟</p></li></ol><h3 id="Redis-为什么这么快？"><a href="#Redis-为什么这么快？" class="headerlink" title="Redis 为什么这么快？"></a>Redis 为什么这么快？</h3><ol><li><p>Redis 基于内存，内存的访问速度是磁盘的上千倍；</p></li><li><p>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用；</p></li><li><p>Redis 内置了多种优化过后的数据结构实现(如hash表和跳表)，性能非常高。</p></li></ol><h2 id="Redis单线程："><a href="#Redis单线程：" class="headerlink" title="Redis单线程："></a>Redis单线程：</h2><p>参考文章：</p><ul><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/03%20%20%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8BRedis%E8%83%BD%E9%82%A3%E4%B9%88%E5%BF%AB%EF%BC%9F.md">高性能IO模型：为什么单线程Redis能那么快？</a></li></ul><h3 id="什么是redis单线程？"><a href="#什么是redis单线程？" class="headerlink" title="什么是redis单线程？"></a>什么是redis单线程？</h3><p>​Redis 单线程指的是<strong>「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发生数据给客户端」</strong>这个过程是由一个线程（主线程）来完成的，这也是我们常说 Redis 是单线程的原因。</p><h3 id="基于多路复用的高性能-I-x2F-O-模型示意图："><a href="#基于多路复用的高性能-I-x2F-O-模型示意图：" class="headerlink" title="基于多路复用的高性能 I&#x2F;O 模型示意图："></a>基于多路复用的高性能 I&#x2F;O 模型示意图：</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230925145105519.png" alt="image-20230925145105519"></p><p>​在 Redis 只运行<u>单线程</u>的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。</p><ul><li>为了在请求到达时能通知到 Redis 线程，select&#x2F;epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。那么，回调机制是怎么工作的呢？其实，select&#x2F;epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。<ul><li>如果是 <strong>连接事件</strong>到来，则会调用 <strong>连接事件处理函数</strong>，该函数会做这些事情：调用 accpet 获取已连接的 socket -&gt;调用 epoll_ctr 将已连接的 socket 加入到 epoll -&gt; 注册「读事件」处理函数；</li><li>如果是 <strong>读事件</strong>到来，则会调用 <strong>读事件处理函数</strong>，该函数会做这些事情：调用 read 获取客户端发送的数据 -&gt; 解析命令 -&gt; 处理命令 -&gt; 将客户端对象添加到发送队列 -&gt; 将执行结果写到发送缓存区等待发送；</li><li>如果是 <strong>写事件</strong>到来，则会调用 <strong>写事件处理函数</strong>，该函数会做这些事情：通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发生完，就会继续注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。</li></ul></li><li>这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。这样一来，Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时，Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。</li></ul><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>​Redis 单线程是指它对网络 IO 和数据读写的操作采用了一个线程，而采用单线程的一个核心原因是避免多线程开发的并发控制问题。单线程的 Redis 也能获得高性能，跟多路复用的 IO 模型密切相关，因为这避免了 accept() 和 send()&#x2F;recv() 潜在的网络 IO 操作阻塞点。</p><h2 id="Redis多线程："><a href="#Redis多线程：" class="headerlink" title="Redis多线程："></a>Redis多线程：</h2><p>参考文章：</p><ul><li><a href="https://juejin.cn/post/6989109527886954527">Redis 6.0 新特性：带你 100% 掌握多线程模型</a></li></ul><h4 id="redis并非只有一个线程："><a href="#redis并非只有一个线程：" class="headerlink" title="redis并非只有一个线程："></a>redis并非只有一个线程：</h4><p>​对于一些长耗时的操作，为了不影响性能，Redis采用多线程方式处理。</p><p>​ Redis 为<strong>「关闭文件、AOF 刷盘、释放内存」</strong>这些任务创建单独的线程来处理</p><h3 id="Redis-6-0-新特性："><a href="#Redis-6-0-新特性：" class="headerlink" title="Redis 6.0 新特性："></a>Redis 6.0 新特性：</h3><p>​Redis6.0后 **<u>允许</u>**采用多个 IO 线程来处理网络请求，提高网络请求处理的并行度。</p><p>​<strong>需要注意的是，Redis 多 IO 线程模型只用来处理<u>网络读写请求</u>，对于 Redis 的读写命令，依然是单线程处理</strong>。</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230925155107569.png" alt="image-20230925155107569" style="zoom: 40%;" /><p><strong>主线程与 IO 多线程实现协作示意图：</strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230925155243715.png" alt="image-20230925155243715" style="zoom:50%;" /><h2 id="Redis过期删除策略和内存淘汰策略："><a href="#Redis过期删除策略和内存淘汰策略：" class="headerlink" title="Redis过期删除策略和内存淘汰策略："></a>Redis过期删除策略和内存淘汰策略：</h2><p>参考文章：</p><ul><li><a href="https://xiaolincoding.com/redis/module/strategy.html#redis-%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">Redis 过期删除策略和内存淘汰策略有什么区别？</a></li></ul><h4 id="过期删除策略："><a href="#过期删除策略：" class="headerlink" title="过期删除策略："></a>过期删除策略：</h4><p>​为key设置过期时间 (通过expire、pexpire命令设置)</p><h5 id="如何判定-key-已过期了？"><a href="#如何判定-key-已过期了？" class="headerlink" title="如何判定 key 已过期了？"></a>如何判定 key 已过期了？</h5><p>​每当我们对一个 key 设置了过期时间时，Redis 会把该 key 带上过期时间存储到一个<strong>过期字典</strong>（expires dict，实际上是一个hash表）中，也就是说「过期字典」保存了数据库中所有 key 的过期时间。</p><ul><li>过期字典的 key 是一个指针，指向某个键对象；</li><li>过期字典的 value 是一个 long long 类型的整数，这个整数保存了 key 的过期时间；</li></ul><h5 id="过期删除策略介绍："><a href="#过期删除策略介绍：" class="headerlink" title="过期删除策略介绍："></a>过期删除策略介绍：</h5><ul><li>定时删除<ul><li><strong>在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作。</strong></li><li>定时删除策略的<strong>优点</strong>：<ul><li>可以保证过期 key 会被尽快删除，也就是内存可以被尽快地释放。因此，定时删除对内存是最友好的。</li></ul></li><li>定时删除策略的<strong>缺点</strong>：<ul><li>在过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间，在内存不紧张但 CPU 时间紧张的情况下，将 CPU 时间用于删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。所以，定时删除策略对 CPU 不友好。</li></ul></li></ul></li><li>惰性删除<ul><li><strong>不主动删除过期键，<u>每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key</u>。</strong></li><li>惰性删除策略的<strong>优点</strong>：<ul><li>因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对 CPU 时间最友好。</li></ul></li><li>惰性删除策略的<strong>缺点</strong>：<ul><li>如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好。</li></ul></li></ul></li><li>定期删除<ul><li><strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</strong></li><li>定期删除策略的<strong>优点</strong>：<ul><li>通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。</li></ul></li><li>定期删除策略的<strong>缺点</strong>：<ul><li>内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少。</li><li>难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。</li></ul></li></ul></li></ul><h5 id="Redis的过期删除策略："><a href="#Redis的过期删除策略：" class="headerlink" title="Redis的过期删除策略："></a>Redis的过期删除策略：</h5><p>​<strong>Redis 选择「惰性删除+定期删除」这两种策略配和使用</strong>，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。</p><p>​</p><h6 id="惰性删除："><a href="#惰性删除：" class="headerlink" title="惰性删除："></a>惰性删除：</h6><p>​Redis 在访问或者修改 key 之前，都会调用 expireIfNeeded 函数对其进行检查，检查 key 是否过期：</p><ul><li>如果过期，则删除该 key，至于选择异步删除，还是选择同步删除，根据 <code>lazyfree_lazy_expire</code> 参数配置决定（Redis 4.0版本开始提供参数），然后返回 null 客户端；</li><li>如果没有过期，不做任何处理，然后返回正常的键值对给客户端；</li></ul><h6 id="定期删除："><a href="#定期删除：" class="headerlink" title="定期删除："></a>定期删除：</h6><ol><li>从过期字典中随机抽取 20个 (默认值，可修改) key；</li><li>检查这 20 个 key 是否过期，并删除已过期的 key；</li><li>如果本轮检查的已过期 key 的数量，超过 5 个（20&#x2F;4），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。</li></ol><p>定期删除的伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//已过期的数量</span></span><br><span class="line">    expired = <span class="number">0</span>；</span><br><span class="line">    <span class="comment">//随机抽取的数量</span></span><br><span class="line">    num = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">        <span class="comment">//1. 从过期字典中随机抽取 1 个 key</span></span><br><span class="line">        <span class="comment">//2. 判断该 key 是否过期，如果已过期则进行删除，同时对 expired++</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 超过时间限制则退出</span></span><br><span class="line">    <span class="keyword">if</span> (timelimit_exit) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果本轮检查的已过期 key 的数量，超过 25%，则继续随机抽查，否则退出本轮检查 */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (expired &gt; <span class="number">20</span>/<span class="number">4</span>); </span><br></pre></td></tr></table></figure><h4 id="内存淘汰策略："><a href="#内存淘汰策略：" class="headerlink" title="内存淘汰策略："></a>内存淘汰策略：</h4><p><u>当 Redis 的运行内存已经超过 Redis 设置的最大内存之后，则会使用内存淘汰策略删除符合条件的 key，以此来保障 Redis 高效的运行。</u></p><p><em>1、不进行数据淘汰的策略</em></p><ul><li><strong>noeviction</strong>（Redis3.0之后，默认的内存淘汰策略） ：它表示当运行内存超过最大设置内存时，不淘汰任何数据，这时如果有新的数据写入，会报错通知禁止写入，不淘汰任何数据，但是如果没用数据写入的话，只是单纯的查询或者删除操作的话，还是可以正常工作。</li></ul><p><em>2、进行数据淘汰的策略</em></p><p>​针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。</p><p>在设置了过期时间的数据中进行淘汰：</p><ul><li><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</li><li><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</li><li><strong>volatile-lru</strong>（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；</li><li><strong>volatile-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；</li></ul><p>在所有数据范围内进行淘汰：</p><ul><li><strong>allkeys-random</strong>：随机淘汰任意键值;</li><li><strong>allkeys-lru</strong>：淘汰整个键值中最久未使用的键值；</li><li><strong>allkeys-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。</li></ul><p>可以使用 <code>config get maxmemory-policy</code> 命令，来查看当前 Redis 的内存淘汰策略</p><h5 id="Redis中的LRU："><a href="#Redis中的LRU：" class="headerlink" title="Redis中的LRU："></a>Redis中的LRU：</h5><p>​Redis 实现的是一种<strong>近似 LRU 算法</strong>，目的是为了更好的节约内存，它的<strong>实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间</strong>。</p><p><u>当 Redis 进行内存淘汰时，会使用<strong>随机采样的方式来淘汰数据</strong>，它是随机取 5 个值（此值可配置），然后<strong>淘汰最久没有使用的那个</strong>。</u></p><p>Redis 实现的 LRU 算法的优点：</p><ul><li>不用为所有的数据维护一个大链表，节省了空间占用；</li><li>不用在每次数据访问时都移动链表项，提升了缓存的性能；</li></ul><p>但是 LRU 算法有一个问题，<strong>无法解决缓存污染问题</strong>，比如<u>应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间</u>，造成缓存污染。</p><p><strong>Redis中的LFU：</strong></p><p>​<strong>在 LFU 算法中</strong>，Redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt(Last Decrement Time)，低 8bit 存储 logc(Logistic Counter)。</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/lru%E5%AD%97%E6%AE%B5.png" alt="img"></p><ul><li>ldt 是用来记录 key 的访问时间戳；</li><li>logc 是用来记录 key 的访问频次，它的值越小表示使用频率越低，越容易淘汰，每个新加入的 key 的logc 初始值为 5。</li></ul><p>注意，logc 并不是单纯的访问次数，而是访问频次（访问频率），因为 <strong>logc 会随时间推移而衰减的</strong>。</p><p>在每次 key 被访问时，<u>会先对 logc 做一个衰减操作，衰减的值跟前后访问时间的差距有关系，如果上一次访问的时间与这一次访问的时间差距很大，那么衰减的值就越大，这样实现的 LFU 算法是根据<strong>访问频率</strong>来淘汰数据的，而不只是访问次数。访问频率需要考虑 key 的访问是多长时间段内发生的</u>。key 的先前访问距离当前时间越长，那么这个 key 的访问频率相应地也就会降低，这样被淘汰的概率也会更大。</p><p>对 logc 做完衰减操作后，就开始对 logc 进行增加操作，增加操作并不是单纯的 + 1，而是根据概率增加，如果 logc 越大的 key，它的 logc 就越难再增加。</p><p>所以，Redis 在访问 key 时，对于 logc 是这样变化的：</p><ol><li>先按照上次访问距离当前的时长，来对 logc 进行衰减；</li><li>然后，再按照一定概率增加 logc 的值</li></ol><p>redis.conf 提供了两个配置项，用于调整 LFU 算法从而控制 logc 的增长和衰减：</p><ul><li><code>lfu-decay-time</code> 用于调整 logc 的衰减速度，它是一个以分钟为单位的数值，默认值为1，lfu-decay-time 值越大，衰减越慢；</li><li><code>lfu-log-factor</code> 用于调整 logc 的增长速度，lfu-log-factor 值越大，logc 增长越慢。</li></ul><h2 id="Redis持久化："><a href="#Redis持久化：" class="headerlink" title="Redis持久化："></a>Redis持久化：</h2><p>参考文章：</p><ul><li><a href="https://xiaolincoding.com/redis/storage/aof.html">AOF持久化是怎么实现的？</a></li><li><a href="https://xiaolincoding.com/redis/storage/rdb.html">RDB 快照是怎么实现的？</a></li></ul><h3 id="AOF："><a href="#AOF：" class="headerlink" title="AOF："></a>AOF：</h3><p>​redis将<u><strong>写操作命令</strong></u>以追加的方式写入AOF文件中，实现数据持久化(存放操作命令)。AOF日志文件中的内容是根据操作命令得出的。</p><p>​</p><h4 id="为什么redis先执行写操作，再将命令记录到AOF日志中？"><a href="#为什么redis先执行写操作，再将命令记录到AOF日志中？" class="headerlink" title="为什么redis先执行写操作，再将命令记录到AOF日志中？"></a>为什么redis先执行写操作，再将命令记录到AOF日志中？</h4><ul><li>这样可以避免一些语法错误的命令被写入，造成额外的检查开销</li><li>并且，如果先执行写操作、再执行日志写入的话，咱们写操作这个流程就不会被写入日志这个操作影响，即<strong>不会阻塞当前写操作命令的执行</strong></li></ul><h4 id="潜在风险："><a href="#潜在风险：" class="headerlink" title="潜在风险："></a>潜在风险：</h4><ul><li>主机宕机时，未写入AOF日志文件中的记录信息丢失。</li><li>虽然<code>写入日志</code>在<code>写操作</code>后执行，但是 <code>写入日志</code> 这个操作会阻塞下一次<code>写操作</code>的执行。</li></ul><h4 id="Redis写入AOF日志的过程："><a href="#Redis写入AOF日志的过程：" class="headerlink" title="Redis写入AOF日志的过程："></a>Redis写入AOF日志的过程：</h4><p>![image-20230929161854043](&#x2F;Users&#x2F;donn&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230929161854043.png)</p><ol><li>Redis 执行完写操作命令后，会将命令追加到 <code>server.aof_buf</code> 缓冲区；</li><li>然后通过 write() 系统调用，将 aof_buf 缓冲区的数据最终写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；</li><li>具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。</li></ol><p>Redis提供了三种写回硬盘的策略：</p><ul><li><strong>Always</strong>：每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘(从内核缓冲区中写回硬盘)；</li><li><strong>Everysec</strong>：每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</li><li><strong>No</strong>：意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</li></ul><p>理解起来也和简单：</p><p>​想要高性能-&gt;使用No策略</p><p>​想要高可靠-&gt;使用Always策略</p><p>​中庸-&gt;使用Everysec策略</p><p>🌟在OS学习过程中，我们知道：</p><p>​<strong>当应用程序向文件写入数据时，内核通常先将数据复制到内核缓冲区中，然后<u>排入队列</u>，然后由内核决定何时写入硬盘。</strong>但是如果我们想要让某个写入硬盘的操作立即执行，<u>我们可以主动调用fsync()函数来立即将数据写入硬盘</u>！</p><p>因此：</p><ul><li>Always 策略就是每次写入 AOF 文件数据后，就执行 fsync() 函数；</li><li>Everysec 策略就会创建一个异步任务来执行 fsync() 函数；</li><li>No 策略就是永不执行 fsync() 函数;</li></ul><h4 id="AOF重写机制："><a href="#AOF重写机制：" class="headerlink" title="AOF重写机制："></a>AOF重写机制：</h4><p>​随着执行的写操作命令越来越多，AOF文件的大小会越来越大。</p><p>当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</p><p>​</p><p>这里我们需要解决两个问题：</p><h5 id="1-为什么AOF重写能够减小AOF文件的大小？"><a href="#1-为什么AOF重写能够减小AOF文件的大小？" class="headerlink" title="1.为什么AOF重写能够减小AOF文件的大小？"></a>1.为什么AOF重写能够减小AOF文件的大小？</h5><p>​首先，我们知道AOF文件中都是对Redis数据库的写操作。</p><p>​其次，Redis中存储的数据值为<strong>最后一次</strong>写操作赋予的值。</p><p>​因此，对于AOF缓存中的写命令，我们只需要留下对每个key的最后一次写操作就可以实现数据的持久化了！</p><h5 id="2-Redis是怎么实现AOF重写的？"><a href="#2-Redis是怎么实现AOF重写的？" class="headerlink" title="2.Redis是怎么实现AOF重写的？"></a>2.Redis是怎么实现AOF重写的？</h5><p>​Redis的 <u>将命令写入日志</u> 这一操作在Redis主进程完成，这是由于写入的只是几条命令，因此不会对主进程的其他操作造成太大影响。</p><p>​然而，AOF重写的过程需要将AOF日志中的所有语句都进行判断，写入到新的AOF文件中，这个操作比较耗时，因此将重写AOF的操作放在主进程中执行是不合理的。</p><h6 id="Redis的解决方案："><a href="#Redis的解决方案：" class="headerlink" title="Redis的解决方案："></a>Redis的解决方案：</h6><p>​Redis 的<strong>重写 AOF 过程通过执行redis命令<code>bgrewriteaof</code> 利用创建的子进程来实现</strong>，具体实现方式如下：</p><ul><li>子进程在重写AOF期间不会阻塞主进程</li><li>这里为什么是子**<u>进程</u><strong>而不是子</strong><u>线程</u>**：<ul><li>因为如果是同一进程中的两个<u>线程</u>的话，线程之间会<u>共享内存</u>，那么在有一方要对共享数据进行修改时，就需要通过加锁的方式保证数据的一致性，降低了性能。</li><li>如果使用子<u>进程</u>，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「<strong>写时复制</strong>」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。</li></ul></li></ul><h6 id="方案的具体实现："><a href="#方案的具体实现：" class="headerlink" title="方案的具体实现："></a>方案的具体实现：</h6><p>​主进程通过 <code>fork</code> 系统调用生成子进程，操作系统会把主进程的「<strong>页表</strong>」复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存，<u>然后让子进程读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志（新的 AOF 文件）。</u></p><p>​现在，父子进程的页表中的内容相同，且父子进程对页表记录的物理内存的权限为「只读」，</p><p>​当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发<strong>写保护中断</strong>，会发生「<strong>写时复制</strong>」</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20231007092622299.png" alt="image-20231007092622299"></p><p>写时复制顾名思义，<strong>在发生写操作的时候，操作系统才会去复制物理内存</strong>，这样是为了<u>防止 fork 创建子进程时，由于物理内存数据的复制时间过长而导致父进程长时间阻塞的问题。(即，对于修改了的数据，才开辟新的空间存储，对于没有修改的数据，则指向原来的地址而不去重新复制一份)</u></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">某线程修改资源时，写时复制会发生什么：</span><br><span class="line">首先，线程会在内存中为要修改的资源创建一个副本，而不是直接在原始资源上进行修改。这个副本是与原始资源共享内存空间的，并且初始状态与原始资源相同。</span><br><span class="line">接下来，该线程可以在副本上进行修改操作，而无需担心其他线程的影响。这意味着在修改期间，其他线程仍然可以访问和读取原始资源，而不会被阻塞。</span><br></pre></td></tr></table></figure><p>有两个阶段会导致阻塞父进程：</p><ul><li>创建子进程的途中，由于要<strong>复制父进程的页表</strong>等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；</li><li>创建完子进程后，如果子进程或者父进程修改了共享数据，就会<strong>发生写时复制</strong>，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长；</li></ul><p>重写 AOF 日志过程中，如果主进程修改了已经存在 key-value，此时这个 key-value 数据在子进程的内存数据就跟主进程的内存数据不一致了，这时要怎么办呢？</p><p>为了解决这种数据不一致问题，Redis 设置了一个 <strong>AOF 重写缓冲区</strong>，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。</p><p><u>在重写 AOF 期间</u>，当 Redis 执行完一个写命令之后，它会<strong>同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20231007094049811.png" alt="image-20231007094049811"></p><p>也就是说，在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:</p><ul><li>执行客户端发来的命令；</li><li>将执行后的写命令追加到 「AOF 缓冲区」；</li><li>将执行后的写命令追加到 「AOF 重写缓冲区」；</li></ul><p>当子进程完成 AOF 重写工作（<em>扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</em>）后，会向主进程<strong>发送一条信号</strong>，信号是进程间通讯的一种方式，且是异步的。</p><p>主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：</p><ul><li>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；</li><li>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</li></ul><p>信号函数执行完后，主进程就可以继续像往常一样处理命令了。</p><p>在整个 AOF 后台重写过程中，除了发生写时复制会对主进程造成阻塞，还有信号处理函数执行时也会对主进程造成阻塞，在其他时候，AOF 后台重写都不会阻塞主进程。</p><h3 id="RDB："><a href="#RDB：" class="headerlink" title="RDB："></a>RDB：</h3><p>RDB 快照记录某一个瞬间的内存数据，记录的是实际数据。</p><p>Redis 提供了两个命令来生成 RDB 文件，分别是 <code>save</code> 和 <code>bgsave</code>，他们的区别就在于是否在「主线程」里执行：</p><ul><li>执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；</li><li>执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以<strong>避免主线程的阻塞</strong>；</li></ul><p>Redis 的快照是<strong>全量快照</strong>，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。</p><p>所以可以认为，执行快照是一个比较重的操作，如果频率太高，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。</p><p>执行快照时，redis中的数据也能够被修改，靠的依然是写时复制技术<strong>（Copy-On-Write, COW）</strong></p><p>父子进程共享页表，父进程若要修改，则复制一个副本后对副本进行修改。这样的话，RDB快照中的数据只能是开始执行复制时的Redis中原本的数据，中途修改的数据不会被记录，而是需要下一次保存RDB快照来记录。</p><p>在 Redis 执行 RDB 持久化期间，刚 fork 时，主进程和子进程共享同一物理内存，但是途中主进程处理了写操作，修改了共享内存，于是当前被修改的数据的物理内存就会被复制一份。那么极端情况下，<strong>如果所有的共享内存都被修改，则此时的内存占用是原先的 2 倍。</strong></p><p>所以，针对写操作多的场景，我们要留意下快照过程中内存的变化，防止内存被占满了。</p><h3 id="RDB和AOF混合："><a href="#RDB和AOF混合：" class="headerlink" title="RDB和AOF混合："></a>RDB和AOF混合：</h3><p>​尽管 RDB 比 AOF 的数据恢复速度快，但是快照的频率不好把握：</p><p>在 Redis 4.0 提出一种方法：<strong>混合使用 AOF 日志和内存快照</strong>，也叫混合持久化。</p><p>​当开启了混合持久化时，在 AOF 重写日志时，<code>fork</code> 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p><p>​使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p><p>​这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。</p><h2 id="Redis高可用："><a href="#Redis高可用：" class="headerlink" title="Redis高可用："></a>Redis高可用：</h2><p>参考文章：</p><ul><li><a href="https://segmentfault.com/a/1190000022808576">你了解 Redis 的三种集群模式吗？</a></li><li><a href="https://security.feishu.cn/link/safety?target=https://xiaolincoding.com/redis/cluster/master_slave_replication.html&scene=ccm&logParams=%7B%22location%22:%22ccm_default%22%7D&lang=zh-CN">主从复制是怎么实现的？</a></li><li><a href="https://xiaolincoding.com/redis/cluster/sentinel.html">为什么要有哨兵</a></li><li><a href="https://z.itpub.net/article/detail/D63884E646552F22E025E7F50BE5C7CB">深入分析Cluster 集群模式</a></li></ul><h3 id="主从模式："><a href="#主从模式：" class="headerlink" title="主从模式："></a>主从模式：</h3><p>​与MySQL中的方案类似，主数据库可以读写、从数据库只读「读写分离」。</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20231008145357993.png" alt="image-20231008145357993" style="zoom:50%;" /><h4 id="主从复制运行原理："><a href="#主从复制运行原理：" class="headerlink" title="主从复制运行原理："></a>主从复制运行原理：</h4><p>​在从服务器上执行一下命令：<u>replicaof &lt;服务器 A 的 IP 地址&gt; &lt;服务器 A 的 Redis 端口号&gt;</u></p><p>​这样，该服务器的redis服务就成为服务器A的从服务器</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20231008140330120.png" alt="image-20231008140330120" style="zoom:50%;" /><h4 id="具体流程："><a href="#具体流程：" class="headerlink" title="具体流程："></a>具体流程：</h4><ul><li>从数据库启动成功后，连接主数据库，发送 SYNC 命令；</li><li>主数据库接收到 SYNC 命令后，开始执行 BGSAVE 命令<strong>生成 RDB 文件</strong>并<strong>使用缓冲区记录此后执行的所有写命令</strong>；</li><li>主数据库 BGSAVE 执行完后，向所有从数据库<strong>发送快照文件</strong>，并在发送期间继续<strong>记录被执行的写命令</strong>；</li><li>从数据库收到快照文件后丢弃所有旧数据，载入收到的快照；</li><li>主数据库快照发送完毕后开始向从数据库发送<strong>缓冲区</strong>中的写<strong>命令</strong>；</li><li>从数据库完成对快照的载入，开始接收命令请求，并执行来自主数据库缓冲区的写命令；（<strong>从数据库初始化完成</strong>）</li><li>主数据库每执行一个写命令就会向从数据库发送相同的写命令，从数据库接收并执行收到的写命令（<strong>从数据库初始化完成后的操作</strong>）</li><li><strong>由于主服务器与从服务器之间完成全量复制后，会维持一个TCP连接用于实现后续的增量复制，如果TCP连接由于网络波动出现断开重连的情况，Redis2.8之后的版本会将断线期间的命令传给从数据库，即仍使用增量复制来进行同步。</strong><ul><li>这种网络断开的情况下，其实也是有增量复制、全量复制两种情况的：<ul><li><u>redis对于写命令会有一个环形缓冲区，主、从服务器各有一个offset指针指向缓冲区中的某条指令，表示执行到了哪条，如果从服务器网络恢复时，其offset指针指向的位置在缓冲区中不存在(说明掉线太久了，环形缓冲区已经被覆盖一圈了，不能够再通过这个缓冲区来同步进度了，这时候会采用全量复制来同步数据；否则，会使用增量复制来同步数据。)</u></li></ul></li></ul></li><li>主从数据库刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。Redis 的策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</li></ul><h4 id="问题：从服务器数量较多："><a href="#问题：从服务器数量较多：" class="headerlink" title="问题：从服务器数量较多："></a>问题：从服务器数量较多：</h4><p>如果从服务器较多，而且都与主服务器进行全量同步的话，就会带来两个问题：</p><ul><li>由于是通过 bgsave 命令来生成 RDB 文件的，那么主服务器就会忙于使用 fork() 创建子进程，如果主服务器的内存数据非大，在执行 fork() 函数时是会阻塞主线程的，从而使得 Redis 无法正常处理请求；</li><li>传输 RDB 文件会占用主服务器的网络带宽，会对主服务器响应命令请求产生影响。</li></ul><p>我们可以构建树状结构的主从关系，让主服务器管理个别从服务器，再让这几个从服务器管理其他的从服务器，以达到分散主服务器压力的目的。</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20231008150658511.png" alt="image-20231008150658511" style="zoom:50%;" /><h4 id="主从复制优点："><a href="#主从复制优点：" class="headerlink" title="主从复制优点："></a>主从复制优点：</h4><ul><li>支持主从复制，主机会自动将数据同步到从机，可以进行<u>读写分离</u>；</li><li>为了<u>分散 Master 的读操作压力</u>，Slave 服务器可以为客户端提供只读操作的服务，写服务仍然必须由Master来完成；</li><li><u>Slave 同样可以接受其它 Slaves 的连接和同步请求</u>，这样可以有效的分散 Master 的同步压力；</li><li>Master Server 是以非阻塞的方式为 Slaves 提供服务。所以<u>在 Master-Slave 同步期间，客户端仍然可以提交查询或修改请求</u>；</li><li>Slave Server 同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据；</li></ul><h4 id="主从复制缺点："><a href="#主从复制缺点：" class="headerlink" title="主从复制缺点："></a>主从复制缺点：</h4><ul><li>Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP(手动重新设置主数据库)才能恢复（<strong>也就是要人工介入</strong>）；</li><li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性；</li><li>如果多个 Slave 断线了，需要重启的时候，尽量不要在同一时间段进行重启。因为只要 Slave 启动，就会发送sync 请求和主机全量同步，当多个 Slave 重启的时候，可能会导致 Master IO 剧增从而宕机。</li><li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂；</li></ul><h3 id="哨兵模式-Sentinel-模式-："><a href="#哨兵模式-Sentinel-模式-：" class="headerlink" title="哨兵模式(Sentinel 模式)："></a>哨兵模式(Sentinel 模式)：</h3><p>​Redis 提供了哨兵的命令，<strong>哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个 Redis 实例</strong>。</p><p>​简单哨兵模式：</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20231008141843134.png" alt="image-20231008141843134" style="zoom:50%;" /><p>​多哨兵模式：</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20231008141935130.png" alt="image-20231008141935130" style="zoom:50%;" /><h4 id="哨兵模式的工作方式："><a href="#哨兵模式的工作方式：" class="headerlink" title="哨兵模式的工作方式："></a>哨兵模式的工作方式：</h4><p>​三步骤：<strong>监控、选主、通知</strong></p><ul><li>每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的 Master 主服务器、Slave 从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。</li><li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为<strong>主观下线</strong>（SDOWN）</li><li>如果一个 Master 主服务器被标记为主观下线（SDOWN），则正在监视这个 Master 主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认 Master 主服务器的确进入了主观下线状态</li><li>当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认 Master 主服务器进入了主观下线状态（SDOWN）， 则 Master 主服务器会被标记为客观下线（ODOWN）<ul><li>🌟</li><li>标记为客观下线后，哨兵们发起<u>投票</u>，先投票<strong>选出一个Leader哨兵</strong>来处理本次故障转移的流程！</li><li>选出Leader哨兵后，实行主从故障转移：<ul><li>第一步：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点。</li><li>第二步：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；</li><li>第三步：将新主节点的 IP 地址和信息，通过「发布者&#x2F;订阅者机制」通知给客户端；</li><li>第四步：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点；</li></ul></li></ul></li><li>在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有 Master 主服务器、Slave 从服务器发送 INFO 命令。</li><li>当 Master 主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master 主服务器的所有 Slave 从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</li><li>若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master 主服务器的客观下线状态就会被移除。若 Master 主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。</li></ul><p>哨兵模式<strong>可以看作自动版的主从复制</strong>，但是仍较难支持在线扩容。</p><h4 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h4><h5 id="1、第一轮投票：判断主节点下线"><a href="#1、第一轮投票：判断主节点下线" class="headerlink" title="1、第一轮投票：判断主节点下线"></a><em>1、第一轮投票：判断主节点下线</em></h5><p>​当哨兵集群中的某个哨兵判定主节点下线（主观下线）后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。</p><p>当这个哨兵的赞同票数达到哨兵配置文件中的 quorum 配置项设定的值后，这时主节点就会被该哨兵标记为「客观下线」。</p><h5 id="2、第二轮投票：选出哨兵leader"><a href="#2、第二轮投票：选出哨兵leader" class="headerlink" title="2、第二轮投票：选出哨兵leader"></a><em>2、第二轮投票：选出哨兵leader</em></h5><p>​某个哨兵判定主节点客观下线后，该哨兵就会发起投票，告诉其他哨兵，它想成为 leader，想成为 leader 的哨兵节点，要满足两个条件：</p><ul><li>第一，拿到半数以上的赞成票；</li><li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。</li></ul><h5 id="3、由哨兵-leader-进行主从故障转移"><a href="#3、由哨兵-leader-进行主从故障转移" class="headerlink" title="3、由哨兵 leader 进行主从故障转移"></a><em>3、由哨兵 leader 进行主从故障转移</em></h5><p>​选举出了哨兵 leader 后，就可以进行主从故障转移的过程了。该操作包含以下四个步骤：</p><ul><li>第一步：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点，选择的规则：<ul><li>过滤掉已经离线的从节点；</li><li>过滤掉历史网络连接状态不好的从节点；</li><li>将剩下的从节点，进行三轮考察：优先级、复制进度、ID 号。在每一轮考察过程中，如果找到了一个胜出的从节点，就将其作为新主节点。</li></ul></li><li>第二步：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；</li><li>第三步：将新主节点的 IP 地址和信息，通过「发布者&#x2F;订阅者机制」通知给客户端；</li><li>第四步：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点；</li></ul><h3 id="集群模式-Cluster-模式-："><a href="#集群模式-Cluster-模式-：" class="headerlink" title="集群模式(Cluster 模式)："></a>集群模式(Cluster 模式)：</h3><p>​Cluster 集群模式，实现了 Redis 的分布式存储，<strong>每台 Redis 节点上存储不同的内容</strong>。</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20231008143654026.png" alt="image-20231008143654026" style="zoom:50%;" /><p>​在这个图中，每一个蓝色的圈都代表着一个 redis 的服务器节点。它们任何两个节点之间都是相互连通的。客户端可以与任何一个节点相连接，然后就可以访问集群中的任何一个节点。对其进行存取和其他操作。</p><p>​</p><h4 id="集群的数据分片："><a href="#集群的数据分片：" class="headerlink" title="集群的数据分片："></a>集群的数据分片：</h4><p>Redis 集群没有使用一致性 hash，而是引入了哈希槽【hash slot】的概念。</p><p>Redis 集群有16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽。集群的每个节点负责一部分hash槽，举个例子，比如当前集群有3个节点，那么：</p><ul><li>节点 A 包含 0 到 5460 号哈希槽</li><li>节点 B 包含 5461 到 10922 号哈希槽</li><li>节点 C 包含 10923 到 16383 号哈希槽</li></ul><p>这种结构很容易添加或者删除节点。比如如果我想新添加个节点 D ， 我需要从节点 A， B， C 中得部分槽到 D 上。如果我想移除节点 A ，需要将 A 中的槽移到 B 和 C 节点上，然后将没有任何槽的 A 节点从集群中移除即可。由于从一个节点将哈希槽移动到另一个节点并不会停止服务，所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态。</p><p>在 Redis 的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383。还有一个就是 cluster，可以理解为是一个集群管理的插件。当我们的存取的 Key到达的时候，Redis 会根据 CRC16 的算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。</p><h4 id="Redis-集群-主从复制模型："><a href="#Redis-集群-主从复制模型：" class="headerlink" title="Redis 集群 + 主从复制模型："></a>Redis 集群 + 主从复制模型：</h4><p>​注意：这里的主从模式并不完全是之前说的主从模式，而是单纯的将从节点作为主节点的备份，主节点如果没挂掉，就用不到从节点。</p><p>​为了保证高可用，<u>redis-cluster集群引入了主从复制模型</u>，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。当其它主节点 ping 一个主节点 A 时，如果半数以上的主节点与 A 通信超时，那么认为主节点 A 宕机了。如果主节点 A 和它的从节点 A1 都宕机了，那么该集群就才被认为无法再提供服务。</p><h4 id="故障检测："><a href="#故障检测：" class="headerlink" title="故障检测："></a>故障检测：</h4><p>一个节点认为某个节点宕机不能说明这个节点真的挂起了，无法提供服务了。只有占据多数的实例节点都认为某个节点挂起了，这时候cluster才进行下线和主从切换的工作。<br>Redis 集群的节点采用 Gossip 协议来广播信息，每个节点都会定期向其他节点发送ping命令，如果接受ping消息的节点在指定时间内没有回复pong，则会认为该节点失联了（PFail），则发送ping的节点就把接受ping的节点标记为主观下线。<br><u>如果集群半数以上的主节点都将主节点 xxx 标记为主观下线，则节点 xxx 将被标记为客观下线，然后向整个集群广播，让其它节点也知道该节点已经下线，并立即对下线的节点进行主从切换。</u></p><h4 id="主从故障转移："><a href="#主从故障转移：" class="headerlink" title="主从故障转移："></a>主从故障转移：</h4><p>当一个从节点发现自己正在复制的主节点进入了已下线，则开始对下线主节点进行故障转移，故障转移的步骤如下：</p><ul><li>如果只有一个slave节点，则从节点会执行SLAVEOF no one命令，成为新的主节点。</li><li>如果是多个slave节点，则采用选举模式进行，竞选出新的Master<ul><li>集群中设立一个自增计数器，初始值为 0 ，每次执行故障转移选举，计数就会+1。</li><li>检测到主节点下线的从节点向集群所有master广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，所有收到消息、并具备投票权的主节点都向这个从节点投票。</li><li>如果收到消息、并具备投票权的主节点未投票给其他从节点（只能投一票哦，所以投过了不行），则返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，表示支持。</li><li>参与选举的从节点都会接收CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，如果收集到的选票 大于等于 (n&#x2F;2) + 1 支持，n代表所有具备选举权的master，那么这个从节点就被选举为新主节点。</li><li>如果这一轮从节点都没能争取到足够多的票数，则发起再一轮选举（自增计数器+1），直至选出新的master。</li></ul></li><li>新的主节点会撤销所有对已下线主节点的slots指派，并将这些slots全部指派给自己。</li><li>新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。</li><li>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</li></ul><h4 id="集群的特点："><a href="#集群的特点：" class="headerlink" title="集群的特点："></a><strong>集群的特点</strong>：</h4><ul><li>所有的 redis 节点彼此互联(PING-PONG机制)，内部使用二进制协议优化传输速度和带宽。</li><li>节点的 fail 是通过集群中超过半数的节点检测失效时才生效。</li><li>客户端与 Redis 节点直连，不需要中间代理层.客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。</li></ul><h2 id="Redis缓存："><a href="#Redis缓存：" class="headerlink" title="Redis缓存："></a>Redis缓存：</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 数据库相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 原理学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础复习</title>
      <link href="/2023/08/10/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/08/10/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>本文根据作者对java基础的掌握程度而写，只记录了我自己容易遗忘的点，可能并不适合java新手学习😵‍💫</p><h3 id="1-深拷贝、浅拷贝以及引用拷贝："><a href="#1-深拷贝、浅拷贝以及引用拷贝：" class="headerlink" title="1.深拷贝、浅拷贝以及引用拷贝："></a>1.深拷贝、浅拷贝以及引用拷贝：</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230810141303963.png" alt="image-20230810141303963"></p><h3 id="2-Object类中的常见方法："><a href="#2-Object类中的常见方法：" class="headerlink" title="2.Object类中的常见方法："></a>2.Object类中的常见方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * naitive 方法，用于创建并返回当前对象的一份拷贝。 ⚠️浅拷贝</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="3-hashCode-和-equals"><a href="#3-hashCode-和-equals" class="headerlink" title="3.hashCode() 和 equals()"></a>3.hashCode() 和 equals()</h3><p><a href="https://www.cnblogs.com/skywang12345/p/3324958.html">Java hashCode() 和 equals()的若干问题解答</a></p><h3 id="4-字符串相关"><a href="#4-字符串相关" class="headerlink" title="4.字符串相关"></a>4.字符串相关</h3><p>​</p><h4 id="String-不可变"><a href="#String-不可变" class="headerlink" title="String:不可变"></a>String:不可变</h4><p>​原因是String底层使用private、final修饰一个char[]，而且并不把修改该char[]的方法暴露，因此不可变</p><p>​java9之后，String使用 byte[] 存储内容 ——原因是：</p><ul><li>byte的存储空间为1B；char为2B<ul><li>大多数情况下 1B的空间能表示我们使用的字符—-使用Latin-1编码方式</li><li>当我们使用到一些特殊字符时，才会用2个byte存储一个字符(此时存储效率与使用char一样)</li></ul></li></ul><p>​</p><h4 id="字符串拼接："><a href="#字符串拼接：" class="headerlink" title="字符串拼接："></a>字符串拼接：</h4><p>Java 语言本身并不支持运算符重载，“+”和“+&#x3D;”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。</p><p>​🌟String 对象通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p><p>​🌟不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个</strong> <strong><code>StringBuilder</code></strong> <strong>以复用，会导致创建过多的</strong> <strong><code>StringBuilder</code></strong> <strong>对象</strong>。</p><h4 id="字符串常量池的作用了解吗？"><a href="#字符串常量池的作用了解吗？" class="headerlink" title="字符串常量池的作用了解吗？"></a>字符串常量池的作用了解吗？</h4><p>JDK1.7后，字符串常量池在堆中</p><p>​<strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了<u>避免字符串的重复创建。</u></p><p>🍓<strong>字符串常量池保存的是</strong>：<u>字符串（key）</u>和 <u>字符串对象的引用（value）</u>的映射关系(维护了一个HashMap)，字符串对象的引用指向堆中的字符串对象。</p><p>因此如果在常量池中找不到某字符串，会<u>在堆中创建以该字符串生成的String对象，再将其地址存储到常量池HashMap的Value中</u>！</p><p>至此，常量池中增加了一个字符串常量。</p><p>因此面对问题：String s1 &#x3D; new String(“abc”);创建了几个String对象？</p><p>—1.为s1创建一个空的String对象，</p><ul><li>如果常量池中没有“abc”，那么首先还需要在堆中创建一个存储了“abc”的String对象，将该对象的引用存入常量池，再为 为s1创建的对象 赋值，因此创建了2个String对象</li><li>如果常量池中有“abc”，那么直接为 为s1创建的对象 赋值即可，只创建了一个对象。</li></ul><h4 id="intern-方法有什么作用"><a href="#intern-方法有什么作用" class="headerlink" title="intern 方法有什么作用?"></a>intern 方法有什么作用?</h4><p>​<code>String.intern()</code> 是一个 native（本地）方法，其作用是**<u>将指定的字符串对象的引用保存在字符串常量池中</u>**，可以简单分为两种情况：</p><ul><li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li><li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”Java“</span></span><br><span class="line"><span class="comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="comment">// 会在堆中在单独创建一个字符串对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s3.intern();</span><br><span class="line"><span class="comment">// s1 和 s2 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s2); </span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// s3 和 s4 指向的是堆中不同的对象</span></span><br><span class="line">System.out.println(s3 == s4); </span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// s1 和 s4 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s4); </span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="5-包装类型的缓存机制了解么？"><a href="#5-包装类型的缓存机制了解么？" class="headerlink" title="5.包装类型的缓存机制了解么？"></a>5.包装类型的缓存机制了解么？</h3><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><h4 id="⚠️包装类等值比较的注意点："><a href="#⚠️包装类等值比较的注意点：" class="headerlink" title="⚠️包装类等值比较的注意点："></a>⚠️包装类等值比较的注意点：<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230811093744235.png" alt="image-20230811093744235"></h4><h3 id="6-为什么浮点数运算的时候会有精度丢失的风险？"><a href="#6-为什么浮点数运算的时候会有精度丢失的风险？" class="headerlink" title="6.为什么浮点数运算的时候会有精度丢失的风险？"></a>6.为什么浮点数运算的时候会有精度丢失的风险？</h3><p>浮点数运算精度丢失代码演示：</p><p>float a &#x3D; 2.0f - 1.9f; float b &#x3D; 1.8f - 1.7f;</p><p>System.out.println(a);&#x2F;&#x2F; 0.100000024 </p><p>System.out.println(b);&#x2F;&#x2F; 0.099999905 </p><p>System.out.println(a &#x3D;&#x3D; b);&#x2F;&#x2F; false</p><p>为什么会出现这个问题呢？</p><p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p><h3 id="7-如何解决浮点数运算的精度丢失问题？"><a href="#7-如何解决浮点数运算的精度丢失问题？" class="headerlink" title="7.如何解决浮点数运算的精度丢失问题？"></a>7.如何解决浮点数运算的精度丢失问题？</h3><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b); </span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c); </span><br><span class="line"></span><br><span class="line">System.out.println(x);   <span class="comment">//0.1</span></span><br><span class="line"></span><br><span class="line">System.out.println(y);   <span class="comment">//0.1</span></span><br><span class="line"></span><br><span class="line">System.out.println(Objects.equals(x, y));  <span class="comment">//true </span></span><br></pre></td></tr></table></figure><h3 id="8-如何实现数组和-List-之间的转换？"><a href="#8-如何实现数组和-List-之间的转换？" class="headerlink" title="8.如何实现数组和 List 之间的转换？"></a>8.如何实现数组和 List 之间的转换？</h3><ul><li>数组转 List：使用 Arrays. asList(array) 进行转换。</li><li>List 转数组：使用 List 自带的 toArray() 方法。</li></ul><h3 id="9-CAS原理"><a href="#9-CAS原理" class="headerlink" title="9.CAS原理"></a>9.CAS原理</h3><p>内存中：</p><ul><li>待修改的值</li></ul><p>线程持有：</p><ul><li>预期值</li><li>新值</li></ul><p>工作方式：线程想要修改内存中的一个值，那么该线程先**<u>从内存中读取该值，作为预期值</u><strong>，在进行业务流程后</strong><u>生成新值</u>**，在修改内存中值之前进行判断：</p><p><em>1.如果预期值 &#x3D;&#x3D; 待修改的值</em>，说明在此期间该‘值’未发生改变，线程便可以将内存中的旧值替换为新值。</p><p><em>2.如果预期值 !&#x3D; 待修改的值</em>，说明在此期间值发生了改变，线程不能进行修改，常见的应对措施是：<u>重新获取预期值和计算新值，再次进行判断。。</u></p><p>​⚠️在*1.*中，在此期间该‘值’未发生改变的情况下 可能发生ABA问题，这种情况下本应重试，不允许修改，但是CAS却检测不出来</p><p>解决方案：添加一个序号(或 时间戳)</p><h1 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h1><h3 id="ArrayList源码学习"><a href="#ArrayList源码学习" class="headerlink" title="ArrayList源码学习"></a>ArrayList源码学习</h3><p><a href="https://juejin.cn/post/7056709563860385822?searchId=20230913151916438B638FBB6D1628A413">参考文章</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化 ID</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认初始容量大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空数组，用于空实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于默认大小空实例的共享空数组实例。</span></span><br><span class="line"><span class="comment">// 我们把它从 EMPTY_ELEMENTDATA 数组中区分出来，以知道在添加第一个元素时容量需要增加多少</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存数据的数组，所以说 ArrayList 的底层是数组，只不过能动态增长而已</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure><h4 id="ArrayList-中的elementData对象被transient修饰，原因是："><a href="#ArrayList-中的elementData对象被transient修饰，原因是：" class="headerlink" title="ArrayList 中的elementData对象被transient修饰，原因是："></a>ArrayList 中的elementData对象被transient修饰，原因是：</h4><ul><li>transient修饰的变量不会被序列化，但是ArrayList底层在序列化时，会调用自己重新实现的 <code>writeObject()</code> 和 <code>readObject()</code> 这两个方法来序列化数组元素，<u>目的是防止ArrayList中开辟了空间但是没有被使用的空间也被序列化</u></li><li>ArrayList底层重新实现的 <code>writeObject()</code> 和 <code>readObject()</code> 中，序列化elementData时是读取了size然后一个一个进行序列化传输的。即：**<u>ArrayList 重写了 JDK 序列化的逻辑，只把 elementData 数组中有效元素的部分序列化，而不会序列化整个数组。</u>**</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素方法</span></span><br><span class="line"><span class="comment"> * 在添加元素前会先调用 ensureCapacityInternal() 方法判断是否需要扩容</span></span><br><span class="line"><span class="comment"> * 然后再将元素添加到数组的尾部</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否需要扩容方法，注意这里传的参数是 元素个数 + 1</span></span><br><span class="line">    <span class="comment">// 1 代表的是新添加的元素</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 追加的数组的尾部</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先调用 calculateCapacity 判断是否是空数组！</span></span><br><span class="line"><span class="comment"> * 再调用 ensureExplicitCapacity() 方法进行进一步处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是空数组，如果是空数组，则比较默认容量 10 和 元素个数 + 1 的大小</span></span><br><span class="line"><span class="comment"> * 二者取最大值，然后返回</span></span><br><span class="line"><span class="comment"> * 得到最小扩容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ArrayList扩容机制："><a href="#ArrayList扩容机制：" class="headerlink" title="ArrayList扩容机制："></a>ArrayList扩容机制：</h4><p>ArrayList通过空构造方法时并不会创建默认大小的elementData，而是让elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA这个空数组，<strong>在添加元素时，ArrayList会先看看elementData是否为空数组，是的话就给他赋值为默认大小的数组，再使用ensureCapacityInternal(size + 1) 来判断现在elementData的大小是否能放入size + 1个元素，如果不行则扩容。</strong></p><h4 id="🌟ArrayList源码中有个参数叫做-modCount，它有什么用？"><a href="#🌟ArrayList源码中有个参数叫做-modCount，它有什么用？" class="headerlink" title="🌟ArrayList源码中有个参数叫做 modCount，它有什么用？"></a>🌟ArrayList源码中有个参数叫做 modCount，它有什么用？</h4><p>​它很像乐观锁的版本检测的过程</p><ul><li><p>modcount（modification count）是一种用于记录数据结构变化状态的计数器，通常用于在迭代器中实现快速失败（fail-fast）机制。</p></li><li><p>在一些数据结构（如ArrayList、HashMap等）中，当数据结构发生变化（如增删元素）时，会增加modcount的值。<strong>当迭代器开始遍历数据结构时，会将当前的modcount值保存下来。在每次迭代器执行操作时，会检查当前的modcount值是否与保存的值相等。</strong>如果不相等，就表示数据结构发生了变化，迭代器会立即抛出ConcurrentModificationException异常，实现了快速失败。</p></li><li><p>modcount的作用是在并发环境中，保证多个线程之间不会产生隐患的访问竞态条件。通过检查modcount值，可以检测到其他线程对数据结构的修改，从而及时发现并防止遍历过程中的异常情况发生。</p></li><li><p>需要注意的是，modcount并不提供线程安全性。在并发环境中操作modcount和数据结构仍然需要使用适当的同步机制来保证线程安全性。modcount的主要作用是实现快速失败机制，及时检测并发修改，而不是作为线程同步的方法。</p></li></ul><h3 id="ConcurrentHashMap："><a href="#ConcurrentHashMap：" class="headerlink" title="ConcurrentHashMap："></a>ConcurrentHashMap：</h3><h4 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7:"></a>JDK1.7:</h4><h5 id="1-Segment-段："><a href="#1-Segment-段：" class="headerlink" title="1.Segment 段："></a>1.Segment 段：</h5><p>​ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。</p><p>​整个 ConcurrentHashMap 由一个个 Segment 组成， Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为<strong>分段锁</strong>。注意，行文中，我很多地方用了“槽”来代表一个segment。</p><h5 id="2-线程安全（Segment-继承-ReentrantLock-加锁）："><a href="#2-线程安全（Segment-继承-ReentrantLock-加锁）：" class="headerlink" title="2.线程安全（Segment 继承 ReentrantLock 加锁）："></a>2.线程安全（Segment 继承 ReentrantLock 加锁）：</h5><p>​简单理解就是， <u>ConcurrentHashMap 是一个 Segment 数组， Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</u></p><h5 id="3-并行度（默认-16）："><a href="#3-并行度（默认-16）：" class="headerlink" title="3.并行度（默认 16）："></a>3.并行度（默认 16）：</h5><p>​concurrencyLevel：并行级别、并发数、 Segment 数，默认是 16，</p><p>​即 <strong>ConcurrentHashMap 有 16 个 Segments</strong>，所以理论上，<u>最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上</u>。这个值可以在初始化的时候设置为其他值<u>，但是一旦初始化以后，它是不可以扩容的</u>。再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</p><h5 id="🌟segment-数量在-ConcurrentHashMap-初始化后就不可改变"><a href="#🌟segment-数量在-ConcurrentHashMap-初始化后就不可改变" class="headerlink" title="🌟segment 数量在 ConcurrentHashMap 初始化后就不可改变"></a>🌟segment 数量在 ConcurrentHashMap 初始化后就不可改变</h5><h5 id="🌟每个-segment-中的hashmap大小可扩容，类似HashMap"><a href="#🌟每个-segment-中的hashmap大小可扩容，类似HashMap" class="headerlink" title="🌟每个 segment 中的hashmap大小可扩容，类似HashMap"></a>🌟每个 segment 中的hashmap大小可扩容，类似HashMap</h5><p>​线程<strong>写</strong>一个segment时，需要获取该segment代表的ReentrantLock，**<u>读取数据并不需要获取锁</u>**，因此<u>只有多个线程同时在写一个segment时才会发生冲突，这时未抢到锁的线程将被阻塞！！！</u></p><h4 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8:"></a>JDK1.8:</h4><p>​由于JDK1.7中segment使用拉链法解决hash冲突，链表过长会导致性能下降。</p><p>​JDK1.8中当链表长度&gt;8时，会自动转换成红黑树存储</p><p>并且使用 <strong>CAS + synchronized</strong> 来保证并发的安全性，**<u>只锁定当前链表或红黑二叉树的首节点</u>**，只要节点 hash 不冲突，就不会产生并发，相比 JDK1.7 的 ConcurrentHashMap 效率又提升了 N 倍！</p><p><a href="https://security.feishu.cn/link/safety?target=https://pdai.tech/md/java/thread/java-thread-x-juc-collection-ConcurrentHashMap.html%23juc%E9%9B%86%E5%90%88-concurrenthashmap%E8%AF%A6%E8%A7%A3&scene=ccm&logParams=%7B%22location%22:%22ccm_default%22%7D&lang=zh-CN">JUC集合: ConcurrentHashMap详解</a></p><h1 id="枚举类："><a href="#枚举类：" class="headerlink" title="枚举类："></a>枚举类：</h1><p>demo Code:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">DemoEnum</span> &#123;</span><br><span class="line">    RED(<span class="string">&quot;r&quot;</span>, <span class="string">&quot;🌹&quot;</span>),</span><br><span class="line">    BLUE(<span class="string">&quot;g&quot;</span>, <span class="string">&quot;wdwd&quot;</span>),</span><br><span class="line">    GREEN(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;ewdwdwdadw&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    DemoEnum(String color, String desc) &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(DemoEnum.RED.color);</span><br><span class="line">        System.out.println(DemoEnum.RED.desc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">  r</span><br><span class="line">  🌹</span><br></pre></td></tr></table></figure><p>其中：Red、Blue、Green被称为**<u>枚举常量</u>**</p><p>枚举常量可以对应有多个属性，如上述枚举类中的“color”，“desc”</p><p>⚠️：在外部类想要访问如<code>DemoEnum.Red.color</code>的话，由于color、desc都是private属性，我们需要在DemoEnum中自定义有关私有属性的访问方法。</p><ul><li>枚举常量：RED、BLUE、GREEN  是枚举类 DemoEnum 的三个实例化对象，它们是唯一的、已命名的常量。( 而(“r”, “🌹”) 就是构造RED这个实例化对象的初始变量 )</li><li>构造方法：枚举类的构造方法<strong>默认是私有</strong>的，只能在枚举类内部使用。在这个示例中，使用私有构造方法来为每个枚举常量设置对应的颜色和原始值。</li><li>values() 方法：这个示例在 main() 方法中使用 TestEnum.values() 方法<strong>获取 DemoEnum 枚举类中的所有枚举常量，</strong>并进行遍历输出。</li><li>valueOf(String name) 方法：通过 TestEnum.valueOf(“RED”) 可以获取枚举常量名为 “RED” 的<strong>枚举对象</strong>。</li><li>ordinal() 方法：枚举常量的 ordinal() 方法返回它们在枚举类型中定义的顺序值（<strong>下标</strong>，从0开始）。</li><li>compareTo() 方法：通过 RED.compareTo(BLACK) 和 BLACK.compareTo(GREEN) 可以比较两个枚举常量的顺序，返回一个整数值。</li></ul><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li><p>易读性和可维护性：枚举类型中的常量是有意义的、自描述的，使得代码更易读、易理解和易于维护。枚举常量具有唯一的名称，提供了更好的文档和注释。</p></li><li><p>类型安全：枚举类型在编译时进行静态类型检查，这意味着编译器可以确保只使用有效的枚举常量，提供了更高的类型安全性。</p></li><li><p>可限定的值集合：枚举类型定义了一个有限的值集合，限定了有效的取值范围。这可以帮助避免程序中出现无效或意外的取值。</p></li><li><p>避免魔法数值：使用枚举类型可以避免使用硬编码的魔法数值，提供了更好的代码可读性和可维护性。</p></li><li><p>增强的编译器支持：枚举类型在编译器层面提供了一些额外的支持，如自动添加常用方法（如values()、valueOf()）、枚举常量的顺序等。</p></li><li><p>适用于状态和选项的表示：枚举类型非常适用于表示状态、选项和固定集合，如季节、颜色、星期几等。</p></li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li><p>不适用于动态变化的数据：枚举类型是在编译时定义的，其常量集合是固定的。如果需要表示动态变化的数据集合，枚举类型可能不适合。</p></li><li><p>不适用于大型数据集合：如果需要表示大型的数据集合，枚举类型的常量定义可能会变得冗长和繁琐。</p></li><li><p>缺乏扩展性：枚举类型的常量是在编译时确定的，不支持动态添加或删除常量。因此，如果需要频繁地修改常量集合，可能会导致代码的改动和维护成本的增加。</p></li><li><p>不支持继承：枚举类型不支持继承，无法实现枚举类型之间的继承关系。</p></li></ul><h1 id="异常分类及处理"><a href="#异常分类及处理" class="headerlink" title="异常分类及处理"></a>异常分类及处理</h1><h4 id="4-1-1-异常概念"><a href="#4-1-1-异常概念" class="headerlink" title="4.1.1. 异常概念"></a>4.1.1. 异常概念</h4><p>​如果某个方法不能按照正常的途径完成任务，就可以通过另一种路径退出方法。在这种情况下会抛出一个封装了错误信息的对象。此时，这个方法会立刻退出同时不返回任何值。另外，调用这个方法的其他代码也无法继续执行，异常处理机制会将代码执行交给异常处理器。</p><h4 id="4-1-2-异常分类"><a href="#4-1-2-异常分类" class="headerlink" title="4.1.2. 异常分类"></a>4.1.2. 异常分类</h4><p><strong><u>Throwable</u></strong> 是 Java 语言中所有错误或异常的超类。下一层分为 <u>Error 和 Exception</u></p><h5 id="Error-非检查异常-："><a href="#Error-非检查异常-：" class="headerlink" title="Error (非检查异常)："></a>Error (非检查异常)：</h5><ul><li>Error 类是指 java <u>运行时系统的内部错误和资源耗尽错误</u>。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。</li></ul><h5 id="Exception（-RuntimeException-非检查异常-、-CheckedException-检查异常-）："><a href="#Exception（-RuntimeException-非检查异常-、-CheckedException-检查异常-）：" class="headerlink" title="Exception（ RuntimeException(非检查异常)、 CheckedException(检查异常) ）："></a>Exception（ RuntimeException(非检查异常)、 CheckedException(检查异常) ）：</h5><ul><li><p>Exception 又 有 两 个 分 支 ， <u>运行时异常(非检查异常)</u> RuntimeException ， <u>检查异常</u>CheckedException。</p><ul><li><p>RuntimeException 如 ： NullPointerException 、 ClassCastException ； <u><strong>RuntimeException 是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 如果出现 RuntimeException，那么一定是程序员的错误。</strong></u></p><ul><li>比如除数为 0 错误 ArithmeticException，强制类型转换错误 ClassCastException，数组索引越界ArrayIndexOutOfBoundsException，使用了空对象NullPointerException等等</li></ul></li><li><p>CheckedException如 ： I&#x2F;O 错误导致的 IOException、 SQLException。一般是外部错误，<u>这种异常都发生在编译阶段</u>， **<u>Java 编译器会强制程序去捕获此类异常，即会出现要求你把这段可能出现异常的程序进行 try catch</u>**，该类异常一般包括几个方面：</p><ul><li>试图在文件尾部读取数据</li><li>试图打开一个错误格式的 URL</li><li>试图根据给定的字符串查找 class 对象，而这个字符串表示的类并不存在</li></ul></li></ul></li></ul><h4 id="4-1-3-三种处理方式"><a href="#4-1-3-三种处理方式" class="headerlink" title="4.1.3.三种处理方式"></a>4.1.3.三种处理方式</h4><ul><li>在try-catch中自定义throw错误信息</li><li>throws给上层</li><li>啥也不做，系统默认帮你抛异常</li></ul><h4 id="4-1-4-Throw-和-throws-的区别："><a href="#4-1-4-Throw-和-throws-的区别：" class="headerlink" title="4.1.4. Throw 和 throws 的区别："></a>4.1.4. Throw 和 throws 的区别：</h4><h5 id="位置不同："><a href="#位置不同：" class="headerlink" title="位置不同："></a>位置不同：</h5><pre><code>1. throws 用在方法上，后面跟的是&lt;u&gt;异常类，可以跟多个&lt;/u&gt;； 而 throw 用在函数内，后面跟的是&lt;u&gt;异常对象&lt;/u&gt;。</code></pre><h5 id="功能不同："><a href="#功能不同：" class="headerlink" title="功能不同："></a>功能不同：</h5><ol start="2"><li><p>throws 用来<u><strong>声明异常，让调用者只知道该功能可能出现的问题，可以给出预先的处理方式</strong></u>； throw <u><strong>抛出具体的问题对象，执行到 throw，功能就已经结束了，跳转到调用者，并将具体的问题对象抛给调用者</strong></u>。也就是说 throw 语句独立存在时，下面不要定义其他语句，因为执行不到。</p></li><li><p>🌟throws 表示出现异常的一种<strong>可能性</strong>，并<strong>不一定会发生这些异常</strong>； throw 则是<u>抛出了异常</u>，<u>执行 throw 则一定抛出了某种异常对象。</u></p></li><li><p>两者都是消极处理异常的方式，<u>只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理</u>。</p></li></ol><h4 id="4-1-5-try-cache-finally-与try-with-resources"><a href="#4-1-5-try-cache-finally-与try-with-resources" class="headerlink" title="4.1.5 try-cache-finally 与try-with-resources"></a>4.1.5 try-cache-finally 与try-with-resources</h4><p><code>try-finally</code> 是java SE7之前我们处理一些需要关闭的资源的做法，无论是否出现异常都要对资源进行关闭。</p><p><strong>如果try块和finally块中的方法都抛出异常那么try块中的异常会被抑制（suppress），只会抛出finally中的异常，而把try块的异常完全忽略。</strong></p><p>这里如果我们用<code>catch</code>语句去获得<code>try</code>块的异常，也没有什么影响，<code>catch</code>块虽然能获取到<code>try</code>块的异常但是对函数运行结束抛出的异常并没有什么影响。</p><p>try-with-resources语句能够帮你自动调用资源的close()函数关闭资源不用到finally块。<br>前提是<strong>只有实现了Closeable接口的才能自动关闭</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">(String path, Consumer&lt;String&gt; consumer)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path))) &#123;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span> )&#123;</span><br><span class="line">            consumer.accept(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是<code>try-with-resources</code>语句的结构，在try关键字后面的( )里<code>new</code>一些需要自动关闭的资源。</p><p>这个时候如果方法 <code>readLine</code> 和自动关闭资源的过程都抛出异常，那么：</p><ul><li><strong>函数执行结束之后抛出的是try块的异常</strong>，而try-with-resources语句<u>关闭过程中的异常</u>会被抑制，放在try块抛出的异常的一个数组里。（上面的非try-with-resources例子抛出的是finally的异常，而且try块的异常也不会放在fianlly抛出的异常的抑制数组里）</li><li>可以通过异常的<code>public final synchronized Throwable[] getSuppressed()</code> 方法获得一个被抑制异常的数组。</li><li><code>try</code>块抛出的异常调用<code>getSuppressed()</code>方法获得一个被它抑制的异常的数组，其中就有关闭资源的过程产生的异常。</li></ul><h5 id="try-with-resources-语句能放多个资源-使用-分割"><a href="#try-with-resources-语句能放多个资源-使用-分割" class="headerlink" title="try-with-resources 语句能放多个资源,使用 ; 分割"></a>try-with-resources 语句能放多个资源,使用 <code>;</code> 分割</h5><p>​最后任务执行完毕或者出现异常中断之后是根据<code>new</code>的反向顺序调用各资源的<code>close()</code>的。后<code>new</code>的先关。</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h4 id="4-2-1-反射机制概念"><a href="#4-2-1-反射机制概念" class="headerlink" title="4.2.1.反射机制概念"></a>4.2.1.反射机制概念</h4><p>在 Java 中的反射机制是指<u>在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；</u>并且<u>对于任意一个对象，都能够调用它的任意一个方法</u>；这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制。</p><h4 id="4-2-2-反射的应用场合"><a href="#4-2-2-反射的应用场合" class="headerlink" title="4.2.2. 反射的应用场合"></a>4.2.2. 反射的应用场合</h4><p>🌟：</p><p>​<u>程序在运行时还可能接收到外部传入的对象， 该对象的编译时类型为 Object,但是程序有需要调用该对象的运行时类型的方法</u>。为了解决这些问题， 程序需要在运行时发现对象和类的真实信息。然而，如果编译时根本无法预知该对象和类属于哪些类，程序只能依靠运行时信息来发现该对象和类的真实信息，此时就必须使用到反射了。</p><h4 id="4-2-3-Java-反射"><a href="#4-2-3-Java-反射" class="headerlink" title="4.2.3. Java 反射"></a>4.2.3. Java 反射</h4><p>API反射 API 用来生成 JVM 中的类、接口或则对象的信息。</p><pre><code>1. Class 类：反射的核心类，可以获取类的属性，方法等信息。</code></pre><ol start="2"><li><p>Field 类： Java.lang.reflec 包中的类， 表示类的<u><strong>成员变量</strong></u>，可以用来获取和设置类之中的属性值。</p></li><li><p>Method 类： Java.lang.reflec 包中的类，表示<u><strong>类的方法</strong></u>，它可以用来获取类中的方法信息或者执行方法。</p></li><li><p>Constructor 类： Java.lang.reflec 包中的类，表示<u><strong>类的构造方法</strong></u>。</p></li></ol><h4 id="4-2-4-反射使用步骤（获取-Class-对象、调用对象方法）"><a href="#4-2-4-反射使用步骤（获取-Class-对象、调用对象方法）" class="headerlink" title="4.2.4. 反射使用步骤（获取 Class 对象、调用对象方法）"></a>4.2.4. 反射使用步骤（获取 Class 对象、调用对象方法）</h4><ol><li><p><u>获取想要操作的类的 Class 对象</u>，他是反射的核心，通过 Class 对象我们可以任意调用类的方法。</p></li><li><p><u>调用 Class 类中的方法</u>，既就是反射的使用阶段。</p></li><li><p>使用反射 API 来操作这些信息。</p></li></ol><p>具体使用看java基础</p><p>反射、注解、内部类、泛型、序列化等看javaguide吧</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2023/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h2><h3 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h3><p><strong>参考文章：</strong></p><ul><li><a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">JSON Web Token 入门教程</a></li><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE">透视HTTP协议</a></li><li><a href="https://juejin.cn/post/7064953803564384263">图解|cookie、session、token的那些事儿</a></li></ul><h4 id="HTTP报文格式："><a href="#HTTP报文格式：" class="headerlink" title="HTTP报文格式："></a>HTTP报文格式：</h4><h5 id="HTTP-请求的格式："><a href="#HTTP-请求的格式：" class="headerlink" title="HTTP 请求的格式："></a>HTTP 请求的格式：</h5><ul><li>请求行（Request Line）：</li></ul><p>​        <strong>&lt;请求方法&gt; &lt;目标资源路径&gt; &lt;协议版本&gt;</strong></p><ul><li>请求头（Request Headers）：包含了关于请求的一些附加信息，格式为键值对，每个键值对占据一行。</li></ul><p>​        &lt;键1&gt;: &lt;值1&gt;</p><p>​        &lt;键2&gt;: &lt;值2&gt;</p><p>​        …</p><p>空行（空格 + 回车换行）：</p><p>​        用于分隔请求头和请求体。</p><ul><li>请求体（Request Body）：</li></ul><p>​        可选的，适用于一些特定的请求，如 POST 请求，用于传输用户提交的数据。</p><hr><h5 id="HTTP-响应的格式："><a href="#HTTP-响应的格式：" class="headerlink" title="HTTP 响应的格式："></a>HTTP 响应的格式：</h5><ul><li>状态行（Status Line）：</li></ul><p>​        <strong>&lt;协议版本&gt; &lt;状态码&gt; &lt;状态信息&gt;</strong></p><ul><li>响应头（Response Headers）：</li></ul><p>​        包含了关于响应的一些附加信息，格式为键值对，每个键值对占据一行。</p><p>​        &lt;键1&gt;: &lt;值1&gt;</p><p>​        &lt;键2&gt;: &lt;值2&gt;</p><p>​        …</p><ul><li>空行（空格 + 回车换行）：</li></ul><p>​        用于分隔响应头和响应体。</p><ul><li>响应体（Response Body）：</li></ul><p>​        包含了服务器响应的数据。</p><hr><p>HTTP&#x2F;1.1 里唯一要求必须提供的头字段是 Host，它<strong>必须出现在请求头</strong>里，标记虚拟主机名。</p><h4 id="HTTP请求方法："><a href="#HTTP请求方法：" class="headerlink" title="HTTP请求方法："></a>HTTP请求方法：</h4><p>仅介绍较为常用的四种请求方法：</p><hr><h5 id="GET："><a href="#GET：" class="headerlink" title="GET："></a>GET：</h5><p>​获取资源，可以理解为读取或者下载数据；</p><p>GET的含义是请求<strong>从服务器获取资源</strong>，这个资源既可以是静态的文本、页面、图片、视频，也可以是由 PHP、Java 动态生成的页面或者其他格式的数据。</p><hr><h5 id="HEAD："><a href="#HEAD：" class="headerlink" title="HEAD："></a>HEAD：</h5><p>​<strong>HEAD</strong>方法与 GET 方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，但<u>服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。</u></p><p>​HEAD 方法可以看做是 GET 方法的一个“简化版”或者“轻量版”。因为它的响应头与 GET 完全相同，所以可以用在很多并不真正需要资源的场合，避免传输 body 数据的浪费。</p><p>应用场景：</p><ul><li><p>想要检查一个文件是否存在，只要发个 HEAD 请求就可以了，没有必要用 GET 把整个文件都取下来。</p></li><li><p>要检查文件是否有最新版本，同样也应该用 HEAD，服务器会在响应头里把文件的修改时间传回来。</p></li></ul><hr><h5 id="POST："><a href="#POST：" class="headerlink" title="POST："></a>POST：</h5><p>​只要向服务器发送数据，用的大多数都是 POST。</p><hr><h5 id="PUT："><a href="#PUT：" class="headerlink" title="PUT："></a>PUT：</h5><p>​PUT 的作用与 POST 类似，也可以向服务器提交数据，但与 POST 存在微妙的不同，通常 POST 表示的是“新建”“create”的含义，而 PUT 则是“修改”“update”的含义。</p><p>​在实际应用中，PUT 用到的比较少。而且<u>，因为它与 POST 的语义、功能太过近似，有的服务器甚至就直接禁止使用 PUT 方法，只用 POST 方法上传数据。</u></p><h4 id="HTTP-URI和URL："><a href="#HTTP-URI和URL：" class="headerlink" title="HTTP URI和URL："></a>HTTP URI和URL：</h4><p>URI（<strong>U</strong>niform <strong>R</strong>esource <strong>I</strong>dentifier）：<strong>统一资源标识符</strong></p><p>URI有两种实现方式：URL和URN</p><p>URL &#x3D; Uniform Resource Locator 统一资源定位符</p><ul><li>以**<u>位置</u>**定位资源</li></ul><p>URN &#x3D; Uniform Resource Name 统一资源名称</p><ul><li>以**<u>名称定</u>**位资源</li></ul><h5 id="URI基本组成："><a href="#URI基本组成：" class="headerlink" title="URI基本组成："></a>URI基本组成：</h5><p>scheme:&#x2F;&#x2F;authority紧跟着path?query</p><ul><li><p>scheme：表示协议名称</p></li><li><p>authority：资源所在的主机名(或域名) + 端口号(如果要使用协议的默认端口，则端口号可以省略)</p></li><li><p>path：标记资源所在的位置的路径，<strong>以&#x2F;开头</strong></p></li><li><p>query：多个<strong>key&#x3D;value</strong>的键值对形式，键值对间使用&amp;分隔</p></li></ul><p>🌟在 URI 里对“@&amp;&#x2F;”等特殊字符和汉字必须要做编码，否则服务器收到 HTTP 报文后会无法正确处理。</p><h4 id="HTTP响应码-状态码-："><a href="#HTTP响应码-状态码-：" class="headerlink" title="HTTP响应码(状态码)："></a>HTTP响应码(状态码)：</h4><p><a href="https://tsejx.github.io/javascript-guidebook/computer-networks/http/http-status-code/">详细状态码记录</a></p><ul><li><p>1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；</p></li><li><p>2××：成功，报文已经收到并被正确处理；</p><ul><li>200 OK：表示请求成功，服务器成功处理了请求。</li></ul></li><li><p>3××：重定向，资源位置发生变动，需要客户端重新发送请求；</p><ul><li><p>301 Moved Permanently：永久重定向，表示请求的资源已经被移动到了新的URL。</p></li><li><p>302 Found：临时重定向，表示请求的资源暂时被移动到了新的URL。</p></li></ul></li><li><p>4××：客户端错误，请求报文有误，服务器无法处理；</p><ul><li>400 Bad Request：表示客户端的请求语法错误或无效，服务器无法理解。</li><li>401 Unauthorized：表示请求需要身份验证，客户端需要提供有效的凭据。</li><li>403 Forbidden：表示服务器理解请求，但拒绝执行，客户端没有访问权限。</li><li>404 Not Found：表示服务器无法找到请求的资源。</li></ul></li><li><p>5××：服务器错误，服务器在处理请求时内部发生了错误。</p><ul><li><p>500 Internal Server Error：表示服务器内部错误，无法完成请求。</p></li><li><p>502 Bad Gateway是指作为代理或网关的服务器从上游服务器接收到一个无效的响应，导致无法完成请求。</p></li><li><p>503 Service Unavailable：表示服务器暂时无法处理请求，通常是由于服务器过载或维护。</p></li></ul></li></ul><h4 id="HTTP连接："><a href="#HTTP连接：" class="headerlink" title="HTTP连接："></a>HTTP连接：</h4><h5 id="短连接："><a href="#短连接：" class="headerlink" title="短连接："></a>短连接：</h5><p>​每次发送请求前需要先与服务器建立连接，收到响应报文后会立即关闭连接。</p><p>​建立、关闭连接消耗大，效率低！</p><h5 id="长连接："><a href="#长连接：" class="headerlink" title="长连接："></a>长连接：</h5><p>​一个连接执行多个请求</p><p>​通过设置过期时间(多少时长内未收到请求，则关闭连接)、设置<code>最大请求执行次数</code>来关闭连接，<u>防止过多的空闲长连接占用服务器资源。</u></p><h5 id="队头阻塞问题："><a href="#队头阻塞问题：" class="headerlink" title="队头阻塞问题："></a>队头阻塞问题：</h5><p>​长连接将其要执行的任务从任务队列中取出依次执行，如果正在执行的请求长时间不能执行成功，这会导致后面排队的请求长时间等待，这是我们不希望发生的。</p><p>​对策：</p><pre><code>每个请求都建立多个长连接，防止单一长连接如果阻塞导致效率低(每个请求都发送到多个长连接中，会导致服务器压力过大，不是个好办法)通过域名分片，将服务器上的资源分类后分散到不同的子服务器中，分摊请求的负担。</code></pre><h4 id="HTTP状态："><a href="#HTTP状态：" class="headerlink" title="HTTP状态："></a>HTTP状态：</h4><h5 id="登录一个页面，服务器怎么知道你是谁？"><a href="#登录一个页面，服务器怎么知道你是谁？" class="headerlink" title="登录一个页面，服务器怎么知道你是谁？"></a>登录一个页面，服务器怎么知道你是谁？</h5><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie:"></a>Cookie:</h5><p>​常用于保存一些让服务器辨识的信息，从而使服务器认识客户端</p><h6 id="Cookie由浏览器维护，常见存储方式："><a href="#Cookie由浏览器维护，常见存储方式：" class="headerlink" title="Cookie由浏览器维护，常见存储方式："></a>Cookie由浏览器维护，常见存储方式：</h6><ul><li>内存存储——非持久化存储</li><li>磁盘存储——持久化存储</li></ul><p>服务器发送Set-Cookie命令，客户端按要求创建Cookie，之后每次访问该服务器都携带Cookie信息，以便于让服务器辨识。</p><h6 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h6><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><p>​Cookie中信息为明文，容易产生安全问题。</p><h5 id="Session"><a href="#Session" class="headerlink" title="Session:"></a>Session:</h5><p>​Session机制将用户的所有活动信息、上下文信息、登录<strong>信息等都存储在服务端</strong>，只是<u>生成一个唯一标识ID发送给客户端，后续的交互将没有重复的用户信息传输，取而代之的是唯一标识ID</u>，暂且称之为Session-ID吧。</p><p>​当浏览器下次请求别的资源的时候，<u>浏览器会将sessionID放置到请求头中，服务器接收到请求后解析得到sessionID，服务器找到该id的session来确定请求方的身份和一些上下文信息</u>。</p><p>​这个sessionID可以放在Cookie中传输，Session与Cookie之间的关系仅此而已。</p><p>​<strong>如果浏览器被禁用了Cookie</strong>，服务端还可以直接将sessionID附加在URL后<u>作为参数传输</u>。—-<strong>URL重写</strong></p><h6 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h6><ul><li>海量用户的巨大存储压力</li><li>分布式系统中信息共享问题</li><li>每个用户的信息存储在服务器，不可避免存在一些 分布式系统的常见的问题</li></ul><h5 id="Token"><a href="#Token" class="headerlink" title="Token:"></a>Token:</h5><p>​Token是令牌的意思，由服务端生成并发放给客户端，是具有时效性的一种验证身份的手段。</p><p>Token避免了Session机制带来的海量信息存储问题，也避免了Cookie机制的一些安全性问题，属于典型的时间换空间的思路。在现代移动互联网场景、跨域访问等场景有广泛的用途。</p><p>​常使用 **JWT ** (<strong>JSON Web Token</strong>)</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20231007152733214.png" alt="image-20231007152733214"></p><h6 id="Token设计："><a href="#Token设计：" class="headerlink" title="Token设计："></a>Token设计：</h6><p>​<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20231007153219035.png" alt="image-20231007153219035"></p><ul><li>Header：<ul><li>令牌头：存放令牌类型、使用的签名(加密)算法</li></ul></li><li>Payload：<ul><li>负载：存放真正需要向服务端传递的信息——（针对认证问题，负载至少应该包含能够告知服务端“这个用户是谁”的信息，针对授权问题，令牌至少应该包含能够告知服务端“这个用户拥有什么角色&#x2F;权限”的信息。）<ul><li>iss（Issuer）：签发人。</li><li>exp（Expiration Time）：令牌过期时间。</li><li>sub（Subject）：主题。</li><li>aud （Audience）：令牌受众。</li><li>nbf （Not Before）：令牌生效时间。</li><li>iat （Issued At）：令牌签发时间。</li><li>jti （JWT ID）：令牌编号。</li><li>还可以放一些自定义信息</li><li>⚠️JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分</li></ul></li></ul></li><li><strong>Signature</strong>：<ul><li>签名：对上述的 (Header以及Payload) 根据header中指定的签名算法 与密钥进行签名运算得到的结果。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> + base64UrlEncode(payload) , secret)</span><br><span class="line"><span class="comment">//HMACSHA256为一种签名算法</span></span><br></pre></td></tr></table></figure><p>header和payload的信息不做加密，只做一般的base64编码</p><p><strong>客户端第一次请求服务器</strong>：未携带Token，服务端根据客户端传来的信息进行身份认证，若验证成功，则生成Token发回给用户使用。</p><p><strong>客户端携带Token后请求服务器</strong>：服务端收到token后剥离出header和payload获取算法、用户、过期时间等信息，然后根据自己的加密密钥来生成signature，并与客户端的sign进行一致性验证。</p><p>这样就实现了用CPU加解密的时间换取存储空间，干净利落，同时<strong>服务端密钥</strong>的重要性就显而易见，一旦泄露整个机制就崩塌了，这个时候就需要考虑HTTPS了。</p><h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><ul><li>Token可以跨站共享，实现单点登录</li><li>Token机制无需太多存储空间，Token包含了用户的信息，只需在客户端存储状态信息即可，对于服务端的扩展性很好</li><li>Token机制的安全性依赖于服务端加密算法和密钥的安全性</li></ul><h6 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h6><ul><li>安全性隐患：如果Token被泄露或者被劫持，攻击者可能会利用Token来冒充用户或者进行非法操作。为了减少这种风险，需要采取适当的加密和保护措施，例如使用HTTPS进行通信以及使用安全的Token存储和传输方式。</li><li><strong>难以撤销和失效</strong>：一旦Token被颁发，除非过期时间到期或者手动撤销，否则Token将一直有效。这可能导致一些安全问题，特别是在Token被偷窃或者用户权限需要立即撤销的情况下。</li><li>难以管理和维护：在大规模系统中，需要对大量的Token进行管理和维护。这可能包括Token颁发、撤销和更新等操作，需要投入相应的资源和工具进行管理，以确保系统的安全性和可靠性。</li><li>性能问题：Token验证可能需要进行密钥解密、签名验证和状态检查等操作，这些操作可能会增加系统的负载并且消耗一定的计算资源。特别是在高并发的情况下，可能会对性能产生一定影响。</li></ul><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>​Session方式将用户的身份信息存放于服务端数据库中，不可避免会带来分布式问题，而Token通过服务器使用自己私有的密钥来对用户信息进行加密生成Token给客户端，通过对客户端发来的Token进行再次运算(检查收到的和算出的签名是否一致)来判断该Token是否有效，即用户是否有权限，避免了使用分布式数据库。</p><h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS:"></a>HTTPS:</h4><p>参考文章：</p><ul><li><a href="https://xiaolincoding.com/network/2_http/https_rsa.html#_3-3-https-rsa-%E6%8F%A1%E6%89%8B%E8%A7%A3%E6%9E%90">HTTPS RSA 握手解析</a></li></ul><p>​由于HTTP协议在传输信息时有以下三个问题：<u>数据遭受监听</u>、<u>数据易被篡改</u>、<u>易被冒充</u></p><p>所以可以在HTTP与TCP之间加入TLS协议，来解决上述问题。HTTPS &#x3D; 有TLS保障的HTTP</p><h5 id="TLS-协议是如何解决-HTTP-的风险的呢？"><a href="#TLS-协议是如何解决-HTTP-的风险的呢？" class="headerlink" title="TLS 协议是如何解决 HTTP 的风险的呢？"></a>TLS 协议是如何解决 HTTP 的风险的呢？</h5><ul><li><em>信息加密</em>： HTTP 交互信息是被加密的，第三方就无法被窃取；</li><li><em>校验机制</em>：校验信息传输过程中是否有被第三方篡改过，如果被篡改过，则会有警告提示；</li><li><em>身份证书</em>：证明淘宝是真的淘宝网；</li></ul><p>TLS协议一般使用RSA算法实现密钥交换，简而言之：</p><p>​客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。</p><h5 id="具体流程图示🌟："><a href="#具体流程图示🌟：" class="headerlink" title="具体流程图示🌟："></a>具体流程图示🌟：</h5><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20231009150718081.png" alt="image-20231009150718081"></p><p>pre-master : 客户端密钥</p><h5 id="什么是数字证书，证书中有什么？"><a href="#什么是数字证书，证书中有什么？" class="headerlink" title="什么是数字证书，证书中有什么？"></a>什么是数字证书，证书中有什么？</h5><ul><li>公钥；</li><li>持有者信息；</li><li>证书认证机构（CA）的信息；</li><li>CA 对这份文件的数字签名及使用的算法；</li><li>证书有效期；</li><li>还有一些其他额外信息；</li></ul><p>​数字证书的作用，是用来认证公钥持有者的身份，以防止第三方进行冒充。说简单些，证书就是用来告诉客户端，该服务端是否是合法的，因为只有证书合法，才代表服务端身份是可信的。</p><h4 id="HTTP版本："><a href="#HTTP版本：" class="headerlink" title="HTTP版本："></a>HTTP版本：</h4><p>参考文章：</p><ul><li><a href="https://xiaolincoding.com/network/2_http/http2.html#_3-6-http-2-%E7%89%9B%E9%80%BC%E5%9C%A8%E5%93%AA">http-2-牛逼在哪</a></li><li><a href="https://xiaolincoding.com/network/2_http/http3.html#_3-7-http-3-%E5%BC%BA%E5%8A%BF%E6%9D%A5%E8%A2%AD">http-3-强势来袭</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20231018151006871.png" alt="image-20231018151006871"></p><h5 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2:"></a>HTTP2:</h5><ul><li>第一点，对于常见的 HTTP 头部通过<strong>静态表和 Huffman 编码</strong>的方式，将体积压缩了近一半，而且针对后续的请求头部，还可以建立<strong>动态表</strong>，将体积压缩近 90%，大大提高了编码效率，同时节约了带宽资源。</li></ul><p>​不过，动态表并非可以无限增大， 因为动态表是会占用内存的，动态表越大，内存也越大，容易影响服务器总体的并发能力，因此服务器需要限制 HTTP&#x2F;2 连接时长或者请求次数。</p><ul><li>第二点，<strong>HTTP&#x2F;2 实现了 Stream 并发</strong>，多个 Stream 只需复用 1 个 TCP 连接，节约了 TCP 和 TLS 握手时间，以及减少了 TCP 慢启动阶段对流量的影响。不同的 Stream ID 可以并发，即使乱序发送帧也没问题，比如发送 A 请求帧 1 -&gt; B 请求帧 1 -&gt; A 请求帧 2 -&gt; B 请求帧2，但是同一个 Stream 里的帧必须严格有序。</li></ul><p>​另外，可以根据资源的渲染顺序来设置 Stream 的<strong>优先级</strong>，从而提高用户体验。</p><ul><li>第三点，<strong>服务器支持主动推送资源</strong>，大大提升了消息的传输性能，服务器推送资源时，会先发送 PUSH_PROMISE 帧，告诉客户端接下来在哪个 Stream 发送资源，然后用偶数号 Stream 发送资源给客户端。</li></ul><p>​HTTP&#x2F;2 通过 Stream 的并发能力，解决了 HTTP&#x2F;1 队头阻塞的问题，看似很完美了，但是 HTTP&#x2F;2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。</p><p>​<strong>HTTP&#x2F;2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP&#x2F;2 应用层才能从内核中拿到数据，这就是 HTTP&#x2F;2 队头阻塞问题。</strong></p><p>​</p><h5 id="HTTP-x2F-3："><a href="#HTTP-x2F-3：" class="headerlink" title="HTTP&#x2F;3："></a>HTTP&#x2F;3：</h5><p>HTTP&#x2F;2 虽然具有多个流并发传输的能力，但是传输层是 TCP 协议，于是存在以下缺陷：</p><ul><li><strong>队头阻塞</strong>，HTTP&#x2F;2 多个请求跑在一个 TCP 连接中，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据，从 HTTP 视角看，就是多个请求被阻塞了；</li><li><strong>TCP 和 TLS 握手时延</strong>，TCP 三次握手和 TLS 四次握手，共有 3-RTT 的时延；</li><li><strong>连接迁移需要重新连接</strong>，移动设备从 4G 网络环境切换到 WiFi 时，由于 TCP 是基于四元组来确认一条 TCP 连接的，那么网络环境变化后，就会导致 IP 地址或端口变化，于是 TCP 只能断开连接，然后再重新建立连接，切换网络环境的成本高；</li></ul><p>HTTP&#x2F;3 就将传输层从 TCP 替换成了 UDP，并在 UDP 协议上开发了 QUIC 协议，来保证数据的可靠传输。</p><p>QUIC 协议的特点：</p><ul><li><strong>无队头阻塞</strong>，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，也不会有底层协议限制，某个流发生丢包了，只会影响该流，其他流不受影响；</li><li><strong>建立连接速度快</strong>，因为 QUIC 内部包含 TLS 1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与 TLS 密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</li><li><strong>连接迁移</strong>，QUIC 协议没有用四元组的方式来“绑定”连接，而是通过「连接 ID 」来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本；</li></ul><h3 id="DNS协议："><a href="#DNS协议：" class="headerlink" title="DNS协议："></a>DNS协议：</h3><p>参考文章：</p><ul><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/06%20%20%E5%9F%9F%E5%90%8D%E9%87%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E9%97%A8%E9%81%93%EF%BC%9F.md">域名里有哪些门道？</a></li><li><a href="https://juejin.cn/post/7035659937166393375">DNS面试也会问，赶紧来看看</a></li></ul><p>​域名 &lt;&#x3D;&#x3D;&#x3D;&gt; ip地址的映射表</p><h4 id="域名服务器的层级："><a href="#域名服务器的层级：" class="headerlink" title="域名服务器的层级："></a>域名服务器的层级：</h4><h5 id="根域名服务器（Root-DNS-Server）："><a href="#根域名服务器（Root-DNS-Server）：" class="headerlink" title="根域名服务器（Root DNS Server）："></a>根域名服务器（Root DNS Server）：</h5><p>​管理顶级域名服务器，返回“com”、“net”、“cn”等顶级域名服务器的 IP 地址；</p><h5 id="顶级域名服务器（Top-level-DNS-Server）："><a href="#顶级域名服务器（Top-level-DNS-Server）：" class="headerlink" title="顶级域名服务器（Top-level DNS Server）："></a>顶级域名服务器（Top-level DNS Server）：</h5><p>​管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；</p><h5 id="权威域名服务器（Authoritative-DNS-Server）："><a href="#权威域名服务器（Authoritative-DNS-Server）：" class="headerlink" title="权威域名服务器（Authoritative DNS Server）："></a>权威域名服务器（Authoritative DNS Server）：</h5><p>​管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 <a href="http://www.apple.com/">www.apple.com</a> 的 IP 地址。</p><p>对于一段域名：最右边的被称为“顶级域名”，然后是“二级域名”，层级关系向左依次降低。</p><p>如果你要访问“<a href="http://www.apple.com”，就要进行下面的三次查询：">www.apple.com”，就要进行下面的三次查询：</a></p><ol><li><p>访问根域名服务器，在其中可以查询到“com”顶级域名服务器的地址；</p><ul><li><p>所有域名都是 <code>根域名</code> 的 <code>子域名</code>，根域名为 <code>.root</code>，一般简写为 <code>.</code>  但是所有域名的根域名都是一样的，所以我们一般都省略根域名不写，DNS解析时计算机会自动为我们加上根域名。</p><p>例如:  <code>www.baidu.com</code> 的完整域名应该是 <code>www.baidu.com.</code> 或者 <code>www.baidu.com.root</code></p></li></ul></li><li><p>访问“com”顶级域名服务器，可以查询到“apple.com”域名服务器的地址；</p></li><li><p>最后访问“apple.com”域名服务器，就得到了“<a href="http://www.apple.com”的地址!/">www.apple.com”的地址！</a></p></li></ol><ul><li>许多大公司、网络运行商都会建立自己的 DNS 服务器，作为用户 DNS 查询的代理，代替用户访问核心 DNS 系统。这些“野生”服务器被称为“非权威域名服务器”，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址。</li><li>计算机操作系统也会对DNS查询的结果进行缓存，以提升查询效率</li><li>操作系统里还有一个特殊的“主机映射”文件，通常是一个可编辑的文本，在 Linux 里是“&#x2F;etc&#x2F;hosts”，在 Windows 里是“C:\WINDOWS\system32\drivers\etc\hosts”，如果操作系统在缓存里找不到 DNS 记录，就会找这个文件。</li></ul><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20231116092454845.png" alt="image-20231116092454845" style="zoom:50%;" /><h4 id="域名的应用："><a href="#域名的应用：" class="headerlink" title="域名的应用："></a>域名的应用：</h4><ol><li>“重定向“，可用于系统维护时切换ip，让同一域名指向不同的主机，保证服务的连续性。</li><li>用域名进行开发，各种服务的ip不用写死</li><li>负载均衡</li></ol><h4 id="迭代查询："><a href="#迭代查询：" class="headerlink" title="迭代查询："></a>迭代查询：</h4><p>迭代查询的过程其实就是：当域名服务器收到迭代查询请求报文时，需求给出主机“你下一步应当向哪一个域名服务器进行查询”的建议，然后由主机进行下一步的查询，当返回内容即没有确切的结果也没有下一步的建议时，DNS失败。</p><h4 id="递归查询："><a href="#递归查询：" class="headerlink" title="递归查询："></a>递归查询：</h4><p>所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的 <code>IP地址</code>，那么本地域名服务器就以 <code>DNS</code> 客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果是所要查询的 <code>IP地址</code> ，或者是报错，表示无法查询到所需的 <code>IP地址</code>。</p><h4 id="🌟DNS查询的完整过程是怎么样的？"><a href="#🌟DNS查询的完整过程是怎么样的？" class="headerlink" title="🌟DNS查询的完整过程是怎么样的？"></a>🌟DNS查询的完整过程是怎么样的？</h4><ol><li>浏览器将会检查缓存中有没有这个域名对应的解析过的 IP 地址，如果有该解析过程将会结束。浏览器缓存域名也是有限制的，包括缓存的时间、大小，可以通过 TTL 属性来设置。</li><li>如果用户的浏览器中缓存中没有，操作系统会先检查自己本地的 DNS 解析器缓存和 hosts 文件是否有这个网址映射关系，如果有，就先调用这个 IP 地址映射，完成域名解析。</li><li>如果都没有，会找 TCP&#x2F;IP 参数中设置的首选 DNS 服务器，我们叫它本地 DNS 服务器。通过递归查询的方式向本地 DNS 服务器发起查询，如果本地 DNS 服务器中有 A记录 或者该域名的映射缓存，则返回</li><li>如果都没有，本地域名服务器会开始迭代查询的过程，会先向 13 台根域名服务器查询该域名，根域名服务器会返回该域名的顶级域名服务器的 IP 地址，也就是 NS 记录。然后本地域名服务器再向顶级域名服务器发起查询，顶级域名服务器返回二级域名服务器的 NS 记录，重复这个过程直到返回 A 记录为止，最后把 A 记录中的 IP 地址返回给主机</li></ol><h3 id="RPC-远程调用-："><a href="#RPC-远程调用-：" class="headerlink" title="RPC(远程调用)："></a>RPC(远程调用)：</h3><p>参考资料：</p><ul><li><p><a href="https://xiaolincoding.com/network/2_http/http_rpc.html#_3-8-%E6%97%A2%E7%84%B6%E6%9C%89-http-%E5%8D%8F%E8%AE%AE-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89-rpc">既然有 HTTP 协议，为什么还要有 RPC？</a></p></li><li><p>纯裸 TCP 是能收发数据，但它是个<strong>无边界</strong>的数据流，上层需要定义<strong>消息格式</strong>用于定义<strong>消息边界</strong>。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。</p></li><li><p><strong>RPC 本质上不算是协议，而是一种调用方式</strong>，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，<strong>不一定非得基于 TCP 协议</strong>。</p></li><li><p>从发展历史来说，<strong>HTTP 主要用于 B&#x2F;S 架构，而 RPC 更多用于 C&#x2F;S 架构。但现在其实已经没分那么清了，B&#x2F;S 和 C&#x2F;S 在慢慢融合</strong>。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。</p></li><li><p>RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP&#x2F;1.1 <strong>性能</strong>要更好，所以大部分公司内部都还在使用 RPC。</p></li><li><p><strong>HTTP&#x2F;2.0</strong> 在 <strong>HTTP&#x2F;1.1</strong> 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。</p></li></ul><p>​</p><h2 id="传输层："><a href="#传输层：" class="headerlink" title="传输层："></a>传输层：</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP:"></a>TCP:</h3><p>​</p><h2 id="网络层："><a href="#网络层：" class="headerlink" title="网络层："></a>网络层：</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL原理学习</title>
      <link href="/2023/07/27/MySQL%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/07/27/MySQL%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL原理"><a href="#MySQL原理" class="headerlink" title="MySQL原理"></a>MySQL原理</h1><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728105935995.png" alt="image-20230728105935995"></p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h3><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728111959688.png" alt="image-20230728111959688" style="zoom: 67%;" /><h4 id="MySQL服务器逻辑架构："><a href="#MySQL服务器逻辑架构：" class="headerlink" title="MySQL服务器逻辑架构："></a>MySQL服务器逻辑架构：</h4><ul><li>最上层的服务并不是 MySQL 所独有的，大多数基于网络的客户端&#x2F;服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。</li><li>第二层架构是 MySQL 比较有意思的部分。大多数 MySQL 的核心服务功能都在这一层，包括<strong>查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数）</strong>，所有跨存储引擎的功能都在这一层实现：<strong>存储过程、触发器、视图</strong>等。</li><li>第三层包含了存储引擎。存储引擎负责 MySQL 中数据的存储和提取。和 GNU&#x2F;Linux 下的各种文件系统一样，每个存储引擎都有它的优势和劣势。<strong>服务器通过 API 与存储引擎进行通信。这些接口屏蔽了不同存储引擎之问的差异，使得这些差异对上层的查询过程透明</strong>。存储引擎API包合几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行记录” 等操作。但存储引擎不会去解析 SQL，不同存储引擎之间也不会相互通信，而只是简单地响应上层服务器的请求。</li></ul><h4 id="连接管理与安全性"><a href="#连接管理与安全性" class="headerlink" title="连接管理与安全性"></a>连接管理与安全性</h4><ul><li><u>每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行</u>，该线程只能轮流在服务器的CPU中运行。</li><li>客户端连接到服务器时，服务器对其进行认证(用户名、主机信息、密码)，认证成功后进一步验证该客户端是否具有执行某个查询的权限</li></ul><h4 id="优化与执行"><a href="#优化与执行" class="headerlink" title="优化与执行"></a>优化与执行</h4><ul><li>MysQL会<strong>解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适索引等</strong>。用户可以通过特殊的关键宇提示(hint） 优化器，影响它的决策过程。也可以请求优化器解释 (explain）优化过程的各个因素，使用户可以知道服务器是如何进行优化决策的，并提供一个参考基准，便于用戶重构查询和 schetna、修改相关配置，使应用尽可能高效运行。</li><li>优化器并不关心表使用的是什么存储引擎，但存储引擎对于优化查询是有影响的。优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等。例如，某些存储引擎的某种索引，可能对一些特定的查询有优化。</li><li>对于 SELECT 语向，在解析查询之前，服务器会先检查查询缓存 (Query Cache)，<strong>如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集</strong>。</li></ul><h3 id="一条SQL的执行过程"><a href="#一条SQL的执行过程" class="headerlink" title="一条SQL的执行过程"></a>一条SQL的执行过程</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728122544760.png" alt="image-20230728122544760"></p><p>MySQL执行SQL查询的流程图⬆️：</p><p>可以看到， MySQL 的架构共分为两层：<strong>Server 层和存储引擎层</strong>，</p><ul><li>**Server 层负责<u>建立连接、分析和执行 SQL</u> **。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。</li><li><strong>存储引擎层负责数据的存储和提取</strong>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。</li></ul><p>好了，现在我们对 Server 层和存储引擎层有了一个简单认识，接下来，就详细说一条 SQL 查询语句的执行流程，依次看看每一个功能模块的作用。</p><h4 id="Step1-连接器"><a href="#Step1-连接器" class="headerlink" title="Step1: 连接器"></a>Step1: 连接器</h4><p>服务器(通常，我们的日常学习中，使用本机提供mysql服务，所以也需要在本机启动mysql)启动MySQL后，用户端连接MySQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># -h 指定 MySQL 服务得 IP 地址，如果是连接本地的 MySQL服务，可以不用这个参数；</span><br><span class="line"># -u 指定用户名，管理员角色名为 root；</span><br><span class="line"># -p 指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里面输入密码</span><br><span class="line">mysql -h$ip -u$user -p</span><br></pre></td></tr></table></figure><ol><li><p><strong>服务器未启动mysql</strong>：连接的过程需要先经过 TCP 三次握手，因为 **<u>MySQL 是基于 TCP 协议进行传输的</u>**，如果 <strong>MySQL 服务并没有启动</strong>，则会收到报错</p></li><li><p><strong>客户端用户名&#x2F;密码错误</strong>：如果 MySQL 服务正常运行，完成 TCP 连接的建立后，连接器就要开始验证你的用户名和密码，如果用户名或密码不对，就收到一个”Access denied for user”的错误，然后客户端程序结束执行。</p></li></ol><p>🌟<strong>如果用户密码都没有问题，连接器就会获取该用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断。所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</strong>——用户信息修改后，本次连接不生效，需重新连接</p><h5 id="如何查看-MySQL-服务被多少个客户端连接了？"><a href="#如何查看-MySQL-服务被多少个客户端连接了？" class="headerlink" title="如何查看 MySQL 服务被多少个客户端连接了？"></a>如何查看 MySQL 服务被多少个客户端连接了？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show processlist;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728123837566.png" alt="image-20230728123837566" style="zoom:50%;" /><h5 id="空闲连接会一直占用着吗？"><a href="#空闲连接会一直占用着吗？" class="headerlink" title="空闲连接会一直占用着吗？"></a>空闲连接会一直占用着吗？</h5><p>不会，MySQL 定义了空闲连接的最大空闲时长，由 <strong>wait_timeout 参数控制</strong>的，默认值是 8 小时（28880秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。</p><p>我们自己也可以手动断开空闲的连接，使用的是 kill connection + id 的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; kill connection +6;</span><br></pre></td></tr></table></figure><p>一个处于空闲状态的连接被服务端主动断开后，<strong>这个客户端并不会马上知道</strong>，等到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”</p><h5 id="MySQL-的连接数有限制吗？"><a href="#MySQL-的连接数有限制吗？" class="headerlink" title="MySQL 的连接数有限制吗？"></a>MySQL 的连接数有限制吗？</h5><p><u>MySQL 服务支持的最大连接数由 max_connections 参数控制</u>，比如我的 MySQL 服务默认是 151 个,超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。</p><h5 id="MySQL-短连接和长连接："><a href="#MySQL-短连接和长连接：" class="headerlink" title="MySQL 短连接和长连接："></a>MySQL 短连接和长连接：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 短连接</span><br><span class="line">连接 mysql 服务（TCP 三次握手）</span><br><span class="line">执行sql</span><br><span class="line">断开 mysql 服务（TCP 四次挥手）</span><br><span class="line"></span><br><span class="line">// 长连接</span><br><span class="line">连接 mysql 服务（TCP 三次握手）</span><br><span class="line">执行sql</span><br><span class="line">执行sql</span><br><span class="line">执行sql</span><br><span class="line">....</span><br><span class="line">断开 mysql 服务（TCP 四次挥手）</span><br></pre></td></tr></table></figure><p>可以看到，使用<strong>长连接</strong>的好处就是可以<strong>减少建立连接和断开连接的过程</strong>，所以一般是推荐使用长连接。</p><p>但是，<u>使用长连接后可能会占用内存增多</u>，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，<u>这些连接对象资源只有在连接断开时才会释放</u>。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象。</p><h5 id="怎么解决长连接占用内存的问题？"><a href="#怎么解决长连接占用内存的问题？" class="headerlink" title="怎么解决长连接占用内存的问题？"></a>怎么解决长连接占用内存的问题？</h5><p>第一种，<strong>定期断开长连接</strong>。既然断开连接后就会释放连接占用的内存资源，那么我们可以定期断开长连接。</p><p>第二种，<strong>客户端主动重置连接</strong>。MySQL 5.7 版本实现了 mysql_reset_connection() 函数的接口，注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。👍</p><h5 id="连接器工作总结："><a href="#连接器工作总结：" class="headerlink" title="连接器工作总结："></a>连接器工作总结：</h5><ul><li>与客户端进行 TCP 三次握手建立<strong>连接</strong>；</li><li><strong>校验客户端的用户名和密码</strong>，如果用户名或密码不对，则会报错；</li><li>如果用户名和密码都对了，会<strong>读取该用户的权限</strong>，然后后面的权限逻辑判断都基于此时读取到的权限；</li></ul><h4 id="Step2-查询缓存"><a href="#Step2-查询缓存" class="headerlink" title="Step2: 查询缓存"></a>Step2: 查询缓存</h4><p>MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段，看看是什么类型的语句。</p><p>如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，<strong>这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。</strong></p><p>但是查询缓存被命中的几率很低，基本不会命中，因此 MySQL 8.0 开始(被移除了)，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了。</p><p>对于 MySQL 8.0 之前的版本，如果想关闭查询缓存，我们可以通过将参数 query_cache_type 设置成 DEMAND。</p><h4 id="Step3-解析SQL"><a href="#Step3-解析SQL" class="headerlink" title="Step3: 解析SQL"></a>Step3: 解析SQL</h4><p>在正式执行 SQL 查询语句之前， MySQL 会先<strong>对 SQL 语句做解析</strong>，这个工作交由「解析器」来完成。</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="解析器："><a href="#解析器：" class="headerlink" title="解析器："></a>解析器：</h5><ul><li><p><strong>词法分析</strong>。MySQL 会根据你输入的字符串<strong>识别出关键字</strong>出来，构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。</p></li><li><p><strong>语法分析</strong>。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p></li></ul><p><u>如果我们输入的 SQL 语句语法不对，就会在解析器这个阶段报错</u>。比如，我下面这条查询语句，把 from 写成了 form，这时 MySQL 解析器就会给报错。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF.png" alt="img"></p><p>⚠️但是注意，<strong>表不存在或者字段不存在，并不是在解析器里做的</strong></p><h4 id="Step4-执行SQL"><a href="#Step4-执行SQL" class="headerlink" title="Step4: 执行SQL"></a>Step4: 执行SQL</h4><p>​经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条<strong>SELECT 查询语句</strong>流程主要可以分为下面这三个阶段：</p><ul><li>prepare 阶段，也就是<strong>预处理阶段；</strong></li><li>optimize 阶段，也就是<strong>优化阶段；</strong></li><li>execute 阶段，也就是<strong>执行阶段；</strong></li></ul><h5 id="🌟预处理阶段："><a href="#🌟预处理阶段：" class="headerlink" title="🌟预处理阶段："></a>🌟预处理阶段：</h5><p>预处理器主要进行如下操作：</p><ol><li><p><strong>检查 SQL 查询语句中的表或者字段是否存在；</strong></p></li><li><p>将 select * 中的 * 符号，扩展为表上的所有列；</p></li></ol><h5 id="🌟优化阶段："><a href="#🌟优化阶段：" class="headerlink" title="🌟优化阶段："></a>🌟优化阶段：</h5><p>优化器主要进行如下操作：</p><p>​<strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</p><p>要想知道优化器选择了哪个索引，我们可以在查询语句最前面加个 explain 命令，这样就会输出这条 SQL 语句的执行计划，然后执行计划中的 key 就表示执行过程中使用了哪个索引</p><h5 id="🌟执行阶段："><a href="#🌟执行阶段：" class="headerlink" title="🌟执行阶段："></a>🌟执行阶段：</h5><p>执行器主要进行如下操作：</p><p><strong>执行前要对操作用户的权限进行判断！</strong></p><p><strong>执行器将与存储引擎交互，执行SQL语句(交互是以记录为单位的)</strong></p><p>​共有三种执行方式：</p><ol><li><strong>主键索引查询</strong></li></ol><p>​根据主键字段的值来查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>​这条查询语句的查询条件用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用访问类型为 const 进行查询，也就是使用主键索引查询一条记录，那么执行器与存储引擎的执行流程是这样的：</p><ul><li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 id &#x3D; 1 交给存储引擎，<strong>让存储引擎定位符合条件的第一条记录</strong>。</li><li>存储引擎通过主键索引的 B+ 树结构定位到 id &#x3D; 1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；</li><li>执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。</li><li>执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。</li></ul><p>至此，这个语句就执行完成了。</p><ol start="2"><li><strong>全表扫描</strong></li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from product where name = &#x27;iphone&#x27;;</span><br></pre></td></tr></table></figure><p>这条查询语句的查询条件没有用到索引，所以优化器决定选用访问类型为 ALL 进行查询，也就是全表扫描的方式查询，那么这时执行器与存储引擎的执行流程是这样的：</p><ul><li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，<strong>让存储引擎读取表中的第一条记录</strong>；</li><li>执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；<strong>如果是则将记录发给客户</strong>（是的没错，S<u>erver 层每从存储引擎读到一条记录就会发送给客户端</u>，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）。</li><li>执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 all，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；</li><li>一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息；</li><li>执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。</li></ul><p>至此，这个语句就执行完成了</p><ol start="3"><li><strong>索引下推</strong></li></ol><p>索引下推能够减少<strong>二级索引</strong>在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情(回表操作)，交给存储引擎层去处理了。</p><p>「<strong>索引下推暂时不必了解</strong>」后面会讲</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>​执行一条 SQL 查询语句，期间发生了什么？</p><ul><li>连接器：建立连接，管理连接、校验用户身份；</li><li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li><li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li><li>执行 SQL：执行 SQL 共有三个阶段：<ul><li>预处理阶段：<u>检查表或字段</u>是否存在；将 select * 中的 * 符号扩展为表上的所有列。</li><li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li><li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li></ul></li></ul><h3 id="引擎分类："><a href="#引擎分类：" class="headerlink" title="引擎分类："></a>引擎分类：</h3><h4 id="MySQL存储引擎有哪些？"><a href="#MySQL存储引擎有哪些？" class="headerlink" title="MySQL存储引擎有哪些？"></a>MySQL存储引擎有哪些？</h4><ul><li>InnoDB</li><li>MyISAM</li><li>……(上面两款最常用)</li></ul><h4 id="Innodb-和-MyISAM-存储引擎有什么区别？"><a href="#Innodb-和-MyISAM-存储引擎有什么区别？" class="headerlink" title="Innodb 和 MyISAM 存储引擎有什么区别？"></a>Innodb 和 MyISAM 存储引擎有什么区别？</h4><h5 id="1-磁盘文件的对比"><a href="#1-磁盘文件的对比" class="headerlink" title="1. 磁盘文件的对比"></a>1. 磁盘文件的对比</h5><p>创建两张表：zz_myisam_index、zz_innodb_index，分别使用了不同的引擎</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728163011906.png" alt="image-20230728163011906"></p><h6 id="1-1-使用MyISAM引擎的表"><a href="#1-1-使用MyISAM引擎的表" class="headerlink" title="1.1 使用MyISAM引擎的表"></a>1.1 使用MyISAM引擎的表</h6><p>zz_myisam_index这张表是使用MyISAM引擎的表，在磁盘中有三个文件：</p><ul><li>zz_myisam_index.frm：该文件中<strong>存储表的结构信息</strong>。</li><li>zz_myisam_index.MYD：该文件中<strong>存储表的行数据</strong>。</li><li>zz_myisam_index.MYI：该文件中<strong>存储表的索引数据</strong>。</li></ul><h6 id="1-2-使用InnoDB引擎的表"><a href="#1-2-使用InnoDB引擎的表" class="headerlink" title="1.2 使用InnoDB引擎的表"></a>1.2 使用InnoDB引擎的表</h6><p>zz_innodb_index这张表是使用InnoDB引擎的表，在磁盘中仅有两个文件：</p><ul><li>zz_innodb_index.frm：该文件中存储表的<strong>结构信息</strong>。</li><li>zz_innodb_index.ibd：该文件中存储表的<strong>行数据和索引数据</strong>。</li></ul><h5 id="2-索引支持的对比"><a href="#2-索引支持的对比" class="headerlink" title="2.索引支持的对比"></a>2.索引支持的对比</h5><ul><li>因为MyISAM引擎在设计之初，会将表分为.frm、.MYD、.MYI三个文件放在磁盘存储，<strong>表数据和索引数据是分别放在.MYD、.MYI文件中</strong>，所以注定了<u>MyISAM引擎只支持非聚簇索引</u>。</li><li>而InnoDB引擎的<strong>表数据、索引数据都放在.ibd文件中存储</strong>，因此<u>InnoDB是支持聚簇索引</u>的。</li></ul><p><strong>聚簇索引的要求</strong>是：索引键和行数据必须在物理空间上也是连续的，而MyISAM表数据和索引数据，分别位于两个磁盘文件中，这也就注定了它无法满足聚簇索引的要求。</p><p>但<strong>不支持聚簇索引也有好处</strong>，也就是<u>无论走任何索引，都只需要一遍查询即可获得数据</u>，而InnoDB引擎的表中，<u>如果不走聚簇（主键）索引查询数据，走其他索引的情况下，都需要经过两遍（回表）查询才能获得数据。</u></p><h5 id="3-事务机制的对比"><a href="#3-事务机制的对比" class="headerlink" title="3.事务机制的对比"></a>3.事务机制的对比</h5><ul><li><strong>InnoDB引擎中有两个自己专享的日志，即 undo-log、redo-log</strong>，使用InnoDB存储引擎的表，可以借助undo-log日志实现事务机制，支持多条SQL组成一个事务，可以保证发生异常的情况下，组成这个事务的SQL到底回滚还是提交。</li><li>而MyISAM并未设计类似的技术，在启动时不会在内存中构建undo_log_buffer缓冲区，磁盘中也没有相应的日志文件，因此MyISAM并<strong>不支持事务机制</strong></li></ul><p>&#x3D;&#x3D;&#x3D;&#x3D;&gt; 一个引擎是否支持事务，这点尤为重要</p><h5 id="4-故障恢复的对比"><a href="#4-故障恢复的对比" class="headerlink" title="4.故障恢复的对比"></a>4.故障恢复的对比</h5><ul><li>InnoDB在启动时，同样会在内存中构建一个redo_log_buffer缓冲区，在磁盘中也会有相应的redo-log日志文件，所以当一条或多条SQL语句执行成功后，不论MySQL在何时宕机，<strong>只要这个事务提交了，InnoDB引擎都能确保该事务的数据不会丢失，也就以此保障了事务的持久性。</strong></li><li>但MyISAM引擎同样<strong>没有redo-log日志，所以并不支持数据的故障恢复</strong>，如果表是使用MyISAM引擎创建的，当一条SQL将数据写入到了缓冲区后，SQL还未被写到bin-log日志，此时机器断电、DB宕机了，重启之后由于数据在宕机前还未落盘，所以丢了也就无法找回。</li></ul><h5 id="5-锁粒度的对比"><a href="#5-锁粒度的对比" class="headerlink" title="5.锁粒度的对比"></a>5.锁粒度的对比</h5><p>MyISAM仅支持表锁，而InnoDB同时支持表锁、行锁，但为啥MyISAM引擎不支持行锁呢？不是不想，而是做不到!</p><p>—-由于MyISAM每个索引都会对应一棵B+树，那么对可能导致基于不同索引查询数据时，一行数据上加多个锁，导致锁失效。</p><h5 id="6-并发性能的对比"><a href="#6-并发性能的对比" class="headerlink" title="6.并发性能的对比"></a>6.并发性能的对比</h5><p>​MyISAM仅支持表锁，InnoDB同时支持表锁、行锁，由于这点原因，其实<strong>InnoDB引擎的并发支持性早已远超MyISAM了，毕竟锁的粒度越小，并发冲突的概率也就越低，因此并发支撑就越高。</strong></p><h5 id="7-内存利用度的对比"><a href="#7-内存利用度的对比" class="headerlink" title="7.内存利用度的对比"></a>7.内存利用度的对比</h5><p>InnoDB引擎的创始人Heikki Tuuri早早想到了这点，通过缓冲池结合异步IO技术，活生生将一款基于磁盘的引擎，演变成了半内存式的引擎。反观MyISAM引擎，内部虽然也有缓冲池以及异步IO技术，但对内存的开发度远不足于InnoDB引擎，运行期间大量操作依旧会走磁盘完成。</p><p>—-InnoDB引擎的内存利用率很高</p><h4 id="🌟为什么InnoDB代替了MyISAM？"><a href="#🌟为什么InnoDB代替了MyISAM？" class="headerlink" title="🌟为什么InnoDB代替了MyISAM？"></a>🌟为什么InnoDB代替了MyISAM？</h4><p>①存储方式：<code>MyISAM</code>引擎会将表数据和索引数据分成两个文件存储。</p><p>②索引支持：因为<code>MyISAM</code>引擎的表数据和索引数据是分开的，因此不支持聚簇索引。</p><p>③事务支持：由于<code>MyISAM</code>引擎没有<code>undo-log</code>日志，所以不支持多条<code>SQL</code>组成事务并回滚。</p><p>④故障恢复：<code>MyISAM</code>引擎依靠<code>bin-log</code>日志实现，<code>bin-log</code>中未写入的数据会永久丢失。</p><p>⑤锁粒度支持：因为<code>MyISAM</code>不支持聚簇索引，因此无法实现行锁，所有并发操作只能加表锁。</p><p>⑥并发性能：<code>MyISAM</code>引擎仅支持表锁，所以多条线程出现读-写并发场景时会阻塞。</p><p>⑦内存利用度：<code>MyISAM</code>引擎过于依赖<code>MySQL Server</code>，对缓冲池、异步<code>IO</code>技术开发度不够。</p><h4 id="MyISAM引擎的可取之处："><a href="#MyISAM引擎的可取之处：" class="headerlink" title="MyISAM引擎的可取之处："></a>MyISAM引擎的可取之处：</h4><ol><li><p>统计总数的优化：</p><p>仅仅是对于<code>select count(*) from table_name;</code>这条语句，MyISAM引擎有更好的表现——因为其维护了一个变量——其存储了表中的记录总数，仅此而已，上述语句添加任何条件都会原形毕露。</p></li><li><p>删除数据&#x2F;表的优化：</p></li></ol><p>​当使用<code>delete</code>命令清空表数据时，<code>MyISAM</code>会直接<strong>重新创建表数据文件</strong>，而<code>InnoDB</code>则是一行行删除数据，因此对于清空表数据的操作，<code>MyISAM</code>比<code>InnoDB</code>快上无数倍。</p><p>​同时<code>MyISAM</code>引擎的表，对于<code>delete</code>过的数据不会立即删除，而且先隐藏起来，后续定时删除或手动删除，</p><ol start="3"><li>CRUD速度更快</li></ol><p>​<code>InnoDB</code>的聚簇索引，会影响读写数据的性能：基于非聚簇索引查找数据，就算查到了也需要经过一次回表才能得到数据，同时插入数据、修改数据时，都需要维护聚簇索引和非聚簇索引之间的关系</p><p>​而<code>MyISAM</code>引擎中，所有已创建的索引都是非聚簇索引，每个索引之间都是独立的，在索引中存储的是直接指向行数据的地址，而并非聚簇索引的索引键，因此无论走任何索引，都仅需一次即可获得数据，无需做回表查询。</p><p><strong>but</strong>：以单连接的方式测试，确实<code>MyISAM</code>会远超<code>InnoDB</code>，毕竟单个连接意味着只有一条线程，一条线程就不会出现锁竞争，表锁会一直由这条线程持有。但是在多连接的情况下，由于MyISAM只支持表锁，因此性能会大大降低，远低于InnoDB！</p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><h3 id="一行记录的存储格式"><a href="#一行记录的存储格式" class="headerlink" title="一行记录的存储格式"></a>一行记录的存储格式</h3><h4 id="MySQL-的数据存放在哪个文件？"><a href="#MySQL-的数据存放在哪个文件？" class="headerlink" title="MySQL 的数据存放在哪个文件？"></a>MySQL 的数据存放在哪个文件？</h4><p>—-MySQL 存储的行为是由存储引擎实现的，MySQL 支持多种存储引擎，<strong>不同的存储引擎保存的文件自然也不同</strong></p><p>本小节针对InnoDB展开讨论：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 我们可以在MySQL中使用下面的指令来获取mysql存储表信息的路径，所有的表结构和表数据都会在这个文件中</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;datadir&#x27;</span>;</span><br></pre></td></tr></table></figure><p>进入该目录，mysql中的每个数据库都会在该目录中对应一个子目录，进入数据库对应的子目录，我们发现其中结构为：</p><ul><li><strong>db.opt</strong> : 存放当前数据库的默认字符集和字idb符校验规则</li><li><strong>表名.frm</strong> : <strong>表结构</strong>会保存在这个文件。在 <u>MySQL 中建立一张表都会生成一个.frm 文件</u>，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。 </li><li><strong>表名.ibd</strong> : <strong>表数据</strong>会保存在这个文件，InnoDB引擎默认将每个表的<u>数据</u>分开存放， <strong>表名.ibd 文件也称为独占表空间文件</strong></li></ul><h5 id="表空间文件-存放表中数据的文件-的结构是怎么样的？"><a href="#表空间文件-存放表中数据的文件-的结构是怎么样的？" class="headerlink" title="表空间文件(存放表中数据的文件)的结构是怎么样的？"></a>表空间文件(存放表中数据的文件)的结构是怎么样的？</h5><p>​<strong>表空间由段（segment）、区（extent）、页（page）、行（row）组成</strong>，InnoDB存储引擎的逻辑存储结构大致如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730144124140.png" alt="image-20230730144124140"></p><h6 id="1、行（row）"><a href="#1、行（row）" class="headerlink" title="1、行（row）"></a>1、行（row）</h6><p>数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。</p><h6 id="2、页（page）"><a href="#2、页（page）" class="headerlink" title="2、页（page）"></a>2、页（page）</h6><p>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I&#x2F;O 操作）只能处理一行数据，效率会非常低。</p><p>因此，<strong>InnoDB 的数据是按「页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。</p><p><strong>默认每个页的大小为 16KB</strong>，也就是最多能保证 16KB 的连续存储空间。</p><p>页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p><h6 id="3、区（extent）"><a href="#3、区（extent）" class="headerlink" title="3、区（extent）"></a>3、区（extent）</h6><p>我们知道 InnoDB 存储引擎是用 B+ 树来组织数据的。</p><p>B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I&#x2F;O，随机 I&#x2F;O 是非常慢的。</p><p>解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I&#x2F;O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。</p><p>那具体怎么解决呢？</p><p><strong>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I&#x2F;O 了</strong>。</p><h6 id="4、段（segment）"><a href="#4、段（segment）" class="headerlink" title="4、段（segment）"></a>4、段（segment）</h6><p>表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。</p><ul><li><strong>索引段</strong>：存放 B + 树的非叶子节点的区的集合；</li><li><strong>数据段</strong>：存放 B + 树的叶子节点的区的集合；</li><li><strong>回滚段</strong>：存放的是回滚数据的区的集合；</li></ul><h4 id="InnoDB-行格式学习："><a href="#InnoDB-行格式学习：" class="headerlink" title="InnoDB 行格式学习："></a>InnoDB 行格式学习：</h4><p><u>行格式（row_format），就是一条记录的存储结构。</u></p><p><strong>COMPACT行格式</strong>——是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。</p><p>其他行格式要么就是太落后已经被淘汰、要么就是在COMPACT格式上进行增强，所以选择了解<strong>COMPACT</strong>行格式。</p><h5 id="COMPACT行格式："><a href="#COMPACT行格式：" class="headerlink" title="COMPACT行格式："></a>COMPACT行格式：</h5><p>​<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730145223318.png" alt="image-20230730145223318"></p><h6 id="1-变长字段长度列表"><a href="#1-变长字段长度列表" class="headerlink" title="1. 变长字段长度列表"></a>1. 变长字段长度列表</h6><ul><li><p>「变长字段长度列表」只出现在<strong>数据表有变长字段的时候</strong></p></li><li><p>根据列的顺序，<strong>逆序</strong>存放每条记录中各个变长字段的真实长度</p></li></ul><p>— 🌟为什么要逆序？</p><ol><li><p>「记录头信息」中指向下一个记录的指针，指向的是下一条记录的<strong>「记录头信息」和「真实数据」之间的位置</strong>，这样向左读就是记录头信息，向右读就是真实数据，比较方便。</p></li><li><p>「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以<strong>使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率</strong>。</p></li><li><p>🧠<u><em>通俗易懂，但不准确的说明</em></u>： 你初始指向的是中间的位置，往左一格更容易读到字段长度信息，往右一格能够读到该字段的真实数据信息(从中间向两边扩张地读取，更容易利用同一个指针实现在一次指针移动，读到同一字段的数据 &amp; 长度信息)</p></li></ol><p>同样的道理， NULL 值列表的信息也需要逆序存放。</p><h6 id="2-NULL-值列表"><a href="#2-NULL-值列表" class="headerlink" title="2. NULL 值列表"></a>2. NULL 值列表</h6><p>NULL 值列表也不是必须的。</p><p><strong>当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了</strong>。</p><p>所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）。</p><p>表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中。</p><p><u>如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit）</u>，二进制位<strong>按照列的顺序<u>逆序</u>排列</strong>。</p><ul><li>二进制位的值为<code>1</code>时，代表该列的值为NULL</li><li>二进制位的值为<code>0</code>时，代表该列的值不为NULL</li></ul><p>NULL 值列表必须用整数个字节的位表示（1字节8位），<strong>如果使用的二进制位个数不足整数个字节，则在字节的高位补 0</strong>——–&gt;意思就是，如果你的允许为null的字段数量不足8的倍数，也会开辟 8 的倍数的空间来存储(高位补0)，即InnoDB的基本存储单元为1B</p><h6 id="3-记录头信息"><a href="#3-记录头信息" class="headerlink" title="3. 记录头信息"></a>3. 记录头信息</h6><p>记录头信息中包含的内容很多，举例几个比较重要的：</p><ul><li><strong>delete_mask</strong> ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。</li><li><strong>next_record</strong>：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</li><li><strong>record_type</strong>：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</li></ul><h6 id="4-记录的真实数据"><a href="#4-记录的真实数据" class="headerlink" title="4. 记录的真实数据"></a>4. 记录的真实数据</h6><p>​记录真实数据部分除了我们定义的字段，还有**<u>三个隐藏字段</u><strong>，分别为：</strong>row_id、trx_id、roll_pointer**，我们来看下这三个字段是什么。</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730152307044.png" alt="image-20230730152307044"></p><ul><li>row_id</li></ul><p>​如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id<strong>不是必需的</strong>，占用 6 个字节。</p><p>​没有主键或唯一约束列时，会自动帮你生成一个隐藏主键(用于聚簇索引！)</p><ul><li>trx_id</li></ul><p>​事务id，表示<strong>这个数据是由哪个事务生成的</strong>。 trx_id是<strong>必需的</strong>，占用 6 个字节。</p><ul><li>roll_pointer</li></ul><p>​<strong>这条记录上一个版本的指针</strong>。roll_pointer 是<strong>必需的</strong>，占用 7 个字节。——-后面我们可以知道，这用于MVCC的实现</p><h4 id="varchar-n-中-n-最大取值为多少？"><a href="#varchar-n-中-n-最大取值为多少？" class="headerlink" title="varchar(n) 中 n 最大取值为多少？"></a>varchar(n) 中 n 最大取值为多少？</h4><p>我们要清楚一点，<strong>MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度<u>加起来</u>不能超过 65535 个字节</strong>。</p><p>也就是说，一行记录除了 TEXT、BLOBs 类型的列，限制最大为 65535 字节，<u>注意是一行的总长度</u>，不是一列。</p><p>知道了这个前提之后，我们再来看看这个问题：「varchar(n) 中 n 最大取值为多少？」</p><p>varchar(n) 字段类型的 n 代表的是最多存储的字符数量，并不是字节大小哦。</p><p>要算 varchar(n) 最大能允许存储的字节数，还要看数据库表的字符集，因为字符集代表着，1个字符要占用多少字节，比如 ascii 字符集， 1 个字符占用 1 字节，那么 varchar(100) 意味着最大能允许存储 100 字节的数据。</p><p>答：一条记录所有字段的「真实数据 + 变长字段长度列表 + NULL值列表」长度和 &lt;&#x3D; 65535 B</p><h4 id="行溢出后，MySQL-是怎么处理的？"><a href="#行溢出后，MySQL-是怎么处理的？" class="headerlink" title="行溢出后，MySQL 是怎么处理的？"></a>行溢出后，MySQL 是怎么处理的？</h4><p>MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 <code>16KB</code>，也就是 <code>16384字节</code>，而一个 varchar(n) 类型的列最多可以存储 <code>65532字节</code>，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会<strong>发生行溢出，多的数据就会存到另外的「溢出页」中</strong>。</p><p>🌟当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。大致如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730153621037.png" alt="image-20230730153621037"></p><p>注意：Compressed 和 Dynamic 这两种行格式(COMPACT的改进版)，它们对于行溢出的处理为：</p><ul><li>采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，<strong>只存储 20 个字节的指针来指向溢出页！而实际的数据都存储在溢出页中；</strong></li></ul><h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><h5 id="MySQL-的-NULL-值是怎么存放的？"><a href="#MySQL-的-NULL-值是怎么存放的？" class="headerlink" title="MySQL 的 NULL 值是怎么存放的？"></a>MySQL 的 NULL 值是怎么存放的？</h5><p>​MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。</p><p>​NULL值列表会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。</p><h5 id="MySQL-怎么知道-varchar-n-实际占用数据的大小？"><a href="#MySQL-怎么知道-varchar-n-实际占用数据的大小？" class="headerlink" title="MySQL 怎么知道 varchar(n) 实际占用数据的大小？"></a>MySQL 怎么知道 varchar(n) 实际占用数据的大小？</h5><p>​MySQL 的 Compact 行格式中会用「变长字段长度列表」存储变长字段实际占用的数据大小。</p><h5 id="varchar-n-中-n-最大取值为多少？-1"><a href="#varchar-n-中-n-最大取值为多少？-1" class="headerlink" title="varchar(n) 中 n 最大取值为多少？"></a>varchar(n) 中 n 最大取值为多少？</h5><p>​所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;&#x3D; 65535。</p><h5 id="行溢出后，MySQL-是怎么处理的？-1"><a href="#行溢出后，MySQL-是怎么处理的？-1" class="headerlink" title="行溢出后，MySQL 是怎么处理的？"></a>行溢出后，MySQL 是怎么处理的？</h5><p>​存到溢出页中，真实数据区存放溢出页地址(非完全行溢出方式、完全行溢出方式)</p><h3 id="char和varchar"><a href="#char和varchar" class="headerlink" title="char和varchar"></a>char和varchar</h3><h4 id="存储机制区别："><a href="#存储机制区别：" class="headerlink" title="存储机制区别："></a>存储机制区别：</h4><ul><li><strong>最大长度</strong>：char是255，varchar是65535，单位是字符（而不是字节）。</li><li><strong>尾随空格</strong>：char会将尾随空格去掉，而varchar不会。<br>因为存储时，char会用空格填充至指定长度，所以取出时需要去除<strong>填充的</strong>空格。如果char字段有唯一索引，<code>a</code> 和 <code>a空格</code> 会提示唯一索引冲突。</li><li><strong>存储空间占用</strong>：<u>varchar会占用额外的1~2字节来<strong>存储字符串长度</strong></u>。如果最大长度超过255，就需要2字节，否则1字节。</li></ul><h4 id="性能差异："><a href="#性能差异：" class="headerlink" title="性能差异："></a>性能差异：</h4><p>从char和varchar的存储结构对比，可以得出一个结论：<strong>char填充空格可能导致浪费存储空间，进而导致性能下降</strong>。因为char多存储一些空格，意味着需要<u>从磁盘读写更多的数据、耗费更多内存、查找数据时删除空格可能也会耗费一些CPU性能</u>。</p><p><strong>大部分情况下，varchar的性能优于char，最好使用varchar。</strong></p><p>不过考虑一个极端的场景：某个字段的最大长度是100字节，但是会频繁修改。如果使用<code>char(100)</code>，则插入记录后就分配了100个字节，后续修改不会造成页分裂、页空隙等问题，而<code>varchar(100)</code>由于没有提前分配存储空间，后续修改时可能出现页分裂，进而导致性能下降。</p><h4 id="即然varchar是变长，那是不是设置varchar（1000）一定比varchar（100）好？"><a href="#即然varchar是变长，那是不是设置varchar（1000）一定比varchar（100）好？" class="headerlink" title="即然varchar是变长，那是不是设置varchar（1000）一定比varchar（100）好？"></a>即然varchar是变长，那是不是设置varchar（1000）一定比varchar（100）好？</h4><p>虽然varchar是变长，在相同长度下，磁盘空间占用一样，将值设置更大一些，弹性空间也更大。但也不是完全没有代价的：</p><p><strong>在内存加载的时候，每次都是按最大空间来分配的。显然，在排序场景，或者一些临时表聚合场景，更大空间会产生明显的不利影响。</strong></p><h3 id="数据页"><a href="#数据页" class="headerlink" title="数据页"></a>数据页</h3><h4 id="InnoDB-是如何存储数据的？"><a href="#InnoDB-是如何存储数据的？" class="headerlink" title="InnoDB 是如何存储数据的？"></a>InnoDB 是如何存储数据的？</h4><p>——按行存储数据，但是读取数据时，一次会读取目标行所在的整页</p><p>数据库的 I&#x2F;O 操作的最小单位是页，<strong>InnoDB 数据页的默认大小是 16KB</strong>，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p><p>数据页包括七个部分，结构如下图：</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731110101701.png" alt="image-20230731110101701" style="zoom: 33%;" /><p><strong>说明：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731110642767.png" alt="image-20230731110642767"></p><h5 id="File-Header："><a href="#File-Header：" class="headerlink" title="File Header："></a>File Header：</h5><p>在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731110737757.png" alt="image-20230731110737757"></p><p>采用链表的结构是让数据页之间不需要是物理上的连续的，而是逻辑上的连续。(而实际上innodb也<strong>尽量</strong>让不同页存储在一个段中，使其物理上连续)</p><h5 id="User-Records："><a href="#User-Records：" class="headerlink" title="User Records："></a>User Records：</h5><p><strong>数据页中的记录按照「主键」顺序组成单向链表</strong>，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。</p><p>因此，数据页中有一个<strong>页目录</strong>，起到记录的索引作用，就像我们书那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。</p><h5 id="Page-Directory："><a href="#Page-Directory：" class="headerlink" title="Page Directory："></a>Page Directory：</h5><p>页目录创建的过程如下：</p><ol><li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；</li><li><u>每个记录组的最后一条记录就是组内最大的那条记录</u>，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段</li><li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），<strong>每个槽相当于指针指向了不同组的最后一个记录</strong>。</li></ol><p><strong>页目录就是由多个槽组成的，槽相当于分组记录的索引</strong>。然后，因为记录是按照「主键值」从小到大排序的，所以<strong>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个页中的记录链表。</p><p>举个例子，5 个槽的编号分别为 0，1，2，3，4，我想查找主键为 11 的用户记录：</p><ul><li>先二分得出槽中间位是 (0+4)&#x2F;2&#x3D;2 ，2号槽里最大的记录为 8。因为 11 &gt; 8，所以需要从 2 号槽后继续搜索记录；</li><li>再使用二分搜索出 2 号和 4 槽的中间位是 (2+4)&#x2F;2&#x3D; 3，3 号槽里最大的记录为 12。因为 11 &lt; 12，所以主键为 11 的记录在 3 号槽里；</li><li>这里有个问题，<strong>「槽对应的值都是这个组的主键最大的记录，如何找到组里最小的记录」</strong>？<ul><li>找前一个槽最大记录+1即可</li></ul></li></ul><p>看到第三步的时候，可能有的同学会疑问，如果某个槽内的记录很多，然后因为记录都是单向链表串起来的，那这样在槽内查找某个记录的时间复杂度不就是 O(n) 了吗？</p><p>这点不用担心，InnoDB 对每个分组中的记录条数都是有规定的，槽内的记录就只有几条：</p><ul><li>第一个分组中的记录只能有 1 条记录；</li><li>最后一个分组中的记录条数范围只能在 1-8 条之间；</li><li>剩下的分组中记录条数范围只能在 4-8 条之间。</li></ul><h5 id="总结——单数据页内的查询步骤："><a href="#总结——单数据页内的查询步骤：" class="headerlink" title="总结——单数据页内的查询步骤："></a>总结——单数据页内的查询步骤：</h5><p>上面我们都是在说一个数据页中的记录检索，因为一个数据页中的记录是有限的，且主键值是有序的，所以通过对所有记录进行分组，然后将组号（槽号）存储到页目录，使其起到索引作用，通过二分查找的方法快速检索到记录在哪个分组，来降低检索的时间复杂度。</p><h4 id="B-树是如何进行查询的？"><a href="#B-树是如何进行查询的？" class="headerlink" title="B+ 树是如何进行查询的？"></a>B+ 树是如何进行查询的？</h4><p>当我们需要存储大量的记录时，就需要多个数据页。<strong>InnoDB 采用了 B+ 树作为索引</strong>。磁盘的 I&#x2F;O 操作次数对索引的使用效率至关重要，因此在构造索引的时候，我们更倾向于采用“矮胖”的 B+ 树数据结构，这样所需要进行的磁盘 I&#x2F;O 次数更少，而且 B+ 树 更适合进行关键字的范围查询。</p><p>InnoDB 里的 B+ 树中的<strong>每个节点都是一个数据页</strong>，结构示意图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731111828591.png" alt="image-20230731111828591"></p><p>通过上图，我们看出 B+ 树的特点：</p><ul><li><u>只有叶子节点（最底层的节点）才存放了数据</u>，非叶子节点（其他上层节）仅用来存放目录项作为索引。</li><li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li><li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</li></ul><p>🌰我们再看看 B+ 树如何实现快速查找主键为 6 的记录，以上图为例子：</p><ul><li>从根节点开始，通过二分法快速定位到符合页内范围包含查询值的页，因为查询的主键值为 6，在[1, 7)范围之间，所以到页 30 中查找更详细的目录项；</li><li>在非叶子节点（页30）中，继续通过二分法快速定位到符合页内范围包含查询值的页，主键值大于 5，所以就到叶子节点（页16）查找记录；</li><li>接着，在叶子节点（页16）中，通过槽查找记录时，使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到主键为 6 的记录。</li></ul><p>🌟<strong>可以看到，在定位记录所在哪一个页时，也是通过二分法快速定位到包含该记录的页。定位到该页后，又会在该页内进行二分法快速定位记录所在的分组（槽号），最后在分组内进行遍历查找。</strong></p><h5 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h5><ol><li><p>构建数据页的B+树</p></li><li><p>将要查询的主键值与B+树节点的最大、最小记录比较，进行二分查找，找到记录所在的数据页</p></li><li><p>在数据页中，再使用二分查找找到记录在哪个槽，在槽中顺序遍历找到结果</p></li></ol><h4 id="聚簇索引和二级索引"><a href="#聚簇索引和二级索引" class="headerlink" title="聚簇索引和二级索引"></a>聚簇索引和二级索引</h4><p>另外，索引又可以分成聚簇索引和非聚簇索引（二级索引），它们<strong>区别就在于叶子节点存放的是什么数据</strong>：</p><ul><li><u>聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点</u>；(InnoDB,索引与数据都存在.idb文件中)</li><li>二级索引的叶子节点存放的是主键值，而不是实际数据。</li></ul><p>因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。</p><p>InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用<strong>主键</strong>作为聚簇索引的索引键；</li><li>如果没有主键，就选择第一个<strong>不包含 NULL 值的唯一列</strong>作为聚簇索引的索引键；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个<strong>隐式自增 id 列</strong>作为聚簇索引的索引键；</li></ul><p>一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了<u>二级索引（非聚簇索引&#x2F;辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。</u></p><p>二级索引的 B+ 树如下图，数据部分为主键值：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731112821532.png" alt="image-20230731112821532"></p><p>因此，<strong>如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。</strong></p><h4 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h4><ul><li>InnoDB 的数据是按「数据页」为单位来读写的，默认数据页大小为 16 KB。<u>每个数据页之间通过双向链表的形式组织起来，物理上不连续，但是逻辑上连续。</u></li><li>数据页内包含用户记录，每个记录之间用单向链表的方式组织起来，为了加快在数据页内高效查询记录，设计了一个页目录，页目录存储各个槽（分组），且主键值是有序的，于是可以通过二分查找法的方式进行检索从而提高效率。</li><li>为了高效查询记录所在的数据页，InnoDB 采用 b+ 树作为索引，每个节点都是一个数据页。</li><li>叶子节点存储实际数据，就是聚簇索引，一个表只能有一个聚簇索引；如果叶子节点存储的不是实际数据，而是主键值则就是二级索引，一个表中可以有多个二级索引。</li><li>在使用二级索引进行查找数据时，如果查询的数据能在二级索引找到(也就是说，查找的数据是建立聚簇索引的列)，那么就是「索引覆盖」操作，如果查询的数据不在二级索引里，就需要先在二级索引找到主键值，需要去聚簇索引中获得数据行，这个过程就叫作「回表」。</li></ul><h3 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h3><h4 id="引出："><a href="#引出：" class="headerlink" title="引出："></a>引出：</h4><p><strong>——就是一个cache，为了减少读磁盘的次数</strong></p><p>虽然说 MySQL 的数据是存储在磁盘里的，但如果每次都从磁盘中读取数据，性能差；</p><p>要想提升查询性能，加个缓存就行了嘛。所以，<u>当数据从磁盘中取出后，缓存内存中，下次查询同样的数据的时候，直接从内存中读取</u>。</p><p>为此，Innodb 存储引擎设计了一个<strong>缓冲池（Buffer Pool）</strong>，来提高数据库的读写性能</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230801091252147.png" alt="image-20230801091252147" style="zoom: 33%;" /><ul><li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li><li>当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后<u>由后台线程将脏页写入到磁盘</u>。</li></ul><h4 id="Buffer-Pool-有多大？"><a href="#Buffer-Pool-有多大？" class="headerlink" title="Buffer Pool 有多大？"></a>Buffer Pool 有多大？</h4><p>—-默认128MB，可以通过调整 <code>innodb_buffer_pool_size</code> 参数来设置 Buffer Pool 的大小，一般建议设置成可用物理内存的 60%~80%</p><h4 id="Buffer-Pool-缓存什么？"><a href="#Buffer-Pool-缓存什么？" class="headerlink" title="Buffer Pool 缓存什么？"></a>Buffer Pool 缓存什么？</h4><p>–<u><strong>一页一页进行缓存</strong></u></p><p>​在 MySQL 启动的时候，<strong>InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的<code>16KB</code>的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页</strong>。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。</p><p>为了更好的管理这些在 Buffer Pool 中的缓存页，InnoDB 为每一个缓存页都创建了一个<strong>控制块</strong>，控制块信息包括「缓存页的表空间、页号、缓存页地址、链表节点」等等。</p><p>控制块也是占有内存空间的，它是放在 Buffer Pool 的最前面，接着才是缓存页，如下图：</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230801095607789.png" alt="image-20230801095607789" style="zoom:50%;" /><p>上图中控制块和缓存页之间白色部分称为碎片空间。</p><h4 id="如何管理-Buffer-Pool？"><a href="#如何管理-Buffer-Pool？" class="headerlink" title="如何管理 Buffer Pool？"></a>如何管理 Buffer Pool？</h4><h5 id="如何管理空闲页？"><a href="#如何管理空闲页？" class="headerlink" title="如何管理空闲页？"></a>如何管理空闲页？</h5><p>使用一个Free链表，专门管理空闲页(使空闲页方便被获取)</p> <img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230801100926879.png" alt="image-20230801100926879" style="zoom:50%;" /><h6 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h6><ul><li><p>Free 链表上除了有控制块，还有一个头节点，该<u>头节点包含链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息</u>。</p></li><li><p><u>Free 链表节点是一个一个的控制块，而每个控制块包含着对应缓存页的地址，所以相当于 Free 链表节点都对应一个空闲的缓存页。</u></p></li><li><p>有了 Free 链表后，每当需要从磁盘中加载一个页到 Buffer Pool 中时，就<u>从 Free链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的控制块从 Free 链表中移除。</u></p></li></ul><h5 id="如何管理脏页？"><a href="#如何管理脏页？" class="headerlink" title="如何管理脏页？"></a>如何管理脏页？</h5><p>—Flush 链表，表中节点都是脏页的控制块，方便管理所有脏页！</p><p>​设计 Buffer Pool 除了能提高读性能，还能提高写性能，也就是<u>更新数据的时候，不需要每次都要写入磁盘，而是将 Buffer Pool 对应的缓存页标记为<strong>脏页</strong>，然后再由后台线程将脏页写入到磁盘。</u></p><p>​那为了能快速知道哪些缓存页是脏的，于是就设计出 <strong>Flush 链表</strong>，它跟 Free 链表类似的，链表的节点也是控制块，区别在于 Flush 链表的元素都是脏页。</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230801101340605.png" alt="image-20230801101340605" style="zoom:45%;" /><p>有了 Flush 链表后，后台线程就可以遍历 Flush 链表，将脏页写入到磁盘。</p><h5 id="如何提高缓存命中率？"><a href="#如何提高缓存命中率？" class="headerlink" title="如何提高缓存命中率？"></a>如何提高缓存命中率？</h5><p>​Buffer Pool 的大小是有限的，<u>对于一些频繁访问的数据我们希望可以一直留在 Buffer Pool 中，而一些很少访问的数据希望可以在某些时机可以淘汰掉；</u></p><p>​——使用简单的LRU算法</p><ul><li>当访问的页在 Buffer Pool 里，就直接把该页对应的 LRU 链表节点移动到链表的头部。</li><li>当访问的页不在 Buffer Pool 里，除了要把页放入到 LRU 链表的头部，还要淘汰 LRU 链表末尾的节点。</li></ul><p>⚠️简单的 LRU 算法并没有被 MySQL 使用，因为简单的 LRU 算法无法避免下面这两个问题：</p><ul><li>预读失效；</li><li>Buffer Pool 污染；</li></ul><h6 id="预读失效："><a href="#预读失效：" class="headerlink" title="预读失效："></a>预读失效：</h6><p>​先来说说 MySQL 的预读机制。程序是有空间局部性的，靠近当前被访问数据的数据，在未来很大概率会被访问到。</p><p>所以，<strong>MySQL 在加载数据页时，会提前把它 <u><em>相邻的</em></u> 数据页一并加载进来，目的是为了减少磁盘 IO。</strong></p><p>但是可能这些<strong>被提前加载进来的数据页，并没有被访问</strong>，相当于这个预读是白做了，这个就是<strong>预读失效</strong>。</p><p>​如果这些预读页如果一直不会被访问到，就会出现问题：不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是频繁访问的页，这样就大大降低了缓存命中率。</p><h6 id="🌟预读失效解决方案："><a href="#🌟预读失效解决方案：" class="headerlink" title="🌟预读失效解决方案："></a>🌟预读失效解决方案：</h6><p>​要避免预读失效带来影响，最好就是**<u>让预读的页停留在 Buffer Pool 里的时间要尽可能的短</u>，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在 Buffer Pool 里的时间尽可能长**。</p><p>MySQL 是这样做的，它改进了 LRU 算法，将 LRU 划分了 2 个区域：<strong>old 区域 和 young 区域</strong>。</p><p>young 区域在 LRU 链表的前半部分，old 区域则是在后半部分，如下图：</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230801102129142.png" alt="image-20230801102129142" style="zoom: 33%;" /><p>**划分这两个区域后，预读的页(所有从磁盘读入的页都先放到old区头部)就只需要加入到 old 区域的头部，<u>当页被真正访问的时候，才将页插入 young 区域的头部</u>**。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。</p><p>—-young、old区域比例关系可手动设计</p><h6 id="Buffer-Pool-污染："><a href="#Buffer-Pool-污染：" class="headerlink" title="Buffer Pool 污染："></a>Buffer Pool 污染：</h6><p>​当某一个 SQL 语句<strong>扫描了大量的数据</strong>时，在 Buffer Pool 空间比较有限的情况下，可能会将 <strong>Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了</strong>，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 <strong>Buffer Pool 污染</strong>。</p><h6 id="Buffer-Pool-污染解决方案："><a href="#Buffer-Pool-污染解决方案：" class="headerlink" title="Buffer Pool 污染解决方案："></a>Buffer Pool 污染解决方案：</h6><p>​像前面这种全表扫描的查询，<u>很多缓冲页其实只会被访问一次，但是它却只因为被访问了一次而进入到 young 区域，从而导致热点数据被替换了。</u></p><p>LRU 链表中 young 区域就是热点数据，只要我们<u>提高进入到 young 区域的门槛</u>，就能有效地保证 young 区域里的热点数据不会被替换掉。</p><p>MySQL 是这样做的，进入到 young 区域条件增加了一个<strong>停留在 old 区域的时间判断</strong>。</p><p>具体是这样做的，在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间：</p><ul><li>如果后续的访问时间与第一次访问的时间<strong>在某个时间间隔内</strong>，那么<strong>该缓存页就不会被从 old 区域移动到 young 区域的头部</strong>；</li><li>如果后续的访问时间与第一次访问的时间<strong>不在某个时间间隔内</strong>，那么<strong>该缓存页移动到 young 区域的头部</strong>；</li></ul><p>这个间隔时间是由 <code>innodb_old_blocks_time</code> 控制的，默认是 1000 ms。</p><p>也就说，<strong>只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部</strong>，这样就解决了 Buffer Pool 污染的问题 。</p><h5 id="脏页什么时候会被刷入磁盘？"><a href="#脏页什么时候会被刷入磁盘？" class="headerlink" title="脏页什么时候会被刷入磁盘？"></a>脏页什么时候会被刷入磁盘？</h5><p>如果每次都要把脏页写入磁盘同步数据的话性能会很低，但是如果不立即同步的话，如果mysql宕机了就会丢失数据？</p><p>​这个不用担心，InnoDB 的更新操作采用的是 Write Ahead Log 策略，即先写日志，再写入磁盘，通过 redo log 日志让 MySQL 拥有了崩溃恢复能力。</p><p>下面几种情况会**<u>触发脏页的刷新</u>**：</p><ul><li>当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；</li><li>Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；</li><li>MySQL 认为空闲时，后台线程会定期将适量的脏页刷入到磁盘；</li><li>MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；</li></ul><p>在我们开启了慢 SQL 监控后，如果你发现<strong>「偶尔」会出现一些用时稍长的 SQL</strong>，这可能是因为脏页在刷新到磁盘时可能会给数据库带来性能开销，导致数据库操作抖动。</p><p>在很短的时间内多次出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Innodb 存储引擎设计了一个<strong>缓冲池（<em>Buffer Pool</em>）</strong>，来提高数据库的读写性能。</p><p>Buffer Pool 以页为单位缓冲数据，可以通过 <code>innodb_buffer_pool_size</code> 参数调整缓冲池的大小，默认是 128 M。</p><p>Innodb 通过三种链表来管理缓页：</p><ul><li>Free List （空闲页链表），管理空闲页；</li><li>Flush List （脏页链表），管理脏页；</li><li>LRU List，管理脏页+干净页，将最近且经常查询的数据缓存在其中，而不常查询的数据就淘汰出去。；</li></ul><p>InnoDB 对 LRU 做了一些优化，我们熟悉的 LRU 算法通常是将最近查询的数据放到 LRU 链表的头部，而 InnoDB 做 2 点优化：</p><ul><li>将 LRU 链表 分为<strong>young 和 old 两个区域</strong>，加入缓冲池的页，优先插入 old 区域；页被访问时，才进入 young 区域，目的是为了解决预读失效的问题。</li><li>当<strong>「页被访问」且「 old 区域停留时间超过 <code>innodb_old_blocks_time</code> 阈值（默认为1秒）」</strong>时，才会将页插入到 young 区域，否则还是插入到 old 区域，目的是为了解决批量数据访问，大量热数据淘汰的问题。</li></ul><p>可以通过调整 <code>innodb_old_blocks_pct</code> 参数，设置 young 区域和 old 区域比例。</p><p>在开启了慢 SQL 监控后，如果你发现「偶尔」会出现一些用时稍长的 SQL，这可能因为脏页在刷新到磁盘时导致数据库性能抖动。如果在很短的时间内多次出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。</p><h3 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h3><p>​当需要更新一个数据页时，如果数据页在内存中就直接更新，而<u>如果这个数据页还没有在内存中</u>的话，在不影响数据一致性的前提下，InooDB 会<u>将这些更新操作缓存在 change buffer 中</u>，这样就不需要从磁盘中读入这个数据页了。在<u>下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作</u>。通过这种方式就能保证这个数据逻辑的正确性。</p><p>需要说明的是，虽然名字叫作 change buffer，实际上它是可以持久化的数据。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。</p><p><strong>将 change buffer 中的操作应用到原数据页</strong>，得到最新结果的过程称为 <strong>merge</strong>。</p><p>执行merge：</p><ol><li>访问这个数据页会触发 merge</li><li>系统有后台线程会定期 merge</li><li>在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作</li></ol><h4 id="什么条件下可以使用-change-buffer？"><a href="#什么条件下可以使用-change-buffer？" class="headerlink" title="什么条件下可以使用 change buffer？"></a>什么条件下可以使用 change buffer？</h4><h5 id="例1🌰："><a href="#例1🌰：" class="headerlink" title="例1🌰："></a>例1🌰：</h5><p>​对于唯一索引来说，<u>所有的更新操作都要先判断这个操作是否违反唯一性约束</u>。比如，要插入 (4,400) 这个记录，就要先判断现在表中是否已经存在 k&#x3D;4 的记录，<u>而这必须要将数据页读入内存才能判断</u>。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。</p><p>⚠️因此，唯一索引的更新就不能使用 change buffer，实际上也只有普通索引(不用判断唯一性，因此更新操作不可能报错)可以使用。</p><h5 id="例2🌰："><a href="#例2🌰：" class="headerlink" title="例2🌰："></a>例2🌰：</h5><p>如果要在这张表中插入一个新记录 (4 {索引列} ,400 {普通列}) 的话，InnoDB 的处理流程是怎样的。</p><p>第一种情况是，<strong>这个记录要更新的目标页在内存中</strong>。这时，InnoDB 的处理流程如下：</p><ul><li>对于唯一索引来说，找到 3 和 5 之间的位置，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，找到 3 和 5 之间的位置，插入这个值，语句执行结束。</li></ul><p>这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间。</p><p>但，这不是我们关注的重点。</p><p>第二种情况是，<strong>这个记录要更新的目标页不在内存中</strong>。这时，InnoDB 的处理流程如下：</p><ul><li>对于唯一索引来说，需要<u>将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束</u>；</li><li>对于普通索引来说，则是<u>将更新记录在 change buffer，语句执行就结束了</u>。</li></ul><p>将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p><h4 id="change-buffer-的使用场景"><a href="#change-buffer-的使用场景" class="headerlink" title="change buffer 的使用场景"></a>change buffer 的使用场景</h4><p>现在，我们已经清楚了使用 change buffer 对更新过程的加速作用，也清楚了 change buffer <u>只限于用在普通索引的场景下，而不适用于唯一索引。</u></p><p>​<strong>那么普通索引的所有场景，使用 change buffer 都可以起到加速作用吗？</strong></p><p>​因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以<u><strong>在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。</strong></u></p><p>​因此，对于<u>写多读少</u>的业务来说，页面在写完以后马上被访问到的概率比较小，此时 <u>change buffer 的使用效果最好</u>。这种业务模型常见的就是账单类、日志类的系统。</p><p>​反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。<u>这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价</u>。所以，对于这种业务模式来说，change buffer 反而起到了副作用。</p><h4 id="普通索引和唯一索引应该怎么选择？"><a href="#普通索引和唯一索引应该怎么选择？" class="headerlink" title="普通索引和唯一索引应该怎么选择？"></a>普通索引和唯一索引应该怎么选择？</h4><p>​其实，这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。所以，建议尽量选择普通索引。</p><p>​如果所有的更新后面，都<u>马上伴随着对这个记录的查询</u>，那么你应该关闭 change buffer。而在其他情况下，change buffer 都能提升更新性能。</p><p>​在实际使用中，你会发现，普通索引和 change buffer 的配合使用，对于数据量大的表的更新优化还是很明显的。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h3><h4 id="B-树索引结构-最广泛"><a href="#B-树索引结构-最广泛" class="headerlink" title="B+树索引结构(最广泛)"></a>B+树索引结构(最广泛)</h4><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><p>​基于<strong>磁盘</strong>的平衡树，但<u>树非常矮，通常为 3~4 层</u>，能存放千万到上亿的排序数据。树矮意味着访问效率高，从千万或上亿数据里查询一条数据，只用 3、4 次 I&#x2F;O。</p><h5 id="组成："><a href="#组成：" class="headerlink" title="组成："></a>组成：</h5><ul><li>B+ 树索引由根节点（root node）、中间节点（non leaf node）、叶子节点（leaf node）组成，其中<strong>叶子节点存放所有排序后的数据</strong>。</li><li>因此在其叶子结点寻找数据只需要logn的时间复杂度！</li></ul><p>⚠️：当 B+ 树的高度大于等于 2 时，<u><strong>根节点和中间节点存放的是索引键对</strong>(仅用来当作‘路标’，划分不同索引值的叶子结点)</u>，由（索引键、指针）组成。</p><h5 id="优化-B-树索引的插入性能："><a href="#优化-B-树索引的插入性能：" class="headerlink" title="优化 B+ 树索引的插入性能："></a>优化 B+ 树索引的插入性能：</h5><p>B+ 树在插入时就对要对数据进行排序，但排序的开销其实并没有你想象得那么大，因为排序是 CPU 操作（当前一个时钟周期 CPU 能处理上亿指令）。</p><p><strong>真正的开销在于 B+ 树索引的维护，保证数据排序，这里存在两种不同数据类型的插入情况</strong>。</p><ul><li><strong>数据顺序（或逆序）插入：</strong> B+ 树索引的维护代价非常小，叶子节点都是从左往右进行插入，比较典型的是自增 ID 的插入、时间的插入（若在自增 ID 上创建索引，时间列上创建索引，则 B+ 树插入通常是比较快的）。</li><li><strong>数据无序插入：</strong> B+ 树为了维护排序，需要对页进行分裂、旋转等开销较大的操作，另外，即便对于固态硬盘，随机写的性能也不如顺序写，所以磁盘性能也会收到较大影响。比较典型的是用户昵称，每个用户注册时，昵称是随意取的，若在昵称上创建索引，插入是无序的，索引维护需要的开销会比较大。</li></ul><p>你不可能要求所有插入的数据都是有序的，因为索引的本身就是用于数据的排序，插入数据都已经是排序的，那么你就不需要 B+ 树索引进行数据查询了。</p><p>所以对于 B+ 树索引，在 MySQL 数据库设计中，仅<u>要求主键的索引设计为顺序</u>，比如使用自增，或使用函数 UUID_TO_BIN 排序的 UUID，而不用无序值做主键。</p><h4 id="为什么-MySQL-采用-B-树作为索引？"><a href="#为什么-MySQL-采用-B-树作为索引？" class="headerlink" title="为什么 MySQL 采用 B+ 树作为索引？"></a>为什么 MySQL 采用 B+ 树作为索引？</h4><p>​数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I&#x2F;O，而磁盘 I&#x2F;O 次数越多，所消耗的时间也就越大。</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230802111506165.png" alt="image-20230802111506165" style="zoom:50%;" /><h5 id="MySQL-默认的存储引擎-InnoDB-采用的是-B-作为索引的数据结构，原因有："><a href="#MySQL-默认的存储引擎-InnoDB-采用的是-B-作为索引的数据结构，原因有：" class="headerlink" title="MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有："></a>MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：</h5><ul><li>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I&#x2F;O次数会更少。</li><li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</li><li>B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树。</li></ul><h5 id="Innodb-里的-B-树："><a href="#Innodb-里的-B-树：" class="headerlink" title="Innodb 里的 B+ 树："></a>Innodb 里的 B+ 树：</h5><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731111828591.png" alt="image-20230731111828591"></p><p>但是 Innodb 使用的 B+ 树有一些特别的点，比如：</p><ul><li>B+ 树的叶子节点之间是用「双向链表」进行连接，这样的好处是既能向右遍历，也能向左遍历。</li><li>B+ 树点节点内容是数据页，数据页里存放了用户的记录以及各种信息，每个数据页默认大小是 16 KB。</li></ul><p>Innodb 根据索引类型不同，分为聚簇和二级索引。他们区别在于，聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点，而二级索引的叶子节点存放的是主键值，而不是实际数据。</p><p>因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个，而二级索引可以创建多个。</p><h3 id="索引存储"><a href="#索引存储" class="headerlink" title="索引存储"></a>索引存储</h3><h4 id="堆表：-性能差"><a href="#堆表：-性能差" class="headerlink" title="堆表：(性能差)"></a>堆表：(性能差)</h4><p>堆表的组织结构中，数据和索引分开存储。索引是排序后的数据，而堆表中的数据是无序的，索引的叶子节点存放了数据在堆表中的地址，当堆表的数据发生改变，且位置发生了变更，所有索引中的地址都要更新，这非常影响性能，特别是对于 OLTP 业务。</p><h4 id="索引组织表："><a href="#索引组织表：" class="headerlink" title="索引组织表："></a>索引组织表：</h4><p><strong>MySQL InnoDB 存储引擎是索引组织表</strong></p><p>​<strong>数据根据主键排序存放在索引中</strong>，<u>主键索引也叫聚簇索引（Clustered Index）</u>。在索引组织表中，数据即索引，索引即数据。</p><h4 id="二级索引："><a href="#二级索引：" class="headerlink" title="二级索引："></a>二级索引：</h4><p>​InnoDB 存储引擎的数据是根据主键索引排序存储的，除了主键索引外，<strong>其他的索引都称之为二级索引（Secondeary Index），</strong> 或非聚簇索引（None Clustered Index）。</p><p>二级索引也是一颗 B+ 树索引，但它和主键索引不同的是<u>叶子节点存放的是索引键值、主键<strong>值</strong></u>。</p><p>索引组织表这样的二级索引设计有一个非常大的好处：<u>若记录发生了修改，则其他索引无须进行维护，除非记录的主键发生了修改。</u></p><p>与堆表的索引实现对比着看，你会发现索引组织表在存在大量变更的场景下，性能优势会非常明显，因为大部分情况下都不需要维护其他二级索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 根据 name 进行查询的 SQL 可以理解为拆分成了两个步骤：(id为主键，name为普通索引)</span></span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> idx_name <span class="keyword">WHERE</span> name <span class="operator">=</span> ?</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">User</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> _id; <span class="comment">-- 回表</span></span><br></pre></td></tr></table></figure><p>在实际核心业务中，开发同学还有很大可能会<u>设计带有业务属性的主键</u>，但请牢记以下两点设计原则：</p><ul><li>要比较顺序，对聚簇索引性能友好；</li><li>尽可能紧凑，对二级索引的性能和存储友好；</li></ul><h4 id="索引组织表和堆表之间的区别总结："><a href="#索引组织表和堆表之间的区别总结：" class="headerlink" title="索引组织表和堆表之间的区别总结："></a><u>索引组织表和堆表</u>之间的区别总结：</h4><ul><li>索引组织表主键是聚簇索引，索引的叶子节点存放表中一整行完整记录；</li><li>除主键索引外的索引都是二级索引，索引的叶子节点存放的是（索引键值，主键值）；</li><li>由于二级索引不存放完整记录，因此需要通过主键值再进行一次回表才能定位到完整数据；</li><li>索引组织表对比堆表，在海量并发的OLTP业务中能有更好的性能表现；</li><li>每种不同数据，对二级索引的性能开销影响是不一样的；(有序的二级索引性能更好)</li><li>有时通过函数索引可以快速解决线上SQL的性能问题；</li><li>虚拟列不占用实际存储空间，在虚拟列上创建索引本质就是函数索引。</li></ul><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><h4 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h4><p>​在实际业务中，我们会遇到很多复杂的场景，比如对多个列进行查询。这时，可能会要求用户创建多个列组成的索引，如列 a 和 b 创建的组合索引，但究竟是创建（a，b）的索引，还是（b，a）的索引，结果却是完全不同的。</p><p>组合索引（Compound Index）是指<u>由多个列所组合而成的 B+树索引</u>，这和我们之前介绍的B+ 树索引的原理完全一样，只是<u><strong>之前是对一个列排序，现在是对多个列排序</strong></u>。</p><p>组合索引既可以是主键索引，也可以是二级索引，下图显示的是一个二级组合索引：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230803090636470.png" alt="image-20230803090636470"></p><p>从上图可以看到，组合索引只是排序的键值从 1 个变成了多个，本质还是一颗 B+ 树索引。但是你<u>一定要意识到（a，b）和（b，a）这样的组合索引，其排序结果是完全不一样的</u>。而索引的字段变多了，设计上更容易出问题，如：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230803090754475.png" alt="image-20230803090754475"></p><h4 id="示例🌰："><a href="#示例🌰：" class="headerlink" title="示例🌰："></a>示例🌰：</h4><p><strong>对组合索引（a，b）来说，因为其对列 a、b 做了排序，所以它可以对下面两个查询进行优化：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> ?</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> ？ <span class="keyword">AND</span> b <span class="operator">=</span> ？</span><br></pre></td></tr></table></figure><p>上述 SQL 查询中，WHERE 后查询列 a 和 b 的顺序无关，即使先写 b &#x3D; ? AND a &#x3D; ？依然可以使用组合索引（a，b）。</p><p>但是下面的 SQL 无法使用组合索引（a，b），因为（a，b）排序并不能推出（b，a）排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> b <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure><p>此外，同样由于索引（a，b）已排序，因此下面这条 SQL 依然可以使用组合索引（a，b），以此提升查询的效率：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> ？ <span class="keyword">ORDER</span> <span class="keyword">BY</span> b <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><p>同样的原因，索引（a，b）排序不能得出（b，a）排序，因此下面的 SQL 无法使用组合索引（a，b）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> b <span class="operator">=</span> ？ <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><h4 id="避免回表可以极大提升性能：！！！"><a href="#避免回表可以极大提升性能：！！！" class="headerlink" title="避免回表可以极大提升性能：！！！"></a>避免回表可以极大提升性能：！！！</h4><p>由于二级组合索引的叶子节点，包含索引键值和主键值，若查询的字段在二级索引的叶子节点中，则可直接返回结果，无需回表。这种<strong>通过组合索引避免回表的优化技术也称为索引覆盖（Covering Index）</strong>。</p><h4 id="总结：-4"><a href="#总结：-4" class="headerlink" title="总结："></a>总结：</h4><p>组合索引也是一颗 B+ 树，只是索引的列由多个组成，组合索引既可以是主键索引，也可以是二级索引。通过今天的学习，我们可以归纳组合索引的三大优势：</p><ol><li>覆盖多个查询条件，如（a，b）索引可以覆盖查询 a &#x3D; ? 或者 a &#x3D; ? and b &#x3D; ?；</li><li>避免 SQL 的额外排序，提升 SQL 性能，如 WHERE a &#x3D; ? ORDER BY b 这样的查询条件；</li><li>利用组合索引包含多个列的特性，可以实现<u><strong>索引覆盖技术</strong></u>，提升 SQL 的查询性能，用好索引覆盖技术，性能提升 10 倍不是难事。</li></ol><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><p>​在我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据在「二级索引」的叶子节点，那么只需要在「二级索引」的 B+ 树找到对应的叶子节点，然后读取要查询的数据即可，这个过程叫做<strong>覆盖索引</strong>。</p><p>但是<u><strong>并不意味着，查询条件用上了索引列，就查询过程就一定都用上索引</strong></u>，接下来我们再一起看看哪些情况会导致索引失效，而发生全表扫描。</p><h4 id="1-对索引使用左或者左右模糊匹配"><a href="#1-对索引使用左或者左右模糊匹配" class="headerlink" title="1.对索引使用左或者左右模糊匹配"></a>1.对索引使用<u>左</u>或者<u>左右</u>模糊匹配</h4><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p>​🌟因为Innodb对你定义索引的字段值进行排序，如果你对字段值的左边进行模糊匹配，当然就无法对目标字段的范围进行一定程度的划分———意思就是找谁都不知道，即便你有序有什么用？</p><p>​因此右模糊匹配还是会走索引的！</p><h4 id="2-对索引使用函数"><a href="#2-对索引使用函数" class="headerlink" title="2.对索引使用函数"></a>2.对索引使用函数</h4><p>​有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，<u>如果查询条件中对索引字段使用函数，就会导致索引失效。</u></p><p>比如下面这条语句查询条件中对 name 字段使用了 LENGTH 函数，执行计划中的 type&#x3D;ALL，代表了全表扫描：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230803094403523.png" alt="image-20230803094403523"></p><h5 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h5><p>​因为存储引擎只对name进行排序，并没有对length(name)或者是任何 函数名(name)进行排序，所以索引自然得失效了！</p><p>不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即<u><strong>可以针对函数计算后的值建立一个索引</strong></u>，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</p><h4 id="3-对索引进行表达式计算"><a href="#3-对索引进行表达式计算" class="headerlink" title="3.对索引进行表达式计算"></a>3.对索引进行表达式计算</h4><p>​在查询条件中<u>对索引进行表达式计算</u>，也是无法走索引的。</p><p>​比如，下面这条查询语句，执行计划中 type &#x3D; ALL，说明是通过全表扫描的方式查询数据的：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230803094828483.png" alt="image-20230803094828483"></p><h5 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a>分析：</h5><p>​显然，对id建立索引，并没有对 (id-1) 建立索引 ——-(虽然这里id - 1 的排序结果 &#x3D;&#x3D; id 的排序结果，但是如果不是简单的加减运算而是 比如 id^2 等计算的话，可能会与原本建立索引的排序结果不相同，因此对索引进行表达式计算，也是无法走索引的！)</p><h4 id="4-对索引隐式类型转换"><a href="#4-对索引隐式类型转换" class="headerlink" title="4.对索引隐式类型转换"></a>4.对索引隐式类型转换</h4><p>涉及mysql整形&lt;&#x3D;&#x3D;&gt;字符串的自动变化：</p><p>MySQL 在<strong>遇到字符串和数字比较的时候</strong>，<u><strong>⚠️会自动把字符串转为数字，然后再进行比较⚠️</strong></u>。</p><h5 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h5><p>​如果<u>索引字段是字符串类型</u>，但是在条件查询中，<u>输入的参数是整型</u>的话，你会在执行计划的结果发现这条语句会走全表扫描。</p><p>​因为：索引字段会被自动转换成数字类型，相当于走了一个函数，因此索引失效！！</p><h5 id="例2"><a href="#例2" class="headerlink" title="例2:"></a>例2:</h5><p>​如果<u>索引字段是整型类型</u>，<u>查询条件中的输入参数即使字符串，是不会导致索引失效</u>，还是可以走索引扫描。</p><p>​因为索引字段是整形，输入参数会改变类型，变为整形，因此索引可以生效！！</p><h4 id="5-联合索引非最左匹配"><a href="#5-联合索引非最左匹配" class="headerlink" title="5.联合索引非最左匹配"></a>5.联合索引非最左匹配</h4><p>那么<strong>多个普通字段组合在一起创建的索引就叫做联合索引</strong>，也叫组合索引。</p><p>创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。</p><p>联合索引要能正确使用需要遵循<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。</p><p>🌟比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p><ul><li>where a&#x3D;1；</li><li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li><li>where a&#x3D;1 and b&#x3D;2；</li></ul><p>需要注意的是，<u>因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。(但如果没有a，是万万不行的！)</u></p><p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p><ul><li>where b&#x3D;2；</li><li>where c&#x3D;3；</li><li>where b&#x3D;2 and c&#x3D;3；</li></ul><p>⚠️有一个比较特殊的查询条件：where a &#x3D; 1 and c &#x3D; 3 ，符合最左匹配吗？</p><p>这种其实严格意义上来说是属于索引截断，不同版本处理方式也不一样。</p><ul><li>MySQL 5.5 的话，<u>前面 a 会走索引，在联合索引找到主键值后，开始回表</u>，到主键索引读取数据行，Server 层从存储引擎层获取到数据行后，然后在 Server 层再比对 c 字段的值。</li><li>从 MySQL 5.6 之后，有一个<strong>索引下推功能</strong>，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">重要细节！！！！！</span><br><span class="line"></span><br><span class="line">⚠️：范围查询后的字段无法使用索引！！！</span><br><span class="line"></span><br><span class="line">🥩：如果查询条件中有多个以 and 连接的 联合索引声明的列的查询条件，那么会按找联合索引的顺序对查询条件进行处理</span><br><span class="line"></span><br><span class="line">例：对(c,b,a)简历联合索引，那么在查询条件为：where a=1 and b=2 and c=3时，会先筛选c=3 再 b=2 最后 a=1</span><br><span class="line"></span><br><span class="line">⚠️注意：如果条件为：where a=1 and b=2 and c&gt;3，先根据c的索引找到c&gt;3的记录，但是因为「范围查询后的字段无法使用索引！」，所以a、b此时无法走索引！！！！！</span><br></pre></td></tr></table></figure><h5 id="索引下推："><a href="#索引下推：" class="headerlink" title="索引下推："></a>索引下推：</h5><p>索引下推的大概原理是：截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在 <code>(a, b, c)</code> 联合索引里的），然后<u><strong>过滤出符合条件的数据后</strong>再返回给 Server 层</u>。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。</p><p>​我们知道，对于联合索引（a, b），在执行 <code>select * from table where a &gt; 1 and b = 2</code> 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？</p><ul><li>在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。</li><li>而 MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <u><strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</u></li></ul><p>当你的查询语句的执行计划里，出现了 Extra 为 <code>Using index condition</code>，那么说明使用了索引下推的优化。</p><h4 id="6-WHERE-子句中的-OR"><a href="#6-WHERE-子句中的-OR" class="headerlink" title="6.WHERE 子句中的 OR"></a>6.WHERE 子句中的 OR</h4><p>​在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p><p>​举个例子，比如下面的查询语句，id 是主键，age 是普通列，从执行计划的结果看，是走了全表扫描。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p>这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。</p><p>要解决办法很简单，将 age 字段设置为索引即可。</p><h4 id="👍总结："><a href="#👍总结：" class="headerlink" title="👍总结："></a>👍总结：</h4><p>6 种会发生索引失效的情况：</p><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li><li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li><li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul><h3 id="索引选择"><a href="#索引选择" class="headerlink" title="索引选择"></a>索引选择</h3><p>MySQL 数据库中的优化器是怎么执行的？根据什么标准选择索引的？</p><h4 id="CBO（Cost-based-Optimizer，基于成本的优化器）"><a href="#CBO（Cost-based-Optimizer，基于成本的优化器）" class="headerlink" title="CBO（Cost-based Optimizer，基于成本的优化器）"></a>CBO（Cost-based Optimizer，基于成本的优化器）</h4><p>MySQL中，<strong>一条 SQL 的计算成本计算如下所示：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cost  = Server Cost + Engine Cost</span><br><span class="line"></span><br><span class="line">      = CPU Cost + IO Cost</span><br></pre></td></tr></table></figure><p>CPU Cost 表示计算的开销，比如<u>索引键值的比较、记录值的比较、结果集的排序</u>……这些操作都在 Server 层完成；</p><p>IO Cost 表示引擎层 IO 的开销，MySQL 8.0 可以通过区分一张表的数据是否在内存中，分别计算<u>读取内存 IO 开销以及读取磁盘 IO 的开销。</u></p><p>MySQL 优化器是 CBO，即一种基于成本的优化器。其会判单每个索引的执行成本，从中选择出最优的执行计划。总结来说：</p><ul><li><p>MySQL 优化器是 CBO 的；</p></li><li><p>MySQL 会<u>选择成本最低的执行计划</u>，你可以通过 EXPLAIN 命令查看每个 SQL 的成本；</p></li><li><p>**<u>一般只对高选择度的字段和字段组合创建索引</u>**，低选择度的字段如性别，不创建索引；</p></li><li><p>低选择性，但是**<u>数据存在倾斜</u>**，通过索引找出少部分数据，可以<u>考虑创建索引</u>；</p><ul><li><p>在电商业务中会有一个这样的逻辑：即会定期扫描字段 o_orderstatus 为支付中的订单，然后强制让其关闭，从而释放库存，给其他有需求的买家进行购买。</p><p>但字段 o_orderstatus 的状态是有限的，一般仅为已完成、支付中、超时已关闭这几种。</p><p>通常订单状态<u>绝大部分都是已完成，只有绝少部分因为系统故障原因，会在 15 分钟后还没有完成订单</u>，<strong>因此订单状态是存在数据倾斜的。</strong></p></li></ul></li><li><p>若数据存在倾斜，可以创建直方图，让优化器知道索引中数据的分布，进一步校准执行计划。</p></li></ul><h3 id="🌟索引应用-总结-："><a href="#🌟索引应用-总结-：" class="headerlink" title="🌟索引应用(总结)："></a>🌟索引应用(总结)：</h3><p>首先，我们要明白索引为什么好，然后我们再了解具体好在什么方面！</p><ol><li><p>单行访问是很慢的。特别是在机械硬盘存储中(SSD的随机 I&#x2F;O 要快很多，不过这一点仍然成立)。如果服务器从存储中读取一个数据块只是为了获取其中一行，那么就浪费了很多工作。最好读取的块中能包含尽可能多所需要的行。<u><strong>使用素引可以创建位置引用以提升效率。</strong></u></p></li><li><p>按顺序访问范围数据是很快的，这有两个原因。</p><ul><li>第一，顺序I&#x2F;O 不需要多次磁盘寻道，所以比随机 I&#x2F;O 要快很多（特别是对机械硬盘）。</li><li>第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且 GROUP BY 查询也无须再做排序和将行按组进行聚合计算了。</li></ul></li><li><p>索引覆盖查询是很快的。如果一个索引包含了查询需要的所有列，那么存储引擎就不需要再回表查找行。这避免了大量的单行访问，而上面的第1点已经写明单行访问是很慢的。</p></li></ol><h4 id="索引的优点："><a href="#索引的优点：" class="headerlink" title="索引的优点："></a>索引的优点：</h4><ul><li>整个数据库中，数据表的<u>查询速度直线提升</u>，数据量越大时效果越明显。</li><li>通过创建<u>唯一索引，可以确保数据表中的数据唯一性</u>，无需额外建立唯一约束。</li><li>在使用<u>分组和排序</u>时，同样可以显著减少<code>SQL</code>查询的分组和排序的时间。</li><li>连表查询时，基于主外键字段上建立索引，可以带来十分明显的性能提升。</li><li>索引默认是<code>B+Tree</code>有序结构，<u>基于索引字段做范围查询时，效率会明显提高</u>。</li><li>从<code>MySQL</code>整体架构而言，减少了查询<code>SQL</code>的执行时间，提高了数据库整体吞吐量。</li></ul><h4 id="索引的缺点："><a href="#索引的缺点：" class="headerlink" title="索引的缺点："></a>索引的缺点：</h4><ul><li>建立索引会生成本地磁盘文件，<u>需要额外的空间存储索引数据</u>，磁盘占用率会变高。</li><li><u><strong>写入数据时，需要额外维护索引结构</strong></u>，增、删、改数据时，都需要额外操作索引。</li><li><u><strong>写入数据</strong></u>时维护索引需要额外的时间开销，执行写<code>SQL</code>时效率会降低，性能会下降。</li></ul><h4 id="🌟主键索引最好使用带顺序性的值-比如：自增id、自增uuid-："><a href="#🌟主键索引最好使用带顺序性的值-比如：自增id、自增uuid-：" class="headerlink" title="🌟主键索引最好使用带顺序性的值(比如：自增id、自增uuid)："></a>🌟主键索引最好使用带顺序性的值(比如：自增id、自增uuid)：</h4><p>因为默认对主键建立索引，主键将被维护在B+树中，如果主键是随机的数，那么B+树将几乎在每次插入数据时重构，但如果主键有序，每次只需要将数据放到最后即可———便于维护B+树🌲</p><h4 id="🌟联合主键要注意非最左匹配的问题-详见索引失效章节"><a href="#🌟联合主键要注意非最左匹配的问题-详见索引失效章节" class="headerlink" title="🌟联合主键要注意非最左匹配的问题(详见索引失效章节)"></a>🌟联合主键要注意非最左匹配的问题(详见索引失效章节)</h4><h4 id="🌟前缀索引的弊端："><a href="#🌟前缀索引的弊端：" class="headerlink" title="🌟前缀索引的弊端："></a>🌟前缀索引的弊端：</h4><p>​前缀索引的特点是短小精悍，我们可以利用一个字段的前<code>N</code>个字符创建索引，以这种形式创建的索引也被称之为前缀索引，相较于使用一个完整字段创建索引，前缀索引能够更加节省存储空间，当数据越多时，带来的优势越明显。</p><p>​前缀索引<u>虽然带来了节省空间的好处</u>，但也正由于其索引节点中，未存储一个字段的完整值，所以<code>MySQL</code>也<u><strong>无法通过前缀索引来完成<code>ORDER BY、GROUP BY</code>等分组排序工作，同时也无法完成覆盖扫描等操作。</strong></u></p><h4 id="🌟全文索引："><a href="#🌟全文索引：" class="headerlink" title="🌟全文索引："></a>🌟全文索引：</h4><p>​可以利用全文索引代替<code>like%</code>语法实现模糊查询，它的性能会比<code>like%</code>快上<code>N</code>倍。</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>由于全文索引是基于分词实现的，所以对一个字段建立全文索引后，<code>MySQL</code>会对该字段做分词处理，这些分词结果也会被存储在全文索引中，因此全文索引的文件会额外的大！</li><li>由于全文索引对每个字段值都会做分词，因此当修改字段值后，分词是需要时间的，所以修改字段数据后不会立马自动更新全文索引，此时需要咱们写存储过程，并调用它手动更新全文索引中的数据。</li><li>除开上述两点外，全文索引最大的硬伤在于对中文支持不够友好，类似于英文可以直接通过符号、空格来分词，但中文呢？一个词语来形容就是博大精深，无法精准的对一段文字做分词，因此全文索引在检索中文时，存在些许精准度问题。</li></ul><h4 id="🌟唯一索引的利弊："><a href="#🌟唯一索引的利弊：" class="headerlink" title="🌟唯一索引的利弊："></a>🌟唯一索引的利弊：</h4><p>​查询快：不用考虑是否有多条索引值相同的记录</p><p>​插入数据慢：需要考虑是否有多条索引值相同的记录</p><h4 id="🍓建立索引时，需要遵守的一些原则："><a href="#🍓建立索引时，需要遵守的一些原则：" class="headerlink" title="🍓建立索引时，需要遵守的一些原则："></a>🍓建立索引时，需要遵守的一些原则：</h4><ul><li>经常频繁用作查询条件的字段应酌情考虑为其创建索引。</li><li>表的主外键或连表字段，必须建立索引，因为能很大程度提升连表查询的性能。</li><li>建立索引的字段，一般值的区分性要足够高，这样才能提高索引的检索效率。</li><li>建立索引的字段，值不应该过长，如果较长的字段要建立索引，可以选择前缀索引。</li><li>建立联合索引，应当遵循最左前缀原则，将多个字段之间按优先级顺序组合。</li><li>经常根据范围取值、排序、分组的字段应建立索引，因为索引有序，能加快排序时间。</li><li>对于唯一索引，如果确认不会利用该字段排序，那可以将结构改为<code>Hash</code>结构。</li><li>尽量使用联合索引代替单值索引，联合索引比多个单值索引查询效率要高。</li></ul><h4 id="🫐建立索引时还需有些注意点："><a href="#🫐建立索引时还需有些注意点：" class="headerlink" title="🫐建立索引时还需有些注意点："></a>🫐建立索引时还需有些注意点：</h4><ul><li><u>值经常会增删改的字段，不合适建立索引，</u>因为每次改变后需维护索引结构。</li><li>一个字段存在<u>大量的重复值时，不适合建立索引</u>，比如之前举例的性别字段。</li><li>索引不能参与计算，因此经常带函数查询的字段，并不适合建立索引。</li><li>一张表中的索引数量并不是越多越好，一般控制在<code>3</code>，最多不能超过<code>5</code>。</li><li><u>建立联合索引时，一定要考虑优先级，查询频率最高的字段应当放首位</u>。</li><li>当表的数据较少，不应当建立索引，因为数据量不大时，维护索引反而开销更大。</li><li><u><strong>索引的字段值无序时，不推荐建立索引</strong></u>，因为会造成页分裂，尤其是主键索引。</li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务的ACID："><a href="#事务的ACID：" class="headerlink" title="事务的ACID："></a>事务的ACID：</h3><h4 id="A–原子性-Atomicity"><a href="#A–原子性-Atomicity" class="headerlink" title="A–原子性(Atomicity):"></a>A–原子性(Atomicity):</h4><p>​一些操作要么全做、要么全不做</p><h4 id="C–一致性-Consistency-："><a href="#C–一致性-Consistency-：" class="headerlink" title="C–一致性(Consistency)："></a>C–一致性(Consistency)：</h4><p>​一致性的体现：操作执行完成后保证数据符合所有既定的约束</p><p>​例如：某个约束为：参与转账的账户的总的余额是不变的</p><h4 id="I–隔离性-Isolation"><a href="#I–隔离性-Isolation" class="headerlink" title="I–隔离性(Isolation):"></a>I–隔离性(Isolation):</h4><p>​不同的操作之间不应相互影响</p><h4 id="D–持久性-Durability"><a href="#D–持久性-Durability" class="headerlink" title="D–持久性(Durability):"></a>D–持久性(Durability):</h4><p>​在操作完成后，实现了数据的状态转换，这个转换的结果将永久地保留。</p><h3 id="事务的隔离级别："><a href="#事务的隔离级别：" class="headerlink" title="事务的隔离级别："></a>事务的隔离级别：</h3><h4 id="并行事务会引发什么问题？"><a href="#并行事务会引发什么问题？" class="headerlink" title="并行事务会引发什么问题？"></a>并行事务会引发什么问题？</h4><p>在同时处理多个事务的时候，就可能出现<strong>脏读（dirty read）</strong>、<strong>不可重复读（non-repeatable read）</strong>、<strong>幻读（phantom read）</strong>的问题。</p><h5 id="脏读："><a href="#脏读：" class="headerlink" title="脏读："></a>脏读：</h5><p>​<u>如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</u></p><h5 id="不可重复读："><a href="#不可重复读：" class="headerlink" title="不可重复读："></a>不可重复读：</h5><p>​<u>在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</u></p><p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取某数据，然后继续执行代码逻辑处理，<strong>在这过程中如果<u>事务 B 更新了这条数据，并提交了事务</u>，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。</strong></p><h5 id="幻读："><a href="#幻读：" class="headerlink" title="幻读："></a>幻读：</h5><p>​在一个事务内多次<u>查询某个符合查询条件的「记录数量」</u>，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。</p><h5 id="📖总结："><a href="#📖总结：" class="headerlink" title="📖总结："></a>📖总结：</h5><ul><li>脏读：读到其他事务未提交的数据；</li><li>不可重复读：前后读取的数据不一致；</li><li>幻读：前后读取的记录数量不一致。</li></ul><h4 id="事务的隔离级别有哪些？"><a href="#事务的隔离级别有哪些？" class="headerlink" title="事务的隔离级别有哪些？"></a>事务的隔离级别有哪些？</h4><p>​<u>上述三个现象的严重性排序：   脏读 &gt; 不可重复读 &gt; 幻读</u></p><p>SQL 标准提出了四种隔离级别来规避这些现象，<strong>隔离级别越高🔢，性能效率就越低</strong>，这四个隔离级别如下：</p><ul><li>4️⃣<strong>读未提交（<em>read uncommitted</em>）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li><li>3️⃣<strong>读提交（<em>read committed</em>）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li><li>2️⃣<strong>可重复读（<em>repeatable read</em>）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li><li>1️⃣<strong>串行化（<em>serializable</em> ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li></ul><p>​</p><p>针对不同的隔离级别，并发事务时可能发生的现象也会不同，如图：</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230804164017574.png" alt="image-20230804164017574" style="zoom:33%;" /><p>我们讨论的 <u>MySQL 虽然支持 4 种隔离级别，但是与SQL 标准中规定的各级隔离级别允许发生的现象却有些出入。</u></p><p>–MySQL中的「可重复读」比SQL标准的「可重复读」更牛！</p><p>MySQL 在「可重复读」隔离级别下，<u>可以很大程度上避免幻读现象的发生</u>（注意是很大程度避免，并不是彻底避免），所以 MySQL 并<u>不会使用「串行化」隔离级别来避免幻读现象的发生，因为使用「串行化」隔离级别会影响性能。</u></p><h5 id="MySQL-InnoDB-引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种："><a href="#MySQL-InnoDB-引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：" class="headerlink" title="MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种："></a><strong>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了）</strong>，解决的方案有两种：</h5><ul><li>针对<strong>快照读</strong>（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<u><strong>即使中途有其他事务插入了一条数据，是查询不出来这条数据的</strong></u>，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><h5 id="这四种隔离级别具体是如何实现的呢？"><a href="#这四种隔离级别具体是如何实现的呢？" class="headerlink" title="这四种隔离级别具体是如何实现的呢？"></a>这四种隔离级别具体是如何实现的呢？</h5><ul><li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li><li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li><li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 <strong>Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。<ul><li>注意，执行「开始事务」命令，并不意味着<u>启动了事务</u>。在 MySQL 有两种开启事务的命令，分别是：<ul><li>第一种：begin&#x2F;start transaction 命令；</li><li>第二种：start transaction with consistent snapshot 命令；</li></ul></li><li>这两种开启事务的命令，事务的启动时机是不同的：<ul><li>执行了 begin&#x2F;start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机；</li><li>执行了 start transaction with consistent snapshot 命令，就会马上启动事务。</li></ul></li></ul></li></ul><h4 id="Read-View-在-MVCC-里如何工作的？"><a href="#Read-View-在-MVCC-里如何工作的？" class="headerlink" title="Read View 在 MVCC 里如何工作的？"></a>Read View 在 MVCC 里如何工作的？</h4><p>​我们需要了解两个知识：</p><ul><li>Read View 中四个字段作用；</li><li>聚簇索引记录中两个跟事务有关的隐藏列；</li></ul><h5 id="Read-View中的四个字段："><a href="#Read-View中的四个字段：" class="headerlink" title="Read View中的四个字段："></a>Read View中的四个字段：</h5><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230804190142894.png" alt="image-20230804190142894"></p><ul><li>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li><li>min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值。</li><li>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1；</li><li>creator_trx_id ：指的是<strong>创建该 Read View 的事务的事务 id</strong>。</li></ul><p>知道了 Read View 的字段，我们还需要了解聚簇索引记录中的两个隐藏列。</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230804224256537.png" alt="image-20230804224256537" style="zoom: 33%;" /><ul><li><u><strong>trx_id</strong></u>：当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</li><li><u><strong>roll_pointer</strong></u>：每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</li></ul><p>在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230804224507005.png" alt="image-20230804224507005" style="zoom:40%;" /><p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p><ul><li>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</li><li>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id 值在 Read View 的<code>min_trx_id</code>和 <code>max_trx_id</code>之间，需要判断 trx_id 是否在 m_ids 列表中：<ul><li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li></ul></li></ul><p><u><strong>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</strong></u></p><h4 id="可重复读是如何工作的？读提交是如何工作的？"><a href="#可重复读是如何工作的？读提交是如何工作的？" class="headerlink" title="可重复读是如何工作的？读提交是如何工作的？"></a>可重复读是如何工作的？读提交是如何工作的？</h4><p>对于「读提交」和「可重复读」隔离级别的事务来说，它们是<u>通过 Read View 来实现的</u>，它们的区别在于创建 Read View 的时机不同：</p><ul><li>「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</li><li>「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。</li></ul><p>这两个隔离级别实现<u><strong>是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。</strong></u></p><p>在可重复读隔离级别中，<strong>普通的 select 语句</strong>就是基于 MVCC 实现的快照读，也就是不会加锁的。而 <u>select .. for update 语句就不是快照读了，而是当前读</u>了，也就是每次读都是拿到最新版本的数据，但是它会对读到的记录加上 next-key lock 锁。</p><h4 id="MySQL-可重复读隔离级别，完全解决幻读了吗？"><a href="#MySQL-可重复读隔离级别，完全解决幻读了吗？" class="headerlink" title="MySQL 可重复读隔离级别，完全解决幻读了吗？"></a>MySQL 可重复读隔离级别，完全解决幻读了吗？</h4><h5 id="1-快照读是如何避免幻读的？"><a href="#1-快照读是如何避免幻读的？" class="headerlink" title="1.快照读是如何避免幻读的？"></a>1.快照读是如何避免幻读的？</h5><p>​可重复读隔离级别是由 MVCC（多版本并发控制）实现的，实现的方式是开始事务后（执行 begin 语句后），在执行第一个查询语句后，会创建一个 Read View，<u><strong>后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的</strong>，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。</u></p><h5 id="2-当前读是如何避免幻读的？"><a href="#2-当前读是如何避免幻读的？" class="headerlink" title="2.当前读是如何避免幻读的？"></a>2.当前读是如何避免幻读的？</h5><p>MySQL 里除了普通查询是快照读，其他都是<strong>当前读</strong>，比如 <u>update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。</u></p><p>这很好理解，假设你要 update 一个记录，另一个事务已经 delete 这条记录并且提交事务了，这样不是会产生冲突吗，所以 update 的时候肯定要知道最新的数据。</p><p>另外，<code>select ... for update</code> 这种查询语句是当前读，每次执行的时候都是读取最新的数据。</p><p><strong>Innodb 引擎为了解决「可重复读」隔离级别使用「当前读」而造成的幻读问题，就引出了next-key lock</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230807143817869.png" alt="image-20230807143817869"></p><p><strong>事务 A 执行了这面这条锁定读语句后，就在对表中的记录加上 id 范围为 (2, +∞] 的 next-key lock（next-key lock 是间隙锁+记录锁的组合）。</strong></p><p>然后，事务 B 在执行插入语句的时候，判断到插入的位置被事务 A 加了 next-key lock，于是事物 B 会生成一个插入意向锁，同时进入等待状态，直到事务 A 提交了事务。这就避免了由于事务 B 插入新记录而导致事务 A 发生幻读的现象。</p><h5 id="幻读被完全解决了吗？"><a href="#幻读被完全解决了吗？" class="headerlink" title="幻读被完全解决了吗？"></a>幻读被完全解决了吗？</h5><p>**可重复读隔离级别下虽然很大程度上避免了幻读，但是还是<u>没能完全解决幻读</u>**。</p><h6 id="幻读场景1"><a href="#幻读场景1" class="headerlink" title="幻读场景1:"></a>幻读场景1:</h6><p>​<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230807144311080.png" alt="image-20230807144311080" style="zoom:50%;" /></p><p>在可重复读隔离级别下，<u>事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id &#x3D; 5 的记录并提交。接着，<strong>事务 A 对 id &#x3D; 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了</strong>，于是就发生了幻读。</u></p><p>因为这种特殊现象的存在，所以我们认为 <strong>MySQL Innodb 中的 MVCC 并不能完全避免幻读现象</strong>。</p><h6 id="幻读场景2"><a href="#幻读场景2" class="headerlink" title="幻读场景2:"></a>幻读场景2:</h6><p>除了上面这一种场景会发生幻读现象之外，还有下面这个场景也会发生幻读现象。</p><ul><li>T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。</li><li>T2 时刻：事务 B 往插入一个 id&#x3D; 200 的记录并提交；</li><li>T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。</li></ul><p><strong>🌟因为T1时刻没有 for update -&gt;进行当前读，因此没有加上next-key lock，因此导致了幻读</strong></p><p><strong>——所以我们开启事务后，要趁早添加next-key lock，即执行select … for update 这类当前读的语句，从而避免其他事务插入一条新记录。</strong></p><h2 id="锁🔒"><a href="#锁🔒" class="headerlink" title="锁🔒"></a>锁🔒</h2><h3 id="锁粒度："><a href="#锁粒度：" class="headerlink" title="锁粒度："></a>锁粒度：</h3><h4 id="1-全局锁："><a href="#1-全局锁：" class="headerlink" title="1.全局锁："></a>1.全局锁：</h4><p>​要使用全局锁，则要执行这条命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用全局锁：</span></span><br><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br><span class="line"><span class="comment">-- 释放全局锁：</span></span><br><span class="line">unlock tables</span><br></pre></td></tr></table></figure><p>​执行完后，<strong>数据库只能被查询</strong>，其他操作都不能做！！！！</p><h5 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h5><p>​全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><p>​那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。</p><h5 id="🌟既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？"><a href="#🌟既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？" class="headerlink" title="🌟既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？"></a>🌟既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？</h5><p>​有的，如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，<u>那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</u></p><p>​因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。</p><p>​备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 <code>–single-transaction</code> 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。</p><p>​InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。</p><p>​但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。</p><h4 id="2-表级锁："><a href="#2-表级锁：" class="headerlink" title="2.表级锁："></a>2.表级锁：</h4><p>MySQL 里面表级别的锁有这几种：</p><ul><li>表锁；</li><li>元数据锁（MDL）;</li><li>意向锁；</li><li>AUTO-INC 锁；</li></ul><h5 id="2-1-表锁："><a href="#2-1-表锁：" class="headerlink" title="2.1.表锁："></a>2.1.表锁：</h5><p>​表锁能够锁住一张表：一个线程对一张表添加了表锁，那么所有线程对该表的写操作都会被阻塞！</p><p>不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，<strong>InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁</strong>。</p><h5 id="2-2-元数据锁-MDL-："><a href="#2-2-元数据锁-MDL-：" class="headerlink" title="2.2.元数据锁(MDL)："></a>2.2.元数据锁(MDL)：</h5><p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p><ul><li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li><li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li></ul><p><u>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</u></p><p>​🌟<strong>当有线程在执行 select 语句（ 加 MDL <u>读</u>锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL <u>写</u>锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。</strong></p><p>​<strong>🌟反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。</strong></p><blockquote><p>MDL 不需要显示调用，那它是在什么时候释放的?</p></blockquote><p>MDL 是<u>在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</u></p><p>那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：</p><ol><li>首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；</li><li>然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；</li><li>接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，</li></ol><p>那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。</p><h5 id="2-3-意向锁："><a href="#2-3-意向锁：" class="headerlink" title="2.3.意向锁："></a>2.3.意向锁：</h5><ul><li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li><li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li></ul><p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p><p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p><p>总之：<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p><h5 id="2-4-AUTO-INC-锁："><a href="#2-4-AUTO-INC-锁：" class="headerlink" title="2.4.AUTO-INC 锁："></a>2.4.AUTO-INC 锁：</h5><p>表里的主键通常都会设置成自增的，这是通过对主键字段声明 <code>AUTO_INCREMENT</code> 属性实现的。</p><p>之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 <strong>AUTO-INC 锁</strong>实现的。</p><p>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。</p><p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p><p>那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 <code>AUTO_INCREMENT</code> 修饰的字段的值是连续递增的。</p><p>但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</p><p>因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增。</p><p>一样也是在插入数据的时候，会为被 <code>AUTO_INCREMENT</code> 修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。</p><h4 id="3-行级锁："><a href="#3-行级锁：" class="headerlink" title="3.行级锁："></a>3.行级锁：</h4><p>​行锁的释放时机是在事务提交（commit）后，锁会被释放，并不是一条语句执行完就释放行锁。</p><p>​需要注意的是，如果 update 语句的 where 条件没有用到索引列，那么就会全表扫描，在一行行扫描的过程中，不仅给行记录加上了行锁，还给行记录两边的空隙也加上了间隙锁，相当于锁住整个表，然后直到事务结束才会释放锁。</p><p>所以在线上千万不要执行没有带索引条件的 update 语句，不然会造成业务停滞</p><h5 id="3-1-记录锁：Record-Lock"><a href="#3-1-记录锁：Record-Lock" class="headerlink" title="3.1.记录锁：Record Lock"></a>3.1.记录锁：Record Lock</h5><p>​Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁( 类似读锁 )和 X 锁( 类似写锁 )之分的：</p><ul><li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li><li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</li></ul><h5 id="3-2-间隙锁：Gap-Lock"><a href="#3-2-间隙锁：Gap-Lock" class="headerlink" title="3.2.间隙锁：Gap Lock"></a>3.2.间隙锁：Gap Lock</h5><p>​Gap Lock **<u>只存在于可重复读隔离级别</u>**，目的是<u>为了解决可重复读隔离级别下幻读的现象</u>。</p><p>假设，表中有一个范围 id 为（3，5）间隙锁，那么<strong>其他事务就<u>无法插入</u> id &#x3D; 4 这条记录了</strong>，这样就有效的防止幻读现象的发生。</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230806093108438.png" alt="image-20230806093108438" style="zoom:50%;" /><p>⚠️间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，<strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong>。</p><h5 id="3-3-临键锁：Next-Key-Lock"><a href="#3-3-临键锁：Next-Key-Lock" class="headerlink" title="3.3.临键锁：Next-Key Lock"></a>3.3.临键锁：Next-Key Lock</h5><p>Next-Key Lock 称为临键锁，是 <u><strong>Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</strong></u></p><p>假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id &#x3D; 4 记录，也不能修改 id &#x3D; 5 这条记录。</p><p><strong>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。—-因为记录X锁不能兼容</p><h5 id="3-4-插入意向锁："><a href="#3-4-插入意向锁：" class="headerlink" title="3.4.插入意向锁："></a>3.4.插入意向锁：</h5><p>​一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。</p><p>如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p><p>举个例子，假设事务 A 已经对表加了一个范围 id 为（3，5）间隙锁。</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230806093108438.png" alt="image-20230806093108438" style="zoom:50%;" /><p>当事务 A 还没提交的时候，事务 B 向该表插入一条 id &#x3D; 4 的新记录，这时会判断到插入的位置已经被事务 A 加了间隙锁，于是事物 B 会生成一个插入意向锁，然后将锁的状态设置为等待状态（<em>PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁</em>），此时事务 B 就会发生阻塞，直到事务 A 提交了事务。</p><p>插入意向锁名字虽然有意向锁，但是它并<strong>不是意向锁，它是一种特殊的间隙锁，属于行级别锁</strong>。</p><p>如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。</p><p>插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。</p><h5 id="☄️两条更新语句更新同一条记录，加的是什么锁？"><a href="#☄️两条更新语句更新同一条记录，加的是什么锁？" class="headerlink" title="☄️两条更新语句更新同一条记录，加的是什么锁？"></a>☄️两条更新语句更新同一条记录，加的是什么锁？</h5><p>在可重复读级别下，加锁的基本单位是next-key锁，但是在一些场景下，会退化成记录锁或者问隙锁。这个题目更新同一条记录，就认为是等值查询的场景。要考虑这几种情况：</p><h6 id="第一种情况：如果更新条件的字段是唯一索引，加什么锁？"><a href="#第一种情况：如果更新条件的字段是唯一索引，加什么锁？" class="headerlink" title="第一种情况：如果更新条件的字段是唯一索引，加什么锁？"></a>第一种情况：如果更新条件的字段是唯一索引，加什么锁？</h6><p>当我们用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：</p><ul><li>当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 <strong>next-key lock会退化成「记录锁」。</strong></li><li>当查询的记录是「不存在」的，在素引(树找到第一条大于该查询记录的记录后，将该记录的索引中的<strong>next-key lock 会退化成「间隙锁」。</strong></li></ul><h6 id="第二种情况：如果更新条件的字段是非唯一索引，加什么锁？"><a href="#第二种情况：如果更新条件的字段是非唯一索引，加什么锁？" class="headerlink" title="第二种情况：如果更新条件的字段是非唯一索引，加什么锁？"></a>第二种情况：如果更新条件的字段是非唯一索引，加什么锁？</h6><p>即非唯一索引等值查询</p><p>当我们用非唯一索引进行等值查询的时候，因为存在两个索引，一个是主键索引，一个是非唯一索引（二级索引），所以在加锁时，同时会对这两个索引都加锁，但是对主键索引加锁的时候，只有满足查询条件的记录才会对它们的主键索引加锁。</p><p>针对非唯一索引等值查询时，查询的记录存不存在，加锁的规则也会不同：</p><ul><li>当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是<strong>非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是next-key 锁，而对于第一个不符合条件的二级索引记录，该二级素引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁。</strong></li><li>当查询的记录「不存在」时，<strong>扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁。</strong></li></ul><h6 id="第三种情况：如果更新条件的字段没有索引，加什么锁？"><a href="#第三种情况：如果更新条件的字段没有索引，加什么锁？" class="headerlink" title="第三种情况：如果更新条件的字段没有索引，加什么锁？"></a>第三种情况：如果更新条件的字段没有索引，加什么锁？</h6><p>即没有加索引的查询</p><p>前面的案例，我们的查询语向都有使用索引查询，也就是查询记录的时候，是通过索引扫描的方式查询的，然后对扫描出来的记录进行加锁。</p><p><strong>如果锁定读查询语句，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞。</strong></p><h3 id="死锁："><a href="#死锁：" class="headerlink" title="死锁："></a>死锁：</h3><p>​</p><h4 id="Insert-语句是怎么加行级锁的？"><a href="#Insert-语句是怎么加行级锁的？" class="headerlink" title="Insert 语句是怎么加行级锁的？"></a>Insert 语句是怎么加行级锁的？</h4><p>Insert 语句在正常执行时是不会生成锁结构的，它是靠聚簇索引记录自带的 trx_id 隐藏列来作为<strong>隐式锁</strong>来保护记录的。</p><blockquote><p>什么是隐式锁？</p></blockquote><p>当事务需要加锁的时，<u>如果这个锁不可能发生冲突，InnoDB会跳过加锁环节，这种机制称为隐式锁</u>。隐式锁是 InnoDB 实现的一种延迟加锁机制，其特点是只有在可能发生冲突时才加锁，从而减少了锁的数量，提高了系统整体性能。</p><p>隐式锁就是在 Insert 过程中不加锁，只有在特殊情况下，才会将隐式锁转换为显示锁，这里我们列举两个场景。</p><ul><li>如果记录之间加有间隙锁，为了避免幻读，此时是不能插入记录的；<ul><li>每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，如果已加间隙锁，此时会生成一个插入意向锁，然后锁的状态设置为等待状态（<em>PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁</em>），现象就是 Insert 语句会被阻塞。</li></ul></li><li>如果 Insert 的记录和已有记录存在唯一键冲突，此时也不能插入记录；<ul><li>如果在插入新记录时，插入了一个与「已有的记录的主键或者唯一二级索引列值相同」的记录（不过可以有多条记录的唯一二级索引列的值同时为NULL，这里不考虑这种情况），此时插入就会失败，然后对于这条记录加上了 <strong>S 型的锁</strong>。<ul><li>如果<u>主键索引重复</u>，插入新记录的事务会给已存在的主键值重复的聚簇索引记录<strong>添加 S 型记录锁</strong>。</li><li>如果<u>唯一二级索引重复</u>，插入新记录的事务都会给已存在的二级索引列值重复的二级索引记录<strong>添加 S 型 next-key 锁</strong>。</li></ul></li></ul></li></ul><h4 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h4><p>​死锁的四个必要条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。</p><p>在数据库层面，有两种策略通过「打破循环等待条件」来解除死锁状态：</p><ul><li><p><strong>设置事务等待锁的超时时间</strong>。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 <code>innodb_lock_wait_timeout</code> 是用来设置超时时间的，默认值时 50 秒。</p><p>当发生超时后，就出现下面这个提示：</p></li></ul><p><img src="https://cdn.xiaolincoding.com//mysql/other/c296c1889f0101d335699311b4ef20a8.png" alt="图片"></p><ul><li><p><strong>开启主动死锁检测</strong>。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑，默认就开启。</p><p>当检测到死锁后，就会出现下面这个提示：</p></li></ul><p><img src="https://cdn.xiaolincoding.com//mysql/other/f380ef357d065498d8d54ad07f145e09.png" alt="图片"></p><p>上面这个两种策略是「当有死锁发生时」的避免方式。</p><p>我们可以回归业务的角度来预防死锁，对订单做幂等性校验的目的是为了保证不会出现重复的订单，那我们可以直接将 order_no 字段设置为唯一索引列，利用它的唯一性来保证订单表不会出现重复的订单，不过有一点不好的地方就是在我们插入一个已经存在的订单记录时就会抛出异常。</p><h4 id="一道面试题："><a href="#一道面试题：" class="headerlink" title="一道面试题："></a>一道面试题：</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230807154158632.png" alt="image-20230807154158632" style="zoom: 33%;" /><p>按题中顺序执行，会发生什么？</p><h5 id="Time1"><a href="#Time1" class="headerlink" title="Time1:"></a>Time1:</h5><p>​**此时事务 A 在主键索引（INDEX_NAME : PRIMARY）上加了间隙锁，锁范围是<code>(20, 30)</code>**。</p><h5 id="Time2"><a href="#Time2" class="headerlink" title="Time2:"></a>Time2:</h5><p>​**事务 B 在主键索引（INDEX_NAME : PRIMARY）上加了间隙锁，锁范围是<code>(20, 30)</code>**。</p><h5 id="Time3"><a href="#Time3" class="headerlink" title="Time3:"></a>Time3:</h5><p>​事务 A 的状态为等待状态（LOCK_STATUS: WAITING），因为向事务 B 生成的间隙锁（范围 <code>(20, 30)</code>）中插入了一条记录，<u>所以事务 A 的插入操作生成了一个插入意向锁</u></p><p>​<strong>尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。所以，插入意向锁和间隙锁之间是冲突的</strong>。</p><p><u><strong>因此事务A会等待事务B在主键范围20~30上的间隙锁释放！</strong></u></p><h5 id="Time4"><a href="#Time4" class="headerlink" title="Time4:"></a>Time4:</h5><p>​事务B会等待事务A在主键范围20~30上的间隙锁释放</p><p>​</p><p>📖 事务 A 和事务 B 在执行完后 update 语句后都持有范围为<code>(20, 30）</code>的间隙锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，满足了死锁的四个条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>，因此发生了死锁。</p><h5 id="总结🌟："><a href="#总结🌟：" class="headerlink" title="总结🌟："></a>总结🌟：</h5><p>​两个事务即使生成的间隙锁的范围是一样的，也不会发生冲突，因为<u>间隙锁目的是为了防止其他事务插入数据，因此间隙锁与间隙锁之间是相互兼容的。</u></p><p>​<u><strong>在执行插入语句时，如果插入的记录在其他事务持有间隙锁范围内，插入语句就会被阻塞，因为插入语句在碰到间隙锁时，会生成一个插入意向锁，然后插入意向锁和间隙锁之间是互斥的关系。</strong></u></p><p>​<u>如果两个事务分别向对方持有的间隙锁范围内插入一条记录，而插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，满足了死锁的四个条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>，因此发生了死锁。</u></p><h4 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h4><p>在工作过程中偶尔会遇到死锁问题，虽然这种问题遇到的概率不大，但每次遇到的时候要想彻底弄懂其原理并找到解决方案却并不容易。其实，对于 MySQL 的 InnoDb 存储引擎来说，死锁问题是避免不了的，没有哪种解决方案可以说完全解决死锁问题，但是我们可以通过一些可控的手段，降低出现死锁的概率。</p><ol><li>对索引加锁顺序的不一致很可能会导致死锁，所以如果可以，尽量以相同的顺序来访问索引记录和表。在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能；</li><li>Gap 锁往往是程序中导致死锁的真凶，由于默认情况下 MySQL 的隔离级别是 RR，所以如果能确定幻读和不可重复读对应用的影响不大，可以考虑将隔离级别改成 RC，可以避免 Gap 锁导致的死锁；</li><li>为表添加合理的索引，如果不走索引将会为表的每一行记录加锁，死锁的概率就会大大增大；</li><li>我们知道 MyISAM 只支持表锁，它采用一次封锁技术来保证事务之间不会发生死锁，所以，我们也可以使用同样的思想，在事务中一次锁定所需要的所有资源，减少死锁概率；</li><li>避免大事务，尽量将大事务拆成多个小事务来处理；因为大事务占用资源多，耗时长，与其他事务冲突的概率也会变高；</li><li>避免在同一时间点运行多个对同一表进行读写的脚本，特别注意加锁且操作数据量比较大的语句；我们经常会有一些定时脚本，避免它们在同一时间点运行；</li><li>设置锁等待超时参数：<code>innodb_lock_wait_timeout</code>，这个参数并不是只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获得所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖跨数据库。我们通过设置合适的锁等待超时阈值，可以避免这种情况发生。</li></ol><h3 id="悲观锁与乐观锁："><a href="#悲观锁与乐观锁：" class="headerlink" title="悲观锁与乐观锁："></a>悲观锁与乐观锁：</h3><h4 id="悲观锁："><a href="#悲观锁：" class="headerlink" title="悲观锁："></a>悲观锁：</h4><p><strong>悲观锁（Pessimistic Lock）：</strong> 就是很悲观，每次去拿数据的时候都认为别人会修改。所以每次在拿数据的时候都会上锁。这样别人想拿数据就被挡住，直到悲观锁被释放，<strong>悲观锁中的共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong></p><p>但是在效率方面，处理加锁的机制会产生额外的开销，还有增加产生死锁的机会。另外还会降低并行性，如果已经锁定了一个线程 A，其他线程就必须等待该线程 A 处理完才可以处理</p><p>数据库中的行锁，表锁，读锁（共享锁），写锁（排他锁），以及 <strong>syncronized</strong> 实现的锁均为悲观锁</p><p>悲观并发控制实际上是“<strong>先取锁再访问</strong>”的保守策略，为数据处理的安全提供了保证</p><h4 id="乐观锁："><a href="#乐观锁：" class="headerlink" title="乐观锁："></a>乐观锁：</h4><p><strong>乐观锁（Optimistic Lock）：</strong> 就是很乐观，每次去拿数据的时候都认为别人不会修改。所以不会上锁，<u>但是如果想要更新数据，则会在更新前检查在读取至更新这段时间别人有没有修改过这个数据。如果修改过，则重新读取，再次尝试更新，循环上述步骤直到更新成功（当然也允许更新失败的线程放弃操作）,<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong></u></p><p>相对于悲观锁，在对数据库进行处理的时候，乐观锁<u>并不会使用数据库提供的锁机制</u>。<u><strong>一般的实现乐观锁的方式就是记录数据版本（version）或者是时间戳来实现，不过使用版本记录是最常用的。</strong></u></p><p>—-&gt;为数据添加一列version，用于version管理</p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="MySQL-日志：undo-log、redo-log、binlog-有什么用？"><a href="#MySQL-日志：undo-log、redo-log、binlog-有什么用？" class="headerlink" title="MySQL 日志：undo log、redo log、binlog 有什么用？"></a>MySQL 日志：undo log、redo log、binlog 有什么用？</h3><ul><li><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</li><li><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</li><li><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li></ul><h4 id="为什么需要-undo-log？"><a href="#为什么需要-undo-log？" class="headerlink" title="为什么需要 undo log？"></a>为什么需要 undo log？</h4><p>如果我们每次在事务执行过程中，都记录下回滚时需要的信息到一个日志里，那么在事务执行中途发生了 MySQL 崩溃后，就不用担心无法回滚到事务之前的数据，我们可以通过这个日志回滚到事务之前的数据。</p><p>实现这一机制就是 <strong>undo log（回滚日志），它保证了事务的 <a href="https://xiaolincoding.com/mysql/transaction/mvcc.html#%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7">ACID 特性 (opens new window)</a>中的原子性（Atomicity）</strong>。</p><p>undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。</p><p><u><strong>一条记录的每一次更新操作产生的 undo log 格式都有一个 roll_pointer 指针和一个 trx_id 事务id：</strong></u></p><ul><li>通过 trx_id 可以知道该记录是被哪个事务修改的；</li><li>通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链；</li></ul><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230808100304687.png" alt="image-20230808100304687" style="zoom:50%;" /><h5 id="🌟undo-log-两大作用："><a href="#🌟undo-log-两大作用：" class="headerlink" title="🌟undo log 两大作用："></a>🌟undo log 两大作用：</h5><ul><li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li><li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li></ul><h4 id="为什么需要-Buffer-Pool？"><a href="#为什么需要-Buffer-Pool？" class="headerlink" title="为什么需要 Buffer Pool？"></a>为什么需要 Buffer Pool？</h4><p>​Innodb 存储引擎设计了一个<strong>缓冲池（Buffer Pool）</strong>，来提高数据库的读写性能。</p><p>​有了 Buffer Pool 后：</p><ul><li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li><li>当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。</li></ul><p>Buffer Pool中还有Undo页，用于记录undo log：</p><p>​开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。</p><h4 id="为什么需要-redo-log-？"><a href="#为什么需要-redo-log-？" class="headerlink" title="为什么需要 redo log ？"></a>为什么需要 redo log ？</h4><p>​Buffer Pool 是提高了读写效率没错，但是问题来了，Buffer Pool 是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。</p><p>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，<strong>这个时候更新就算完成了</strong>。</p><p>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <strong>WAL （Write-Ahead Logging）技术</strong>。</p><p><strong>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>。</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230808101725828.png" alt="image-20230808101725828" style="zoom: 45%;" /><p>redo log 是物理日志，记录了某个数据页做了什么修改，比如<strong>对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新</strong>，每当执行一个事务就会产生这样的一条或者多条物理日志。</p><p>在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。</p><p>当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。</p><ul><li>redo log 记录了此次事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值；</li><li>undo log 记录了此次事务「<strong>开始前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值；</li></ul><p>⚠️<u><strong>事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务</strong></u></p><h5 id="redo-log-要写到磁盘，数据也要写磁盘，为什么要多此一举？"><a href="#redo-log-要写到磁盘，数据也要写磁盘，为什么要多此一举？" class="headerlink" title="redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？"></a>redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？</h5><p>写入 redo log 的方式使用了追加操作， 所以磁盘操作是<strong>顺序写</strong>，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是<strong>随机写</strong>。</p><p>磁盘的「顺序写 」比「随机写」 高效的多，因此 redo log 写入磁盘的开销更小。</p><p>可以说这是 WAL 技术的另外一个优点：<strong>MySQL 的写操作从磁盘的「随机写」变成了「顺序写」</strong>，提升语句的执行性能。这是因为 MySQL 的写操作并不是立刻更新到磁盘上，而是先记录在日志上，然后在合适的时间再更新到磁盘上 。</p><p>⚠️至此， 针对为什么需要 redo log 这个问题我们有两个答案：</p><ul><li><strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li><li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。</li></ul><h5 id="redo-log直接写入磁盘吗？"><a href="#redo-log直接写入磁盘吗？" class="headerlink" title="redo log直接写入磁盘吗？"></a>redo log直接写入磁盘吗？</h5><p>redo log 也会先被保存在内存中的<strong>redo log buffer</strong>中，一定时机下存入磁盘——因为如果每条redo log都立即存入磁盘会增加I&#x2F;O开销，大大降低性能。</p><h5 id="redo-log-buffer何时写入磁盘："><a href="#redo-log-buffer何时写入磁盘：" class="headerlink" title="redo log buffer何时写入磁盘："></a>redo log buffer何时写入磁盘：</h5><ul><li>MySQL 正常关闭时；</li><li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li><li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li><li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制，别的参数代表别的方案）</li></ul><h5 id="redo-log-文件写满了怎么办？"><a href="#redo-log-文件写满了怎么办？" class="headerlink" title="redo log 文件写满了怎么办？"></a>redo log 文件写满了怎么办？</h5><p>默认情况下， InnoDB 存储引擎有 1 个重做日志文件组( redo log Group），「重做日志文件组」由有 2 个 redo log 文件组成，这两个 redo 日志的文件名叫 ：<code>ib_logfile0</code> 和 <code>ib_logfile1</code> 。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84.drawio.png" alt="重做日志文件组"></p><p>在重做日志组中，每个 redo log File 的大小是固定且一致的，假设每个 redo log File 设置的上限是 1 GB，那么总共就可以记录 2GB 的操作。</p><p>重做日志文件组是以<strong>循环写</strong>的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形。</p><p>所以 InnoDB 存储引擎会先写 ib_logfile0 文件，当 ib_logfile0 文件被写满的时候，会切换至 ib_logfile1 文件，当 ib_logfile1 文件也被写满时，会切换回 ib_logfile0 文件。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B.drawio.png" alt="重做日志文件组写入过程"></p><p>我们知道 redo log 是为了防止 Buffer Pool 中的脏页丢失而设计的，那么如果随着系统运行，Buffer Pool 的脏页刷新到了磁盘中，那么 redo log 对应的记录也就没用了，这时候我们擦除这些旧记录，以腾出空间记录新的更新操作。</p><h4 id="为什么需要-binlog-？"><a href="#为什么需要-binlog-？" class="headerlink" title="为什么需要 binlog ？"></a>为什么需要 binlog ？</h4><p>—-记录了所有<strong>数据库表结构变更和表数据修改</strong>的日志</p><p>前面介绍的 undo log 和 redo log 这两个日志都是 <u>Innodb 存储引擎生成</u>的。</p><p>MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后<u>事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件。</u></p><p>binlog 文件是<u>记录了所有<strong>数据库表结构变更和表数据修改</strong>的日志</u>，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。</p><h5 id="redo-log-和-binlog-有什么区别？"><a href="#redo-log-和-binlog-有什么区别？" class="headerlink" title="redo log 和 binlog 有什么区别？"></a>redo log 和 binlog 有什么区别？</h5><p>这两个日志有四个区别。</p><p><em>1、适用对象不同：</em></p><ul><li>binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；</li><li>redo log 是 Innodb 存储引擎实现的日志；</li></ul><p><em>2、文件格式不同：</em></p><ul><li>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：<ul><li>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；</li><li>ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；</li><li>MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</li></ul></li><li>redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；</li></ul><p><em>3、写入方式不同：</em></p><ul><li>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</li><li>redo log 是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。</li></ul><p><em>4、用途不同：</em></p><ul><li>binlog 用于备份恢复、主从复制；</li><li>redo log 用于掉电等故障恢复。</li></ul><p>如果不小心整个数据库的数据被删除了，只能使用binlog恢复数据库，redolog文件为循环写机制，边写边擦除，只留有最新的操作</p><h5 id="MySQL主从复制："><a href="#MySQL主从复制：" class="headerlink" title="MySQL主从复制："></a>MySQL主从复制：</h5><p>MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上。</p><p>这个过程一般是<strong>异步</strong>的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="MySQL 主从复制过程"></p><p>MySQL 集群的主从复制过程梳理成 3 个阶段：</p><ul><li><strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据。</li><li><strong>同步 Binlog</strong>：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。</li><li><strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据。</li></ul><p>具体详细过程如下：</p><ul><li>MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。</li><li>从库会创建一个专门的 I&#x2F;O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。</li><li>从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。</li></ul><p>在完成主从复制之后，你就可以在写数据时只写主库，在读数据时只读从库，这样即使写请求会锁表或者锁记录，也不会影响读请求的执行。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="MySQL 主从架构"></p><h5 id="binlog-什么时候刷盘？"><a href="#binlog-什么时候刷盘？" class="headerlink" title="binlog 什么时候刷盘？"></a>binlog 什么时候刷盘？</h5><p>事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，再把 binlog cache 写到 binlog 文件中。</p><p>一个事务的 binlog 是不能被拆开的，因此无论这个事务有多大（比如有很多条语句），也要保证一次性写入。这是因为有一个线程只能同时有一个事务在执行的设定，所以每当执行一个 begin&#x2F;start transaction 的时候，就会默认提交上一个事务，这样如果一个事务的 binlog 被拆开的时候，在备库执行就会被当做多个事务分段自行，这样破坏了原子性，是有问题的。</p><p>MySQL 给每个线程分配了一片内存用于缓冲 binlog ，该内存叫 binlog cache，参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p><h5 id="为什么需要两阶段提交？"><a href="#为什么需要两阶段提交？" class="headerlink" title="为什么需要两阶段提交？"></a>为什么需要两阶段提交？</h5><p>​事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。<strong>因为 redo log 影响主库的数据，binlog 影响从库的数据，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致。</strong></p><h5 id="两阶段提交的实现过程："><a href="#两阶段提交的实现过程：" class="headerlink" title="两阶段提交的实现过程："></a>两阶段提交的实现过程：</h5><p>​事务的提交过程有两个阶段，就是<strong>将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog</strong>，具体如下：</p><ul><li><strong>prepare 阶段</strong>：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit &#x3D; 1 的作用）；</li><li><strong>commit 阶段</strong>：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog &#x3D; 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功；</li></ul><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230808110410810.png" alt="image-20230808110410810" style="zoom: 43%;" /><h5 id="事务没提交的时候，redo-log-会被持久化到磁盘吗？"><a href="#事务没提交的时候，redo-log-会被持久化到磁盘吗？" class="headerlink" title="事务没提交的时候，redo log 会被持久化到磁盘吗？"></a>事务没提交的时候，redo log 会被持久化到磁盘吗？</h5><p>会的。</p><p>事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些缓存在 redo log buffer 里的 redo log 也会被「后台线程」每隔一秒一起持久化到磁盘。</p><p>也就是说，<strong>事务没提交的时候，redo log 也是可能被持久化到磁盘的</strong>。</p><p>有的同学可能会问，如果 mysql 崩溃了，还没提交事务的 redo log 已经被持久化磁盘了，mysql 重启后，数据不就不一致了？</p><p>放心，这种情况 mysql 重启会进行回滚操作，因为事务没提交的时候，binlog 是还没持久化到磁盘的。</p><p>所以， redo log 可以在事务没提交之前持久化到磁盘，但是 binlog 必须在事务提交之后，才可以持久化到磁盘。</p><h4 id="🌟总结："><a href="#🌟总结：" class="headerlink" title="🌟总结："></a>🌟总结：</h4><p>具体更新一条记录 <code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1;</code> 的流程如下:</p><ol><li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id &#x3D; 1 这一行记录：<ul><li>如果 id&#x3D;1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li><li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li></ul></li><li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：<ul><li>如果一样的话就不进行后续更新流程；</li><li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li></ul></li><li>开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li><li>InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 <strong>WAL 技术</strong>，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</li><li>至此，一条记录更新完了。</li><li>在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li><li>事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：<ul><li><strong>prepare 阶段</strong>：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li><li><strong>commit 阶段</strong>：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；</li></ul></li><li>至此，一条更新语句执行完成。</li></ol><h3 id="数据库备份：备份文件也要检查！"><a href="#数据库备份：备份文件也要检查！" class="headerlink" title="数据库备份：备份文件也要检查！"></a>数据库备份：备份文件也要检查！</h3><h4 id="全量备份："><a href="#全量备份：" class="headerlink" title="全量备份："></a>全量备份：</h4><h5 id="1-逻辑备份："><a href="#1-逻辑备份：" class="headerlink" title="1. 逻辑备份："></a>1. 逻辑备份：</h5><p>指备份数据库的逻辑内容，就是每张表中的内容<u>通过 INSERT 语句的形式进行备份</u>。</p><p>MySQL 官方提供的逻辑备份工具有 <strong>mysqldump 和 mysqlpump</strong></p><p>mysqldump：单线程</p><p>mysqlpump：基于表的多线程，<u>不同表可以同时备份</u>(不能构建一个一致性的备份)</p><h5 id="2-物理备份："><a href="#2-物理备份：" class="headerlink" title="2. 物理备份："></a>2. 物理备份：</h5><p>逻辑备份虽然好，但是它所需要的时间比较长，因为本质上逻辑备份就是进行 INSERT … SELECT … 的操作。</p><p>而<u>物理备份直接备份数据库的物理表空间文件和重做日志，不用通过逻辑的 SELECT 取出数据</u>。所以物理备份的速度，通常是比逻辑备份快的，恢复速度也比较快。</p><p>但它不如 mydumper 的是，<u><strong>物理备份只能恢复整个实例的数据，而不能按指定表进行恢复</strong></u>。MySQL 8.0 的物理备份工具可以选择官方的 Clone Plugin。</p><h4 id="增量备份："><a href="#增量备份：" class="headerlink" title="增量备份："></a>增量备份：</h4><p>​我们需要通过“全量备份 + 增量备份”的方式，构建完整的备份策略。<strong>增量备份就是对日志文件进行备份，在 MySQL 数据库中就是二进制日志文件。</strong></p><p>​因为二进制日志保存了对数据库所有变更的修改，所以“全量备份 + 增量备份”，就可以实现基于时间点的恢复（point in time recovery），也就是“通过全量 + 增量备份”可以恢复到任意时间点。</p><p>​MySQL 增量备份的本质是通过 mysqlbinlog 模拟一个 slave 从服务器，然后主服务器不断将二进制日志推送给从服务器，利用之前介绍的复制技术，实现数据库的增量备份。</p><p>增量备份的恢复，就是通过 mysqlbinlog 解析二进制日志，然后进行恢复</p><h4 id="备份策略："><a href="#备份策略：" class="headerlink" title="备份策略："></a>备份策略：</h4><p>在掌握全量备份、增量备份的知识点后，我们就能构建自己的备份策略了。</p><p>首先，我们要设置全量备份的频率，因为全量备份比较大，所以建议设置 1 周 1 次全量备份，实时增量备份的频率。这样最坏的情况就是要恢复 7 天前的一个全备，然后通过 7 天的增量备份恢复。</p><p>对于备份文件，也需要进行备份。我们不能认为备份文件的存储介质不会损坏。所以，至少在 2 个机房的不同存储服务器上存储备份文件，即备份文件至少需要 2 个副本。至于备份文件的保存期限，取决于每个公司自己的要求（比如有的公司要求永久保存，有的公司要求保留至少近 3 个月的备份文件）。</p><p>所有的这些备份策略，都需要自己的备份系统进行调度，这个并没有什么特别好的开源项目，需要根据自己的业务需求，定制开发。</p><h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><h3 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a>benchmark</h3><p>mysql性能测试：<a href="https://developer.aliyun.com/article/250710">https://developer.aliyun.com/article/250710</a></p><h3 id="🌟explain执行计划"><a href="#🌟explain执行计划" class="headerlink" title="🌟explain执行计划"></a>🌟explain执行计划</h3><p>​一条查询语句在经过MySQL**<u>查询优化器</u>**的各种基于成本和规则的优化会后<u>生成一个所谓的执行计划</u>，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。</p><p>​设计MySQL的大叔贴心的为我们提供了EXPLAIN语句来<u><strong>帮助我们查看某个查询语句的具体执行计划</strong></u>，本章的内容就是为了帮助大家看懂EXPLAIN语句的各个输出项都是干嘛使的，从而可以有针对性的提升我们查询语句的性能。</p><h4 id="1-查看某条查询语句的执行计划："><a href="#1-查看某条查询语句的执行计划：" class="headerlink" title="1. 查看某条查询语句的执行计划："></a>1. 查看某条查询语句的执行计划：</h4><p>​在查询语句前加上 explain 即可</p><h4 id="2-explain执行计划中每个列的含义："><a href="#2-explain执行计划中每个列的含义：" class="headerlink" title="2. explain执行计划中每个列的含义："></a>2. explain执行计划中每个列的含义：</h4><p>​先把EXPLAIN 语句输出的各个列的作用先大致罗列一下：</p><p>​<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230809143140850.png" alt="image-20230809143140850" style="zoom:50%;" /></p><h5 id="table："><a href="#table：" class="headerlink" title="table："></a>table：</h5><p>​EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名。</p><p>——每条记录的table列中只有一个表名、如果查询语句中查了多个表，那么就会有多条执行计划记录，每个记录的table中只有一个表</p><h5 id="id："><a href="#id：" class="headerlink" title="id："></a>id：</h5><p>​mysql为每个select语句分配一个id，其中：</p><ul><li><u><strong>连接查询</strong></u>中出现的几个表的**<u>id是相同</u>**的，出现在前面的表是主表，出现在后面的表是从表<ul><li>对于连接查询来说，一个 SELECT 关键字后边的 FROM 子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的</li></ul></li><li>对于<u><strong>包含子查询的查询语句</strong></u>来说，就可能涉及多个 SELECT 关键字，所以在包含子查询的查询语句的执行计划中，<u>每个 SELECT 关键字都会对应一个<strong>唯一</strong>的 id 值</u><ul><li>⚠️但是，<u>查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询</u>。所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，**<u>直接查看执行计划就好了，如果子查询的执行计划中多条记录的id相同，那么说明语句被重写！</u>**</li></ul></li></ul><h5 id="select-type："><a href="#select-type：" class="headerlink" title="select_type："></a>select_type：</h5><p>SIMPLE：简单 SELECT，不需要使用 UNION 操作或子查询。<br>PRIMARY：如果查询包含子查询，最外层的 SELECT 被标记为 PRIMARY；或者UNION语句的最左边的查询<br>UNION：UNION 操作中第二个或后面的 SELECT 语句。<br>SUBQUERY：子查询中的第一个 SELECT。<br>DERIVED：派生表的 SELECT 子查询。（从一个刚select出来的表中查询）</p><p>……</p><h5 id="type："><a href="#type：" class="headerlink" title="type："></a>type：</h5><p>mysql对某个表执行查询时的访问方法</p><ul><li><p>system</p><ul><li>当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是 system 。</li></ul></li><li><p>const</p><ul><li>当我们根据主键或者唯一二级索引列与<u>常数进行等值匹配</u>时，对单表的访问方法就是 const</li></ul></li><li><p>eq_ref</p><ul><li>⚠️<u>针对被驱动表的执行计划</u></li><li>在连接查询时，如果<u><strong>被驱动表</strong></u>是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是eq_ref</li></ul></li><li><p>ref</p><ul><li>当**<u>通过普通的二级索引列与常量进行等值匹配</u>**时来查询某个表，那么对该表的访问方法就可能是 ref</li></ul></li><li><p>range</p><ul><li>如果使用索引获取某些 <u>范围区间</u> 的记录，那么就可能使用到 range 访问方法</li></ul></li><li><p>index</p><ul><li>当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是 index</li></ul></li><li><p>all</p><ul><li>全表扫描</li></ul></li></ul><h5 id="possible-keys和key："><a href="#possible-keys和key：" class="headerlink" title="possible_keys和key："></a>possible_keys和key：</h5><p>​可能用到的索引、用到的索引</p><h5 id="key-len："><a href="#key-len：" class="headerlink" title="key_len："></a>key_len：</h5><p>​key_len 列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度，它是由这三个部分构成的：</p><ul><li>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是 VARCHAR(100) ，使用的字符集是 utf8 ，那么该列实际占用的最大存储空间就是 100 × 3 &#x3D; 300 个字节。</li><li>如果该索引列可以存储 NULL 值，则 key_len 比不可以存储 NULL 值时多1个字节。</li><li>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</li></ul><h5 id="ref："><a href="#ref：" class="headerlink" title="ref："></a>ref：</h5><p>当使用索引列等值匹配的条件去执行查询时，也就是在<u>访问方法是 const 、 eq_ref 、 ref 、 ref_or_null 、unique_subquery 、 index_subquery 其中之一时</u>， <u><strong>ref 列展示的就是与索引列作等值匹配的东东是个啥，比如只是一个常数或者是某个列。</strong></u></p><h5 id="rows："><a href="#rows：" class="headerlink" title="rows："></a>rows：</h5><p>​如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的 rows 列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的 rows 列就代表预计扫描的索引记录行数。</p><h5 id="Extra："><a href="#Extra：" class="headerlink" title="Extra："></a>Extra：</h5><p>​顾名思义， Extra 列是用来说明一些额外信息的，我们可以通过这些额外信息来更准确的<u><strong>理解 MySQL 到底将如何执行给定的查询语句。</strong></u></p><p>—大多数是报错信息</p><ul><li>No tables used —— 当查询语句的<u>没有 FROM 子句</u>时将会提示该额外信息</li><li>Impossible WHERE —— 查询语句的 WHERE 子句永远为 FALSE 时将会提示该额外信息</li><li>No matching min&#x2F;max row —— 当查询列表处有 MIN 或者 MAX 聚集函数，但是<u>并没有符合 WHERE 子句中的搜索条件的记录时，将会提示该额外信息，</u></li></ul><h3 id="索引调优"><a href="#索引调优" class="headerlink" title="索引调优"></a>索引调优</h3><ul><li><p>虽然例如性别字段只有两个取值(比如 male、female)选择性低，但是如果几乎每个查询都会用到sex列的话，我们有必要对其建立索引，并通过下面的小技巧，在查询没有使用sex的列时绕过：</p><ul><li>在查询条件中添加条件：SEX IN (‘male’, ‘female’);即可！</li><li>上面这种技巧只<u><strong>适用于绕过建立了索引但选择性低的列</strong></u></li></ul></li><li><p>尽可能将需要做范围查询的列(如 age)放到索引的后面，以便优化器能使用尽可能多的索引列</p></li><li><p>如果遇到一条sql语句中有两个范围查询，很遗憾，并没有直接的优化方式。我们只能通过 <u>构造新列、转换概念</u> 等方式尝试将某一个范围查询转换为等值查询</p></li><li><p>🌟对于海量数据的分页查询进行优化：</p><ul><li><p>即使<u>有索引</u>，如果用户界面上需要翻页，并且翻页翻到比较靠后时查询也可能非常慢。下面这个查询就通过 ORDER BY和 LIMIT 偏移量的组合翻页到很后面的时候 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT &lt;cols&gt; FROM profiles WHERE sex=&#x27;M&#x27;ORDER BY rating LIMIT 100000, 10</span><br></pre></td></tr></table></figure><p>无论如何创建索引，这种查询都是个严重的问题。**<u>因为随着偏移量的增加，MySQL需要花费大量的时间来扫描需要丢弃的数据</u><strong>。反范式化、预先计算和缓存可能是解决这类查询的仅有策略。一个更好的办法是限制用户能够翻页的数量，实际上这对用户体验的影响不大，因为用户很少会真正在乎搜索结果的第 10 000 页。<br>⚠️优化这类索引的另一个比较好的策略是使用延迟关联，</strong><u>通过使用覆盖索引查询返回需要的主键，再根据这些主键关联原表获得需要的行</u>**。这可以减少 MySQL 扫描那些需要丢弃的行数。下面这个查询显示了如何高效地使用(sex, rating)索引进行排序和分页。</p></li><li><pre><code class="mysql">mysql&gt; SELECT &lt;cols&gt; FROM profiles where 某主键列 in(  SELECT &lt; 某主键列 &gt; FROM profiles  WHERE X.sex=&#39;M&#39; ORDER BY rating LIMIT 100000，10  );<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### SQL优化</span><br><span class="line"></span><br><span class="line">参考文章：[SQL优化篇:如何成为一位写优质SQL语句的绝顶高手!](https://juejin.cn/post/7163894728201601060#heading-7)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### MySQL性能优化</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230816135517270.png&quot; alt=&quot;image-20230816135517270&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">- **SQL 语句和索引相关问题是最常见的，带来的价值也是最明显的**；</span><br><span class="line">- 系统配置库表结构带来的价值次之；</span><br><span class="line">- 而硬件层次的优化优先级是不高的。</span><br><span class="line"></span><br><span class="line">#### 1. 硬件配置：</span><br><span class="line"></span><br><span class="line">现在我们基本上都是使用云服务器，就会涉及服务器配置选型，对于数据库处理复杂 SQL 而言，尽量选择高频 CPU，而且数据库一般都会**开辟缓存池来存放数据**，所以在服务器选型的时候内存大小也需要考虑。一般来说**数据库服务器的硬件配置的重要性高于应用服务器配置**，这方面了解下即可，测试工作基本上不会涉及数据库服务器的选型，而且一旦选型固定之后不会轻易改变数据库的硬件配置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2. MySQL系统配置选项：</span><br><span class="line"></span><br><span class="line">##### 1）max_connections</span><br><span class="line"></span><br><span class="line">这个参数表示 MySQL 可以**接收到的最大连接数**，可以直接通过如下命令查看：</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">show variables like &#x27;%max_connections%&#x27;;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>如果 max_connections 的值设置较小，在高并发的情况下易出现 “<strong>too many connections</strong>” 这样的报错，我们可以通过如下命令调节配置从而减少此问题的发生，你可以根据所在公司的实际情况进行配置。</p><h5 id="2）innodb-buffer-pool-size"><a href="#2）innodb-buffer-pool-size" class="headerlink" title="2）innodb_buffer_pool_size"></a>2）innodb_buffer_pool_size</h5><p>这个参数实际定义了 <strong>InnoDB 存储引擎下 MySQL 的内存缓冲区(buffer_pool)大小</strong></p><p>我们可以通过计算缓存命中率来判断，公式为：</p><blockquote><p>(1-innodb_buffer_pool_reads &#x2F; innodb_buffer_pool_read_request) * 100</p></blockquote><p>一般来说，<strong>当缓存命中率低于 90% 就说明需要加大缓冲池了。</strong></p><p>关于公式中的两个变量的查看方式，通过如下命令你就可以获得：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">show</span> status <span class="keyword">like</span>  <span class="string">&#x27;Innodb_buffer_pool_read_%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------+----------+</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> Variable_name                         <span class="operator">|</span> <span class="keyword">Value</span>    <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------+----------+</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> Innodb_buffer_pool_read_ahead_rnd     <span class="operator">|</span> <span class="number">0</span>        <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> Innodb_buffer_pool_read_ahead         <span class="operator">|</span> <span class="number">51</span>       <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> Innodb_buffer_pool_read_ahead_evicted <span class="operator">|</span> <span class="number">0</span>        <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> Innodb_buffer_pool_read_requests      <span class="operator">|</span> <span class="number">25688179</span> <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> Innodb_buffer_pool_reads              <span class="operator">|</span> <span class="number">2171</span>     <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------+----------+</span></span><br></pre></td></tr></table></figure><h4 id="3-SQL-优化"><a href="#3-SQL-优化" class="headerlink" title="3. SQL 优化"></a>3. SQL 优化</h4><p>常见的问题是索引缺失、索引失效</p><p>​造成的原因分别是：添加条件判断的字段未建立索引、添加了索引但未生效，具体内容前面「索引」章节详细介绍过。</p><p>​查看sql语句的执行计划，对其索引使用情况进行分析，具体内容在「explain执行计划」中详细介绍过。</p><p>本博客对以下文章有参考借鉴，十分感谢这些作者的文章🙏：</p><ul><li><p>执行一条 select 语句，期间发生了什么？<a href="https://xiaolincoding.com/mysql/base/how_select.html)https://xiaolincoding.com/mysql/base/how_select.html">https://xiaolincoding.com/mysql/base/how_select.html)https://xiaolincoding.com/mysql/base/how_select.html</a></p></li><li><p>MySQL引擎篇：<a href="https://juejin.cn/post/7151275584218202143">https://juejin.cn/post/7151275584218202143</a></p></li><li><p>MySQL 一行记录是怎么存储的？<a href="https://xiaolincoding.com/mysql/base/row_format.html">https://xiaolincoding.com/mysql/base/row_format.html</a></p></li><li><p>MySQL中char与varchar的区别：存储机制、性能差异：<a href="https://www.maoyingdong.com/mysql-char-vs-varchar/">https://www.maoyingdong.com/mysql-char-vs-varchar/</a></p></li><li><p>从数据页的角度看 B+ 树：<a href="https://xiaolincoding.com/mysql/index/page.html">https://xiaolincoding.com/mysql/index/page.html</a></p></li><li><p>揭开 Buffer Pool 的面纱：<a href="https://xiaolincoding.com/mysql/buffer_pool/buffer_pool.html">https://xiaolincoding.com/mysql/buffer_pool/buffer_pool.html</a></p></li><li><p>普通索引和唯一索引，应该怎么选择？<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2">https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2</a></p></li><li><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%98%E5%AE%9D%E5%85%B8">https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%98%E5%AE%9D%E5%85%B8</a></p><ul><li>08 索引：排序的艺术</li><li>09 索引组织表：万物皆索引</li><li>10 组合索引：用好，性能提升 10 倍！</li><li>11 索引出错：请理解 CBO 的工作原理</li><li>18 如何才能优化 MySQL 性能？</li><li>21 数据库备份：备份文件也要检查！</li></ul></li><li><p>为什么 MySQL 采用 B+ 树作为索引？<a href="https://xiaolincoding.com/mysql/index/why_index_chose_bpuls_tree.html">https://xiaolincoding.com/mysql/index/why_index_chose_bpuls_tree.html</a></p></li><li><p>索引失效有哪些？<a href="https://xiaolincoding.com/mysql/index/index_lose.html">https://xiaolincoding.com/mysql/index/index_lose.html</a></p></li><li><p>建立索引的正确姿势与使用索引的最佳指南！<a href="https://juejin.cn/post/7149074488649318431">https://juejin.cn/post/7149074488649318431</a></p></li><li><p>索引常见面试题：<a href="https://xiaolincoding.com/mysql/index/index_interview.html">https://xiaolincoding.com/mysql/index/index_interview.html</a></p></li><li><p>事务隔离级别是怎么实现的？<a href="https://xiaolincoding.com/mysql/transaction/mvcc.html">https://xiaolincoding.com/mysql/transaction/mvcc.html</a></p></li><li><p>MySQL 可重复读隔离级别，完全解决幻读了吗？<a href="https://xiaolincoding.com/mysql/transaction/phantom.html">https://xiaolincoding.com/mysql/transaction/phantom.html</a></p></li><li><p>MySQL 有哪些锁？<a href="https://xiaolincoding.com/mysql/lock/mysql_lock.html">https://xiaolincoding.com/mysql/lock/mysql_lock.html</a></p></li><li><p>MySQL 是怎么加锁的？(校招可不掌握)<a href="https://xiaolincoding.com/mysql/lock/how_to_lock.html">https://xiaolincoding.com/mysql/lock/how_to_lock.html</a></p></li><li><p>MySQL 死锁了，怎么办？<a href="https://xiaolincoding.com/mysql/lock/deadlock.html">https://xiaolincoding.com/mysql/lock/deadlock.html</a></p></li><li><p>字节面试：加了什么锁，导致死锁的？<a href="https://xiaolincoding.com/mysql/lock/show_lock.html">https://xiaolincoding.com/mysql/lock/show_lock.html</a></p></li><li><p>MySQL 日志：undo log、redo log、binlog 有什么用？<a href="https://xiaolincoding.com/mysql/log/how_update.html">https://xiaolincoding.com/mysql/log/how_update.html</a></p></li><li><p><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">好文推荐</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 原理学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2023/07/27/SpringMVC/"/>
      <url>/2023/07/27/SpringMVC/</url>
      
        <content type="html"><![CDATA[<p>本博客是根据韩顺平老师的SpingMVC课程进行的知识总结！</p>]]></content>
      
      
      <categories>
          
          <category> Spring开发框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实操中遇到的后端开发相关问题与解决方案</title>
      <link href="/2023/07/24/%E5%AE%9E%E6%93%8D%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2023/07/24/%E5%AE%9E%E6%93%8D%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="java："><a href="#java：" class="headerlink" title="java："></a>java：</h1><h3 id="流的使用："><a href="#流的使用：" class="headerlink" title="流的使用："></a>流的使用：</h3><ol><li>需求：将得到的对象List 根据某一属性进行分组(例如你需要根据分别对产品id的每种情况进行讨论)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 用于存储从每条记录中得到的有效信息</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InfoDTO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long equipmentId;</span><br><span class="line">    <span class="keyword">private</span> Boolean isSuccess;</span><br><span class="line">    <span class="keyword">private</span> Date actingTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InfoDTO</span><span class="params">(Long equipmentId, Date actingTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.equipmentId = equipmentId;</span><br><span class="line">        <span class="built_in">this</span>.actingTime = actingTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InfoDTO</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ArrayList&lt;InfoDTO&gt; successInfo = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//填充successInfo，此处省略       </span></span><br><span class="line">Map&lt;Long,List&lt;InfoDTO&gt;&gt; groupedList = successInfo.stream().collect(Collectors.groupingBy(InfoDTO::getEquipmentId));</span><br></pre></td></tr></table></figure><h3 id="Map中，值的自增、自减操作的简单写法："><a href="#Map中，值的自增、自减操作的简单写法：" class="headerlink" title="Map中，值的自增、自减操作的简单写法："></a>Map中，值的自增、自减操作的简单写法：</h3><p>应用场景：查询Map中的某一key值，如果有就+1，如果没有就put进value &#x3D; 1</p><p>🐌原本的写法：判断是否存在key，如果存在则取出value， + 1后再put回去；如果没有就put(key，1)进入</p><p>现在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">&quot;你要找的key&quot;</span>, map.getOrDefault(<span class="string">&quot;你要找的key&quot;</span>, <span class="number">0</span>) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="将本地代码打jar包上传服务器并测试运行："><a href="#将本地代码打jar包上传服务器并测试运行：" class="headerlink" title="将本地代码打jar包上传服务器并测试运行："></a>将本地代码打jar包上传服务器并测试运行：</h3><h4 id="1-将本地项目代码打jar包-idea中"><a href="#1-将本地项目代码打jar包-idea中" class="headerlink" title="1.将本地项目代码打jar包(idea中)"></a>1.将本地项目代码打jar包(idea中)</h4><ul><li>Command + ; 打开项目结构界面，创建jar包</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20231215140746859.png" alt="image-20231215140746859"></p><ul><li>进入页面后，选择需要创建jar包的主类，点击确定后再应用</li></ul><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20231215141013951.png" alt="image-20231215141013951" style="zoom: 50%;" /><ul><li>之后再根据需要构建工件即可在生成目录中得到jar包</li></ul><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20231215141350692.png" alt="image-20231215141350692" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20231215141517041.png" alt="image-20231215141517041" style="zoom:50%;" /><h4 id="2-将jar包上传到服务器指定目录"><a href="#2-将jar包上传到服务器指定目录" class="headerlink" title="2.将jar包上传到服务器指定目录"></a>2.将jar包上传到服务器指定目录</h4><ul><li>使用sftp与服务器建立连接，使用put方法将本地jar包上传至服务器</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put localfilepath remotefilepath</span><br></pre></td></tr></table></figure><h4 id="3-在服务器对应目录运行jar包进行测试"><a href="#3-在服务器对应目录运行jar包进行测试" class="headerlink" title="3.在服务器对应目录运行jar包进行测试"></a>3.在服务器对应目录运行jar包进行测试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxxx.jar</span><br></pre></td></tr></table></figure><h1 id="数据库："><a href="#数据库：" class="headerlink" title="数据库："></a>数据库：</h1><h3 id="动态查询："><a href="#动态查询：" class="headerlink" title="动态查询："></a>动态查询：</h3><h5 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h5><p>​有许多同类型的表(表名前缀相同，都是类似于xxxx202209 –&gt; 公共前缀+年月信息)，由于数据量庞大按月份分成了多张表，我们需要根据前端请求中携带的年月信息去查询不同的表</p><h5 id="实现方案："><a href="#实现方案：" class="headerlink" title="实现方案："></a>实现方案：</h5><p>​使用拦截器，(按照我目前的理解。。)对数据库查询语句进行拦截，当查询表名为公共前缀时，就获取请求头传来的日期信息，凭借成完整的表名，去对应的表中查询！</p><h5 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.springbootinit.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.DynamicTableNameInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> miemie</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018-08-10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.nrec.springbootinit.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="type">DynamicTableNameInnerInterceptor</span> <span class="variable">dynamicTableNameInnerInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicTableNameInnerInterceptor</span>();</span><br><span class="line">        dynamicTableNameInnerInterceptor.setTableNameHandler((sql, tableName) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;这里填哪些相同结构表名的公共前缀&quot;</span>.equals(tableName)) &#123;</span><br><span class="line">              <span class="comment">//这里，我在controller中，用户请求时，就将date信息存放在请求参数传递辅助类的 map 中，因此在这里可以获取</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">dateSuf</span> <span class="operator">=</span> RequestDataHelper.getRequestData(<span class="string">&quot;date&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;公共前缀&quot;</span> + dateSuf;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//如果不是我要查询的表，那么就还是按原来的表名查询</span></span><br><span class="line">                <span class="keyword">return</span> tableName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        interceptor.addInnerInterceptor(dynamicTableNameInnerInterceptor);</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.xxx.springbootinit.config;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.toolkit.CollectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求参数传递辅助类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDataHelper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求参数存取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; REQUEST_DATA = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置请求参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestData 请求参数 MAP 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setRequestData</span><span class="params">(Map&lt;String, Object&gt; requestData)</span> &#123;</span><br><span class="line">        REQUEST_DATA.set(requestData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取请求参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param 请求参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 请求参数 MAP 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getRequestData</span><span class="params">(String param)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; dataMap = getRequestData();</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(dataMap)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) dataMap.get(param);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取请求参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 请求参数 MAP 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title function_">getRequestData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> REQUEST_DATA.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//controller层示例接口：</span></span><br><span class="line"> <span class="meta">@GetMapping(&quot;/query&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResultDTO <span class="title function_">query</span><span class="params">(<span class="meta">@RequestParam(&quot;date&quot;)</span>String date)</span>&#123;</span><br><span class="line">        RequestDataHelper.setRequestData(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&quot;date&quot;</span>, date);&#125;&#125;);</span><br><span class="line">      <span class="comment">//继续写业务。。。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux:"></a>Linux:</h1><h3 id="xxx-用户名-不在-sudoers文件中，此事将被报告-解决方案"><a href="#xxx-用户名-不在-sudoers文件中，此事将被报告-解决方案" class="headerlink" title="xxx(用户名) 不在 sudoers文件中，此事将被报告 解决方案"></a>xxx(用户名) 不在 sudoers文件中，此事将被报告 解决方案</h3><p>执行<strong>sudo</strong>时提示“XXX 不在sudoers文件中，此事将被报告”</p><p><strong>解释</strong>：sudo命令可以让你以root身份执行命令，来完成一些我们这个账号完成不了的任务。但是并非所有用户都能够执行sudo，因为有权限的用户都在&#x2F;etc&#x2F;sudoers中。</p><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20231215161542383.png" alt="image-20231215161542383" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 项目开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目开发 </tag>
            
            <tag> 经验总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2023/07/16/Spring/"/>
      <url>/2023/07/16/Spring/</url>
      
        <content type="html"><![CDATA[<p> 本博客参照了韩顺平老师的 Spring 课程讲义！</p><h1 id="1-Spring-基本介绍"><a href="#1-Spring-基本介绍" class="headerlink" title="1 Spring 基本介绍"></a>1 Spring 基本介绍</h1><h2 id="1-1-官方资料"><a href="#1-1-官方资料" class="headerlink" title="1.1 官方资料"></a>1.1 官方资料</h2><h3 id="1-1-1-官网-https-spring-io"><a href="#1-1-1-官网-https-spring-io" class="headerlink" title="1.1.1 官网 https://spring.io/"></a>1.1.1 官网 <a href="https://spring.io/">https://spring.io/</a></h3><h3 id="1-1-2-Spring5-下载"><a href="#1-1-2-Spring5-下载" class="headerlink" title="1.1.2 Spring5 下载"></a>1.1.2 Spring5 下载</h3><p>……</p><h3 id="1-1-3-在线文档-https-docs-spring-io-spring-framework-docs-current-reference-html"><a href="#1-1-3-在线文档-https-docs-spring-io-spring-framework-docs-current-reference-html" class="headerlink" title="1.1.3 在线文档: https://docs.spring.io/spring-framework/docs/current/reference/html/"></a>1.1.3 在线文档: <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/">https://docs.spring.io/spring-framework/docs/current/reference/html/</a></h3><h3 id="1-1-4-离线文档-解压-spring-5-3-8-dist-zipspring-framework-5-3-8-docs-reference-html-index-html"><a href="#1-1-4-离线文档-解压-spring-5-3-8-dist-zipspring-framework-5-3-8-docs-reference-html-index-html" class="headerlink" title="1.1.4 离线文档 : 解压 spring-5.3.8-dist.zipspring-framework-5.3.8\docs\reference\html\index.html"></a>1.1.4 离线文档 : 解压 spring-5.3.8-dist.zipspring-framework-5.3.8\docs\reference\html\index.html</h3><h3 id="1-1-5-离线API-解压-spring-5-3-8-dist-zipspring-framework-5-3-8-docs-javadoc-api-index-html"><a href="#1-1-5-离线API-解压-spring-5-3-8-dist-zipspring-framework-5-3-8-docs-javadoc-api-index-html" class="headerlink" title="1.1.5 离线API: 解压 spring-5.3.8-dist.zipspring-framework-5.3.8\docs\javadoc-api\index.html"></a>1.1.5 离线API: 解压 spring-5.3.8-dist.zipspring-framework-5.3.8\docs\javadoc-api\index.html</h3><h2 id="1-2-Spring-学习的核心内容"><a href="#1-2-Spring-学习的核心内容" class="headerlink" title="1.2 Spring 学习的核心内容"></a>1.2 Spring 学习的核心内容</h2><p>一图胜千言</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230716213809556.png" alt="image-20230716213809556"></p><p>老韩解读上图:</p><p>1、Spring 核心学习内容 IOC、AOP, jdbcTemplate, 声明式事务</p><p>2、IOC: 控制反转 , 可以管理 java 对象</p><p>3、AOP : 切面编程</p><p>4、 JDBCTemplate : 是 spring 提供一套访问数据库的技术, 应用性强，相对好理解</p><p>5、声明式事务: 基于 ioc&#x2F;aop 实现事务管理, 理解需要小伙伴花时间</p><p>6、IOC, AOP 是重点同时难点</p><h2 id="1-3-Spring-几个重要概念"><a href="#1-3-Spring-几个重要概念" class="headerlink" title="1.3 Spring 几个重要概念"></a>1.3 Spring 几个重要概念</h2><ol><li>Spring 可以整合其他的框架(老韩解读: Spring 是管理框架的框架)</li><li>Spring 有两个核心的概念: <strong>IOC</strong> 和 <strong>AOP</strong></li><li>IOC [Inversion Of Control 反转控制]</li></ol><h3 id="●-传统的开发模式-JdbcUtils-x2F-反射"><a href="#●-传统的开发模式-JdbcUtils-x2F-反射" class="headerlink" title="● 传统的开发模式[JdbcUtils &#x2F; 反射]"></a>● 传统的开发模式[JdbcUtils &#x2F; 反射]</h3><p>程序——&gt;环境 &#x2F;&#x2F;程序读取环境配置，然后自己创建对象.</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230716214351358.png" alt="image-20230716214351358"></p><p>老韩解读上图(以连接到数据库为例说明)</p><p>1、<strong>程序员编写程序, 在程序中读取配置信息</strong></p><p>2、**(程序员)创建对象**, new Object???() || 反射方式</p><p>3、使用对象完成任务</p><h3 id="●-IOC-的开发模式-EmpAction-EmpService-EmpDao-Emp"><a href="#●-IOC-的开发模式-EmpAction-EmpService-EmpDao-Emp" class="headerlink" title="● IOC 的开发模式 [EmpAction EmpService EmpDao Emp]"></a>● IOC 的开发模式 [EmpAction EmpService EmpDao Emp]</h3><p>程序&lt;—–容器 &#x2F;&#x2F;<strong>容器创建好对象，程序直接使用</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230716214640935.png" alt="image-20230716214640935"></p><p>老韩解读上图</p><p>1、<u>Spring 根据配置文件 xml || 注解, 创建对象</u>， 并放入到容器(如：ConcurrentHashMap)中,并且可以完成对象之间的依赖</p><p>2、**<u>当需要使用某个对象实例的时候, 就直接从容器中获取即可</u>**</p><p>3、程序员可以更加关注如何使用对象完成相应的业务  (以前是 new … &#x3D;&#x3D;&gt; 注解&#x2F;配置方式)</p><p>4、<strong>DI—Dependency Injection 依赖注入</strong>，可以理解成是 IOC 的另外叫法.</p><p>5、Spring最大的价值，通过配置，<strong>给程序提供需要使用的web 层</strong>[Servlet(Action&#x2F;Controller)]&#x2F;Service&#x2F;Dao&#x2F;[JavaBean&#x2F;entity]<strong>对象</strong>,这个是核心价值所在，也是 ioc 的具体体现, 实现了解耦</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230716220144385.png" alt="image-20230716220144385" style="zoom:50%;" /><h2 id="1-4-Spring-快速入门"><a href="#1-4-Spring-快速入门" class="headerlink" title="1.4 Spring 快速入门"></a>1.4 Spring 快速入门</h2><h3 id="1-4-1-需求说明"><a href="#1-4-1-需求说明" class="headerlink" title="1.4.1 需求说明"></a>1.4.1 需求说明</h3><ol><li>通过 Spring 的方式[配置文件]， 获取 JavaBean: Monster 的对象， 并给该的对象属性赋值， 输出该对象信息</li></ol><h3 id="1-4-2-完成步骤"><a href="#1-4-2-完成步骤" class="headerlink" title="1.4.2 完成步骤"></a>1.4.2 完成步骤</h3><p>……</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      1. 配置monster对象/javabean</span></span><br><span class="line"><span class="comment">      2. 在beans中可以配置多个bean</span></span><br><span class="line"><span class="comment">      3. bean表示就是一个java对象</span></span><br><span class="line"><span class="comment">      4. class属性是用于指定类的全路径-&gt;spring底层使用反射创建</span></span><br><span class="line"><span class="comment">      5. 🌟id属性表示该java对象在spring容器中的id, 通过id可以获取到对象</span></span><br><span class="line"><span class="comment">      6. &lt;property name=&quot;monsterId&quot; value=&quot;100&quot;&gt; 用于给该对象的属性赋值</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Monster&quot;</span> <span class="attr">id</span>=<span class="string">&quot;monster01&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monsterId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;牛魔王&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;skill&quot;</span> <span class="attr">value</span>=<span class="string">&quot;芭蕉扇&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Monster&quot;</span> <span class="attr">id</span>=<span class="string">&quot;monster02&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monsterId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1001&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;牛魔王~&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;skill&quot;</span> <span class="attr">value</span>=<span class="string">&quot;芭蕉扇~&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-3-注意事项和细节"><a href="#1-4-3-注意事项和细节" class="headerlink" title="1.4.3 注意事项和细节"></a>1.4.3 注意事项和细节</h3><h4 id="1、-说明"><a href="#1、-说明" class="headerlink" title="1、 说明"></a>1、 说明</h4><p>ClassPathXmlApplicationContext ioc &#x3D;new ClassPathXmlApplicationContext(“beans.xml”);</p><p>——为什么读取到 beans.xml</p><h4 id="2、解释一下类加载路径-可以给学员输出一下"><a href="#2、解释一下类加载路径-可以给学员输出一下" class="headerlink" title="2、解释一下类加载路径. 可以给学员输出一下:"></a>2、解释一下类加载路径. 可以给学员输出一下:</h4><p>&#x2F;&#x2F; 获取「<strong>类加载路径</strong>」</p><p>&#x2F;&#x2F; File f &#x3D; new File(this.getClass().getResource(“&#x2F;“).getPath());</p><p>&#x2F;&#x2F; System.out.println(f);</p><p>—输出——项目文件夹\工程名\out\production\工程名</p><h4 id="3、debug-看看-spring-容器结构-x2F-机制-记住你是-OOP-程序员-重要"><a href="#3、debug-看看-spring-容器结构-x2F-机制-记住你是-OOP-程序员-重要" class="headerlink" title="3、debug 看看 spring 容器结构&#x2F;机制, 记住你是 OOP 程序员,重要!"></a>3、debug 看看 spring 容器结构&#x2F;机制, 记住你是 OOP 程序员,重要!</h4><ul><li>老韩说明: 注意配置 debugger, 否则你看到的 debug 视图和老师不一样</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230717215641546.png" alt="image-20230717215641546"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230717215726473.png" alt="image-20230717215726473"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230717215817159.png" alt="image-20230717215817159"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230717215902732.png" alt="image-20230717215902732"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230717215925529.png" alt="image-20230717215925529"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230717220000530.png" alt="image-20230717220000530"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230717220027499.png" alt="image-20230717220027499"></p><h4 id="4、ioc-structure-summary："><a href="#4、ioc-structure-summary：" class="headerlink" title="4、ioc structure summary："></a>4、ioc structure summary：</h4><p>ioc容器(ClassPathXmlApplicationContext)：</p><p>——beanFactory(DefaultListableBeanFactory)</p><p>————beanDefinitionMap(ConcurrentHashMap)</p><p>——————table(ConcurrentHashMap$Node[512])</p><p>——————可以存放beans.xml中的bean节点配置的bean对象信息</p><p>——————<strong>key是 在beans.xml中配置的bean的id，value是这个bean的各种信息(如：属性、属性值、类信息、是不是懒加载等信息)</strong></p><p>————singletonObjects(ConcurrentHashMap)</p><p>——————table(ConcurrentHashMap$Node[512])</p><p>——————在beans.xml文件中配置的对象默认是单例的，会初始化在该table中；还有一些spring初始化的——————单例对象</p><p>————beanDefinitionNames(ArrayList)</p><p>————存放了beans.xml中，所有配置的bean的id，方便查看</p><p><strong>用户想要一个对象—&gt;先去beanDefinitionMap的table中找其定义的位置看看：如果是多例，则直接创建一个对象并返回；如果是单例的，则去singletonObjects的table中取出事先创建好的对象返回给用户</strong></p><h2 id="1-5-手动开发-简单的-Spring-基于-XML-配置的程序"><a href="#1-5-手动开发-简单的-Spring-基于-XML-配置的程序" class="headerlink" title="1.5 手动开发- 简单的 Spring 基于 XML 配置的程序"></a>1.5 手动开发- 简单的 Spring 基于 XML 配置的程序</h2><h3 id="1-5-1-需求说明"><a href="#1-5-1-需求说明" class="headerlink" title="1.5.1 需求说明"></a>1.5.1 需求说明</h3><ol><li><p>自己写一个简单的 Spring 容器, 通过读取 beans.xml， 获取第 1 个 JavaBean: Monster 的对象， 并给该的对象属性赋值， 放入到容器中, 输出该对象信息.</p></li><li><p>也就是说，不使用 Spring 原生框架，我们自己简单模拟实现</p></li><li><p>可以让小伙伴了解 Spring 容器的简单机制</p></li></ol><h3 id="1-5-2-思路分析"><a href="#1-5-2-思路分析" class="headerlink" title="1.5.2 思路分析"></a>1.5.2 思路分析</h3><ol><li>思路分析&#x2F;图解</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230718083350279.png" alt="image-20230718083350279"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.spring.hspapplicationcontext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.study.spring.bean.Monster;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 韩顺平</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 老师解读</span></span><br><span class="line"><span class="comment"> * 1. 这个程序用于实现Spring的一个简单容器机制</span></span><br><span class="line"><span class="comment"> * 2. 后面我们还会详细的实现</span></span><br><span class="line"><span class="comment"> * 3. 这里我们实现如何将beans.xml文件进行解析，并生成对象,放入容器中</span></span><br><span class="line"><span class="comment"> * 4. 提供一个方法 getBean(id) 返回对应的对象</span></span><br><span class="line"><span class="comment"> * 5. 这里就是一个开胃小点心, 理解Spring容器的机制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HspApplicationContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, Object&gt; singletonObjects =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//接收一个容器的配置文件 比如 beans.xml, 该文件默认在src</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HspApplicationContext</span><span class="params">(String iocBeanXmlFile)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 得到类加载路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getResource(<span class="string">&quot;/&quot;</span>).getPath();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 创建 Saxreader</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 得到Document对象</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span></span><br><span class="line">                saxReader.read(<span class="keyword">new</span> <span class="title class_">File</span>(path + iocBeanXmlFile));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 得到rootDocument</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">rootElement</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 得到第一个bean-monster01</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">bean</span> <span class="operator">=</span> (Element) rootElement.elements(<span class="string">&quot;bean&quot;</span>).get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 获取到第一个bean-monster01的相关属性</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> bean.attributeValue(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">classFullPath</span> <span class="operator">=</span> bean.attributeValue(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">        List&lt;Element&gt; property = bean.elements(<span class="string">&quot;property&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历-&gt;老师简化直接获取</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">monsterId</span> <span class="operator">=</span></span><br><span class="line">                Integer.parseInt(property.get(<span class="number">0</span>).attributeValue(<span class="string">&quot;value&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> property.get(<span class="number">1</span>).attributeValue(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">skill</span> <span class="operator">=</span> property.get(<span class="number">2</span>).attributeValue(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. 使用反射创建对象.=&gt; 回顾反射机制</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(classFullPath);</span><br><span class="line">        <span class="comment">//这里o对象就是Monster对象</span></span><br><span class="line">        <span class="type">Monster</span> <span class="variable">o</span> <span class="operator">=</span> (Monster) aClass.newInstance();</span><br><span class="line">        <span class="comment">//给o对象赋值</span></span><br><span class="line">        <span class="comment">//反射来赋值=&gt; 这里老师就简化，直接赋值-&gt;目的就是先理解流程</span></span><br><span class="line">        <span class="comment">//这里的方法就是setter方法</span></span><br><span class="line">        <span class="comment">//Method[] declaredMethods = aClass.getDeclaredMethods();</span></span><br><span class="line">        <span class="comment">//for (Method declaredMethod : declaredMethods) &#123;</span></span><br><span class="line">        <span class="comment">//    declaredMethod.invoke();</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        o.setMonsterId(monsterId);</span><br><span class="line">        o.setName(name);</span><br><span class="line">        o.setSkill(skill);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//8. 将创建好的对象放入到singletonObjects</span></span><br><span class="line">        singletonObjects.put(id, o);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="comment">//这里小伙伴可以再处理</span></span><br><span class="line">        <span class="keyword">return</span> singletonObjects.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-6-🌟Spring-原生容器底层结构"><a href="#1-6-🌟Spring-原生容器底层结构" class="headerlink" title="1.6 🌟Spring 原生容器底层结构"></a>1.6 🌟Spring 原生容器底层结构</h2><h3 id="1-6-1-一图胜千言"><a href="#1-6-1-一图胜千言" class="headerlink" title="1.6.1 一图胜千言"></a>1.6.1 一图胜千言</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230718105740683.png" alt="image-20230718105740683"></p><h3 id="1-6-2-课后作业题"><a href="#1-6-2-课后作业题" class="headerlink" title="1.6.2 课后作业题"></a>1.6.2 课后作业题</h3><ol><li>在 beans.xml 中， 我们注入 2 个 Monster 对象, 但是不指定 id,如下</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.beans.Monster&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monsterId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1010&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;牛魔王~&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;skill&quot;</span> <span class="attr">value</span>=<span class="string">&quot;芭蕉扇~&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.beans.Monster&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monsterId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;牛魔王~~!!&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;skill&quot;</span> <span class="attr">value</span>=<span class="string">&quot;芭蕉扇~~&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>问题 1：运行会不会报错</li></ol><ul><li>答：不会报错，会正常运行</li></ul><ol start="3"><li>问题 2：如果不报错, 你能否找到分配的 id, 并获得到该对象.</li></ol><ul><li>答：<strong>系统会默认分配 id</strong> ,<u>分配 id 的规则是 全类名#0 , 全类名#1 这样的规则来分配 id</u>, 我们可以通过 debug 方式来查看.</li></ul><h1 id="2-Spring-管理-Bean-IOC"><a href="#2-Spring-管理-Bean-IOC" class="headerlink" title="2 Spring 管理 Bean-IOC"></a>2 Spring 管理 Bean-IOC</h1><h2 id="2-1-Spring-配置-x2F-管理-bean-介绍"><a href="#2-1-Spring-配置-x2F-管理-bean-介绍" class="headerlink" title="2.1 Spring 配置&#x2F;管理 bean 介绍"></a>2.1 Spring 配置&#x2F;管理 bean 介绍</h2><h3 id="2-1-1-Bean-管理包括两方面"><a href="#2-1-1-Bean-管理包括两方面" class="headerlink" title="2.1.1 Bean 管理包括两方面"></a>2.1.1 Bean 管理包括两方面</h3><h4 id="2-1-1-1-创建-bean-对象"><a href="#2-1-1-1-创建-bean-对象" class="headerlink" title="2.1.1.1 创建 bean 对象"></a>2.1.1.1 创建 bean 对象</h4><h4 id="2-1-1-2-给-bean-注入属性"><a href="#2-1-1-2-给-bean-注入属性" class="headerlink" title="2.1.1.2 给 bean 注入属性"></a>2.1.1.2 给 bean 注入属性</h4><h3 id="2-1-2-Bean-配置方式"><a href="#2-1-2-Bean-配置方式" class="headerlink" title="2.1.2 Bean 配置方式"></a>2.1.2 Bean 配置方式</h3><h4 id="2-1-2-1-基于-xml-文件配置方式"><a href="#2-1-2-1-基于-xml-文件配置方式" class="headerlink" title="2.1.2.1 基于 xml 文件配置方式"></a>2.1.2.1 基于 xml 文件配置方式</h4><h4 id="2-1-2-2-基于注解方式"><a href="#2-1-2-2-基于注解方式" class="headerlink" title="2.1.2.2 基于注解方式"></a>2.1.2.2 基于注解方式</h4><h2 id="2-2-基于-XML-配置-bean"><a href="#2-2-基于-XML-配置-bean" class="headerlink" title="2.2 基于 XML 配置 bean"></a>2.2 基于 XML 配置 bean</h2><h3 id="2-2-1-通过类型来获取-bean"><a href="#2-2-1-通过类型来获取-bean" class="headerlink" title="2.2.1 通过类型来获取 bean"></a>2.2.1 通过类型来获取 bean</h3><h4 id="2-2-1-1-应用案例"><a href="#2-2-1-1-应用案例" class="headerlink" title="2.2.1.1 应用案例"></a>2.2.1.1 应用案例</h4><p>​● 案例说明:</p><ol><li>通过 spring 的 ioc 容器, 获取一个 bean 对象</li><li>说明：获取 bean 的方式：按类型</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Monster</span> <span class="variable">monster</span> <span class="operator">=</span> ioc.getBean(Monster.class);</span><br></pre></td></tr></table></figure><h4 id="2-2-1-2-细节说明"><a href="#2-2-1-2-细节说明" class="headerlink" title="2.2.1.2 细节说明"></a>2.2.1.2 细节说明</h4><ol><li><p>按类型来获取 bean, 要求 ioc 容器中的同一个类的 bean 只能有一个, 否则会抛出异常 NoUniqueBeanDefinitionException</p></li><li><p>这种方式的应用场景：比如 XxxAction&#x2F;Servlet&#x2F;Controller, 或 XxxService <strong>在一个线程中只需要一个对象实例(单例)的情况</strong></p></li><li><p>老师这里在说明一下: 在容器配置文件(比如 beans.xml)中<strong>给属性赋值, 底层是通过 setter 方法完成的</strong>, 这也是为什么我们需要提供 setter 方法的原因</p></li></ol><h3 id="2-2-2-通过构造器配置-bean"><a href="#2-2-2-通过构造器配置-bean" class="headerlink" title="2.2.2 通过构造器配置 bean"></a>2.2.2 通过构造器配置 bean</h3><h4 id="2-2-2-1-应用案例"><a href="#2-2-2-1-应用案例" class="headerlink" title="2.2.2.1 应用案例"></a>2.2.2.1 应用案例</h4><p>● 案例说明:</p><p>在 spring 的 ioc 容器, 可以通过构造器来配置 bean 对象</p><p>● 完成步骤</p><ol><li>在 beans.xml 配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Monster对象，并且指定构造器</span></span><br><span class="line"><span class="comment">老师解读</span></span><br><span class="line"><span class="comment">1. constructor-arg标签可以指定使用构造器的参数</span></span><br><span class="line"><span class="comment">2. index表示构造器的第几个参数 从0开始计算的</span></span><br><span class="line"><span class="comment">3. 除了可以通过index 还可以通过 name / type 来指定参数方式</span></span><br><span class="line"><span class="comment">4. 解除大家的疑惑, 类的构造器，不能有完全相同类型和顺序的构造器，所以可以通过type来指定</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- index --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;monster03&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Monster&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;200&quot;</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;白骨精&quot;</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;吸人血&quot;</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- name --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;monster04&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Monster&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;200&quot;</span> <span class="attr">name</span>=<span class="string">&quot;monsterId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;白骨精&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;吸人血&quot;</span> <span class="attr">name</span>=<span class="string">&quot;skill&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- type --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;monster05&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Monster&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;300&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.Integer&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;白骨精~&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;吸人血~&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-2-2-使用细节"><a href="#2-2-2-2-使用细节" class="headerlink" title="2.2.2.2 使用细节"></a>2.2.2.2 使用细节</h4><ol><li>通过 index 属性来区分是第几个参数</li><li>通过 type 属性来区分是什么类型(按照顺序)</li></ol><h3 id="2-2-3-通过-p-名称空间配置-bean"><a href="#2-2-3-通过-p-名称空间配置-bean" class="headerlink" title="2.2.3 通过 p 名称空间配置 bean"></a>2.2.3 通过 p 名称空间配置 bean</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在beans标签中添加    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--通过p名称空间来配置bean</span></span><br><span class="line"><span class="comment">    老韩解读</span></span><br><span class="line"><span class="comment">    1. 将光标放在p , 输入alt+enter , 就会自动的添加xmlns</span></span><br><span class="line"><span class="comment">    2. 有时需要多来几次</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;monster06&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Monster&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:monsterId</span>=<span class="string">&quot;500&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:name</span>=<span class="string">&quot;红孩儿&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:skill</span>=<span class="string">&quot;吐火&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-4-引用-x2F-注入其它-bean-对象-某类中有其他类型的数据，也需要初始化"><a href="#2-2-4-引用-x2F-注入其它-bean-对象-某类中有其他类型的数据，也需要初始化" class="headerlink" title="2.2.4 引用&#x2F;注入其它 bean 对象(某类中有其他类型的数据，也需要初始化)"></a>2.2.4 引用&#x2F;注入其它 bean 对象(某类中有其他类型的数据，也需要初始化)</h3><h4 id="2-2-4-1-实例演示"><a href="#2-2-4-1-实例演示" class="headerlink" title="2.2.4.1 实例演示"></a>2.2.4.1 实例演示</h4><p>​● 案例说明:在 spring 的 ioc 容器, 可以<strong>通过 ref 来实现 bean 对象的相互引用</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置MemberServiceImpl对象</span></span><br><span class="line"><span class="comment">    老韩解读</span></span><br><span class="line"><span class="comment">    1. ref=&quot;memberDAO&quot;表示  MemberServiceImpl对象属性memberDAO引用的对象是id=memberDAO</span></span><br><span class="line"><span class="comment">    的对象</span></span><br><span class="line"><span class="comment">    2. 这里就体现出spring容器的依赖注入</span></span><br><span class="line"><span class="comment">    3. 注意再spring容器中, 他是「作为一个整体来执行的」即如果你引用到一个bean对象, 对你配置的顺序没有要求</span></span><br><span class="line"><span class="comment">    4. 建议还是按顺序，好处是阅读的时候，比较方便</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置MemberDAOImpl对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.dao.MemberDAOImpl&quot;</span> <span class="attr">id</span>=<span class="string">&quot;memberDAO&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.service.MemberServiceImpl&quot;</span> <span class="attr">id</span>=<span class="string">&quot;memberService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;memberDAO&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;memberDAO&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-5-引用-x2F-注入内部-bean-对象"><a href="#2-2-5-引用-x2F-注入内部-bean-对象" class="headerlink" title="2.2.5 引用&#x2F;注入内部 bean 对象"></a>2.2.5 引用&#x2F;注入内部 bean 对象</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;memberServiceImpl02&quot;</span><span class="attr">class</span>=<span class="string">&quot;com.study.spring.service.MemberServiceImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;memberDAO&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.dao.MemberDAOImpl&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-6-引用-x2F-注入集合-x2F-数组类型"><a href="#2-2-6-引用-x2F-注入集合-x2F-数组类型" class="headerlink" title="2.2.6 引用&#x2F;注入集合&#x2F;数组类型"></a>2.2.6 引用&#x2F;注入集合&#x2F;数组类型</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Master对象</span></span><br><span class="line"><span class="comment">体会 spring 容器配置特点 依赖注入-非常灵活</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Master&quot;</span> <span class="attr">id</span>=<span class="string">&quot;master&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;太上老君&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--给list属性赋值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monsterList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--引用的方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;monster01&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;monster02&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--内部bean--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Monster&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;老鼠精&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monsterId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;skill&quot;</span> <span class="attr">value</span>=<span class="string">&quot;吃粮食&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--给map属性赋值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monsterMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>monster03<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--这里老师使用的外部bean,引入--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;monster03&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>monster04<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;monster04&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--给set属性赋值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monsterSet&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;monster05&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;monster06&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Monster&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;金角大王&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;skill&quot;</span> <span class="attr">value</span>=<span class="string">&quot;吐水&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monsterId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--给数组属性赋值</span></span><br><span class="line"><span class="comment">    老师多说一句: array标签中使用 value 还是 bean , ref .. 要根据你的业务决定</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monsterName&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>小妖怪<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>大妖怪<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>老妖怪<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--给Properties属性赋值 结构k(String)-v(String)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pros&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;username&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;ip&quot;</span>&gt;</span>127.0.0.1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-6-2-使用细节"><a href="#2-2-6-2-使用细节" class="headerlink" title="2.2.6.2 使用细节"></a>2.2.6.2 使用细节</h4><ol><li><p>主要掌握 List&#x2F;Map&#x2F;Properties 三种集合的使用.</p></li><li><p>Properties 集合的特点</p><ul><li><p>这个 Properties 是 Hashtable 的子类 , 是 key-value 的形式</p></li><li><p>key 是 string 而 value 也是 string</p></li></ul></li></ol><h3 id="2-2-7-通过-util-名称空间创建-list"><a href="#2-2-7-通过-util-名称空间创建-list" class="headerlink" title="2.2.7 通过 util 名称空间创建 list"></a>2.2.7 通过 util 名称空间创建 list</h3><h4 id="2-2-7-1-实例演示"><a href="#2-2-7-1-实例演示" class="headerlink" title="2.2.7.1 实例演示"></a>2.2.7.1 实例演示</h4><p>​● 案例说明</p><p>​spring 的 ioc 容器, 可以通过 util 名称空间创建 list 集合</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">xmlns:util=&quot;http://www.springframework.org/schema/util&quot;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--定义一个util:list 并且指定id 可以达到数据复用</span></span><br><span class="line"><span class="comment">老师说明: 在使用util:list 名称空间时候，需要引入相应的标签, 一般来说通过alt+enter会自动加入</span></span><br><span class="line"><span class="comment">, 如果没有就手动添加一下即可.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;myBookList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>三国演义<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>红楼梦<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>水浒传<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置BookStore对象--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.BookStore&quot;</span> <span class="attr">id</span>=<span class="string">&quot;bookStore&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookList&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;myBookList&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-8-级联属性赋值"><a href="#2-2-8-级联属性赋值" class="headerlink" title="2.2.8 级联属性赋值"></a>2.2.8 级联属性赋值</h3><h4 id="2-2-8-1-实例演示"><a href="#2-2-8-1-实例演示" class="headerlink" title="2.2.8.1 实例演示"></a>2.2.8.1 实例演示</h4><p>​● 案例说明</p><p>​spring 的 ioc 容器, 可以直接给对象属性的属性赋值， 即级联属性赋值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Dept对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Dept&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置Emp对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Emp&quot;</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jack&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这里我希望给dept的name属性指定值[级联属性赋值]--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept.name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Java开发部门&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-9-通过静态工厂获取对象"><a href="#2-2-9-通过静态工厂获取对象" class="headerlink" title="2.2.9 通过静态工厂获取对象"></a>2.2.9 通过静态工厂获取对象</h3><h4 id="2-2-9-1-实例演示"><a href="#2-2-9-1-实例演示" class="headerlink" title="2.2.9.1 实例演示"></a>2.2.9.1 实例演示</h4><p>​● 案例说明</p><p>​在 spring 的 ioc 容器, 可以通过静态工厂获取 bean 对象</p><ol><li>创 建com\study\spring\factory\MyStaticFactory.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStaticFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Monster&gt; monsterMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用 static代码块 进行初始化</span></span><br><span class="line">    <span class="comment">//在java基础的时候，讲过的</span></span><br><span class="line">    <span class="keyword">static</span>  &#123;</span><br><span class="line">        monsterMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        monsterMap.put(<span class="string">&quot;monster01&quot;</span>, <span class="keyword">new</span> <span class="title class_">Monster</span>(<span class="number">100</span>,<span class="string">&quot;牛魔王&quot;</span>,<span class="string">&quot;芭蕉扇&quot;</span>));</span><br><span class="line">        monsterMap.put(<span class="string">&quot;monster02&quot;</span>, <span class="keyword">new</span> <span class="title class_">Monster</span>(<span class="number">200</span>,<span class="string">&quot;狐狸精&quot;</span>,<span class="string">&quot;美人计&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个方法,返回Monster对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Monster <span class="title function_">getMonster</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> monsterMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>修改 beans.xml , 增加配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置monster对象,通过静态工厂获取</span></span><br><span class="line"><span class="comment">   老师解读</span></span><br><span class="line"><span class="comment">   1. 通过静态工厂获取/配置bean</span></span><br><span class="line"><span class="comment">   2. class 是静态工厂类的全路径</span></span><br><span class="line"><span class="comment">   3. factory-method 表示是指定静态工厂类的哪个方法返回对象</span></span><br><span class="line"><span class="comment">   4. constructor-arg value=&quot;monster02&quot; value是指定要返回静态工厂的哪个对象</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;my_monster01&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">class</span>=<span class="string">&quot;com.study.spring.factory.MyStaticFactory&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">factory-method</span>=<span class="string">&quot;getMonster&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;monster02&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-10-通过实例工厂获取对象"><a href="#2-2-10-通过实例工厂获取对象" class="headerlink" title="2.2.10 通过实例工厂获取对象"></a>2.2.10 通过实例工厂获取对象</h3><h4 id="2-2-10-1-实例演示"><a href="#2-2-10-1-实例演示" class="headerlink" title="2.2.10.1 实例演示"></a>2.2.10.1 实例演示</h4><p>​● 案例说明在 spring 的 ioc 容器, 可以通过实例工厂获取 bean 对象</p><p>​● 完成步骤1. 创 建com\study\spring\factory\MyInstanceFactory.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInstanceFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Monster&gt; monster_map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过普通代码块进行初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        monster_map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        monster_map.put(<span class="string">&quot;monster03&quot;</span>, <span class="keyword">new</span> <span class="title class_">Monster</span>(<span class="number">300</span>, <span class="string">&quot;牛魔王~&quot;</span>, <span class="string">&quot;芭蕉扇~&quot;</span>));</span><br><span class="line">        monster_map.put(<span class="string">&quot;monster04&quot;</span>, <span class="keyword">new</span> <span class="title class_">Monster</span>(<span class="number">400</span>, <span class="string">&quot;狐狸精~&quot;</span>, <span class="string">&quot;美人计~&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法返回Monster对象</span></span><br><span class="line">    <span class="keyword">public</span> Monster <span class="title function_">getMonster</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> monster_map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 beans.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置2个实例工厂对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.factory.MyInstanceFactory&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myInstanceFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.factory.MyInstanceFactory&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myInstanceFactory2&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置monster对象, 通过实例工厂</span></span><br><span class="line"><span class="comment">老韩解读</span></span><br><span class="line"><span class="comment">1. factory-bean 指定使用 &#x27;哪个实例工厂&#x27; 对象返回bean</span></span><br><span class="line"><span class="comment">2. factory-method 指定使用实例工厂对象的 &#x27;哪个方法&#x27; 返回bean</span></span><br><span class="line"><span class="comment">3. constructor-arg value=&quot;monster03&quot; 指定获取到实例工厂中的哪个monster</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;my_monster02&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;myInstanceFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getMonster&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;monster03&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;my_monster03&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;myInstanceFactory2&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getMonster&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;monster03&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-12-通过-FactoryBean-获取对象-重点"><a href="#2-2-12-通过-FactoryBean-获取对象-重点" class="headerlink" title="2.2.12 通过 FactoryBean 获取对象(重点)"></a>2.2.12 通过 FactoryBean 获取对象(重点)</h3><h4 id="2-2-12-1-应用实例"><a href="#2-2-12-1-应用实例" class="headerlink" title="2.2.12.1 应用实例"></a>2.2.12.1 应用实例</h4><p>​● 案例说明</p><p>​在 spring 的 ioc 容器,通过 FactoryBean 获取 bean 对象(重点)</p><ol><li>创 建com\study\spring\factory\MyFactoryBean.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Monster&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个就是你配置时候，指定要获取的对象对应key</span></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Monster&gt; monster_map;</span><br><span class="line"></span><br><span class="line">    &#123;   <span class="comment">//代码块，完成初始化</span></span><br><span class="line">        monster_map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        monster_map.put(<span class="string">&quot;monster03&quot;</span>, <span class="keyword">new</span> <span class="title class_">Monster</span>(<span class="number">300</span>, <span class="string">&quot;牛魔王~&quot;</span>, <span class="string">&quot;芭蕉扇~&quot;</span>));</span><br><span class="line">        monster_map.put(<span class="string">&quot;monster04&quot;</span>, <span class="keyword">new</span> <span class="title class_">Monster</span>(<span class="number">400</span>, <span class="string">&quot;狐狸精~&quot;</span>, <span class="string">&quot;美人计~&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Monster <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> monster_map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Monster.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;<span class="comment">//这里指定是否返是单例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 beans.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置monster对象，通过FactoryBean获取</span></span><br><span class="line"><span class="comment">老师解读</span></span><br><span class="line"><span class="comment">1. class 指定使用的FactoryBean</span></span><br><span class="line"><span class="comment">2. key表示就是 MyFactoryBean 属性key</span></span><br><span class="line"><span class="comment">3. value就是你要获取的对象对应key</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;my_monster05&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.factory.MyFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;key&quot;</span> <span class="attr">value</span>=<span class="string">&quot;monster04&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-13-bean-配置信息重用-继承"><a href="#2-2-13-bean-配置信息重用-继承" class="headerlink" title="2.2.13 bean 配置信息重用(继承)"></a>2.2.13 bean 配置信息重用(继承)</h3><h4 id="2-2-13-1-应用实例"><a href="#2-2-13-1-应用实例" class="headerlink" title="2.2.13.1 应用实例"></a>2.2.13.1 应用实例</h4><p>​● 说明</p><p>​在 spring 的 ioc 容器, 提供了一种继承的方式来实现 bean 配置信息的重用</p><p>​● 应用实例演示</p><ol><li>配置 beans.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Monster对象</span></span><br><span class="line"><span class="comment">1. 如果bean指定了 abstract=&quot;true&quot;, 表示该bean对象, 是用于被继承</span></span><br><span class="line"><span class="comment">2. 本身这个bean就不能被获取/实例化</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;monster12&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Monster&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monsterId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;蜈蚣精~&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;skill&quot;</span> <span class="attr">value</span>=<span class="string">&quot;蜇人~&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;monster13&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Monster&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;monster12&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-14-bean-创建顺序"><a href="#2-2-14-bean-创建顺序" class="headerlink" title="2.2.14 bean 创建顺序"></a>2.2.14 bean 创建顺序</h3><h4 id="2-2-14-1-实例演示"><a href="#2-2-14-1-实例演示" class="headerlink" title="2.2.14.1 实例演示"></a>2.2.14.1 实例演示</h4><p>​● 说明</p><ol><li>在 spring 的 ioc 容器, 默认是按照配置的顺序创建 bean 对象</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--测试bean对象的创建顺序</span></span><br><span class="line"><span class="comment">老师解读</span></span><br><span class="line"><span class="comment">1. 在默认情况下, bean创建的顺序是按照配置顺序来的</span></span><br><span class="line"><span class="comment">2. 但是如果我们增加了 depends-on=&quot;department01&quot; 这时就会先创建id= department01对象</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hspedu.bean.Student&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;department01&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;department01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hspedu.bean.Department&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>2.2.14.2 一个问题</p><p>​● 问题说明</p><ol><li>先看下面的配置, 请问两个 bean 创建的顺序是什么? 并分析执行流<ol><li>先创建 id&#x3D;memberDAOImpl</li><li>再创建 id &#x3D; memberServiceImpl</li><li>调用 memberServiceImpl.setMemberDAO() 完成引用</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230720095126833.png" alt="image-20230720095126833"></p><ol start="2"><li><p>先看下面的配置, 请问两个 bean 创建的顺序是什么, 并分析执行流程</p><ol><li>先创建 id &#x3D; memberServiceImpl</li><li>再创建 id&#x3D;memberDAOImpl</li></ol><ol start="3"><li>用 memberServiceImpl.setMemberDAO() 完成引用.   （像是栈</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230720095309694.png" alt="image-20230720095309694"></p><h3 id="2-2-15-bean-对象的单例和多例"><a href="#2-2-15-bean-对象的单例和多例" class="headerlink" title="2.2.15 bean 对象的单例和多例"></a>2.2.15 bean 对象的单例和多例</h3><h4 id="2-2-15-1-应用实例"><a href="#2-2-15-1-应用实例" class="headerlink" title="2.2.15.1 应用实例"></a>2.2.15.1 应用实例</h4><p>​● 说明</p><p>​<u>在 spring 的 ioc 容器, 在默认是按照单例创建的， 即配置一个 bean 对象后， ioc 容器只会创建一个 bean 实例。</u></p><p>​如果,我们希望 ioc 容器配置的某个 bean 对象， 是以多个实例形式创建的则可以通过配置<strong>scope&#x3D;”prototype”</strong> 来指定</p><p><strong>配置 beans.xml：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Cat对象</span></span><br><span class="line"><span class="comment">    老师解读</span></span><br><span class="line"><span class="comment">    1. 在默认情况下 scope属性是 singleton</span></span><br><span class="line"><span class="comment">    2. 在ioc容器中, 只要有一个这个bean对象</span></span><br><span class="line"><span class="comment">    3. 当程序员执行getBean时, 返回的的是同一个对象</span></span><br><span class="line"><span class="comment">    4. 如果我们希望每次getBean返回一个新的Bean对象，则可以scope=&quot;prototype&quot;</span></span><br><span class="line"><span class="comment">    5. 如果bean的配置是 scope=&quot;singleton&quot; lazy-init=&quot;true&quot; 这时,ioc容器就不会提前创建该对象</span></span><br><span class="line"><span class="comment">       , 而是当执行getBean方法的时候，才会创建对象</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Cat&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小花猫&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-15-2-使用细节"><a href="#2-2-15-2-使用细节" class="headerlink" title="2.2.15.2 使用细节"></a>2.2.15.2 使用细节</h4><ol><li><p><strong>默认是单例 singleton, 在启动容器时, 默认就会创建 , 并放入到 singletonObjects 集合</strong></p></li><li><p>当 <bean scope="prototype" > <strong><u>设置为多实例机制后, 该 bean 是在 getBean()时才创建</u></strong> </p></li><li><p>如果是单例 singleton, 同时希望在 getBean 时才创建 , 可以指定懒加载lazy-init&#x3D;”true” (注意默认是 false)</p></li><li><p><u>通常情况下, lazy-init 就使用默认值 false , 在开发看来, 用空间换时间是值得的,</u> 除非有特殊的要求.</p></li><li><p><strong>如果 scope&#x3D;”prototype” 这时你的 lazy-init 属性的值不管是 ture, 还是 false 都是在getBean 时候，才创建对象.</strong></p></li></ol><h3 id="2-2-16-bean-的生命周期"><a href="#2-2-16-bean-的生命周期" class="headerlink" title="2.2.16 bean 的生命周期"></a>2.2.16 bean 的生命周期</h3><h4 id="2-2-16-1-应用实例"><a href="#2-2-16-1-应用实例" class="headerlink" title="2.2.16.1 应用实例"></a>2.2.16.1 应用实例</h4><p>​● 说明: bean 对象创建是由 JVM 完成的，然后执行如下方法</p><p>​<strong>1.</strong>  执行构造器</p><p>​<strong>2.</strong>  执行 set 相关方法</p><p>​<strong>3.</strong>  调用 bean 的初始化的方法（需要配置）</p><p>​<strong>4.</strong>  使用 bean </p><p>​<strong>5.</strong>  当容器关闭时候，调用 bean 的销毁方法（需要配置）</p><p>​● 应用实例演示</p><ol><li>创建 com.hspedu.spring.beans;</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">House</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">House</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;House() 构造器...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;House setName()=&quot;</span> + name);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//老师解读</span></span><br><span class="line">    <span class="comment">//1. 这个方法是程序员来编写的.</span></span><br><span class="line">    <span class="comment">//2. 根据自己的业务逻辑来写.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;House init()..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//老师解读</span></span><br><span class="line">    <span class="comment">//1. 这个方法是程序员来编写的.</span></span><br><span class="line">    <span class="comment">//2. 根据自己的业务逻辑来写.</span></span><br><span class="line">    <span class="comment">//3. 名字也不是固定的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;House destroy()..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;House&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 beans.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置House对象，演示整个Bean的生命周期</span></span><br><span class="line"><span class="comment">老师解读</span></span><br><span class="line"><span class="comment">1. init-method=&quot;init&quot; 指定bean的初始化方法 , 在setter方法后执行</span></span><br><span class="line"><span class="comment">2. init方法执行的时机，由spring容器来控制</span></span><br><span class="line"><span class="comment">3. destroy-method=&quot;destroy&quot; 指定bean的销毁方法, 在容器关闭的时候执行</span></span><br><span class="line"><span class="comment">4. destroy方法执行的时机，也由spring容器来控制</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.hspedu.spring.bean.House&quot;</span> <span class="attr">id</span>=<span class="string">&quot;house&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;北京豪宅&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-16-2-使用细节"><a href="#2-2-16-2-使用细节" class="headerlink" title="2.2.16.2 使用细节"></a>2.2.16.2 使用细节</h4><ol><li><p>初始化 init 方法和 destory 方法, 是程序员来指定</p></li><li><p>销毁方法就是当关闭容器时，才会被调用.</p></li></ol><h3 id="2-2-17-配置-bean-的后置处理器-【这个比较难】"><a href="#2-2-17-配置-bean-的后置处理器-【这个比较难】" class="headerlink" title="2.2.17 配置 bean 的后置处理器 【这个比较难】"></a>2.2.17 配置 bean 的后置处理器 【这个比较难】</h3><h4 id="2-2-17-1-应用实例"><a href="#2-2-17-1-应用实例" class="headerlink" title="2.2.17.1 应用实例"></a>2.2.17.1 应用实例</h4><p>● 说明</p><ol><li>在 spring 的 ioc 容器,可以配置 <strong>bean 的后置处理器</strong></li><li>该处理器&#x2F;对象会在 <strong>bean 初始化方法<u>调用前</u>和初始化方法<u>调用后</u>被调用</strong></li><li>程序员可以在后置处理器中编写自己的代码</li></ol><p>后置处理器创建好后，也注册在beans.xml中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 什么时候被调用: 在Bean的init方法前被调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bean 传入的在IOC容器中创建/配置Bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName 传入的在IOC容器中创建/配置Bean的id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Object 程序员对传入的bean 进行修改/处理【如果有需要的话】 ,返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;postProcessBeforeInitialization().. bean=&quot;</span></span><br><span class="line">            + bean + <span class="string">&quot; beanName=&quot;</span> + beanName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初步体验案例: 如果类型是House的统一改成 上海豪宅</span></span><br><span class="line">    <span class="comment">//对多个对象进行处理/编程==&gt;切面编程</span></span><br><span class="line">    <span class="keyword">if</span>(bean <span class="keyword">instanceof</span> House) &#123;</span><br><span class="line">        ((House)bean).setName(<span class="string">&quot;上海豪宅~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 什么时候被调用: 在Bean的init方法后被调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bean  传入的在IOC容器中创建/配置Bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName 传入的在IOC容器中创建/配置Bean的id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 程序员对传入的bean 进行修改/处理【如果有需要的话】 ,返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;postProcessAfterInitialization().. bean=&quot;</span></span><br><span class="line">            + bean + <span class="string">&quot; beanName=&quot;</span> + beanName);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置后置处理器对象</span></span><br><span class="line"><span class="comment">老师解读</span></span><br><span class="line"><span class="comment">1. 当我们在beans02.xml 容器配置文件 配置了 MyBeanPostProcessor</span></span><br><span class="line"><span class="comment">2. 这时后置处理器对象，就会作用在该容器创建的Bean对象</span></span><br><span class="line"><span class="comment">3. 已经是针对所有对象编程-&gt;切面编程AOP</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.hspedu.spring.bean.MyBeanPostProcessor&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myBeanPostProcessor&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-17-2-其它说明"><a href="#2-2-17-2-其它说明" class="headerlink" title="2.2.17.2 其它说明"></a>2.2.17.2 其它说明</h4><p>1、 怎么执行到这个方法?&#x3D;&gt; 使用 AOP(反射+动态代理+IO+容器+注解)</p><p>2、有什么用？&#x3D;&gt; 可以对 IOC 容器中所有的对象进行统一处理 ,比如 <strong>日志处理&#x2F;权限的校验&#x2F;安全的验证&#x2F;事务管理.</strong></p><p>​-初步体验案例: 如果类型是 House 的<strong>统一</strong>改成 上海豪宅</p><p>3、针对容器的所有对象吗? 是的&#x3D;&gt;切面编程特点</p><p>4、后面我们会自己实现这个底层机制，这个是一个比较难理解的知识点, 现在不做过多的纠结，后面我会带小伙伴实现这个机制</p><h3 id="2-2-18-通过属性文件给-bean-注入值"><a href="#2-2-18-通过属性文件给-bean-注入值" class="headerlink" title="2.2.18 通过属性文件给 bean 注入值"></a>2.2.18 通过属性文件给 bean 注入值</h3><h4 id="2-2-18-1-应用实例"><a href="#2-2-18-1-应用实例" class="headerlink" title="2.2.18.1 应用实例"></a>2.2.18.1 应用实例</h4><p>​● 说明</p><p>在 spring 的 ioc 容器,通过属性文件给 bean 注入值</p><p>​● 应用实例演示</p><ol><li>src&#x2F; 创建 my.properties</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">monsterId</span>=<span class="string">1000</span></span><br><span class="line"><span class="attr">name</span>=<span class="string">\u4e4c\u9f9f\u7cbe</span></span><br><span class="line"><span class="attr">skill</span>=<span class="string">\u7f29\u8116\u5b50</span></span><br></pre></td></tr></table></figure><ol start="2"><li>修改 src\beans.xml , 继续完成配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line"><span class="comment">&lt;!--指定属性文件</span></span><br><span class="line"><span class="comment">     1. 先把这个文件修改成提示All Problem</span></span><br><span class="line"><span class="comment">     2. 提示错误，将光标放在context 输入alt+enter 就会自动引入namespace</span></span><br><span class="line"><span class="comment">     3. location=&quot;classpath:my.properties&quot; 表示指定属性文件的位置</span></span><br><span class="line"><span class="comment">     4. 提示，需要带上 classpath</span></span><br><span class="line"><span class="comment">     5. 属性文件有中文，需要将其转为unicode编码-&gt; 使用工具</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:my.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;monster100&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hspedu.spring.beans.Monster&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monsterId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;id&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;name&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;skill&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;skill&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-19-基于-XML-的-bean-的自动装配"><a href="#2-2-19-基于-XML-的-bean-的自动装配" class="headerlink" title="2.2.19 基于 XML 的 bean 的自动装配"></a>2.2.19 基于 XML 的 bean 的自动装配</h3><h4 id="2-2-19-1-应用实例"><a href="#2-2-19-1-应用实例" class="headerlink" title="2.2.19.1 应用实例"></a>2.2.19.1 应用实例</h4><p>​● 说明</p><p>​在 spring 的 ioc 容器,可以实现自动装配 bean</p><p>​● 应用实例演示</p><p>​这里说的 Action 就是我们前面讲过的 Servlet-&gt;充当 Controller</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置OrderDao对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.hspedu.spring.dao.OrderDao&quot;</span> <span class="attr">id</span>=<span class="string">&quot;orderDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置OrderService对象</span></span><br><span class="line"><span class="comment">        老师解读</span></span><br><span class="line"><span class="comment">        1. autowire=&quot;byType&quot; 表示 在创建 orderService时</span></span><br><span class="line"><span class="comment">           通过类型的方式 给对象属性 自动完成赋值/引用</span></span><br><span class="line"><span class="comment">        2. 比如OrderService 对象有 private OrderDao orderDao</span></span><br><span class="line"><span class="comment">        3. 就会在容器中去找有没有 OrderDao类型对象</span></span><br><span class="line"><span class="comment">        4. 如果有，就会自动的装配, 老师提示如果是按照 byType 方式来装配, 这个容器中，不能有两个</span></span><br><span class="line"><span class="comment">          的OrderDao类型对象</span></span><br><span class="line"><span class="comment">        5. 如果你的对象没有属性,  autowire就没有必要写</span></span><br><span class="line"><span class="comment">        6. 其它类推..</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        7. 如果我们设置的是 autowire=&quot;byName&quot; 表示通过名字完成自动装配</span></span><br><span class="line"><span class="comment">        8. 比如下面的 autowire=&quot;byName&quot; class=&quot;com.hspedu.spring.service.OrderService&quot;</span></span><br><span class="line"><span class="comment">           1) 先看 OrderService 属性 private OrderDao orderDao</span></span><br><span class="line"><span class="comment">           2) 再根据这个属性的setXxx()方法的 xxx 来找对象id</span></span><br><span class="line"><span class="comment">           3) public void setOrderDao() 就会找id=orderDao对象来进行自动装配</span></span><br><span class="line"><span class="comment">           4) 如果没有就装配失败</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hspedu.spring.service.OrderService&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">id</span>=<span class="string">&quot;orderService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置OrderAction--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hspedu.spring.web.OrderAction&quot;</span> <span class="attr">id</span>=<span class="string">&quot;orderAction&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>2.2.19.2 其它说明</p><pre><code>1. 这个知识点作为了解即可， 后面我们主要还是使用基于注解的方式(重点.)1. 但是机制和原理类似</code></pre><h2 id="2-3-🌟基于注解配置-bean"><a href="#2-3-🌟基于注解配置-bean" class="headerlink" title="2.3 🌟基于注解配置 bean"></a>2.3 🌟基于注解配置 bean</h2><h3 id="2-3-18-基本使用"><a href="#2-3-18-基本使用" class="headerlink" title="2.3.18 基本使用"></a>2.3.18 基本使用</h3><h4 id="2-3-18-1-说明"><a href="#2-3-18-1-说明" class="headerlink" title="2.3.18.1 说明"></a>2.3.18.1 说明</h4><p>​● 基本介绍基于注解的方式配置 bean, 主要是项目开发中的组件， 比如 Controller、 Service、 和 Dao.</p><p>​● 组件注解的形式有</p><ol><li><p><u>@Component</u> 表示当前注解标识的<strong>是一个组件</strong>，<u>最宽泛，只是把该类注册到spring ioc容器中</u></p></li><li><p><u>@Controller</u> 表示当前注解标识的<strong>是一个控制器， 通常用于 Servlet</strong></p></li><li><p><u>@Service</u> 表示当前注解标识的是一个<strong>处理业务逻辑的类</strong>， 通常用于 Service 类</p></li><li><p><u>@Repository</u> 表示当前注解标识的是<strong>一个持久化层的类</strong>， 通常用于 Dao 类</p></li></ol><h4 id="2-3-18-2-快速入门"><a href="#2-3-18-2-快速入门" class="headerlink" title="2.3.18.2 快速入门"></a>2.3.18.2 快速入门</h4><p>​● 应用实例使用注解的方式来配置  Controller &#x2F; Service &#x2F; Respository &#x2F; Component</p><p>​● 代码实现</p><p>​1. 引入 spring-aop-5.3.8.jar , 在 spring&#x2F;libs 下拷贝即可</p><p>​2.创建 UserAction.java UserService.java, UserDao.java MyComponent.java</p><p>​3.配置 beans.xml(<strong>配置自动扫描的包</strong>)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置自动扫描的包，注意需要加入 context 名称空间 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.study.spring.component&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-18-3-注意事项和细节说明"><a href="#2-3-18-3-注意事项和细节说明" class="headerlink" title="2.3.18.3 注意事项和细节说明"></a>2.3.18.3 注意事项和细节说明</h4><ol><li><p>需要导入 spring-aop-5.3.8.jar , 别忘了</p></li><li><p>必须在 Spring 配置文件中指定”自动扫描的包”，IOC 容器才能够检测到当前项目中哪些类被标识了注解， 注意到导入 context 名称空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置自动扫描的包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hspedu.spring.component&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>可以使用通配符 * 来指定 ，比如 com.hspedu.spring.* 表示<br><strong>–提问: com.hspedu.spring.component 会不会去扫描它的子包?–答：会的</strong></p></li><li><p>Spring 的 IOC 容器不能检测一个使用了@Controller 注解的类到底是不是一个真正的控制器。注解的名称是用于程序员自己识别当前标识的是什么组件。其它的@Service@Repository 也是一样的道理 [也就是说 <em><strong>spring 的 IOC 容器只要检查到注解就会生成对象，但是这个注解的含义 spring 不会识别，注解是给程序员编程方便看的</strong></em>]</p></li><li><p>&lt;context:component-scan base-package&#x3D;”com.hspedu.spring.component”resource-pattern&#x3D;”User* .class” &#x2F;&gt;resource-pattern&#x3D;”User*.class”: <strong>表示只扫描满足要求的类</strong>.[使用的少，不想扫描，不写注解就可以, 知道这个知识点即可]</p></li><li><p>&lt;context:component-scan base-package&#x3D;”com.hspedu.spring.component” &gt;</p><!-- 排除哪些类 , 以 annotaion 注解为例 --><p>&lt;context:exclude-filter type&#x3D;”annotation”expression&#x3D;”org.springframework.stereotype.Service”&#x2F;&gt;</context></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) &lt;context:exclude-filter&gt; 放在&lt;context:component-scan&gt;内，表示扫描过滤掉当前包的某些类</span><br><span class="line">2) type=&quot;annotation&quot; 按照注解类型进行过滤.</span><br><span class="line">3) expression :就是注解的全类名，比如 org.springframework.stereotype.Service 就是@Service 注解的全类名,其它比@Controller @Repository 等 依次类推</span><br><span class="line">4) 上面表示过滤掉 com.hspedu.spring.component 包下，加入了@Service 注解的类</span><br><span class="line">5) 完成测试， 修改 beans.xml, 增加 exclude-filter , 发现 UserService, 不会注入到容器.</span><br></pre></td></tr></table></figure><ol start="6"><li>指定自动扫描哪些注解类</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    需求：如果我们希望按照自己的规则，来扫描包/子包下的某些注解, 可以通过 include-filter</span></span><br><span class="line"><span class="comment">    1. use-default-filters=&quot;false&quot; 表示不使用默认的过滤机制/扫描机制</span></span><br><span class="line"><span class="comment">    2. context:include-filter 表示要去扫描哪些类</span></span><br><span class="line"><span class="comment">    3. type=&quot;annotation&quot; 按照注解方式来扫描/过滤</span></span><br><span class="line"><span class="comment">    4. expression=&quot;org.springframework.stereotype.Service&quot; 指定要扫描的注解的全路径</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hspedu.spring.component&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Service&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Repository&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="7"><li><p>默认情况：<strong>标记注解后，默认把类名首字母小写作为 id 的值。也可以使用注解的 value 属性指定 id 值，并且 value 可以省略。</strong></p></li><li><p>扩展-@Controller 、@Service、@Component 区别 : (回去看看一下老师的讲解的注解基础) <a href="https://zhuanlan.zhihu.com/p/454638478">https://zhuanlan.zhihu.com/p/454638478</a></p></li></ol><h3 id="2-3-19-🌟手动开发简单的-Spring-基于注解配置的程序"><a href="#2-3-19-🌟手动开发简单的-Spring-基于注解配置的程序" class="headerlink" title="2.3.19 🌟手动开发简单的 Spring 基于注解配置的程序"></a>2.3.19 🌟手动开发简单的 Spring 基于注解配置的程序</h3><p> -老韩要求: 小伙伴要至少独立写 2 遍</p><h4 id="2-3-19-1-需求说明"><a href="#2-3-19-1-需求说明" class="headerlink" title="2.3.19.1 需求说明"></a>2.3.19.1 需求说明</h4><ol><li><p><strong>自 己 写 一 个 简 单 的 Spring 容 器 , 通 过 读 取 类 的 注 解 (@Component @Controller@Service @Reponsitory)， 将对象注入到 IOC 容器</strong></p></li><li><p>也就是说，<strong>不使用 Spring 原生框架，我们自己使用 IO+Annotaion+反射+集合 技术实现, 打通 Spring 注解方式开发的技术痛点</strong></p></li></ol><h4 id="2-3-19-2-思路分析"><a href="#2-3-19-2-思路分析" class="headerlink" title="2.3.19.2 思路分析"></a>2.3.19.2 思路分析</h4><ol><li><p>思路分析+程序结构</p><p>1)我们使用注解方式完成, 这里老韩不用 xml 来配</p><p>2)程序框架图</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230725093807908.png" alt="image-20230725093807908"></p><h4 id="2-3-19-3-代码实现"><a href="#2-3-19-3-代码实现" class="headerlink" title="2.3.19.3 代码实现"></a>2.3.19.3 代码实现</h4><p>​● 应用实例</p><ol><li><p>手动实现注解的方式来配置 Controller &#x2F; Service &#x2F; Respository &#x2F; Component</p></li><li><p>我们使用自定义注解来完成.</p><p>● 代码实现</p></li><li><p>仍然使用前面的 \com\hspedu\spring\component\ 包下的类</p></li><li><p>创建 ComponentScan.java</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解读</span></span><br><span class="line"><span class="comment"> * 1. <span class="doctag">@Target</span>(ElementType.TYPE)指定我们的ComponentScan注解可以修饰 Type程序元素</span></span><br><span class="line"><span class="comment"> * 2. <span class="doctag">@Retention</span>(RetentionPolicy.RUNTIME) 指定ComponentScan注解 保留范围</span></span><br><span class="line"><span class="comment"> * 3. String value() default &quot;&quot;; 表示ComponentScan 可以传入 value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ComponentScan &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>创 建 HspSpringConfig.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.spring.annotation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 韩顺平</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 这是一个配置类, 作用类似我们原生spring的 beans.xml 容器配置文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.hspedu.spring.component&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HspSpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>创 建 HspSpringApplicationContext.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HspSpringApplicationContext 类的作用类似Spring原生ioc容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HspSpringApplicationContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Class configClass;</span><br><span class="line">    <span class="comment">//ioc我存放的就是通过反射创建的对象(基于注解方式)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Object&gt; ioc =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HspSpringApplicationContext</span><span class="params">(Class configClass)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.configClass = configClass;</span><br><span class="line">        System.out.println(<span class="string">&quot;this.configClass=&quot;</span> + <span class="built_in">this</span>.configClass);</span><br><span class="line">        <span class="comment">//获取要扫描的包</span></span><br><span class="line">        <span class="comment">//1. 先得到HspSpringConfig配置的的@ComponentScan(value = &quot;com.hspedu.spring.component&quot;)</span></span><br><span class="line">        <span class="type">ComponentScan</span> <span class="variable">componentScan</span> <span class="operator">=</span></span><br><span class="line">                (ComponentScan) <span class="built_in">this</span>.configClass.getDeclaredAnnotation(ComponentScan.class);</span><br><span class="line">        <span class="comment">//2. 通过componentScan的value=&gt; 即要扫描的包</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> componentScan.value();</span><br><span class="line">        System.out.println(<span class="string">&quot;要扫描的包= &quot;</span> + path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到要扫描的包下的所有资源(类 .class)⚠️要去out目录下，而不是src目录</span></span><br><span class="line">        <span class="comment">//1.得到类的加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span></span><br><span class="line">                HspApplicationContext.class.getClassLoader();</span><br><span class="line">        <span class="comment">//2. 通过类的加载器获取到要扫描的包的资源 url=》类似一个路径</span></span><br><span class="line">        path = path.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>);<span class="comment">//一定要把. 替换成 /</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">resource</span> <span class="operator">=</span></span><br><span class="line">                classLoader.getResource(path);</span><br><span class="line">        System.out.println(<span class="string">&quot;resource=&quot;</span> + resource);</span><br><span class="line">        <span class="comment">//3. 将要加载的资源(.class) 路径下的文件进行遍历=&gt;io</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(resource.getFile());</span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            File[] files = file.listFiles();</span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;=&quot;</span> + f.getAbsolutePath());</span><br><span class="line">                <span class="comment">//D:\hspedu_spring\spring\out\production\spring\com\hspedu\spring\component\UserService.class</span></span><br><span class="line">                <span class="comment">//获取到 com.hspedu.spring.component.UserService</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">fileAbsolutePath</span> <span class="operator">=</span> f.getAbsolutePath();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//这里我们只处理.class文件</span></span><br><span class="line">                <span class="keyword">if</span> (fileAbsolutePath.endsWith(<span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//1. 获取到类名</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span></span><br><span class="line">                            fileAbsolutePath.substring(fileAbsolutePath.lastIndexOf(<span class="string">&quot;\\&quot;</span>) + <span class="number">1</span>, fileAbsolutePath.indexOf(<span class="string">&quot;.class&quot;</span>));</span><br><span class="line">                    <span class="comment">//System.out.println(&quot;className=&quot; + className);</span></span><br><span class="line">                    <span class="comment">//2. 获取类的完整的路径(全类名)</span></span><br><span class="line">                    <span class="comment">//老师解读 path.replace(&quot;/&quot;,&quot;.&quot;) =&gt; com.hspedu.spring.component.</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">classFullName</span> <span class="operator">=</span> path.replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;.&quot;</span>) +  <span class="string">&quot;.&quot;</span> + className;</span><br><span class="line">                    <span class="comment">//System.out.println(&quot;classFullName=&quot; + classFullName);</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//3. 判断该类是不是需要注入容器, 就看该类是不是有注解 @Component @Service..</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//这时，我们就得到老该类的Class对象</span></span><br><span class="line">                        <span class="comment">//Class clazz = Class.forName(classFullName)</span></span><br><span class="line">                        <span class="comment">//老师说一下</span></span><br><span class="line">                        <span class="comment">//1. Class clazz = Class.forName(classFullName) 可以反射加载类</span></span><br><span class="line">                        <span class="comment">//2. classLoader.loadClass(classFullName); 可以反射类的Class</span></span><br><span class="line">                        <span class="comment">//3. 区别是 : 上面方式后调用来类的静态方法, 下面方法不会</span></span><br><span class="line">                        <span class="comment">//4. aClass.isAnnotationPresent(Component.class) 判断该类是否有 @Component</span></span><br><span class="line">                        Class&lt;?&gt; aClass = classLoader.loadClass(classFullName);</span><br><span class="line">                        <span class="keyword">if</span> (aClass.isAnnotationPresent(Component.class) ||</span><br><span class="line">                                aClass.isAnnotationPresent(Controller.class) ||</span><br><span class="line">                                aClass.isAnnotationPresent(Service.class) ||</span><br><span class="line">                                aClass.isAnnotationPresent(Repository.class)) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//这里老师演示一个Component注解指定value,分配id</span></span><br><span class="line">                            <span class="comment">//老师就是演示了一下机制.</span></span><br><span class="line">                            <span class="keyword">if</span>(aClass.isAnnotationPresent(Component.class)) &#123;</span><br><span class="line">                                <span class="comment">//获取到该注解</span></span><br><span class="line">                                <span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> aClass.getDeclaredAnnotation(Component.class);</span><br><span class="line">                                <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> component.value();</span><br><span class="line">                                <span class="keyword">if</span>(!<span class="string">&quot;&quot;</span>.endsWith(id)) &#123;</span><br><span class="line">                                    className = id;<span class="comment">//替换</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//这时就可以反射对象，并放入到容器中</span></span><br><span class="line">                            Class&lt;?&gt; clazz = Class.forName(classFullName);</span><br><span class="line">                            <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">                            <span class="comment">//放入到容器中, 将类名的首字母小写作为id</span></span><br><span class="line">                            <span class="comment">//StringUtils</span></span><br><span class="line"></span><br><span class="line">                            ioc.put(StringUtils.uncapitalize(className) , instance);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写方法返回对容器中对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ioc.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-19-4-注意事项和细节说明"><a href="#2-3-19-4-注意事项和细节说明" class="headerlink" title="2.3.19.4 注意事项和细节说明"></a>2.3.19.4 注意事项和细节说明</h4><p>还可以通过@Component(value &#x3D; “xx”) @Controller(value &#x3D; “yy”) @Service(value &#x3D; “zz”)中指定的 value, 给 bean 分配 id</p><h3 id="2-3-20-自动装配"><a href="#2-3-20-自动装配" class="headerlink" title="2.3.20 自动装配"></a>2.3.20 自动装配</h3><h4 id="2-3-20-1-应用实例"><a href="#2-3-20-1-应用实例" class="headerlink" title="2.3.20.1 应用实例"></a>2.3.20.1 应用实例</h4><p>​● 基本说明</p><ol><li><p>基于注解配置 bean，也可实现自动装配，使用的注解是：@AutoWired 或者 @Resource</p></li><li><p><strong>@AutoWired 的规则说明</strong></p><ol><li>🌟在 IOC 容器中查找待装配的组件的<strong>类型</strong>，如果有唯一的 bean 匹配，则使用该 bean 装配 </li><li>🌟如待装配的类型对应的 bean 在 IOC 容器中有多个，则使用<strong>待装配的属性的属性名作为 id 值</strong>再进行查找, 找到就装配，找不到就抛异常</li></ol></li><li><p><strong>@Resource 的规则说明</strong></p><ol><li>🌟@Resource 有两个属性是比较重要的,分是 name 和 type,Spring 将@Resource 注解的name 属性解析为 bean 的名字,而 type 属性则解析为 bean 的类型.所以如果使用 name 属性,则使用 byName 的自动注入策略,而使用 type 属性时则使用 byType 自动注入策略(同样，容器中只能有一个该类型的对象)</li><li>🌟如果@Resource 没有指定 name 和 type ,则先使用byName注入策略(用你的对象名字找ioc容器中的id), 如果匹配不上,再使用 byType 策略(ioc容器中该类型对象必须唯一), 如果都不成功，就会报错</li></ol></li><li><p>总结：<strong>不管是@Autowired 还是 @Resource都保证属性名是规范的写法就可以注入.</strong></p></li></ol><h4 id="2-3-20-2-注意事项和细节说明"><a href="#2-3-20-2-注意事项和细节说明" class="headerlink" title="2.3.20.2 注意事项和细节说明"></a>2.3.20.2 注意事项和细节说明</h4><ol><li>如待装配的类型对应的 bean 在 IOC 容器中有多个， 则使用待装配的属性的属性名作为 id 值再进行查找, 找到就装配， 找不到就抛异常</li></ol><h3 id="2-3-21-泛型依赖注入"><a href="#2-3-21-泛型依赖注入" class="headerlink" title="2.3.21 泛型依赖注入"></a>2.3.21 泛型依赖注入</h3><h4 id="2-3-21-1-泛型依赖解释"><a href="#2-3-21-1-泛型依赖解释" class="headerlink" title="2.3.21.1 泛型依赖解释"></a>2.3.21.1 泛型依赖解释</h4><p>​● 基本说明</p><ol><li><p><strong>为了更好的管理有继承和相互依赖的 bean 的自动装配</strong>， spring 还提供基于泛型依赖的注入机制</p></li><li><p>在继承关系复杂情况下， 泛型依赖注入就会有很大的优越性</p></li></ol><h4 id="2-3-21-2-应用实例"><a href="#2-3-21-2-应用实例" class="headerlink" title="2.3.21.2 应用实例"></a>2.3.21.2 应用实例</h4><p>​● 应用实例需求</p><ol><li>各个类关系图</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230725145512754.png" alt="image-20230725145512754"></p><ol start="2"><li>传统方法是将 PhoneDao &#x2F;BookDao 自动装配到 BookService&#x2F;PhoneSerive 中，当这种继承关系多时，就比较麻烦，可以使用 spring 提供的泛型依赖注入</li></ol><p>(跟配置mybatis plus的service层、impl层、mapper层之间的关系很像)</p><h1 id="3-AOP"><a href="#3-AOP" class="headerlink" title="3 AOP"></a>3 AOP</h1><h2 id="3-1-官方文档"><a href="#3-1-官方文档" class="headerlink" title="3.1 官方文档"></a>3.1 官方文档</h2><h3 id="3-1-1-AOP-讲解"><a href="#3-1-1-AOP-讲解" class="headerlink" title="3.1.1 AOP 讲解:"></a>3.1.1 AOP 讲解:</h3><p>spring-framework-5.3.8&#x2F;docs&#x2F;reference&#x2F;html&#x2F;core.html#aop</p><h3 id="3-1-2-AOP-APIs"><a href="#3-1-2-AOP-APIs" class="headerlink" title="3.1.2 AOP APIs :"></a>3.1.2 AOP APIs :</h3><p>spring-framework-5.3.8&#x2F;docs&#x2F;reference&#x2F;html&#x2F;core.html#aop-api</p><h2 id="3-2-动态代理-精致小案例"><a href="#3-2-动态代理-精致小案例" class="headerlink" title="3.2 动态代理-精致小案例"></a>3.2 动态代理-精致小案例</h2><h3 id="3-2-1-需求说明"><a href="#3-2-1-需求说明" class="headerlink" title="3.2.1 需求说明"></a>3.2.1 需求说明</h3><p>● 需求说明</p><ol><li>有 Vehicle(交通工具接口, 有一个 run 方法), 下面有两个实现类 Car 和 Ship</li><li>当运行 Car 对象 的 run 方法和 Ship 对象的 run 方法时，输入如下内容, 注意观察前后有统一的输出.</li></ol><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230725153717459.png" alt="image-20230725153717459" style="zoom:50%;" /><h3 id="3-2-2-解决方案-传统方式"><a href="#3-2-2-解决方案-传统方式" class="headerlink" title="3.2.2 解决方案-传统方式"></a>3.2.2 解决方案-传统方式</h3><ol><li><p>传统的解决思路， 在各个方法的[前， 执行过程, 后]输出日志提示信息</p></li><li><p>来思考一下， 解决方案好吗? &#x3D;&#x3D;&#x3D;&gt; 代码冗余, 其实就是单个对象的调用,并没有很好的解决</p></li></ol><h3 id="3-2-3-解决方案-🌟动态代理方式"><a href="#3-2-3-解决方案-🌟动态代理方式" class="headerlink" title="3.2.3 解决方案-🌟动态代理方式 !!!!!!!!"></a>3.2.3 解决方案-🌟动态代理方式 !!!!!!!!</h3><p>● 解决方案 2-代码实现</p><ol><li>动态代理解决思路，在调用方法时，使用反射机制，根据方法去决定调用哪个对象方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.spring.proxy2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 韩顺平</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 接口，该接口有run方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fly</span><span class="params">(<span class="type">int</span> height)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.spring.proxy2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VehicleProxyProvider 该类可以返回一个代理对象.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VehicleProxyProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个属性</span></span><br><span class="line">    <span class="comment">//target_vehicle 表示真正要执行的对象</span></span><br><span class="line">    <span class="comment">//该对象实现了Vehicle接口</span></span><br><span class="line">    <span class="keyword">private</span> Vehicle target_vehicle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VehicleProxyProvider</span><span class="params">(Vehicle target_vehicle)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target_vehicle = target_vehicle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，可以返回一个代理对象, 该代理对象可以通过反射机制调用到被代理对象的方法</span></span><br><span class="line">    <span class="comment">//老师解读</span></span><br><span class="line">    <span class="comment">//1. 这个方法非常重要， 理解有一定难度</span></span><br><span class="line">    <span class="keyword">public</span> Vehicle <span class="title function_">getProxy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span></span><br><span class="line">                target_vehicle.getClass().getClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到要代理的对象/被执行对象 的接口信息,底层是通过接口来完成调用</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = target_vehicle.getClass().getInterfaces();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建InvocationHandler 对象</span></span><br><span class="line">        <span class="comment">//因为 InvocationHandler 是接口，所以我们可以通过匿名对象的方式来创建该对象</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * public interface InvocationHandler &#123;</span></span><br><span class="line"><span class="comment">         *  public Object invoke(Object proxy, Method method, Object[] args)</span></span><br><span class="line"><span class="comment">         *         throws Throwable;</span></span><br><span class="line"><span class="comment">         * &#125;</span></span><br><span class="line"><span class="comment">         * invoke 方法是将来执行我们的target_vehicle的方法时，会调用到</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * invoke 方法是将来执行我们的target_vehicle的方法时，会调用到</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> o 表示代理对象</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> method 就是通过代理对象调用方法时，的哪个方法 代理对象.run()</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> args : 表示调用 代理对象.run(xx) 传入的参数</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span> 表示 代理对象.run(xx) 执行后的结果.</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object o, Method method, Object[] args)</span></span><br><span class="line">                    <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;交通工具开始运行了....&quot;</span>);</span><br><span class="line">                <span class="comment">//这里是我们的反射基础 =&gt; OOP</span></span><br><span class="line">                <span class="comment">//method 是？: public abstract void com.hspedu.spring.proxy2.Vehicle.run()</span></span><br><span class="line">                <span class="comment">//target_vehicle 是?: Ship对象</span></span><br><span class="line">                <span class="comment">//args 是null</span></span><br><span class="line">                <span class="comment">//这里通过反射+动态绑定机制，就会执行到被代理对象的方法</span></span><br><span class="line">                <span class="comment">//执行完毕就返回</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target_vehicle, args);</span><br><span class="line">                System.out.println(<span class="string">&quot;交通工具停止运行了....&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          public static Object newProxyInstance(ClassLoader loader,</span></span><br><span class="line"><span class="comment">                                          Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="comment">                                          InvocationHandler h)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          老师解读</span></span><br><span class="line"><span class="comment">          1. Proxy.newProxyInstance() 可以返回一个代理对象</span></span><br><span class="line"><span class="comment">          2. ClassLoader loader: 类的加载器.</span></span><br><span class="line"><span class="comment">          3. Class&lt;?&gt;[] interfaces 就是将来要代理的对象的接口信息</span></span><br><span class="line"><span class="comment">          4. InvocationHandler h 调用处理器/对象 有一个非常重要的方法invoke</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">proxy</span> <span class="operator">=</span></span><br><span class="line">                (Vehicle)Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.spring.proxy2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 韩顺平</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVehicle</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//OOP基础=&gt;java基础</span></span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">vehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ship</span>();</span><br><span class="line">        <span class="comment">//动态绑定</span></span><br><span class="line">        vehicle.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">proxyRun</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建Ship对象</span></span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">vehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建VehicleProxyProvider对象, 并且我们传入的要代理的对象</span></span><br><span class="line">        <span class="type">VehicleProxyProvider</span> <span class="variable">vehicleProxyProvider</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">VehicleProxyProvider</span>(vehicle);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取代理对象, 该对象可以代理执行方法</span></span><br><span class="line">        <span class="comment">//老师解读</span></span><br><span class="line">        <span class="comment">//1. porxy 编译类型 Vehicle</span></span><br><span class="line">        <span class="comment">//2. 运行类型 是代理类型 class com.sun.proxy.$Proxy9</span></span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">proxy</span> <span class="operator">=</span> vehicleProxyProvider.getProxy();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;proxy的编译类型是 Vehicle&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;proxy的运行类型是 &quot;</span> + proxy.getClass());</span><br><span class="line">        <span class="comment">//下面老韩就要给大家解读/debug怎么 执行到 代理对象的 public Object invoke(Object o, Method method, Object[] args)</span></span><br><span class="line">        <span class="comment">//梳理完毕. proxy的编译类型是 Vehicle, 运行类型是 class com.sun.proxy.$Proxy9</span></span><br><span class="line">        <span class="comment">//所以当执行run方法时，会执行到 代理对象的invoke</span></span><br><span class="line">        <span class="comment">//如何体现动态 [1. 被代理的对象 2. 方法]</span></span><br><span class="line">        <span class="comment">//proxy.run();</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> proxy.fly(<span class="number">10000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result=&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-动态代理深入"><a href="#3-3-动态代理深入" class="headerlink" title="3.3 动态代理深入"></a>3.3 动态代理深入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.spring.aop.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 韩顺平</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 可以返回一个动态代理对象, 可以执行SmartDog对象的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProxyProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义我们要执行的目标对象, 该对象需要实现SmartAnimalable</span></span><br><span class="line">    <span class="keyword">private</span> SmartAnimalable target_obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyProxyProvider</span><span class="params">(SmartAnimalable target_obj)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target_obj = target_obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法, 可以返回代理对象，该代理对象可以执行目标对象</span></span><br><span class="line">    <span class="keyword">public</span> SmartAnimalable <span class="title function_">getProxy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 先到的类加载器/对象</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> target_obj.getClass().getClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 得到要执行的目标对象的接口信息</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = target_obj.getClass().getInterfaces();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 创建InvocationHandler</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;方法执行前-日志-方法名-&quot;</span> + method.getName() + <span class="string">&quot;-参数 &quot;</span></span><br><span class="line">                            + Arrays.asList(args)); <span class="comment">//这里从AOP看，就是一个横切关注点-前置通知</span></span><br><span class="line">                    <span class="comment">//使用反射调用方法</span></span><br><span class="line">                    result = method.invoke(target_obj, args);</span><br><span class="line">                    System.out.println(<span class="string">&quot;方法执行正常结束-日志-方法名-&quot;</span> + method.getName() + <span class="string">&quot;-结果result= &quot;</span></span><br><span class="line">                            + result);<span class="comment">//从AOP看, 也是一个横切关注点-返回通知</span></span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">//如果反射执行方法时，出现异常,就会进入到catch&#123;&#125;</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;方法执行异常-日志-方法名-&quot;</span> + method.getName()</span><br><span class="line">                            + <span class="string">&quot;-异常类型=&quot;</span> + e.getClass().getName());<span class="comment">//从AOP看, 也是一个横切关注点-异常通知</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;<span class="comment">//不管你是否出现异常,最终都会执行到finally&#123;&#125;</span></span><br><span class="line">                    <span class="comment">//从AOP的角度看, 也是一个横切关注点-最终通知</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;方法最终结束-日志-方法名-&quot;</span> + method.getName());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        <span class="type">SmartAnimalable</span> <span class="variable">proxy</span> <span class="operator">=</span></span><br><span class="line">                (SmartAnimalable)Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-老韩分析：-问题再次出现"><a href="#3-4-老韩分析：-问题再次出现" class="headerlink" title="3.4 老韩分析： 问题再次出现"></a>3.4 老韩分析： 问题再次出现</h2><h3 id="3-4-1-问题提出"><a href="#3-4-1-问题提出" class="headerlink" title="3.4.1 问题提出"></a>3.4.1 问题提出</h3><p>​● 问题提出</p><ol><li>在 MyProxyProvider.java 中, 我们的输出语句功能比较弱，在实际开发中，我们希望是以一个方法的形式，嵌入到真正执行的目标方法前，怎么办?</li><li>也就是如图分析</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230725164754136.png" alt="image-20230725164754136"></p><h3 id="3-4-2-用老韩的土方法解决"><a href="#3-4-2-用老韩的土方法解决" class="headerlink" title="3.4.2 用老韩的土方法解决"></a>3.4.2 用老韩的土方法解决</h3><ol><li><p>需求分析： 使用老韩的土方法解决前面的问题 &#x3D;&gt; 后面使用 Spring 的 AOP 组件完成, 先过苦日子， 再过甜日子</p></li><li><p>先新建一个包，把相关文件拷贝过来，进行修改完成，思路更加清晰.</p></li></ol><p>老师学习小技巧:新建一个包，保留原来的代码</p><p>具体实现方式省略…………把红框里的代码在同一类中自行封装成一个个方法即可</p><ol start="3"><li>该方法问题分析：耦合度高</li></ol><h3 id="3-4-3-对土方法解耦-开发简易的-AOP-类"><a href="#3-4-3-对土方法解耦-开发简易的-AOP-类" class="headerlink" title="3.4.3 对土方法解耦-开发简易的 AOP 类"></a>3.4.3 对土方法解耦-开发简易的 AOP 类</h3><p>把这些方法抽出，放到一个类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 韩顺平</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 我们自己编写一个一个极简的AOP类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HspAOP</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们一个方法,在目标对象执行前执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HspAOP-方法执行前-日志-方法名-&quot;</span> + method.getName() + <span class="string">&quot;-参数 &quot;</span></span><br><span class="line">                + Arrays.asList(args)); <span class="comment">//这里从AOP看，就是一个横切关注点-前置通知</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们一个方法,在目标对象执行后执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(Method method, Object result)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HspAOP-方法执行正常结束-日志-方法名-&quot;</span> + method.getName() + <span class="string">&quot;-结果result= &quot;</span> + result);<span class="comment">//从AOP看, 也是一个横切关注点-返回通知</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-4-再次分析-提出-Spring-AOP"><a href="#3-4-4-再次分析-提出-Spring-AOP" class="headerlink" title="3.4.4 再次分析-提出 Spring AOP"></a>3.4.4 再次分析-提出 Spring AOP</h3><h4 id="3-4-4-1-土方法-不够灵活"><a href="#3-4-4-1-土方法-不够灵活" class="headerlink" title="3.4.4.1 土方法 不够灵活"></a>3.4.4.1 土方法 不够灵活</h4><h4 id="3-4-4-2-土方法-复用性差"><a href="#3-4-4-2-土方法-复用性差" class="headerlink" title="3.4.4.2 土方法 复用性差"></a>3.4.4.2 土方法 复用性差</h4><h4 id="3-4-4-3-土方法-还是一种硬编码-因为没有注解和反射支撑"><a href="#3-4-4-3-土方法-还是一种硬编码-因为没有注解和反射支撑" class="headerlink" title="3.4.4.3 土方法 还是一种硬编码(因为没有注解和反射支撑)"></a>3.4.4.3 土方法 还是一种硬编码(因为没有注解和反射支撑)</h4><h4 id="3-4-4-4-Spring-AOP-闪亮登场-底层是-ASPECTJ"><a href="#3-4-4-4-Spring-AOP-闪亮登场-底层是-ASPECTJ" class="headerlink" title="3.4.4.4 Spring AOP 闪亮登场-底层是 ASPECTJ"></a>3.4.4.4 Spring AOP 闪亮登场-底层是 ASPECTJ</h4><h4 id="3-4-4-5-有了前面的技术引导，-理解-Spring-AOP-就水到渠成"><a href="#3-4-4-5-有了前面的技术引导，-理解-Spring-AOP-就水到渠成" class="headerlink" title="3.4.4.5 有了前面的技术引导， 理解 Spring AOP 就水到渠成"></a>3.4.4.5 有了前面的技术引导， 理解 Spring AOP 就水到渠成</h4><h2 id="3-5-AOP-的基本介绍"><a href="#3-5-AOP-的基本介绍" class="headerlink" title="3.5 AOP 的基本介绍"></a>3.5 AOP 的基本介绍</h2><p>​● 什么是 AOP</p><p>​AOP 的全称(aspect oriented programming) ，<strong>面向切面编程</strong></p><p>​● 2 张示意图说明 AOP 的相关概念</p><ol><li>一张简易图说明 AOP</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230725224710622.png" alt="image-20230725224710622"></p><ol start="2"><li>一张详细图说明 AOP</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230725225233953.png" alt="image-20230725225233953"></p><p>● AOP 实现方式</p><ol><li><p>基于动态代理的方式[内置 aop 实现]</p></li><li><p>使用框架 aspectj 来实现</p></li></ol><h2 id="3-6-AOP-编程快速入门"><a href="#3-6-AOP-编程快速入门" class="headerlink" title="3.6 AOP 编程快速入门"></a>3.6 AOP 编程快速入门</h2><h2 id="3-6-1-基本说明"><a href="#3-6-1-基本说明" class="headerlink" title="3.6.1 基本说明"></a>3.6.1 基本说明</h2><p>​● 说明</p><ol><li><p>需要引入核心的 aspect 包</p></li><li><p>在切面类中声明通知方法</p><ol><li>前置通知：@Before</li><li>返回通知：@AfterReturning</li><li>异常通知：@AfterThrowing</li><li>后置通知：@After</li><li>环绕通知：@Around</li></ol></li></ol><h3 id="3-6-2-快速入门实例"><a href="#3-6-2-快速入门实例" class="headerlink" title="3.6.2 快速入门实例"></a>3.6.2 快速入门实例</h3><p>​● 需求说明</p><p>​我们使用 aop 编程的方式，来实现手写的动态代理案例效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.spring.aop.aspectj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.Signature;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切面类 , 类似于我们以前自己写的MyProxyProvider,但是功能强大很多</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Order(value = 1)</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//表示是一个切面类[底层切面编程的支撑(动态代理+反射+动态绑定...)]</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">//会将SmartAnimalAspect3注入到容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmartAnimalAspect3</span> &#123;</span><br><span class="line">    <span class="comment">//希望将f1方法切入到SmartDog-getSum前执行-前置通知</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 老师解读</span></span><br><span class="line"><span class="comment">     * 1. <span class="doctag">@Before</span> 表示前置通知:即在我们的目标对象执行方法前执行</span></span><br><span class="line"><span class="comment">     * 2. value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float)</span></span><br><span class="line"><span class="comment">     * 指定切入到哪个类的哪个方法  形式是: 访问修饰符 返回类型 全类名.方法名(形参列表)</span></span><br><span class="line"><span class="comment">     * 3. showBeginLog方法可以理解成就是一个切入方法, 这个方法名是可以程序员指定  比如:showBeginLog</span></span><br><span class="line"><span class="comment">     * 4. JoinPoint joinPoint 在底层执行时，由AspectJ切面框架，会给该切入方法传入joinPoint对象, 通过                                                   * 该方法，程序员可以获取到相关信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showBeginLog</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="comment">//通过连接点对象joinPoint 可以获取方法签名</span></span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        System.out.println(<span class="string">&quot;SmartAnimalAspect3-切面类showBeginLog()-方法执行前-日志-方法名-&quot;</span> + signature.getName() + <span class="string">&quot;-参数 &quot;</span></span><br><span class="line">                + Arrays.asList(joinPoint.getArgs()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回通知：即把showSuccessEndLog方法切入到目标对象方法正常执行完毕后的地方</span></span><br><span class="line">    <span class="comment">//老韩解读</span></span><br><span class="line">    <span class="comment">//1. 如果我们希望把目标方法执行的结果，返回给切入方法</span></span><br><span class="line">    <span class="comment">//2. 可以再 @AfterReturning 增加属性 , 比如 returning = &quot;res&quot;</span></span><br><span class="line">    <span class="comment">//3. 同时在切入方法增加 Object res</span></span><br><span class="line">    <span class="comment">//4. 注意: returning = &quot;res&quot; 和 Object res 的 res名字一致</span></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float))&quot;, returning = &quot;res&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showSuccessEndLog</span><span class="params">(JoinPoint joinPoint, Object res)</span> &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        System.out.println(<span class="string">&quot;SmartAnimalAspect3-切面类showSuccessEndLog()-方法执行正常结束-日志-方法名-&quot;</span> + signature.getName() + <span class="string">&quot; 返回的结果是=&quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常通知：即把showExceptionLog方法切入到目标对象方法执行发生异常的的catch&#123;&#125;</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float))&quot;, throwing = &quot;throwable&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showExceptionLog</span><span class="params">(JoinPoint joinPoint, Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        System.out.println(<span class="string">&quot;SmartAnimalAspect3-切面类showExceptionLog()-方法执行异常-日志-方法名-&quot;</span> + signature.getName() + <span class="string">&quot; 异常信息=&quot;</span> + throwable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终通知：即把showFinallyEndLog方法切入到目标方法执行后(不管是否发生异常,都要执行 finally&#123;&#125;)</span></span><br><span class="line">    <span class="meta">@After(value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showFinallyEndLog</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        System.out.println(<span class="string">&quot;SmartAnimalAspect3-切面类showFinallyEndLog()-方法最终执行完毕-日志-方法名-&quot;</span> + signature.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用AOP时，记得在beans.xml中添加以下代码，以开启基于注解的 AOP 功能 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-6-3-细节说明"><a href="#3-6-3-细节说明" class="headerlink" title="3.6.3 细节说明"></a>3.6.3 细节说明</h3><ol><li><p>关于切面类方法命名可以自己规范一下, 比如 showBeginLog(), showSuccessEndLog(), showExceptionLog() , showFinallyEndLog()</p></li><li><p>切入表达式的更多配置，比如使用模糊配置@Before(value&#x3D;”execution(* com.hspedu.aop.proxy.SmartDog.*(..))”)</p></li><li><p>表示所有访问权限，所有包的下所有有类的所方法，都会被执行该前置通知方法</p></li></ol><p>​@Before(value&#x3D;”execution(* <em>.</em>(..))”)</p><ol start="4"><li><strong>当 spring 容器开启了 <!-- 开启基于注解的 AOP 功能 -->&lt; aop:aspectj-autoproxy&#x2F;&gt; , 我们获取注入的对象, 需要以接口的类型来获取, 因为你注入的对象.getClass() 已经是代理类型了!</strong></li><li><strong>当 spring 容器开启了 <!-- 开启基于注解的 AOP 功能 -->&lt; aop:aspectj-autoproxy&#x2F;&gt;  , 我们获取注入的对象, 也可以通过 id 来获取, 但是也要转成接口类型</strong></li></ol><h2 id="3-7-AOP-切入表达式"><a href="#3-7-AOP-切入表达式" class="headerlink" title="3.7 AOP-切入表达式"></a>3.7 AOP-切入表达式</h2><h3 id="3-7-1-具体使用"><a href="#3-7-1-具体使用" class="headerlink" title="3.7.1 具体使用"></a>3.7.1 具体使用</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230726083322753.png" alt="image-20230726083322753"></p><h3 id="3-7-2-注意事项和细节"><a href="#3-7-2-注意事项和细节" class="headerlink" title="3.7.2 注意事项和细节"></a>3.7.2 注意事项和细节</h3><ol><li><p>切入表达式可以指向类的方法, 这时切入表达式会对该类&#x2F;对象生效(类名.*)</p></li><li><p>切入表达式也可以<strong>指向接口的方法</strong>, 这时切入表达式会**<u>对实现了接口的类&#x2F;对象生效</u>**</p></li><li><p>切入表达式也可以对没有实现接口的类，进行切入</p></li><li><p>老师补充: 动态代理 jdk 的 Proxy 与 Spring 的 CGlib</p></li></ol><p>🌟<a href="https://www.cnblogs.com/threeAgePie/p/15832586.html">https://www.cnblogs.com/threeAgePie/p/15832586.html</a></p><p>—对没有实现接口的类生成的代理是CGlib动态代理</p><h4 id="两个动态代理的区别"><a href="#两个动态代理的区别" class="headerlink" title="两个动态代理的区别"></a>两个动态代理的区别</h4><ol><li>JDK动态代理是面向接口的，只能增强实现类中接口中存在的方法。CGlib是面向父类的，可以增强父类的所有方法</li><li>JDK得到的对象是JDK代理对象实例，而CGlib得到的对象是被代理对象的子类</li></ol><h2 id="3-8-AOP-JoinPoint"><a href="#3-8-AOP-JoinPoint" class="headerlink" title="3.8 AOP-JoinPoint"></a>3.8 AOP-JoinPoint</h2><h3 id="3-8-1-应用实例"><a href="#3-8-1-应用实例" class="headerlink" title="3.8.1 应用实例"></a>3.8.1 应用实例</h3><p>​● 通过 JoinPoint 可以获取到调用方法的签名</p><p>​● 应用实例需求</p><p>说明: 在调用前置通知获取到调用方法的签名, 和其它相关信息</p><p>​● 应用实例-代码实现</p><p>​前面我们已经举例说明过了</p><p>​● 其它常用方法一览</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeMethod</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">joinPoint.getSignature().getName(); <span class="comment">// 获取目标方法名    </span></span><br><span class="line">joinPoint.getSignature().getDeclaringType().getSimpleName(); <span class="comment">// 获取目标方法所属类的简单类名</span></span><br><span class="line">joinPoint.getSignature().getDeclaringTypeName(); <span class="comment">// 获取目标方法所属类的类名</span></span><br><span class="line">joinPoint.getSignature().getModifiers(); <span class="comment">// 获取目标方法声明类型(public、 private、protected)</span></span><br><span class="line">  Object[] args = joinPoint.getArgs(); <span class="comment">// 获取传入目标方法的参数， 返回一个数组</span></span><br><span class="line">  joinPoint.getTarget(); <span class="comment">// 获取被代理的对象joinPoint.getThis(); // 获取代理对象自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-9-AOP-返回通知获取结果"><a href="#3-9-AOP-返回通知获取结果" class="headerlink" title="3.9 AOP-返回通知获取结果"></a>3.9 AOP-返回通知获取结果</h2><h3 id="3-9-1-应用实例"><a href="#3-9-1-应用实例" class="headerlink" title="3.9.1 应用实例"></a>3.9.1 应用实例</h3><p>​● 如何在返回通知方法获取返回结果</p><p>​看一个需求:</p><p>​在返回通知方法获取返回的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 如果我们希望把目标方法执行的结果，返回给切入方法</span></span><br><span class="line"><span class="comment">//2. 可以再 @AfterReturning 增加属性 , 比如 returning = &quot;res&quot;</span></span><br><span class="line"><span class="comment">//3. 同时在切入方法增加 Object res</span></span><br><span class="line"><span class="comment">//4. 注意: returning = &quot;res&quot; 和 Object res 的 res名字一致</span></span><br><span class="line"><span class="meta">@AfterReturning(value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float))&quot;, returning = &quot;res&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showSuccessEndLog</span><span class="params">(JoinPoint joinPoint, Object res)</span> &#123;</span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">    System.out.println(<span class="string">&quot;SmartAnimalAspect3-切面类showSuccessEndLog()-方法执行正常结束-日志-方法名-&quot;</span> + signature.getName() + <span class="string">&quot; 返回的结果是=&quot;</span> + res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-10-AOP-异常通知中获取异常"><a href="#3-10-AOP-异常通知中获取异常" class="headerlink" title="3.10 AOP-异常通知中获取异常"></a>3.10 AOP-异常通知中获取异常</h2><p>同理……</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异常通知：即把showExceptionLog方法切入到目标对象方法执行发生异常的的catch&#123;&#125;</span></span><br><span class="line"><span class="meta">@AfterThrowing(value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float))&quot;, throwing = &quot;throwable&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showExceptionLog</span><span class="params">(JoinPoint joinPoint, Throwable throwable)</span> &#123;</span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">    System.out.println(<span class="string">&quot;SmartAnimalAspect3-切面类showExceptionLog()-方法执行异常-日志-方法名-&quot;</span> + signature.getName() + <span class="string">&quot; 异常信息=&quot;</span> + throwable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-11-AOP-环绕通知【了解】"><a href="#3-11-AOP-环绕通知【了解】" class="headerlink" title="3.11 AOP-环绕通知【了解】"></a>3.11 AOP-环绕通知【了解】</h2><h3 id="3-11-1-应用实例"><a href="#3-11-1-应用实例" class="headerlink" title="3.11.1 应用实例"></a>3.11.1 应用实例</h3><p>​● 环绕通知可以完成其它四个通知要做的事情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示环绕通知的使用-了解</span></span><br><span class="line"><span class="comment">//老师解读</span></span><br><span class="line"><span class="comment">//1. @Around: 表示这是一个环绕通知[完成其它四个通知的功能]</span></span><br><span class="line"><span class="comment">//2. value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float)) 切入点表达式</span></span><br><span class="line"><span class="comment">//3. doAround 表示要切入的方法 - 调用结构 try-catch-finally</span></span><br><span class="line"><span class="meta">@Around(value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.相当于前置通知完成的事情</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        List&lt;Object&gt; argList = Arrays.asList(args);</span><br><span class="line">        System.out.println(<span class="string">&quot;AOP环绕通知[-前置通知]&quot;</span> + methodName + <span class="string">&quot;方法开始了--参数有：&quot;</span> + argList);</span><br><span class="line">        <span class="comment">//在环绕通知中一定要调用joinPoint.proceed()来执行目标方法</span></span><br><span class="line">        result = joinPoint.proceed();</span><br><span class="line">        <span class="comment">//2.相当于返回通知完成的事情</span></span><br><span class="line">        System.out.println(<span class="string">&quot;AOP环绕通知[-返回通知]&quot;</span> + methodName + <span class="string">&quot;方法结束了--结果是：&quot;</span> + result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        <span class="comment">//3.相当于异常通知完成的事情</span></span><br><span class="line">        System.out.println(<span class="string">&quot;AOP环绕通知[-异常通知]&quot;</span> + methodName + <span class="string">&quot;方法抛异常了--异常对象：&quot;</span> + throwable);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.相当于最终通知完成的事情</span></span><br><span class="line">        System.out.println(<span class="string">&quot;AOP环绕通知[-后置通知]&quot;</span> + methodName + <span class="string">&quot;方法最终结束了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-12-AOP-切入点表达式重用"><a href="#3-12-AOP-切入点表达式重用" class="headerlink" title="3.12 AOP-切入点表达式重用"></a>3.12 AOP-切入点表达式重用</h2><h3 id="3-12-1-应用实例"><a href="#3-12-1-应用实例" class="headerlink" title="3.12.1 应用实例"></a>3.12.1 应用实例</h3><p>● 切入点表达式重用(其实就是把切入表达式提取出来，这样可以避免当一个方法需要多次切入时，每个切入方法都需要重写一遍切入表达式的情况)</p><p>为了统一管理切入点表达式，可以使用切入点表达式重用技术</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个切入点, 在后面使用时可以直接引用, 提高了复用性</span></span><br><span class="line"><span class="meta">@Pointcut(value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float)))</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string">public void myPointCut() &#123;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//希望将myPointCut方法切入到SmartDog-getSum前执行-前置通知</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * 老师解读</span></span><br><span class="line"><span class="string"> * 1. @Before 表示前置通知:即在我们的目标对象执行方法前执行</span></span><br><span class="line"><span class="string"> * 2. value = &quot;</span>execution(<span class="keyword">public</span> <span class="type">float</span> com.hspedu.spring.aop.aspectj.SmartDog.getSum(<span class="type">float</span>, <span class="type">float</span>)</span><br><span class="line"> * 指定切入到哪个类的哪个方法  形式是: 访问修饰符 返回类型 全类名.方法名(形参列表)</span><br><span class="line"> * <span class="number">3.</span> showBeginLog方法可以理解成就是一个切入方法, 这个方法名是可以程序员指定  比如:showBeginLog</span><br><span class="line"> * <span class="number">4.</span> JoinPoint joinPoint 在底层执行时，由AspectJ切面框架， 会给该切入方法传入 joinPoint对象</span><br><span class="line"> * , 通过该方法，程序员可以获取到 相关信息</span><br><span class="line"> *</span><br><span class="line"> * <span class="meta">@param</span> joinPoint</span><br><span class="line"> */</span><br><span class="line"><span class="comment">//@Before(value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float))&quot;)</span></span><br><span class="line"><span class="comment">//这里我们使用定义好的切入点</span></span><br><span class="line"><span class="meta">@Before(value = &quot;myPointCut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showBeginLog</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">    <span class="comment">//通过连接点对象joinPoint 可以获取方法签名</span></span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">    System.out.println(<span class="string">&quot;SmartAnimalAspect-切面类showBeginLog()[使用的myPointCut()]-方法执行前-日志-方法名-&quot;</span> + signature.getName() + <span class="string">&quot;-参数 &quot;</span></span><br><span class="line">            + Arrays.asList(joinPoint.getArgs()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回通知：即把showSuccessEndLog方法切入到目标对象方法正常执行完毕后的地方</span></span><br><span class="line"><span class="comment">//老韩解读</span></span><br><span class="line"><span class="comment">//1. 如果我们希望把目标方法执行的结果，返回给切入方法</span></span><br><span class="line"><span class="comment">//2. 可以再 @AfterReturning 增加属性 , 比如 returning = &quot;res&quot;</span></span><br><span class="line"><span class="comment">//3. 同时在切入方法增加 Object res</span></span><br><span class="line"><span class="comment">//4. 注意: returning = &quot;res&quot; 和 Object res 的 res名字一致</span></span><br><span class="line"><span class="comment">//@AfterReturning(value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float))&quot;, returning = &quot;res&quot;)</span></span><br><span class="line"><span class="comment">//使用切入点</span></span><br><span class="line"><span class="meta">@AfterReturning(value = &quot;myPointCut()&quot;, returning = &quot;res&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showSuccessEndLog</span><span class="params">(JoinPoint joinPoint, Object res)</span> &#123;</span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">    System.out.println(<span class="string">&quot;SmartAnimalAspect-切面类showSuccessEndLog()-方法执行正常结束-日志-方法名-&quot;</span> + signature.getName() + <span class="string">&quot; 返回的结果是=&quot;</span> + res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//异常通知：即把showExceptionLog方法切入到目标对象方法执行发生异常的的catch&#123;&#125;</span></span><br><span class="line"><span class="comment">//@AfterThrowing(value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float))&quot;, throwing = &quot;throwable&quot;)</span></span><br><span class="line"><span class="comment">//直接使用切入点表达式</span></span><br><span class="line"><span class="meta">@AfterThrowing(value = &quot;myPointCut()&quot;, throwing = &quot;throwable&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showExceptionLog</span><span class="params">(JoinPoint joinPoint, Throwable throwable)</span> &#123;</span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">    System.out.println(<span class="string">&quot;SmartAnimalAspect-切面类showExceptionLog()-方法执行异常-日志-方法名-&quot;</span> + signature.getName() + <span class="string">&quot; 异常信息=&quot;</span> + throwable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终通知：即把showFinallyEndLog方法切入到目标方法执行后(不管是否发生异常,都要执行 finally&#123;&#125;)</span></span><br><span class="line"><span class="comment">//@After(value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float))&quot;)</span></span><br><span class="line"><span class="comment">//直接使用切入点</span></span><br><span class="line"><span class="meta">@After(value = &quot;myPointCut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showFinallyEndLog</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">    System.out.println(<span class="string">&quot;SmartAnimalAspect-切面类showFinallyEndLog()-方法最终执行完毕-日志-方法名-&quot;</span> + signature.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-13-AOP-切面优先级问题"><a href="#3-13-AOP-切面优先级问题" class="headerlink" title="3.13 AOP-切面优先级问题"></a>3.13 AOP-切面优先级问题</h2><h3 id="3-13-1-应用实例"><a href="#3-13-1-应用实例" class="headerlink" title="3.13.1 应用实例"></a>3.13.1 应用实例</h3><p>​● 切面优先级问题:</p><p>​如果同一个方法，有多个切面在同一个切入点切入，那么执行的优先级如何控制.</p><p>​● 基本语法:</p><p>​@order(value&#x3D;n) 来控制 n 值越小，优先级越高.</p><h3 id="3-13-2-注意事项和细节说明"><a href="#3-13-2-注意事项和细节说明" class="headerlink" title="3.13.2 注意事项和细节说明"></a>3.13.2 注意事项和细节说明</h3><ol><li>不能理解成： 优先级高的每个消息通知都先执行， 这个和方法调用机制(和 Filter 过滤器链式调用类似)</li></ol><p><strong>优先级越高，前置通知先执行(队列)，但其他的通知都是最后执行(栈)</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230726092923563.png" alt="image-20230726092923563"></p><h2 id="3-14-AOP-基于-XML-配置-AOP"><a href="#3-14-AOP-基于-XML-配置-AOP" class="headerlink" title="3.14 AOP-基于 XML 配置 AOP"></a>3.14 AOP-基于 XML 配置 AOP</h2><h3 id="3-14-1-应用实例"><a href="#3-14-1-应用实例" class="headerlink" title="3.14.1 应用实例"></a>3.14.1 应用实例</h3><p>​● 基本说明:</p><p>​前面我们是通过注解来配置 aop 的， 在 spring 中， 我们也可以通过 xml 的方式来配置 AOP</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--使用XML配置，完成AOP编程--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置一个切面类对象-bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.hspedu.spring.aop.xml.SmartAnimalAspect&quot;</span> <span class="attr">id</span>=<span class="string">&quot;smartAnimalAspect&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置一个SmartDog对象-bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.hspedu.spring.aop.xml.SmartDog&quot;</span> <span class="attr">id</span>=<span class="string">&quot;smartDog&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切面类, 细节一定要引入 xmlns:aop--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(public float com.hspedu.spring.aop.xml.SmartDog.getSum(float, float)))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切面的前置，返回, 异常, 最终通知--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;smartAnimalAspect&quot;</span> <span class="attr">order</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置前置通知--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;showBeginLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--返回通知--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;showSuccessEndLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">returning</span>=<span class="string">&quot;res&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--异常通知--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;showExceptionLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;throwable&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--最终通知--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;showFinallyEndLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置环绕通知--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;aop:around method=&quot;&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="4-手动实现-Spring-底层机制【-初始化-IOC容器-依赖注入-BeanPostProcessor-机制-AOP】"><a href="#4-手动实现-Spring-底层机制【-初始化-IOC容器-依赖注入-BeanPostProcessor-机制-AOP】" class="headerlink" title="4 手动实现 Spring 底层机制【 初始化 IOC容器+依赖注入+BeanPostProcessor 机制+AOP】"></a>4 手动实现 Spring 底层机制【 初始化 IOC容器+依赖注入+BeanPostProcessor 机制+AOP】</h1><h3 id="4-1-1-引言：-前面我们实际上已经用代码简单实现了"><a href="#4-1-1-引言：-前面我们实际上已经用代码简单实现了" class="headerlink" title="4.1.1 引言： 前面我们实际上已经用代码简单实现了"></a>4.1.1 引言： 前面我们实际上已经用代码简单实现了</h3><h4 id="4-1-1-1-Spring-XML-注入-bean"><a href="#4-1-1-1-Spring-XML-注入-bean" class="headerlink" title="4.1.1.1 Spring XML 注入 bean"></a>4.1.1.1 Spring XML 注入 bean</h4><h4 id="4-1-1-2-Spring-注解方式注入-bean"><a href="#4-1-1-2-Spring-注解方式注入-bean" class="headerlink" title="4.1.1.2 Spring 注解方式注入 bean"></a>4.1.1.2 Spring 注解方式注入 bean</h4><h4 id="4-1-1-3-Spring-AOP-动态代理实现"><a href="#4-1-1-3-Spring-AOP-动态代理实现" class="headerlink" title="4.1.1.3 Spring AOP 动态代理实现"></a>4.1.1.3 Spring AOP 动态代理实现</h4><h3 id="4-1-2-继续思考-原生-Spring-如何实现依赖注入和-singleton、-prototype"><a href="#4-1-2-继续思考-原生-Spring-如何实现依赖注入和-singleton、-prototype" class="headerlink" title="4.1.2 继续思考-原生 Spring 如何实现依赖注入和 singleton、 prototype"></a>4.1.2 继续思考-原生 Spring 如何实现依赖注入和 singleton、 prototype</h3><h4 id="4-1-2-1-实例演示-Maven-项目"><a href="#4-1-2-1-实例演示-Maven-项目" class="headerlink" title="4.1.2.1 实例演示-Maven 项目"></a>4.1.2.1 实例演示-Maven 项目</h4><p>其实就是第二章，去看一下即可……</p><p>​● 快速给小伙伴完成这个小案例(提示： 创建新项目, 不和原来的 Spring 混在一起)</p><ol><li><h5 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h5></li><li><h5 id="修改-pom-xml-引入需要的-jar-包"><a href="#修改-pom-xml-引入需要的-jar-包" class="headerlink" title="修改 pom.xml, 引入需要的 jar 包"></a>修改 pom.xml, 引入需要的 jar 包</h5></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加入spring开发的基本包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加入spring开发切面编程需要的包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><h5 id="创-建UserAction-java"><a href="#创-建UserAction-java" class="headerlink" title="创 建UserAction.java"></a>创 建UserAction.java</h5></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 就是一个Controller</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//也可以使用@Controller</span></span><br><span class="line"><span class="comment">//在默认情况下 我们配置@Component @Controller @Service @Repository 是单例</span></span><br><span class="line"><span class="comment">//@Scope(value = &quot;prototype&quot;) 表示以多实例形式，返回UserAction bean</span></span><br><span class="line"><span class="comment">//老师思考:Spring容器底层如何实现</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//@Scope(value = &quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAction</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><h5 id="创-建UserDao-java"><a href="#创-建UserDao-java" class="headerlink" title="创 建UserDao.java"></a>创 建UserDao.java</h5></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以使用@Repository</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserDao-hi()---&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><h5 id="创-建UserService-java"><a href="#创-建UserService-java" class="headerlink" title="创 建UserService.java"></a>创 建UserService.java</h5></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以使用@Service</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="comment">//老师思考：加入 @Autowired , Spring容器时如何实现依赖注入?</span></span><br><span class="line">    <span class="comment">//也可以使用@Resource</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.hi();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里我们需要指定init() 是初始化方法</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserService-init()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><h5 id="创建-beans-xml"><a href="#创建-beans-xml" class="headerlink" title="创建 beans.xml"></a>创建 beans.xml</h5></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置自动扫描的包, 同时引入对应的名称空间--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--老师说明：</span></span><br><span class="line"><span class="comment">    1. 如果我们是普通的java项目, beans.xml 放在src下</span></span><br><span class="line"><span class="comment">    2. 如果我们是java maven 项目, beans.xml 放在 src/main/resources</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hspedu.spring.component&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hspedu.spring.aop&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--启用基于注解方式的AOP功能--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置后置处理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.hspedu.spring.process.MyBeanPostProcessor&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myBeanPostProcessor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="7"><li><h5 id="创建-AppMain-java"><a href="#创建-AppMain-java" class="headerlink" title="创建 AppMain.java"></a>创建 AppMain.java</h5></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试看看是否可以得到spring容器中的bean , 同时看看依赖注入是否OK</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ioc</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserAction</span> <span class="variable">userAction</span> <span class="operator">=</span> (UserAction) ioc.getBean(<span class="string">&quot;userAction&quot;</span>);</span><br><span class="line">        <span class="type">UserAction</span> <span class="variable">userAction2</span> <span class="operator">=</span> (UserAction) ioc.getBean(<span class="string">&quot;userAction&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;userAction=&quot;</span> + userAction);</span><br><span class="line">        System.out.println(<span class="string">&quot;userAction2=&quot;</span> + userAction2);</span><br><span class="line"></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) ioc.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;userDao=&quot;</span> + userDao);</span><br><span class="line"></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ioc.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;userService=&quot;</span> + userService);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试一下当前的依赖注入</span></span><br><span class="line">        userService.m1();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试一下AOP</span></span><br><span class="line">        <span class="type">SmartAnimalable</span> <span class="variable">smartDog</span> <span class="operator">=</span> ioc.getBean(SmartAnimalable.class);</span><br><span class="line">        smartDog.getSum(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-2-思考问题"><a href="#4-1-2-2-思考问题" class="headerlink" title="4.1.2.2 思考问题"></a>4.1.2.2 思考问题</h4><h5 id="4-1-2-2-1-Spring-底层实现-如何实现-IOC-容器创建和初始化【前面我们实现过，-现在要再深入】"><a href="#4-1-2-2-1-Spring-底层实现-如何实现-IOC-容器创建和初始化【前面我们实现过，-现在要再深入】" class="headerlink" title="4.1.2.2.1 Spring 底层实现, 如何实现 IOC 容器创建和初始化【前面我们实现过， 现在要再深入】"></a>4.1.2.2.1 Spring 底层实现, 如何实现 IOC 容器创建和初始化【前面我们实现过， 现在要再深入】</h5><h5 id="4-1-2-2-2-Spring-底层实现-如何实现-getBean-根据-singleton-和-prototype-来返回-bean-实例"><a href="#4-1-2-2-2-Spring-底层实现-如何实现-getBean-根据-singleton-和-prototype-来返回-bean-实例" class="headerlink" title="4.1.2.2.2 Spring 底层实现, 如何实现 getBean, 根据 singleton 和 prototype 来返回 bean 实例"></a>4.1.2.2.2 Spring 底层实现, 如何实现 getBean, 根据 singleton 和 prototype 来返回 bean 实例</h5><h3 id="4-1-3-继续思考-原生-Spring-如何实现-BeanPostProcessor"><a href="#4-1-3-继续思考-原生-Spring-如何实现-BeanPostProcessor" class="headerlink" title="4.1.3 继续思考-原生 Spring 如何实现 BeanPostProcessor"></a>4.1.3 继续思考-原生 Spring 如何实现 BeanPostProcessor</h3><h4 id="4-1-3-1-实例演示"><a href="#4-1-3-1-实例演示" class="headerlink" title="4.1.3.1 实例演示"></a>4.1.3.1 实例演示</h4><ol><li>创 建MyBeanPostProcessor.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在Bean的 init初始化方法前调用-&gt; 这个知识点，在前面讲解后置处理器时讲过的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;postProcessBeforeInitialization 被 调 用 &quot;</span> + beanName + <span class="string">&quot; bean= &quot;</span> + bean.getClass());</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在Bean的 init初始化方法后调用-&gt; 这个知识点，在前面讲解后置处理器时讲过的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postProcessAfterInitialization 被 调 用 &quot;</span> + beanName + <span class="string">&quot; bean= &quot;</span> + bean.getClass());</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-2-思考问题"><a href="#4-1-3-2-思考问题" class="headerlink" title="4.1.3.2 思考问题"></a>4.1.3.2 思考问题</h4><h5 id="4-1-3-2-1-Spring-底层实现-如何实现-Bean-后置处理器机制"><a href="#4-1-3-2-1-Spring-底层实现-如何实现-Bean-后置处理器机制" class="headerlink" title="4.1.3.2.1 Spring 底层实现, 如何实现 Bean 后置处理器机制"></a>4.1.3.2.1 Spring 底层实现, 如何实现 Bean 后置处理器机制</h5><p>——当然是动态代理呀</p><h3 id="4-1-4-继续思考-原生-Spring-是如何实现-AOP"><a href="#4-1-4-继续思考-原生-Spring-是如何实现-AOP" class="headerlink" title="4.1.4 继续思考-原生 Spring 是如何实现 AOP"></a>4.1.4 继续思考-原生 Spring 是如何实现 AOP</h3><h4 id="4-1-4-1-实例演示"><a href="#4-1-4-1-实例演示" class="headerlink" title="4.1.4.1 实例演示"></a>4.1.4.1 实例演示</h4><p>看第三章…… </p><h4 id="4-1-4-2-简单分析-AOP-和-BeanPostProcessor-关系"><a href="#4-1-4-2-简单分析-AOP-和-BeanPostProcessor-关系" class="headerlink" title="4.1.4.2 简单分析 AOP 和 BeanPostProcessor 关系"></a>4.1.4.2 简单分析 AOP 和 BeanPostProcessor 关系</h4><p>……</p><p>老韩解读：</p><ul><li>AOP 底层是基于 BeanPostProcessor 机制的.</li><li>即在 Bean 创建好后，<strong>根据是否需要 AOP 处理</strong>，决定返回代理对象，还是原生 Bean</li><li>在返回代理对象时，就可以根据要代理的类和方法来返回</li><li>其实这个机制并不难，本质就是在 BeanPostProcessor 机制 + 动态代理技术</li></ul><h4 id="4-1-4-3-思考问题"><a href="#4-1-4-3-思考问题" class="headerlink" title="4.1.4.3 思考问题"></a>4.1.4.3 思考问题</h4><h5 id="4-1-4-3-1-Spring-底层实现-如何实现-AOP-编程"><a href="#4-1-4-3-1-Spring-底层实现-如何实现-AOP-编程" class="headerlink" title="4.1.4.3.1 Spring 底层实现, 如何实现 AOP 编程"></a>4.1.4.3.1 Spring 底层实现, 如何实现 AOP 编程</h5><h3 id="4-1-5-我们的目标-不用-Spring-框架-模拟-Spring-底层实现-也能完成相同的功能"><a href="#4-1-5-我们的目标-不用-Spring-框架-模拟-Spring-底层实现-也能完成相同的功能" class="headerlink" title="4.1.5 我们的目标: 不用 Spring 框架, 模拟 Spring 底层实现, 也能完成相同的功能"></a>4.1.5 我们的目标: 不用 Spring 框架, 模拟 Spring 底层实现, 也能完成相同的功能</h3><h2 id="4-2-🌟Spring-整体架构分析"><a href="#4-2-🌟Spring-整体架构分析" class="headerlink" title="4.2 🌟Spring 整体架构分析"></a>4.2 🌟Spring 整体架构分析</h2><h3 id="4-2-1-🌟一图胜千言"><a href="#4-2-1-🌟一图胜千言" class="headerlink" title="4.2.1 🌟一图胜千言"></a>4.2.1 🌟一图胜千言</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727094752719.png" alt="image-20230727094752719"></p><h2 id="4-3-手动实现-Spring-底层机制"><a href="#4-3-手动实现-Spring-底层机制" class="headerlink" title="4.3 手动实现 Spring 底层机制"></a>4.3 手动实现 Spring 底层机制</h2><p>【初始化 IOC 容器+依赖注入+BeanPostProcessor 机制+AOP】</p><h3 id="4-3-1-实现任务阶段-1-编写自己-Spring-容器，-实现扫描包，-得到-bean-的-class-对象"><a href="#4-3-1-实现任务阶段-1-编写自己-Spring-容器，-实现扫描包，-得到-bean-的-class-对象" class="headerlink" title="4.3.1 实现任务阶段 1- 编写自己 Spring 容器， 实现扫描包， 得到 bean 的 class 对象"></a>4.3.1 实现任务阶段 1- 编写自己 Spring 容器， 实现扫描包， 得到 bean 的 class 对象</h3><h4 id="4-3-1-1-知识扩展：-类加载器"><a href="#4-3-1-1-知识扩展：-类加载器" class="headerlink" title="4.3.1.1 知识扩展： 类加载器"></a>4.3.1.1 知识扩展： 类加载器</h4><p>​● java 的类加载器 3 种</p><p>​Bootstrap 类加载器————–对应路径 jre&#x2F;lib</p><p>​Ext 类加载器——————–对应路径 jre&#x2F;lib&#x2F;ext</p><p>​App 类加载器——————-对应路径 classpath</p><h4 id="4-3-1-2-说明-编写自己-Spring-容器，-实现扫描包，-得到-bean-的-class-对象"><a href="#4-3-1-2-说明-编写自己-Spring-容器，-实现扫描包，-得到-bean-的-class-对象" class="headerlink" title="4.3.1.2 说明: 编写自己 Spring 容器， 实现扫描包， 得到 bean 的 class 对象"></a>4.3.1.2 说明: 编写自己 Spring 容器， 实现扫描包， 得到 bean 的 class 对象</h4><h3 id="🌟看p12-P41"><a href="#🌟看p12-P41" class="headerlink" title="🌟看p12-P41"></a>🌟看p12-P41</h3><p>先了解spring底层机制 具体实现日后有空再说</p><p>JDBC等知识由于之后都用mybatis等工具，也先不学</p><p>事务先不学了，之后补！</p><h1 id="5-Spring面试准备"><a href="#5-Spring面试准备" class="headerlink" title="5.Spring面试准备"></a>5.Spring面试准备</h1><h3 id="IOC实现原理总结："><a href="#IOC实现原理总结：" class="headerlink" title="IOC实现原理总结："></a>IOC实现原理总结：</h3><p>具体来说，Spring IOC 的实现过程如下：</p><ol><li>读取配置文件或解析注解信息，将其转换为内部的对象定义和依赖关系。在 Spring 中，可以使用 <u>XML 文件或注解</u>来配置对象和依赖关系。Spring 通过解析配置文件或注解信息，将其转换为内部的对象定义和依赖关系（BeanDefinition）放到容器（BeanFactory）中。对象定义包括对象的类型、属性、构造函数等信息，依赖关系包括对象之间的依赖关系、依赖注入方式等信息。</li><li>实例化bean对象：Spring 会根据对象定义的类型和构造函数信息，使用反射机制来创建对象。</li><li>设置属性：实例化后的仍然是一个原生的状态，并没有进行依赖注入。 这一步Spring根据BeanDefinition中的信息进行属性填充，依赖注入。 </li><li>调用Aware接口：Spring会检测该对象是否实现了xxxAware接口，如果有会在这里执行完成。Aware主要是能获取到Spring容器中的一些资源，然后可以供后续步骤，例如初始化阶段使用。</li><li>BeanPostProcessor前置处理：postProcessBeforeInitialzation方法。上述几个步骤后，bean对象已经被正确构造，但如果想要对象被初始化前再进行一些自定义的处理，就可以通过BeanPostProcessor接口的该方法来实现。</li><li>初始化阶段：该阶段Spring首先会看是否是实现了InitializingBean接口的afterPropertiesSet方法以及是否有自定义的init-method等，如果有会进行调用执行。</li><li>BeanPostProcessor后置处理：postProcessAfterInitialzation方法。当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理，与前面前置处理相对的，这个函数会在InitialzationBean完成后执行，因此称为后置处理。</li><li>bean初始化完成可以被使用了。</li></ol><p>总的来说，Spring IOC 的实现原理是通过反射机制动态创建对象，依赖注入，对象初始化。通过解耦对象之间的依赖关系，使得应用程序更加灵活、可维护、可扩展。</p><h3 id="BeanFactory和ApplicationContext的关系"><a href="#BeanFactory和ApplicationContext的关系" class="headerlink" title="BeanFactory和ApplicationContext的关系"></a>BeanFactory和ApplicationContext的关系</h3><p>BeanFactory和ApplicationContext是Spring框架中的两个重要的接口。它们都用于管理Spring Bean对象，但是它们在功能上有一些不同点。</p><p>BeanFactory是Spring框架中最基本的容器，它提供了最基础的IOC和DI的支持，它的主要功能是用于创建、管理和查找Bean对象。BeanFactory只是个接口，并不是IOC容器的具体实现， 它为其他具体的IOC容器提供了最基本的规范，例如DefaultListableBeanFactory,ApplicationContext 等容器实现或容器接口都是基于BeanFactory，再在其基础之上附加了其他的功能，原始的BeanFactory无法支持spring的许多插件，如AOP功能、Web应用等。原始BeanFactory是延时加载，也就是说在容器启动时不会注入bean，而是在需要使用bean的时候，才会对该bean进行加载实例化。</p><p>ApplicationContext接口是基于BeanFactory扩展而来，也是一个容器接口，具有BeanFactory所有的功能，同时继承了MessageSource，所以提供了更完整的框架功能，支持国际化、资源文件访问、载入多个上下文配置文件，使得每一个上下文都专注于一个特定层次，提供在监听器中注册bean事件。ApplicationContext 是预加载，在容器启动的时候一次性加载所有的bean，所以运行的时候速度相对BeanFactory比较快，缺点就是耗内存。</p><p>总的来说，BeanFactory是Spring框架中最基本的容器，提供最基础的IOC和DI的支持；而ApplicationContext是在BeanFactory的基础上扩展而来的，提供了更多的功能和特性。ApplicationContext是Spring框架中使用较为广泛的容器。</p><h3 id="谈谈你对AOP的理解？"><a href="#谈谈你对AOP的理解？" class="headerlink" title="谈谈你对AOP的理解？"></a>谈谈你对AOP的理解？</h3><p>Spring AOP（面向切面编程）是 Spring 框架中的一个重要模块，用于解决系统中的横切关注点（cross-cutting concerns）问题。所谓横切关注点，指的是系统中分散在各个模块中、与主业务逻辑无关的代码，例如日志记录、事务管理、权限控制等。</p><p>Spring AOP 采用代理模式实现，它通过在运行期间动态代理目标对象，将横切关注点织入到系统中，从而实现了业务逻辑与横切关注点的分离。Spring AOP 主要由以下几个概念组成：</p><ol><li>切面（Aspect）：切面是一个类，它包含了一组横切关注点和相应的逻辑。一个切面通常会跨越多个对象，因此它不仅定义了横切关注点，还定义了横切关注点与业务逻辑的关系。</li><li>连接点（Join Point）：连接点是在程序执行期间可以插入切面的点。例如方法调用、异常抛出等。</li><li>切入点（Pointcut）：切入点是一组连接点的集合，它定义了在哪些连接点上应用切面。例如所有的方法调用、所有的异常抛出等。</li><li>通知（Advice）：通知是切面在特定连接点执行的代码。Spring AOP 提供了五种类型的通知：前置通知（Before）、后置通知（After）、返回通知（After-returning）、异常通知（After-throwing）和环绕通知（Around）。</li><li>切面织入（Weaving）：切面织入是将切面应用到目标对象并创建代理对象的过程。</li></ol><p>Spring AOP 通过配置文件或注解的方式来定义切面、连接点、切入点和通知等信息，并使用代理模式将切面织入到目标对象中。通过 AOP 技术，可以有效地解耦业务逻辑和横切关注点，提高了系统的可维护性和可扩展性。</p><h3 id="动态代理了解吗？"><a href="#动态代理了解吗？" class="headerlink" title="动态代理了解吗？"></a>动态代理了解吗？</h3><p>Java动态代理是Java中一种重要的代理模式，它允许在运行时动态地生成代理类和对象，无需编写静态代理类。</p><p>在Java中，动态代理可以通过Java自带的两种方式实现：基于接口的动态代理和基于类的动态代理。</p><ol><li>基于接口的动态代理</li></ol><p>基于接口的动态代理是Java官方提供的一种动态代理实现方式。在这种实现方式中，代理类必须实现一个或多个接口，然后在运行时动态创建代理对象。JDK中提供了一个Proxy类和一个InvocationHandler接口来实现基于接口的动态代理。</p><p>首先，需要定义一个实现InvocationHandler接口的代理类，该类实现了代理类的逻辑。这个类中有一个invoke方法，这个方法在代理类的方法被调用时被执行。在运行时通过Proxy类的静态方法newProxyInstance生成代理类对象。这个方法需要三个参数：ClassLoader、代理类需要实现的接口数组和InvocationHandler实现类的实例。当通过代理类对象调用方法时，这个方法首先被转发到InvocationHandler的invoke方法中。在invoke方法中，可以根据代理类方法的不同来执行不同的逻辑，包括调用被代理对象的方法和执行其他的逻辑。最终，代理类的方法被执行完毕，返回结果。</p><ol start="2"><li>基于类的动态代理</li></ol><p>基于类的动态代理是通过字节码生成技术实现的。在这种实现方式中，代理类不需要实现接口，而是通过继承一个已有的类来实现代理功能。在Java中，可以通过CGLIB库实现基于类的动态代理。</p><p>CGLIB（Code Generation Library）是一个高性能的代码生成库，它可以在运行时动态生成字节码来实现类的增强功能。通过CGLIB库，可以直接在运行时创建目标对象的子类，从而实现基于类的动态代理。</p><p>基于类的动态代理相比于基于接口的动态代理，可以代理那些没有实现任何接口的类，更加灵活。但是它的实现原理比较复杂，需要在运行时动态生成字节码，会带来一定的性能开销。</p><h3 id="SpringMVC的执行流程了解吗？"><a href="#SpringMVC的执行流程了解吗？" class="headerlink" title="SpringMVC的执行流程了解吗？"></a>SpringMVC的执行流程了解吗？</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230815153451136.png" alt="image-20230815153451136"></p><p>SpringMVC是基于MVC设计模式实现的Web框架，其工作流程如下：</p><ol><li>客户端发送HTTP请求至前端控制器DispatcherServlet。</li><li>DispatcherServlet根据请求信息调用HandlerMapping，解析请求对应的Handler即处理器（Controller）。</li><li>HandlerMapping根据请求URL查找对应的Controller，同时生成用于执行该请求的HandlerExecutionChain对象（包含Interceptor链）。</li><li>DispatcherServlet调用HandlerAdapter执行Handler。在执行过程中，HandlerAdapter将把ModelAndView对象传递给DispatcherServlet。</li><li>Handler执行完成后，返回一个ModelAndView对象给HandlerAdapter。</li><li>HandlerAdapter将ModelAndView对象传递给DispatcherServlet。</li><li>DispatcherServlet调用ViewResolver解析视图（View）。</li><li>ViewResolver解析出View对象后，将其返回给DispatcherServlet。</li><li>DispatcherServlet调用View对象的render()方法进行视图渲染。</li><li>DispatcherServlet将渲染后的视图返回给客户端。</li></ol><p>在这个过程中，DispatcherServlet是整个SpringMVC的核心，它负责协调各个组件的工作。HandlerMapping负责将请求映射到对应的Controller，而HandlerAdapter负责执行Controller。ViewResolver则根据逻辑视图名（如JSP文件名）解析出View对象，最后由View渲染出实际的页面内容。通过这种分工协作的方式，SpringMVC可以实现灵活、高效、可扩展的Web应用程序开发。</p>]]></content>
      
      
      <categories>
          
          <category> Spring开发框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API接口开放平台</title>
      <link href="/2023/07/11/API%E6%8E%A5%E5%8F%A3%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/"/>
      <url>/2023/07/11/API%E6%8E%A5%E5%8F%A3%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="API开放平台"><a href="#API开放平台" class="headerlink" title="API开放平台"></a>API开放平台</h1><h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><ol><li><p>前端开发需要用到后台接口</p></li><li><p>使用现成的系统的功能</p></li></ol><h3 id="做一个API接口平台："><a href="#做一个API接口平台：" class="headerlink" title="做一个API接口平台："></a>做一个API接口平台：</h3><ol><li>防止攻击(安全性)</li><li>不能随便调用(限制、开通)</li><li>统计调用次数</li><li>计费</li><li>流量保护</li><li>API接入</li></ol><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>做一个提供API接口调用的平台：</p><ul><li><p>用户可以注册登录，开通接口调用权限。用户可以使用接口，并且每次调用会进行统计。</p></li><li><p>管理员可以发布接口、下线接口、接入接口，以及可视化接口的调用情况、数据。</p></li></ul><h3 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711194146565.png" alt="image-20230711194146565"></p><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><ul><li><p>Ant Design Pro</p></li><li><p>React</p></li><li><p>Ant Design Procomponents</p></li><li><p>Umi</p></li><li><p>Umi Request(Axios的封装)</p></li></ul><h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><ul><li><p>Spring Boot</p></li><li><p>Spring Boot Starter(SDK开发)</p></li><li><p>网关、限流、日志实现 —–&gt; dubbo+nacos</p></li></ul><h3 id="项目开发的阶段划分"><a href="#项目开发的阶段划分" class="headerlink" title="项目开发的阶段划分"></a>项目开发的阶段划分</h3><h4 id="1、初始化和展示"><a href="#1、初始化和展示" class="headerlink" title="1、初始化和展示"></a>1、初始化和展示</h4><p>项目介绍、设计、技术选型</p><p>基础项目的搭建</p><p>接口管理</p><p>用户查看接口</p><h4 id="2、接口调用"><a href="#2、接口调用" class="headerlink" title="2、接口调用"></a>2、接口调用</h4><ol><li>继续开发接口管理前端页面</li><li>开发模拟API接口</li><li>开发调用这个接口的代码</li><li>保证调用的安全性(API签名认证)</li><li>客户端SDK的开发</li></ol><h4 id="3、接口计量与保护"><a href="#3、接口计量与保护" class="headerlink" title="3、接口计量与保护"></a>3、接口计量与保护</h4><ol><li>开发接口发布&#x2F;下线的功能(管理员)</li><li>前端去浏览接口、查看接口文档、申请签名(注册)、在线调试(用户)</li><li>统计用户调用接口次数</li><li>优化系统 - API网关</li></ol><h5 id="开发接口发布-x2F-下线的功能-管理员"><a href="#开发接口发布-x2F-下线的功能-管理员" class="headerlink" title="开发接口发布&#x2F;下线的功能(管理员)"></a>开发接口发布&#x2F;下线的功能(管理员)</h5><h6 id="发布接口-仅管理员可用-："><a href="#发布接口-仅管理员可用-：" class="headerlink" title="发布接口(仅管理员可用)："></a>发布接口(仅管理员可用)：</h6><ol><li>检查该接口是否存在</li><li>判断该接口是否可以调用</li><li>修改接口数据库中的状态字段为1</li></ol><h6 id="下线接口："><a href="#下线接口：" class="headerlink" title="下线接口："></a>下线接口：</h6><ol><li>检查该接口是否存在</li><li>判断该接口是否可以调用</li><li>修改接口数据库中的状态字段为0</li></ol><p>前端去浏览接口、查看接口文档</p><p>–动态路由，用url来传递id，加载不同的接口信息</p><p>申请签名(注册) ：</p><p>用户在注册成功时，自动分配 accessKey、secretKey</p><p>扩展：用户可以申请更换签名</p><p>在线调用</p><p>​请求参数的类型(直接用 json 类型)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;username&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>先跑通整个流程，再去针对不同的请求或接口类型来设计界面和表单，给用户更好的体验(可以参考postman)</p><p>调用流程：</p><p>使用走后端方式流程：(后端相当于中转站，防止用户直接拿到接口的地址，从而绕过系统自行调用)</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230716140059896.png" alt="image-20230716140059896" style="zoom:50%;" /><p>流程：</p><pre><code>1. 前端将用户输入的请求参数和要测试的接口发送给平台后端2. (在调用前可以做一些调用)3. 平台后端去调用模拟接口</code></pre><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求参数要注意大小写！</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;userName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;don&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h4><p>判断该接口是否可以调用时 由固定方法名改为根据测试地址来调用</p><p>用户测试接口 由固定方法名-&gt;根据测试地址来调用</p><p>模拟接口改为从数据库校验 akey</p><h4 id="4、管理、统计分析"><a href="#4、管理、统计分析" class="headerlink" title="4、管理、统计分析"></a>4、管理、统计分析</h4><ol><li><p>开发接口调用次数的统计</p></li><li><p>优化整个系统的架构</p><p>a. 网关是什么？</p><p>b. 网关的作用？</p><p>c. 网关的应用场景及实现</p><p>d. 结合业务去应用网关</p></li></ol><h6 id="接口调用次数统计"><a href="#接口调用次数统计" class="headerlink" title="接口调用次数统计"></a>接口调用次数统计</h6><p>​<strong>1、需求：用户每次调用接口成功，次数+1</strong></p><p>​2、给用户分配或者用户自主申请接口调用次数</p><p>​业务流程：</p><p>​1、用户调用接口</p><p>​2、修改数据库，调用次数+1</p><h4 id="5、鉴权"><a href="#5、鉴权" class="headerlink" title="5、鉴权"></a>5、鉴权</h4><ol><li>实现<strong>统一</strong>的用户鉴权、统一的接口调用次数统计（把API网关应用到项目中）<ul><li>用到的<strong>网关相关特性</strong><ul><li>路由：用户原本直接请求模拟接口，在模拟接口鉴权；现在，我们在网关对用户进行鉴权，网关鉴权通过后再将请求重定向到模拟接口。</li><li>统一鉴权(accessKey、secretKey)</li><li>统一业务处理(每次请求接口后，调用次数都要+1)</li><li>访问控制(黑白名单)</li><li>流量染色(记录请求是否为网关来的，但是这样的话，在最终接口处还要对请求进行判断,看看有没有被染色)</li><li>统一日志(记录每次的请求与响应)</li></ul></li><li>业务逻辑<ol><li>用户发送请求到API网关</li><li>请求日志</li><li>(黑白名单)</li><li>用户鉴权(判断ak、sk是否合法)</li><li>请求的模拟接口是否存在？</li><li>请求转发，调用模拟接口</li><li>响应日志</li><li>调用成功，接口调用次数+1</li><li>调用失败，返回一个规范的错误码</li></ol></li></ul></li></ol><h4 id="6、网关"><a href="#6、网关" class="headerlink" title="6、网关"></a>6、网关</h4><ol><li>补充完整网关的业务逻辑(怎么去操作数据库、怎么复用之前的方法——RPC)</li><li>完善系统，开发一个监控统计功能</li></ol><h5 id="网关业务逻辑"><a href="#网关业务逻辑" class="headerlink" title="网关业务逻辑"></a>网关业务逻辑</h5><p>问题：网关项目比较纯净，没有操作数据库的包、并且还要调用我们之前写过的代码？复制粘贴维护麻烦</p><p>理想：直接请求到其他项目的方法</p><h6 id="怎么调用其他项目的方法？："><a href="#怎么调用其他项目的方法？：" class="headerlink" title="怎么调用其他项目的方法？："></a>怎么调用其他项目的方法？：</h6><ol><li>复制代码、环境</li><li>HTTP请求(提供一个接口、供其他项目使用)<ul><li>server开发一个接口(地址、请求方法、参数、返回值)</li><li>client使用HTTP Client之类的代码包去发送HTTP请求</li></ul></li><li>RPC<ul><li>作用：像调用本地方法一样调用远程方法</li><li>对开发者更透明，减少了很多沟通成本</li><li>RPC向远程服务器发送请求时，未必要使用HTTP协议，比如 TCP&#x2F;IP(性能更高、内部服务更适用)等等等等</li></ul></li><li>把公共项目打包成jar包，其他项目去引用(客户端SDK)</li></ol><p>![image-20230719103013425](&#x2F;Users&#x2F;donn&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230719103013425.png)</p><h6 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h6><ol><li>请求转发</li></ol><p>用一个前缀匹配断言：所有路径为 &#x2F;api&#x2F;** 的请求转发到<a href="http://localhost:8123/api/">http://localhost:8123/api/</a>**</p><p>例如：<a href="http://localhost:8090/api/name/">http://localhost:8090/api/name/</a>** &#x3D;&#x3D;&#x3D;&gt; <a href="http://localhost:8123/api/name/">http://localhost:8123/api/name/</a>**</p><p>模拟接口请求地址：<a href="http://localhost:8123/api/name/get?name=123">http://localhost:8123/api/name/get?name=123</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddResponseHeader=source,</span> <span class="string">donn</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">api_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8123</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/api/**</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>编写业务逻辑</p><p>使用了GlobalFilter全局请求拦截处理(类似AOP)</p></li></ol><p>​因为网关项目没引入MyBatis等操作数据库的类库，如果该操作较为复杂，可以由backend增删改查项目提供接口，我们直接调用，不用再重复写逻辑。</p><ul><li>HTTP请求 (用HTTPClient、用RestTemplate、Feign)</li><li>RPC (Dubbo)</li></ul><h6 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h6><p>预期是等模拟接口调用完成，才调用响应日志、统计调用次数</p><p>但实际上 chain.filter 方法立即返回了，直到filter过滤器 return 后才调用了模拟接口</p><p>原因：chain.filter 是一个异步操作，理解为前端的 promise</p><p>解决方案：利用response装饰者，增强原有的response的处理能力</p><h6 id="Dubbo框架-RPC实现"><a href="#Dubbo框架-RPC实现" class="headerlink" title="Dubbo框架(RPC实现)"></a>Dubbo框架(RPC实现)</h6><p>​两种使用方式：</p><ol><li><p>Spring Boot 代码(注解 + 编程式)：写java接口，服务提供者和消费者都去引用这个接口 </p></li><li><p>IDL (接口调用语言)：创建一个公共的接口定义文件，服务提供者和消费者读取这个文件，优点是跨语言、所有的框架都认识</p></li></ol><p>底层是Triple协议</p><h5 id="整合运用："><a href="#整合运用：" class="headerlink" title="整合运用："></a>整合运用：</h5><ol><li>backend项目作为服务提供者，提供三个方法</li></ol><ul><li>去数据库中查是否已分配给用户</li><li>查询数据库，模拟接口是否存在，以及请求方法是否匹配</li><li>调用成功后 调用次数+1 invokeCount</li></ul><ol start="2"><li>Gataway项目作为服务调用者，调用这三个方法</li></ol><h4 id="7、完善网关、接口调用信息可视化、展望……"><a href="#7、完善网关、接口调用信息可视化、展望……" class="headerlink" title="7、完善网关、接口调用信息可视化、展望……"></a>7、完善网关、接口调用信息可视化、展望……</h4><ol><li>完成网关业务逻辑<ul><li>实际情况应该是去数据库查看是否已分配给用户(ak、sk是否合法)<ul><li>先根据accessKey判断用户是否存在，查到secretKey</li><li>对比secretKey和用户传的加密后的secretKey是否一致</li></ul></li><li>从数据库查询模拟接口是否存在，以及请求方式是否匹配(还可以校验请求参数)</li><li>调用成功后，调用次数+1 （invoke count</li></ul></li><li>开发管理员分析的功能</li><li>上线</li></ol><h6 id="如何获取接口转发服务器的地址"><a href="#如何获取接口转发服务器的地址" class="headerlink" title="如何获取接口转发服务器的地址"></a>如何获取接口转发服务器的地址</h6><p>​网关启动时， 获取所有的接口信息，维护到内存的hashmap中；有请求时，根据请求的url路径或者其他参数[比如host请求头]来判断应该转发到哪台服务器，以及用于校验接口是否存在</p><h6 id="公共服务："><a href="#公共服务：" class="headerlink" title="公共服务："></a>公共服务：</h6><p>​目的是让方法、实体类在多个项目间复用，重复编写</p><pre><code>1. 数据库中查询是否已分配给用户密钥(accessKey，返回用户信息，为空表示不存在)1. 从数据库查询模拟接口是否存在(请求路径、请求方法、请求参数、返回接口信息，为空表示不存在)1. 调用次数+1 (accessKey(标识用户)、接口路径)</code></pre><p>步骤：</p><ol><li>新建干净的maven项目，只保留必要的公共依赖</li><li>抽取service和实体类</li><li>install本地 maven包</li><li>让服务提供方引入common包，测试是否正常运行</li><li>让服务消费方引入common包</li></ol><h6 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h6><ol><li><p>怎么让其他用户也上传接口？</p><p>需要提供一个机制(界面)，让用户输入自己的接口host(服务器地址)、接口信息，将接口信息写入数据库。</p><p>将接口信息写入数据库之前，要对接口进行校验，比如测试调用，保证接口正常。并遵循我们项目的要求(并且使用我们的sdk)</p></li><li><p>在interfaceInfo表中加入host字段，区分服务器地址，让接口提供者更灵活地接入系统。</p></li><li><p>网关判断是否还有调用次数</p></li><li><p>网关限流、提高性能等等</p></li></ol><h5 id="开发统计分析："><a href="#开发统计分析：" class="headerlink" title="开发统计分析："></a>开发统计分析：</h5><p>提供可视化平台，用图表的方式展示所有的调用情况，便于调整业务</p><h6 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h6><p>​各接口总调用次数占比(饼图)前3的接口，从而分析出哪些接口没人用(降低资源或者下线)以及高频接口(增加资源、提高收费)</p><h6 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h6><h6 id="前端："><a href="#前端：" class="headerlink" title="前端："></a>前端：</h6><p>​展示饼图——推荐使用线程的库</p><p>​ECharts、AntV</p><ul><li>看官网</li><li>进入实例页面</li><li>找到想要的图</li><li>在线调试</li><li>复制代码</li><li>改为真实数据</li></ul><h6 id="后端："><a href="#后端：" class="headerlink" title="后端："></a>后端：</h6><p>​1. SQL查询调用数据</p><p>​select interfaceInfoId, sum(totalNum) as totalNum from interface_info group by interfaceInfoId order by totalNum desc limit 3;</p><p>​2. 业务层去关联查询接口信息</p><h6 id="上线："><a href="#上线：" class="headerlink" title="上线："></a>上线：</h6><p>前端：参考用户中心的上线方式</p><p>后端：</p><ul><li>backend项目：web项目，部署springboot的jar包(对外的)</li><li>gateway项目：web项目，部署springboot的jar包(对外的)</li><li>interface 模拟接口项目：web项目，部署springboot的jar包(不建议对外暴露的)</li></ul><p>如果自己学习用：单个服务器部署这三个项目足够</p><p>如果想搞大事：多个服务器建议在同一内网，内网交互会更快，且更安全</p><p>设计库表：</p><p>哪个用户？哪个接口？</p><p>用户 &lt;&#x3D;&#x3D;多对多&#x3D;&#x3D;&gt; 接口</p><p>因此需要再创建一个表：</p><p>用户调用接口关系表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用户调用接口关系表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> tjyapi.`user_interface_info`</span><br><span class="line">(</span><br><span class="line">    `id` <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment comment <span class="string">&#x27;主键&#x27;</span> <span class="keyword">primary</span> key,</span><br><span class="line">  `userId` <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;调用用户id&#x27;</span>,</span><br><span class="line">  `interfaceInfoId` <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;接口id&#x27;</span>,</span><br><span class="line">    `totalNum` <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;总调用次数&#x27;</span>,</span><br><span class="line">    `leftNum` <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;剩余调用次数&#x27;</span>,</span><br><span class="line">  `status` <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;0-正常 1-禁用&#x27;</span>,</span><br><span class="line">  `createTime` datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    `updateTime` datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">CURRENT_TIMESTAMP</span> comment <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">    `isDelete` tinyint <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;是否删除 0-未删 1-已删,</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">) comment &#x27;</span>用户调用接口关系表<span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure><p>步骤：</p><pre><code>1. 开发基本增删改查(给管理员用)1. 开发用户调用接口次数+1的功能(service)</code></pre><p>​问题：</p><p>​——如果每个接口的方法都写调用次数+1，是不是比较麻烦？</p><p>​——致命问题：接口开发者需要自己去添加统计代码</p><p>使用AOP切面的优点：独立于接口，在每个接口调用后统计次数+1</p><p>AOP切面的缺点：存在于单个项目中，如果每个团队都要开发自己的接口，那么都需要写AOP切面—还是没有解决 问题</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230717140031212.png" alt="image-20230717140031212"></p><h3 id="网关相关知识："><a href="#网关相关知识：" class="headerlink" title="网关相关知识："></a>网关相关知识：</h3><p>​网关的优点：统一进行一些操作，处理一些问题</p><ul><li><p>路由</p><ul><li><p>起到转发的作用，比如有接口 A 和接口 B，网关会记录这些信息，根据用户访问的地址和参数，转发请求到对应的接口（服务器&#x2F;集群）</p><p>&#x2F;a&#x3D;＞接口A</p><p>&#x2F;b&#x3D;＞接口B</p></li></ul></li><li><p>统一鉴权</p><ul><li>判断用户是否有权限进行操作，无论访问什么接口，都统一去判断，不用重复写</li></ul></li><li><p>统一跨域处理</p><ul><li>网关统一处理跨域</li></ul></li><li><p>缓存</p></li><li><p>流量染色</p><ul><li>给请求(流量)添加一些标识，一般是设置在请求头中，添加新的请求头</li></ul></li><li><p>访问控制</p><ul><li>黑白名单，比如限制DDOS IP</li></ul></li><li><p>统一业务处理</p><ul><li>把每个项目中都要做的通用逻辑放到上层(网关)，统一处理，比如本项目的接口调用次数统计</li></ul></li><li><p>发布控制</p><ul><li>灰度发布，比如上线新接口，先给新接口分配20%流量，慢慢增加，最终替代老接口</li></ul></li><li><p>负载均衡</p><ul><li>在路由的基础上</li></ul></li></ul><p>​&#x2F;c&#x3D;＞服务 A &#x2F; 集群A（随机转发到其中的某一个机器）</p><ul><li>统一接口保护<ul><li>限制请求</li><li>信息脱敏</li><li>降级(熔断)</li><li>限流</li><li>超时时间</li></ul></li><li>统一日志<ul><li>统一的请求、响应信息记录</li></ul></li><li>统一文档<ul><li>将下游项目的文档进行聚合，在一个页面统一查看</li></ul></li></ul><h4 id="网关的分类"><a href="#网关的分类" class="headerlink" title="网关的分类"></a>网关的分类</h4><ol><li>全局网关(接入层网关)：作用是负载均衡、请求日志等，不和业务逻辑绑定</li><li>业务网关(微服务网关)：会有一些业务逻辑，作用是将请求转发到不同的业务&#x2F;项目&#x2F;接口&#x2F;服务</li></ol><h4 id="实现：-1"><a href="#实现：-1" class="headerlink" title="实现："></a>实现：</h4><ol><li><p>Nginx( 全局网关 )、Kong网关( API网关 Kong: <a href="https://github.com/Kong/kong">https://github.com/Kong/kong</a> )，编程成本高</p></li><li><p>Spring Cloud Gateway (取代了 Zuul) 性能高，可以用Java代码来写逻辑，易于学习</p></li></ol><p>参考文章：<a href="https://blog.csdn.net/qq_21040559/article/details/122961395">https://blog.csdn.net/qq_21040559/article/details/122961395</a></p><p>网关技术选型：<a href="https://zhuanlan.zhihu.com/p/500587132">https://zhuanlan.zhihu.com/p/500587132</a></p><h4 id="Spring-Cloud-Gateway用法"><a href="#Spring-Cloud-Gateway用法" class="headerlink" title="Spring Cloud Gateway用法"></a>Spring Cloud Gateway用法</h4><p>官网：<a href="https://spring.io/projects/spring-cloud-gateway">https://spring.io/projects/spring-cloud-gateway</a></p><h5 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h5><p>路由：根据什么条件，转发请求到哪里</p><p>断言：一组规则、条件，用来确定如何转发路由</p><p>过滤器：对请求进行一系列处理，比如添加请求头、添加请求参数</p><h5 id="请求流程："><a href="#请求流程：" class="headerlink" title="请求流程："></a>请求流程：</h5><ol><li>客户端发起请求</li><li>Handler Mapping：根据断言，去将请求转发到对应的路由</li><li>Web Handler：处理请求(一层层经过过滤器)</li><li>实际调用服务</li></ol><h5 id="两种配置方式："><a href="#两种配置方式：" class="headerlink" title="两种配置方式："></a>两种配置方式：</h5><ol><li>配置式(application.yaml中配置) 方便、规范</li><li>编程式     相对麻烦、灵活</li></ol><h5 id="断言：-一些条件"><a href="#断言：-一些条件" class="headerlink" title="断言：(一些条件)"></a>断言：(一些条件)</h5><ol><li>after：在什么时间之后</li><li>before……</li></ol><p>……等等多种因素都能放进来考虑</p><p>建议开启日志——方便发现问题：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">org:</span></span><br><span class="line">      <span class="attr">springframework:</span></span><br><span class="line">        <span class="attr">cloud:</span></span><br><span class="line">          <span class="attr">gateway:</span> <span class="string">trace</span></span><br></pre></td></tr></table></figure><h5 id="过滤器："><a href="#过滤器：" class="headerlink" title="过滤器："></a>过滤器：</h5><p>基本(对请求头、响应头进行增删改查)</p><p>​在某设定路由下，做自定义的事(如添加请求头、添加请求体参数等等等等)</p><p>​或者 访问某路由如果失败，会转而访问另一个设定的路由(降级)</p><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><ol><li>管理员可以对接口信息进行增删改查</li><li>用户可以访问前台，查看接口信息</li></ol><h3 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h3><h4 id="接口信息表"><a href="#接口信息表" class="headerlink" title="接口信息表"></a>接口信息表</h4><p>id</p><p>name 接口名称</p><p>description  描述</p><p>url 接口地址</p><p>type请求类型</p><p>requestHeader请求头</p><p>responseHeader  响应头</p><p>status 接口状态 0-关闭 1-开启</p><p>isDelete</p><p>createTime</p><p>updateTime</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">use tjyapi;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 接口信息</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> tjyapi.`interface_info`</span><br><span class="line">(</span><br><span class="line">    `id` <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment comment <span class="string">&#x27;主键&#x27;</span> <span class="keyword">primary</span> key,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;接口名称&#x27;</span>,</span><br><span class="line">    `description` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">null</span> comment <span class="string">&#x27;描述&#x27;</span>,</span><br><span class="line">    `url` <span class="type">varchar</span>(<span class="number">512</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;接口地址&#x27;</span>,</span><br><span class="line">    `requestHeader` text <span class="keyword">null</span> comment <span class="string">&#x27;请求头&#x27;</span>,</span><br><span class="line">    `responseHeader` text <span class="keyword">null</span> comment <span class="string">&#x27;响应头&#x27;</span>,</span><br><span class="line">    `status` <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;接口状态 0-关闭 1-开启&#x27;</span>,</span><br><span class="line">    `<span class="keyword">method</span>` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;接口类型&#x27;</span>,</span><br><span class="line">    `userId` <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;创建人&#x27;</span>,</span><br><span class="line">    `createTime` datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    `updateTime` datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">CURRENT_TIMESTAMP</span> comment <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">    `isDelete` tinyint <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;是否删除 1-已删&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;接口信息&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;唐果&#x27;</span>, <span class="string">&#x27;江胤祥&#x27;</span>, <span class="string">&#x27;www.hui-russel.net&#x27;</span>, <span class="string">&#x27;7IE&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;姜烨磊&#x27;</span>, <span class="number">7</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;范浩&#x27;</span>, <span class="string">&#x27;崔振家&#x27;</span>, <span class="string">&#x27;www.peter-schmeler.info&#x27;</span>, <span class="string">&#x27;Pj0&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;黄钰轩&#x27;</span>, <span class="number">12857921</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;唐航&#x27;</span>, <span class="string">&#x27;孔健雄&#x27;</span>, <span class="string">&#x27;www.tanner-bednar.name&#x27;</span>, <span class="string">&#x27;Hi9QM&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;宋昊然&#x27;</span>, <span class="number">18787</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;袁子默&#x27;</span>, <span class="string">&#x27;石明杰&#x27;</span>, <span class="string">&#x27;www.mitsuko-zboncak.net&#x27;</span>, <span class="string">&#x27;4q&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;周涛&#x27;</span>, <span class="number">954194648</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;朱博涛&#x27;</span>, <span class="string">&#x27;秦昊焱&#x27;</span>, <span class="string">&#x27;www.rey-ondricka.biz&#x27;</span>, <span class="string">&#x27;GhO&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;王瑾瑜&#x27;</span>, <span class="number">43144</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;陆绍齐&#x27;</span>, <span class="string">&#x27;曹鸿涛&#x27;</span>, <span class="string">&#x27;www.cathleen-gusikowski.org&#x27;</span>, <span class="string">&#x27;pP0Z&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;尹乐驹&#x27;</span>, <span class="number">23494</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;尹思聪&#x27;</span>, <span class="string">&#x27;贺钰轩&#x27;</span>, <span class="string">&#x27;www.jeni-bartell.co&#x27;</span>, <span class="string">&#x27;ZZdsp&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;冯果&#x27;</span>, <span class="number">25646340</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;崔钰轩&#x27;</span>, <span class="string">&#x27;冯熠彤&#x27;</span>, <span class="string">&#x27;www.timothy-legros.org&#x27;</span>, <span class="string">&#x27;Qr&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;龙乐驹&#x27;</span>, <span class="number">275486388</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;马子骞&#x27;</span>, <span class="string">&#x27;邹晋鹏&#x27;</span>, <span class="string">&#x27;www.tori-wisoky.io&#x27;</span>, <span class="string">&#x27;cwVv&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;熊俊驰&#x27;</span>, <span class="number">9055718270</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;李嘉懿&#x27;</span>, <span class="string">&#x27;毛弘文&#x27;</span>, <span class="string">&#x27;www.tawna-murazik.info&#x27;</span>, <span class="string">&#x27;d8H&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;钟靖琪&#x27;</span>, <span class="number">596652</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;龚绍齐&#x27;</span>, <span class="string">&#x27;崔伟祺&#x27;</span>, <span class="string">&#x27;www.bart-dare.biz&#x27;</span>, <span class="string">&#x27;VM&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;陆乐驹&#x27;</span>, <span class="number">720475</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;严熠彤&#x27;</span>, <span class="string">&#x27;许炫明&#x27;</span>, <span class="string">&#x27;www.lane-schoen.com&#x27;</span>, <span class="string">&#x27;pc05M&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;余健雄&#x27;</span>, <span class="number">481356844</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;邵凯瑞&#x27;</span>, <span class="string">&#x27;郭智渊&#x27;</span>, <span class="string">&#x27;www.von-rempel.org&#x27;</span>, <span class="string">&#x27;FSiqa&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;龙博超&#x27;</span>, <span class="number">1368599</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;赖果&#x27;</span>, <span class="string">&#x27;杨天宇&#x27;</span>, <span class="string">&#x27;www.kourtney-lubowitz.name&#x27;</span>, <span class="string">&#x27;3C&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;韩修杰&#x27;</span>, <span class="number">6026675</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;段浩宇&#x27;</span>, <span class="string">&#x27;韩鸿涛&#x27;</span>, <span class="string">&#x27;www.rupert-schmeler.co&#x27;</span>, <span class="string">&#x27;mMo&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;魏远航&#x27;</span>, <span class="number">76</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;沈炎彬&#x27;</span>, <span class="string">&#x27;张昊天&#x27;</span>, <span class="string">&#x27;www.sheri-kerluke.co&#x27;</span>, <span class="string">&#x27;adMn1&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;薛明&#x27;</span>, <span class="number">3551</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;高黎昕&#x27;</span>, <span class="string">&#x27;谢志泽&#x27;</span>, <span class="string">&#x27;www.sterling-adams.org&#x27;</span>, <span class="string">&#x27;baP&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;金明哲&#x27;</span>, <span class="number">91</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;胡语堂&#x27;</span>, <span class="string">&#x27;覃浩然&#x27;</span>, <span class="string">&#x27;www.khalilah-breitenberg.biz&#x27;</span>, <span class="string">&#x27;gDtv&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;雷睿渊&#x27;</span>, <span class="number">21221843</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;陆雨泽&#x27;</span>, <span class="string">&#x27;曾雪松&#x27;</span>, <span class="string">&#x27;www.jonas-fritsch.co&#x27;</span>, <span class="string">&#x27;XvfU&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;侯智渊&#x27;</span>, <span class="number">472525914</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;邓昊焱&#x27;</span>, <span class="string">&#x27;秦胤祥&#x27;</span>, <span class="string">&#x27;www.aron-buckridge.com&#x27;</span>, <span class="string">&#x27;fBh3&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;丁子默&#x27;</span>, <span class="number">12000</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="前端项目脚手架："><a href="#前端项目脚手架：" class="headerlink" title="前端项目脚手架："></a>前端项目脚手架：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 在终端运行</span><br><span class="line">npm i @ant-design/pro-cli -g</span><br><span class="line">2. 进入你放的目录的终端，自动创建项目</span><br><span class="line">pro create 项目名称</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">版本信息：</span><br><span class="line">donn@Macc ~ % node -v</span><br><span class="line">v16.13.0</span><br><span class="line">donn@Macc ~ % npm -v       </span><br><span class="line">8.1.0</span><br></pre></td></tr></table></figure><p>运行一下空项目：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711212835653.png" alt="image-20230711212835653"></p><p>前端：ant design pro 脚手架</p><p>后端：直接使用模板 springboot-init</p><h4 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h4><p>增删改查、登录(复制粘贴)</p><p>前端接口调用：openapi插件自动生成</p><p>openapi规范</p><h4 id="模拟接口项目-tjyapi-interface"><a href="#模拟接口项目-tjyapi-interface" class="headerlink" title="模拟接口项目 tjyapi-interface"></a>模拟接口项目 tjyapi-interface</h4><p>提供三个模拟接口</p><ol><li>GET接口</li><li>POST接口(url传参)</li><li>POST接口(Restful)</li></ol><h4 id="调用接口"><a href="#调用接口" class="headerlink" title="调用接口"></a>调用接口</h4><p>几种 HTTP 调用方式：</p><ol><li><p>HttpClient</p></li><li><p>RestTemplate</p></li><li><p>第三方库(OKHTTP、Hutool)</p></li></ol><p>Hutool：<a href="https://www.hutool.cn/">https://www.hutool.cn</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://doc.hutool.cn/pages/HttpUtil/#%E6%A6%82%E8%BF%B0">https://doc.hutool.cn/pages/HttpUtil/#概述</a></p><h3 id="API签名认证"><a href="#API签名认证" class="headerlink" title="API签名认证"></a>API签名认证</h3><h5 id="本质："><a href="#本质：" class="headerlink" title="本质："></a>本质：</h5><pre><code>1. 签发签名1. 使用签名(校验签名)</code></pre><h5 id="为什么需要？"><a href="#为什么需要？" class="headerlink" title="为什么需要？"></a>为什么需要？</h5><ol><li>保证安全性，不能随便来一个人都能调用</li></ol><h5 id="怎么实现？"><a href="#怎么实现？" class="headerlink" title="怎么实现？"></a>怎么实现？</h5><p>通过http request header头 传递参数</p><p><strong>参数1:</strong> accessKey：调用的标识 userA、userB(复杂、无序、无规律)</p><p><strong>参数2:</strong> secretKey： 密钥——–<strong>该参数不传递到请求头中，通过私下约定进行同步</strong></p><p>可以暂时理解为用户名和密码，区别为：ak、sk是无状态的；你每次访问都需携带正确的ak、sk才能访问</p><p>自行编写代码给每个用户生成ak、sk</p><p>千万不能把密钥直接在服务器之间传递，因为有可能被拦截</p><p>(所以要对密码进行进一步处理)</p><p><strong>参数3:</strong> 用户请求参数</p><p><strong>参数4:</strong> sign 参数</p><p>加密方式：对称加密、非对称加密、md5签名</p><p>用户参数：abc + 密钥 &#x3D;&gt; 签名生成算法 &#x3D;&gt; 不可解密的值</p><p>abc + miyao &#x3D;&gt; dnasufbnusfuisdafiuadbfouiadbfuiasdbofibdaiksfbefewdf</p><p><strong>服务端用一样的方式生成签名，只要结果和用户传来的一致，就表示一致</strong> </p><p>怎么防重放？</p><p><strong>参数5:</strong> 每次请求时都 + nonce随机数，只能用一次</p><p>服务端要保存用过的随机数</p><p><strong>参数6:</strong> 加timestamp时间戳，校验时间戳是否过期</p><p><strong>API签名认证是一个很灵活的设计，具体有哪些参数，参数名如何 一定要根据具体场景来，(比如userId、appId、version、固定值等等)</strong></p><p>思考：开发者每次调用接口都要自己写签名算法？</p><h3 id="——开发一个简单易用的SDK"><a href="#——开发一个简单易用的SDK" class="headerlink" title="——开发一个简单易用的SDK"></a>——开发一个简单易用的SDK</h3><p>理想情况：开发者只需要关心调用哪些接口、传递哪些参数，就跟调用自己写的代码一样简单。</p><p>——开发一个starter的好处：</p><p>开发者引入后，可以直接在application.yaml中写配置，自动创建客户端</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230715142059798.png" alt="image-20230715142059798"></p><p>spring-boot-configuration-processor的作用是自动生成配置的代码提示</p>]]></content>
      
      
      <categories>
          
          <category> 项目开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb</title>
      <link href="/2023/07/04/JavaWeb/"/>
      <url>/2023/07/04/JavaWeb/</url>
      
        <content type="html"><![CDATA[<p> 本博客参照了韩顺平老师的 JavaWeb 课程讲义！</p><h1 id="7-Tomcat"><a href="#7-Tomcat" class="headerlink" title="7 Tomcat"></a>7 Tomcat</h1><h2 id="7-1-官方文档"><a href="#7-1-官方文档" class="headerlink" title="7.1 官方文档"></a>7.1 官方文档</h2><h3 id="7-1-1-地址-https-tomcat-apache-org-tomcat-8-0-doc"><a href="#7-1-1-地址-https-tomcat-apache-org-tomcat-8-0-doc" class="headerlink" title="7.1.1 地址: https://tomcat.apache.org/tomcat-8.0-doc/"></a>7.1.1 地址: <a href="https://tomcat.apache.org/tomcat-8.0-doc/">https://tomcat.apache.org/tomcat-8.0-doc/</a></h3><h2 id="7-2-WEB开发介绍"><a href="#7-2-WEB开发介绍" class="headerlink" title="7.2 WEB开发介绍"></a>7.2 WEB开发介绍</h2><ol><li><p>WEB，在英语中 web 表示网&#x2F;网络资源(页面, 图片, css, js)意思，它用于表示 WEB 服务器(主机)供浏览器访问的资源</p></li><li><p>WEB 服务器(主机)上供外界访问的 web 资源分为：</p></li></ol><ul><li>静态web资源（如 html 页面）：指web页面中供人们浏览的数据始终是不变。</li><li>动态web资源，比如 Servlet(java)、PHP 等</li></ul><ol start="3"><li>静态web 资源开发技术</li></ol><ul><li>Html、CSS、js 等</li></ul><ol start="4"><li>常用动态web 资源开发技术：</li></ol><ul><li>Servlet、SpringBoot、SpringvVC、 PHP、ASP.NET 等</li></ul><h2 id="7-3-JavaWeb开发技术栈图"><a href="#7-3-JavaWeb开发技术栈图" class="headerlink" title="7.3 JavaWeb开发技术栈图"></a>7.3 JavaWeb开发技术栈图</h2><p>-一图胜千言</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230704161447451.png" alt="image-20230704161447451"></p><h2 id="7-4-BS-与-CS-开发介绍"><a href="#7-4-BS-与-CS-开发介绍" class="headerlink" title="7.4 BS 与 CS 开发介绍"></a>7.4 BS 与 CS 开发介绍</h2><h3 id="7-4-1-BS开发"><a href="#7-4-1-BS开发" class="headerlink" title="7.4.1 BS开发"></a>7.4.1 BS开发</h3><p><strong>B</strong>: browser(浏览器,种类太多 ff, chrome, ie, edge) </p><p><strong>S</strong>: Server(服务端,考虑很多)<br><strong>示意图:</strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230704162955992.png" alt="image-20230704162955992" style="zoom:30%;" /><p>对BS的解读:</p><ol><li><p>兼容性，因为浏览器的种类很多，发现你号的程序，在某个浏览器会出观问题，其它浏览器正常</p></li><li><p>安全性，通常情况下，Bs 安全性不如 CS 好控制</p></li><li><p>易用性，BS 好于CS，浏览器可直接下载</p></li><li><p>扩展性，BS相对统一，只需要写 Server</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230704163213955.png" alt="image-20230704163213955"></p><h3 id="7-4-2-CS开发"><a href="#7-4-2-CS开发" class="headerlink" title="7.4.2 CS开发"></a>7.4.2 CS开发</h3><p><strong>C</strong>: Client(客户端) </p><p><strong>S</strong>: Server(服务端) </p><p><strong>示意图:</strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230704163427794.png" alt="image-20230704163427794" style="zoom:30%;" /><h2 id="7-5-JavaWeb服务软件"><a href="#7-5-JavaWeb服务软件" class="headerlink" title="7.5 JavaWeb服务软件"></a>7.5 JavaWeb服务软件</h2><h3 id="7-5-1-JavaWeb服务器软件介绍"><a href="#7-5-1-JavaWeb服务器软件介绍" class="headerlink" title="7.5.1 JavaWeb服务器软件介绍"></a>7.5.1 JavaWeb服务器软件介绍</h3><p>1.学习Javaweb 开发，需要先安装 JavaWeb 服务软件【我们把安装了 Javaweb 服务软件主机称为 web服务器&#x2F;Javaweb 服务器】，然后在web 服务器中开发相应的 web 资源。[ Javaweb 服务器，Mysql服务器]</p><p>2.老韩提问：学习Javaweb 开发，为什么必须要先装 WEB 服务软件？</p><p>答：需要安装，理解 Tomcat 本质就是一个Java 程序，但是这个 Java 程序可以处理来自浏览器的 HTTP 请求，和我们前面讲的 java 网络服务（多人聊天,Server)</p><h3 id="7-5-2-手写简单-Web-服务程序"><a href="#7-5-2-手写简单-Web-服务程序" class="headerlink" title="7.5.2 手写简单 Web 服务程序"></a>7.5.2 手写简单 <strong>Web</strong> 服务程序</h3><p><strong>1.</strong> 需求**:** 手写 <strong>MyWebServer.java ,</strong> 让大家体验一下 <strong>JavaWeb</strong> 服务本质 </p><p> <strong>提醒</strong>: 这里，我们需要使用到 Java基础(IO&#x2F;网络),</p><p>​<a href="http://localhost:9999/">http://localhost:9999</a> 表示浏览器向localhost(127.0.0.1)表示本机的9999端口发出请求</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230704164133005.png" alt="image-20230704164133005" style="zoom:50%;" /><p><strong>2.</strong> <strong>创建</strong> <strong>hspedu_mytomcat</strong> <strong>的</strong> <strong>Java</strong> <strong>应用程序</strong>.</p><p><strong>3.</strong> <strong>创建</strong> <strong>D:\idea_java_projects\hspedu_mytomcat\src\hello.html</strong></p><p>​Hello, I AM WEB Server!</p><p><strong>4.</strong> <strong>创建</strong> <strong>D:\idea_java_projects\hspedu_mytomcat\src\MyWebServer.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTomcat</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.在 9999 端口监听</span></span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="comment">//如果 serverSocket 没有关闭，就等待连接, 不停的等待 </span></span><br><span class="line">    <span class="keyword">while</span> (!serverSocket.isClosed()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;=====我的 web 服务在 9999 端口监听=====&quot;</span>); </span><br><span class="line">    <span class="comment">//2. 等待浏览器/客户端连接, 得到 socket</span></span><br><span class="line">    <span class="comment">// 该 socket 用于通信</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">    <span class="comment">//3. 通过 socket 得到 输出流，[]</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream(); <span class="comment">// 返回给浏览器/客户端</span></span><br><span class="line">    <span class="comment">//4. 读取 hello.html 文件返回即可=&gt; 如何读取文件内容 </span></span><br><span class="line">    <span class="comment">// 得到文件输入流(字符输入流), 和 src/hello.html </span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src/hello.html&quot;</span>)); </span><br><span class="line">    <span class="type">String</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 循环读取 hello.html</span></span><br><span class="line">    <span class="keyword">while</span> ((buf = bufferedReader.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">      outputStream.write(buf.getBytes()); &#125;</span><br><span class="line">      outputStream.close();</span><br><span class="line">    socket.close(); </span><br><span class="line">    &#125;</span><br><span class="line">    serverSocket.close();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5.</strong> <strong>完成测试</strong>: <strong>浏览器</strong> <strong><a href="http://localhost:9999/">http://localhost:9999/</a></strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230704165444597.png" alt="image-20230704165444597" style="zoom:33%;" /><h3 id="7-5-3-常用-JavaWeb-服务软件"><a href="#7-5-3-常用-JavaWeb-服务软件" class="headerlink" title="7.5.3 常用 JavaWeb 服务软件"></a>7.5.3 常用 JavaWeb 服务软件</h3><p><strong>1.</strong> <strong>Tomcat</strong>:由 <strong>Apache</strong> 组织提供的一种 <strong>Web</strong> 服务器，提供对 <strong>jsp</strong> 和 <strong>Servlet</strong> 的支持。它是一种轻量级的 <strong>javaWeb</strong> 容器(服务器)，也是当前应用最广的 <strong>JavaWeb</strong> 服务器(免费)。</p><p><strong>2.</strong> <strong>Jboss:是一个遵从</strong> <strong>JavaEE</strong> <strong>规范的、它支持所有的</strong> <strong>JavaEE</strong> <strong>规范(免费)。</strong></p><p><strong>3.</strong> <strong>GlassFish</strong>: 由 <strong>Oracle</strong> <strong>公司开发的一款</strong> <strong>JavaWeb</strong> <strong>服务器，是一款商业服务器，达到产品级质量(应用很少)。</strong></p><p><strong>4.</strong> <strong>Resin:是CAUCHO</strong> <strong>公司的产品，是一个非常流行的服务器，对</strong> <strong>servlet</strong> <strong>和</strong> <strong>JSP</strong> <strong>提供了良好的支持， 性能也比较优良(收费)。</strong></p><p><strong>5.</strong> <strong>WebLogic</strong>【很猛】:是 <strong>Oracle</strong> <strong>公司的产品，支持</strong> <strong>JavaEE</strong> <strong>规范， 而且不断的完善以适应新的开发要求，适合大型项目(收费，用的不多，适合大公司)。</strong></p><h2 id="7-6-Tomcat"><a href="#7-6-Tomcat" class="headerlink" title="7.6 Tomcat"></a>7.6 Tomcat</h2><h3 id="7-6-1-Tomcat下载和安装"><a href="#7-6-1-Tomcat下载和安装" class="headerlink" title="7.6.1 Tomcat下载和安装"></a><strong>7.6.1 Tomcat</strong>下载和安装</h3><p><strong>1. Tomcat</strong> 官方站点:**<a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a> **</p><p><strong>2.</strong> <strong>获取</strong> <strong>Tomcat</strong> <strong>安装程序包</strong></p><p><strong>tar.gz</strong>文件是<u>Linux</u>操作系统下的安装版本</p><p><strong>zip</strong>文件是<u>Windows</u>系统下的压缩版本</p><p><strong>3.</strong> <strong>使用</strong> <strong>zip</strong> <strong>包安装</strong> <strong>Tomcat</strong></p><p>**4. which version <a href="https://tomcat.apache.org/whichversion.html">https://tomcat.apache.org/whichversion.html</a> ,**可以看到 <strong>Tomcat</strong> <strong>仍然是支持</strong> <strong>jsp</strong> <strong>和</strong> <strong>el</strong></p><p><strong>5.</strong> Tomcat <strong>最好的小伙伴是</strong> <strong>JSP+EL</strong></p><h3 id="7-6-2-Tomcat启动"><a href="#7-6-2-Tomcat启动" class="headerlink" title="7.6.2 Tomcat启动"></a><strong>7.6.2 Tomcat</strong>启动</h3><p>windows系统：双击 <strong>bin</strong> 目录下的 <strong>startup.bat</strong> 文件</p><p>macos：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">🌟进入tomcat安装目录的bin目录下</span><br><span class="line">cd /Applications/压缩包资源/apache-tomcat-9.0.73/bin</span><br><span class="line"></span><br><span class="line">🌟启动tomcat</span><br><span class="line">./startup.sh</span><br><span class="line">🌟关闭tomcat</span><br><span class="line">./shutdown.sh</span><br><span class="line">🌟查看版本信息</span><br><span class="line">./version.sh</span><br></pre></td></tr></table></figure><p><strong>输入</strong> <strong><a href="http://localhost:8080/%EF%BC%8C%E6%98%BE%E7%A4%BA%E5%A6%82%E4%B8%8B%E7%95%8C%E9%9D%A2%E4%BB%A3%E8%A1%A8%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F">http://localhost:8080/，显示如下界面代表安装成功</a></strong>, <strong>默认在</strong> <strong>8080</strong> <strong>端口</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230705084311991.png" alt="image-20230705084311991"></p><p><strong>在开发中，我们可以看一下哪些端口在监听：</strong> netstat -anb</p><h3 id="7-6-3-Tomcat启动故障排除"><a href="#7-6-3-Tomcat启动故障排除" class="headerlink" title="7.6.3 Tomcat启动故障排除"></a><strong>7.6.3 Tomcat</strong>启动故障排除</h3><p><strong>1.</strong> 双击 <strong>startup.bat</strong> 文件，出现一个小黑窗口然后就没了，原因是因为没有配置好<strong>JAVA_HOME</strong> 环境变量<strong>Tomcat</strong> <strong>本质是一个</strong> <strong>Java</strong> <strong>程序，所以要</strong> <strong>jdk,</strong> <strong>会去根据</strong> <strong>JAVA_HOME</strong> <strong>使用指定</strong> <strong>jdk</strong></p><p><strong>2. JAVA_HOME</strong> <strong>必须全大写</strong></p><p><strong>3. JAVA_HOME</strong> <strong>中间必须是下划线</strong></p><p><strong>4. JAVA_HOME</strong> <strong>配置的路径只需要配置到</strong> <strong>jdk</strong> <strong>的安装目录即可。不需要带上</strong> <strong>bin</strong> <strong>目录</strong></p><p><strong>5.</strong> <strong>端口</strong> <strong>8080</strong> <strong>被占用</strong> **[**查看端口<u>netstat -anb</u>,使用的非常多]</p><p><strong>6.</strong> <strong>如果其它服务程序占用了</strong> <strong>8080</strong> <strong>端口，可以关闭该服务，或者修改</strong> <strong>Tomcat</strong> <strong>服务的默认 端口</strong> **8080 [**后面讲]</p><h3 id="7-6-4-Tomcat-目录结构"><a href="#7-6-4-Tomcat-目录结构" class="headerlink" title="7.6.4 Tomcat 目录结构"></a><strong>7.6.4 Tomcat</strong> 目录结构</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230705085601438.png" alt="image-20230705085601438"></p><p>解读<br><strong>1. server.xml</strong> <strong>用于配置</strong> <strong>tomcat的基本设置(启动端口，关闭端口,主机名)</strong></p><p><strong>2. wex.xml 用于指定 tomcat 运行时配置(比如servlet等</strong>.)</p><p><strong>3. webapps 目录是存放web应用，就是网站</strong></p><h3 id="7-6-5-catalina-启动-Tomcat-Windows"><a href="#7-6-5-catalina-启动-Tomcat-Windows" class="headerlink" title="7.6.5 catalina 启动 Tomcat(Windows)"></a>7.6.5 catalina 启动 Tomcat(Windows)</h3><p><strong>1.</strong> 进入到 <strong>Tomcat</strong> 的 <strong>bin</strong> 目录下</p><p><strong>2.</strong> <strong>执行命令:</strong> <strong>catalina run</strong></p><h3 id="7-6-6-停止-Tomcat"><a href="#7-6-6-停止-Tomcat" class="headerlink" title="7.6.6 停止 Tomcat"></a>7.6.6 停止 Tomcat</h3><p><strong>进入</strong> <strong>Tomcat</strong> <strong>的</strong> <strong>bin</strong> <strong>目录下的</strong> <strong>shutdown.bat</strong> <strong>双击，就可以停止</strong> <strong>Tomcat</strong> <strong>服务器</strong>(windows)</p><h3 id="7-6-7-修改-Tomcat-服务端口"><a href="#7-6-7-修改-Tomcat-服务端口" class="headerlink" title="7.6.7 修改 Tomcat 服务端口"></a>7.6.7 修改 Tomcat 服务端口</h3><p><strong>1. Tomcat</strong> 目录下的 <strong>conf</strong> 目录，修改 <strong>server.xml</strong> 配置文件</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230705152146388.png" alt="image-20230705152146388"></p><p><strong>2.</strong> <strong>老韩说明:</strong> <strong><a href="http://localhost/">http://localhost</a> ,</strong> <strong>默认是访问</strong> <strong>80</strong> <strong>端口</strong>,<strong>即</strong> <a href="http://localhost**等价**http//localhost:80">http://localhost**等价**http://localhost:80</a></p><h3 id="7-6-8-Tomcat-服务中部署-WEB-应用"><a href="#7-6-8-Tomcat-服务中部署-WEB-应用" class="headerlink" title="7.6.8 Tomcat 服务中部署 WEB 应用"></a>7.6.8 Tomcat 服务中部署 <strong>WEB</strong> 应用</h3><ul><li>什么是<strong>Web</strong>应用</li></ul><ol><li><p>WEB应用是多个web资源的集合。简单的说，可以把web应用理解为硬盘上的一个目录，这个目录用于管理多个web资源。</p></li><li><p>web应用通常也称之为web应用程序，或web工程，通俗的说就是网站。</p></li></ol><ul><li><strong>Web应用</strong>组成</li></ul><p>一个 WEB 应用由多个WEB 资源或其它文件组成，包括html 文件、css 文件、js文件、动态web页面、java 程序、支持jar 包、配置文件等。开发人员在开发 web 应用时，按照规定目录结构存放这些文件。否则，在把 web 应用交给 web 服务器管理时，不仅可能会使web 应用无法访问，还会导致 web 服务器启动报错。</p><ul><li>Javaweb程序&#x2F;应用&#x2F;工程目录结构</li></ul><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230706111003709.png" alt="image-20230706111003709" style="zoom: 40%;" /><ul><li>部署方式1：将web工程的目录拷贝到 Tomcat 的webapps 目录下</li></ul><ol><li><p>news web工程(目前都是静态资源 html， 图片）</p></li><li><p>将该news目录&#x2F;文件夹 拷贝到 Tomcat 的webapps目录下</p></li><li><p>浏览器输入：<a href="http://ip[域名]:port/news/子目录.../文件名">http://ip[域名]:port/news/子目录.../文件名</a></p></li></ol><ul><li>部署方式2：</li></ul><p>在tomcat下的 conf&#x2F;Catalina&#x2F;localhost&#x2F; 目录中，添加配置文件，可以映射到其他位置的web应用(在其他地方寻找web应用，解决磁盘空间分配问题)</p><p><strong>ROOT 的工程的访问:</strong></p><ol><li><p>在浏览器地址栏中输入访问地址如下：<a href="http://ip[域名]:port，">http://ip[域名]:port，</a><u>没有web工程&#x2F; 应用名时，默认访问的是 ROOT 工程</u></p></li><li><p>在浏览器地址栏中输入的访问地址如下: <a href="http://ip[域名]:port/工程名/">http://ip[域名]:port/工程名/</a> ，没有资源名,<strong>则默认访问</strong> <strong>index.jsp</strong> <strong>页面</strong></p></li></ol><h3 id="7-6-9-浏览器访问-Web-服务过程详解"><a href="#7-6-9-浏览器访问-Web-服务过程详解" class="headerlink" title="7.6.9 浏览器访问 Web 服务过程详解"></a>7.6.9 浏览器访问 Web 服务过程详解</h3><h4 id="7-6-9-1-回顾前面的-JavaWeb-开发技术栈图"><a href="#7-6-9-1-回顾前面的-JavaWeb-开发技术栈图" class="headerlink" title="7.6.9.1 回顾前面的 JavaWeb 开发技术栈图"></a>7.6.9.1 回顾前面的 JavaWeb 开发技术栈图</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230704161447451.png" alt="image-20230704161447451"></p><h4 id="7-6-9-2-浏览器访问-web-服务器文件-UML-时序图"><a href="#7-6-9-2-浏览器访问-web-服务器文件-UML-时序图" class="headerlink" title="7.6.9.2 浏览器访问 web 服务器文件 UML 时序图!!!"></a>7.6.9.2 浏览器访问 web 服务器文件 UML 时序图!!!</h4><p><strong>1.</strong> 说明</p><p>下面，我们对浏览器访问web服务器资源(html,css,图片,js)做详解，通过一个时序图加强对这个重要过程的理解,重要，核心</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230706111724367.png" alt="image-20230706111724367"></p><h2 id="7-7-IDEA-开发-JavaWeb-工程"><a href="#7-7-IDEA-开发-JavaWeb-工程" class="headerlink" title="7.7 IDEA 开发 JavaWeb 工程"></a>7.7 IDEA 开发 JavaWeb 工程</h2><h3 id="7-7-1-开发-javaweb-工程-amp-配置-TomCat-amp-启动项目"><a href="#7-7-1-开发-javaweb-工程-amp-配置-TomCat-amp-启动项目" class="headerlink" title="7.7.1 开发 javaweb 工程 &amp; 配置 TomCat &amp; 启动项目"></a>7.7.1 开发 javaweb 工程 &amp; 配置 TomCat &amp; 启动项目</h3><p>1.需求&#x2F;图解：使用 IDEA 开发 Javaweb 工程fishweb，并将网页部署到 fishweb 工程，看老师演示</p> <img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230706112454090.png" alt="image-20230706112454090" style="zoom:33%;" /><h3 id="7-7-2-注意事项和细节"><a href="#7-7-2-注意事项和细节" class="headerlink" title="7.7.2 注意事项和细节"></a>7.7.2 注意事项和细节</h3><h4 id="1-热加载选项说明"><a href="#1-热加载选项说明" class="headerlink" title="1. 热加载选项说明"></a>1. 热加载选项说明</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230706135810014.png" alt="image-20230706135810014"></p><p>解读：</p><p>(1)on update action ：表示当我们<strong>更新操作</strong>时，Tomcat 会自动更新类和资源（<u>当jsp&#x2F;html文件修改时，可以生效，但是如果你修改的java 文件，需要 Redepoly 才会生效</u>）</p><p>(2) on frame deactivation ：表示 <strong>IDEA 失去焦点</strong>（(比如最小化)，也会导致jsp&#x2F;html 发生更新，但是java 修改了，还是需要 Redeploy</p><h4 id="2-端口修改"><a href="#2-端口修改" class="headerlink" title="2. 端口修改"></a>2. 端口修改</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230706140054643.png" alt="image-20230706140054643" style="zoom:50%;" /><p><strong>这里修改的端口， 只会影响到当前的项目，而不是去修改 server.xml</strong></p><h4 id="3-out-目录是什么"><a href="#3-out-目录是什么" class="headerlink" title="3.out 目录是什么"></a>3.out 目录是什么</h4><p>当tomcat 启动时，会生成 out 目录，该目录就是原项目资源的映射，我们浏览器访问的资源是 out 目录</p><h4 id="4-当我们从外部拷贝资源到项目（图片，文件，js，css-等"><a href="#4-当我们从外部拷贝资源到项目（图片，文件，js，css-等" class="headerlink" title="4.当我们从外部拷贝资源到项目（图片，文件，js，css 等)"></a>4.当我们从外部拷贝资源到项目（图片，文件，js，css 等)</h4><p>如果出现 404 不能访问错误,解决方式 rebulid project -＞重启 Tomcat</p><h3 id="7-7-3-JavaWeb-工程的目录介绍"><a href="#7-7-3-JavaWeb-工程的目录介绍" class="headerlink" title="7.7.3 JavaWeb 工程的目录介绍"></a><strong>7.7.3 JavaWeb</strong> 工程的目录介绍</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230706141714376.png" alt="image-20230706141714376"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230706141833960.png" alt="image-20230706141833960"></p><h1 id="8-动态-WEB-开发核心-Servlet"><a href="#8-动态-WEB-开发核心-Servlet" class="headerlink" title="8 动态 WEB 开发核心-Servlet"></a>8 动态 WEB 开发核心-Servlet</h1><h2 id="8-1-官方文档"><a href="#8-1-官方文档" class="headerlink" title="8.1 官方文档"></a>8.1 官方文档</h2><h3 id="8-1-1-地址-https-tomcat-apache-org-tomcat-8-0-doc-servletapi-index-html"><a href="#8-1-1-地址-https-tomcat-apache-org-tomcat-8-0-doc-servletapi-index-html" class="headerlink" title="8.1.1 地址: https://tomcat.apache.org/tomcat-8.0-doc/servletapi/index.html"></a>8.1.1 地址: <a href="https://tomcat.apache.org/tomcat-8.0-doc/servletapi/index.html">https://tomcat.apache.org/tomcat-8.0-doc/servletapi/index.html</a></h3><h3 id="8-1-3-Servlet和Tomcat的关系-一句话-Tomcat支持Servlet"><a href="#8-1-3-Servlet和Tomcat的关系-一句话-Tomcat支持Servlet" class="headerlink" title="8.1.3 Servlet和Tomcat的关系:一句话,Tomcat支持Servlet"></a>8.1.3 Servlet和Tomcat的关系:一句话,Tomcat支持Servlet</h3><h2 id="8-2-为什么会出现-Servlet"><a href="#8-2-为什么会出现-Servlet" class="headerlink" title="8.2 为什么会出现 Servlet"></a>8.2 为什么会出现 Servlet</h2><p>提出需求**:** 请用你现有的<strong>html css javascript</strong>，开发网站，比如可以让用户留言**&#x2F;<strong>购物</strong>&#x2F;<strong>支付</strong>,** 你能搞定吗**?**</p><p>—不能，因为无法操作数据库</p><ul><li>引入我们动态网页(能和用户交互)技术 <strong>&#x3D;&#x3D;&#x3D;&gt; Servlet</strong></li><li>对Java Web 技术体系的流程图改造说明(细化).[整体的概念]</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230706145610695.png" alt="image-20230706145610695"></p><h2 id="8-3-什么是-Servlet"><a href="#8-3-什么是-Servlet" class="headerlink" title="8.3 什么是 Servlet"></a>8.3 什么是 Servlet</h2><ul><li><p>什么是Servlet</p><ul><li>Servlet 在开发动态 WEB 工程中，得到广泛的应用，掌握好 Servlet 非常重要,Servlet(基石)是 SpringMVC 的基础</li></ul></li><li><p>Servlet(java 服务器小程序)，它的特点：</p><ul><li>他是由服务器端调用和执行的(一句话：是Tomcat解析和执行）</li><li>他是用java语言编号的，本质就是Java类</li><li>他是按照Servlet规范开发的（除 了tomcat-&gt;Servlet weblogic-&gt;Servlet)</li><li>功能强大，可以完成几乎所有的网站功能(在以前，我们老程员，使用Servlet开发网站）技术栈要求高</li></ul></li></ul><h2 id="8-4-Servlet在JavaWeb项目位置"><a href="#8-4-Servlet在JavaWeb项目位置" class="headerlink" title="8.4 Servlet在JavaWeb项目位置"></a>8.4 Servlet在JavaWeb项目位置</h2><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230707084620291.png" alt="image-20230707084620291"></p><h2 id="8-5-Servlet基本使用"><a href="#8-5-Servlet基本使用" class="headerlink" title="8.5 Servlet基本使用"></a>8.5 Servlet基本使用</h2><h3 id="8-5-1-Servlet开发方式说明"><a href="#8-5-1-Servlet开发方式说明" class="headerlink" title="8.5.1 Servlet开发方式说明"></a><strong>8.5.1 Servlet</strong>开发方式说明</h3><ol><li><p>servlet3.0 前使用 <strong>web.xml , servlet3.0</strong> 版本以后**(**包括 **3.0)**支持注解， 同时支持 <strong>web.xml</strong> 配置</p></li><li><p><strong>如何查看</strong> <strong>servlet版本[如图]</strong></p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230707085030431.png" alt="image-20230707085030431"></p><ol start="3"><li><p>讲解SpringBoot 时，我们用注解方式，从 ssm,springboot 后面全部使用注解</p></li><li><p>这专门讲 servlet， 为让大家更清晰知道 servlet 使用原理，老师用配置方式（说明: 原生的 Servlet 在项目中使用很少</p></li><li><p>不管使用哪种方式，本质都一样</p></li></ol><h3 id="8-5-2-快速入门-手动开发-Servlet"><a href="#8-5-2-快速入门-手动开发-Servlet" class="headerlink" title="8.5.2 快速入门- 手动开发 Servlet"></a>8.5.2 快速入门- 手动开发 Servlet</h3><p>需求说明</p><p>1、开发一个 Helloservlet</p><p>2、当浏览器 访问 <a href="http://localhost:8080/web%E5%BA%94%E7%94%A8%E5%90%8D/helloServlet">http://localhost:8080/web应用名/helloServlet</a> 时，后台输出 “hi HelloServelt”</p><ul><li>具体步骤<ul><li>编写类Helloservlet去实现 Servlet <strong>接口</strong></li><li>实现 service 方法，处理请求，并响应数据</li><li>在 web.xml 中去配置 servlet 程序的访问地址</li></ul></li></ul><p>1.创建 hspedu_servlet JavaWeb 工程，并配置好Tomcat</p><p>2.添加servlet-api.jar(在tomcat&#x2F;lib下)到工程,因为servlet.jar不是jdk自带的,要引入</p><p>3.在src下包<strong>com.hspedu.servlet.HelloServlet.java</strong>，并实现Servlet接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/7/7</span></span><br><span class="line"><span class="comment"> * 09:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="comment">//当创建HelloServlet时，会调用init方法</span></span><br><span class="line">    <span class="comment">//该方法只会被调用一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servlet被调用~~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回Servlet的配置信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * service 方法是专门用来处理请求和响应的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy 被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.在web.xml配置HelloServlet，即:给HelloServlet提供对外访问地址</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  1.web.xml主要用来配置该web应用使用到的Servlet  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  2.servlet-name:给Servlet取名(程序员决定)，该名字唯一</span></span><br><span class="line"><span class="comment">      3.servlet-class：Servlet的类的全路径：Tomcat在反射生成该Servlet需要使用</span></span><br><span class="line"><span class="comment">      4.url-pattern：该servlet访问的url的配置(路径)</span></span><br><span class="line"><span class="comment">      这时我们应访问：http://localhost:8080/servlet/helloServlet</span></span><br><span class="line"><span class="comment">      5.url-pattern 取名是程序员决定的</span></span><br><span class="line"><span class="comment">      6.load-on-startup:表示在tomcat启动时，会自动加载servlet实例</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.study.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/helloServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>5.通过浏览器访问HelloServlet ,看是否正确(记住要redeploy[快]或者restart[慢])</p><p><a href="http://localhost:8080/servlet/helloServlet">http://localhost:8080/servlet/helloServlet</a></p><h3 id="8-5-3-浏览器调用-Servlet-流程分析"><a href="#8-5-3-浏览器调用-Servlet-流程分析" class="headerlink" title="8.5.3 浏览器调用 Servlet 流程分析"></a>8.5.3 浏览器调用 Servlet 流程分析</h3><p>一图胜千言</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230707095156118.png" alt="image-20230707095156118"></p><p>如果在web.xml中未查询到请求的资源，则会返回404错误！</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230707095634908.png" alt="image-20230707095634908"></p><p><strong>Servlet常驻内存，属于单例模式</strong></p><h3 id="8-5-4-Servlet生命周期"><a href="#8-5-4-Servlet生命周期" class="headerlink" title="8.5.4 Servlet生命周期"></a><strong>8.5.4 Servlet</strong>生命周期</h3><p>● 主要有三个方法：</p><p><strong>1. init()：</strong>初始化阶段</p><p><strong>2. service()：</strong>处理浏览器请求阶段</p><p><strong>3. destroy()：</strong>终止阶段</p><ul><li><strong>示意图</strong></li></ul><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230707100629527.png" alt="image-20230707100629527" style="zoom:40%;" /><ul><li><p><strong>初始化阶段</strong></p><ul><li><p>servlet 容器(比如：Tomcat)&#x2F;加载 Servlet，加载完成后，Servlet 容器会创建一个 Servlet 实例</p><p>并调用 init()方法，init()方法只会调用一次，Servlet 容器在下面的情况装载 Servlet:</p><ul><li><p>Servlet 容器 (Tomcat) 启动时自动装载某些 servlet，实现这个需要在 web.xml 文件中添加</p><p><load-on-startup>1</load-on-startup>1 表示装载的顺序</p></li><li><p>在servlet 容器启动后，浏览器首次向 servlet 发送请求(这个前面说过）</p></li><li><p>Servlet 重新部署后(比如 tomcat 进行 redeploy 【*<u><strong>redeploy 会销毁所有的 servlet 实例!!!</strong></u>*】）。</p><p>浏览器再向 Servlet 发送第1次请求(或配置了tomcat启动自动装载)</p></li></ul></li></ul></li><li><p><strong>处理浏览器请求阶段</strong>(service <strong>方法</strong>)</p></li><li><p>每收到一个http 请求，服务器就会产生一个新的线程去处理[线程]</p></li><li><p>创建一个用于封装 HTTP 请求消息的 <strong>ServletRequest 对象</strong>和一个代表 HTTP 响应消息的<strong>ServletResponse</strong> 对象</p></li><li><p>然后调用 Servlet 的 service()方法并将请求和响应对象作为参数传递进去</p></li><li><p>终止阶段 destory 方法(体现 Servlet 完整的生命周期)</p><ul><li><p>当web 应用被終止，或者 servlet 容器終止运行，或者Servlet 类重新装载时，会调用 destroy(方法</p></li><li><p>比如重启 tomcat,或者redeploy web 应用</p></li></ul></li></ul><h3 id="8-5-5-GET-和-POST-请求的分发处理"><a href="#8-5-5-GET-和-POST-请求的分发处理" class="headerlink" title="8.5.5 GET 和 POST 请求的分发处理"></a>8.5.5 GET 和 POST 请求的分发处理</h3><ul><li><p>开发 servlet，通常编写 doGet、doPost 方法。来对表单的get 和 post 请求进行分发处理</p></li><li><p>代码演示 HelloServlet.java   register.html</p></li></ul><ol><li>创建 servlet\web\register.html</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">title</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>注册用户<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:8080/servlet/helloServlet&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">            u: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注册用户&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.</strong> 修改 <strong>servlet\src\com\hspedu\servlet\HelloServlet.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//思考-&gt;从 servletRequest 对象来获取请求方式-&gt;</span></span><br><span class="line">        <span class="comment">//1. ServletRequest 没有得到提交方式的方法</span></span><br><span class="line">        <span class="comment">//2. ServletRequest 看看 ServletRequest 子接口有没有相关方法</span></span><br><span class="line">        <span class="comment">//3. 老师小技巧:ctrl+alt+b =&gt; 可以看到接口的子接口和实现子类</span></span><br><span class="line">        <span class="comment">//4. 把 servletReqeust 转成 HttpServletRequest 引用</span></span><br><span class="line">        <span class="comment">//5. 仍然是 Java 基础的 OOP</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> httpServletRequest.getMethod();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;GET&quot;</span>.equals(method)) &#123;</span><br><span class="line">            doGet();    <span class="comment">//用 doGet() 处理 GET 请求 &#125;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;POST&quot;</span>.equals(method)) &#123;</span><br><span class="line">            doPost();   <span class="comment">//用 doPost() 处理 POST 请求</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doGet被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doPost被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="8-5-6-通过继承-HttpServlet-开发-Servlet"><a href="#8-5-6-通过继承-HttpServlet-开发-Servlet" class="headerlink" title="8.5.6 通过继承 HttpServlet 开发 Servlet"></a>8.5.6 通过继承 HttpServlet 开发 Servlet</h3><ul><li>HttpServlet 介绍</li></ul><p>在实际项目中，都是使用继承 HttpServlet 类开发 Servlet 程序，更加方便</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230707112036074.png" alt="image-20230707112036074" style="zoom:50%;" /><ul><li>HttpServlet 介绍</li></ul><p>1、通过继承 HttpServlet 开发一个 HiServlet</p><p>2、当浏览器 访问 <a href="http://localhost:8080/web">http://localhost:8080/web</a> 应用名&#x2F;hiServlet 时，后台输出 “hi HiServelt”</p><ul><li>具体的开发步骤</li></ul><ol><li>编写一个类去继承 HttpServlet 类</li><li>根据业务需要重写 doGet 或 doPost 方法</li><li>到 web.xml 中的配置 Servlet 程序</li></ol><ul><li>应用实例</li></ul><p>1.创建HiServlet.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/7/7</span></span><br><span class="line"><span class="comment"> * 13:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HiServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HiServlet doGet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HiServlet doPost&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.修改web.xml完成配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HiServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.study.servlet.HiServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HiServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hiServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.完成测试</p><p><a href="http://localhost:8080/servlet/hiServlet">http://localhost:8080/servlet/hiServlet</a></p><h3 id="8-5-7-IDEA-开发-Servlet-程序"><a href="#8-5-7-IDEA-开发-Servlet-程序" class="headerlink" title="8.5.7 IDEA 开发 Servlet 程序"></a>8.5.7 IDEA 开发 Servlet 程序</h3><ul><li>说明</li></ul><p>编手动开发 Servlet 需要程序员自己配置 Servlet ,比较麻烦，在工作中，直接使用 IDEA 开发 Servlet 会更加方便</p><ul><li>应用实例</li></ul><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230707140732732.png" alt="image-20230707140732732" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230707140642567.png" alt="image-20230707140642567" style="zoom: 50%;" /><h3 id="8-5-8-Servlet-注意事项和细节"><a href="#8-5-8-Servlet-注意事项和细节" class="headerlink" title="8.5.8 Servlet 注意事项和细节"></a>8.5.8 Servlet 注意事项和细节</h3><ol><li>Servlet 是一个供其他 Java 程序（Servlet 引擎） 调用的 Java 类， 不能独立运行</li><li>针对浏览器的多次 Servlet 请求，通常情况下，服务器只会创建一个 Servlet 实例对象，也就是说 Servlet 实例对象一旦创建，它就会驻留在内存中，为后续的其它请求服务，直至web 容器退出&#x2F;或者 redeploy 该 web 应用，servlet 实例对象才会销毁 【示意图】</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230710085610919.png" alt="image-20230710085610919" style="zoom:50%;" /><ol start="3"><li><p>在 Servlet 的整个生命周期内，init 方法只被调用一次。而对每次请求都导致 Servlet 引擎调用一次 servlet 的 service 方法。</p></li><li><p>对于每次访问请求，Servlet 引擎都会创建一个新的 HttpServletRequest 请求对象和一个新的 HttpServletResponse 响应对象，然后将这两个对象作为参数传递给它调用的 Servlet的 service()方法，service 方法再根据请求方式分别调用 doXXX 方法</p></li><li><p>如果在<servlet>元素中配置了一个<load-on-startup>元素，那么 WEB 应用程序在启动时，就会装载并创建 Servlet 的实例对象、以及调用 Servlet 实例对象的 init()方法         应用场景：(定时发送邮件的服务&#x2F;自动启动-&gt;完成任务)</p></li></ol><h2 id="8-6-Servlet-注解方式"><a href="#8-6-Servlet-注解方式" class="headerlink" title="8.6 Servlet - 注解方式"></a>8.6 Servlet - 注解方式</h2><h3 id="8-6-1-快速入门"><a href="#8-6-1-快速入门" class="headerlink" title="8.6.1 快速入门"></a>8.6.1 快速入门</h3><ul><li>具体步骤</li></ul><ol><li><p>编写类OkServlet去继承HttpServlet</p></li><li><p>注解方式配置OkServlet, 一个Servlet支持配置多个urlPattern</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.servlet.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/7/7</span></span><br><span class="line"><span class="comment"> * 14:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 1.注解方式配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@WebServlet</span>是一个注解</span></span><br><span class="line"><span class="comment"> * 2.源码：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Target</span>(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Retention</span>(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Documented</span></span></span><br><span class="line"><span class="comment"> * public <span class="doctag">@interface</span> WebServlet &#123;</span></span><br><span class="line"><span class="comment"> *     String name() default &quot;&quot;;</span></span><br><span class="line"><span class="comment"> *     String[] value() default &#123;&#125;;</span></span><br><span class="line"><span class="comment"> *     String[] urlPatterns() default &#123;&#125;;</span></span><br><span class="line"><span class="comment"> *     int loadOnStartup() default -1;</span></span><br><span class="line"><span class="comment"> *     WebInitParam[] initParams() default &#123;&#125;;</span></span><br><span class="line"><span class="comment"> *     boolean asyncSupported() default false;</span></span><br><span class="line"><span class="comment"> *     String smallIcon() default &quot;&quot;;</span></span><br><span class="line"><span class="comment"> *     String largeIcon() default &quot;&quot;;</span></span><br><span class="line"><span class="comment"> *     String description() default &quot;&quot;;</span></span><br><span class="line"><span class="comment"> *     String displayName() default &quot;&quot;;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * 3.urlPatterns 对应 &lt;url-patterns&gt;&lt;url-patterns/&gt;</span></span><br><span class="line"><span class="comment"> * 4.&#123;&quot;/ok1&quot;,&quot;/ok2&quot;&#125; 可以给OkServlet配置多个url-pattern</span></span><br><span class="line"><span class="comment"> * 5.用户在浏览器可以这样访问：http://localhost:8080/servlet/ok2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &#123;&quot;/ok1&quot;,&quot;/ok2&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OkServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;注解方式 OkServlet doPost&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;注解方式 OkServlet doGet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>注解方式是如何实现的？</p><p>——Tomcat对包进行扫描，如果发现某个类被@WebServlet修饰，就说明该类是Servlet，就读取注解中的urlPatterns，然后进行下一步……(看请求的资源是否能从注解中找到……，找到则得到urlPatterns，去hashmap中看该servlet是否已经加载过……)</p><h3 id="8-6-2-Servlet-urlPattern-配置"><a href="#8-6-2-Servlet-urlPattern-配置" class="headerlink" title="8.6.2 Servlet urlPattern 配置"></a>8.6.2 Servlet urlPattern 配置</h3><h4 id="8-6-2-1-精确匹配"><a href="#8-6-2-1-精确匹配" class="headerlink" title="8.6.2.1 精确匹配"></a>8.6.2.1 精确匹配</h4><p>——最简单、普遍的路径设置方式</p><p>配置路径 : @WebServlet(“&#x2F;ok&#x2F;zs”)</p><p>访问 servlet: localhost:8080&#x2F;servlet&#x2F;ok&#x2F;zs</p><h4 id="8-6-2-2-目录匹配"><a href="#8-6-2-2-目录匹配" class="headerlink" title="8.6.2.2 目录匹配"></a>8.6.2.2 目录匹配</h4><p>—— * 表示：零层、任意单层、任意多层</p><p>配置路径 : @WebServlet(“&#x2F;ok&#x2F;*”)</p><p>访问文件: localhost:8080&#x2F;servlet&#x2F;ok&#x2F;aaa localhost:8080&#x2F;servlet&#x2F;ok&#x2F;bbb</p><h4 id="8-6-2-3-扩展名匹配"><a href="#8-6-2-3-扩展名匹配" class="headerlink" title="8.6.2.3 扩展名匹配"></a>8.6.2.3 扩展名匹配</h4><p>——必须保证后缀为 .action</p><p>配置路径 : @WebServlet(“**.action”)*</p><p>访问文件: localhost:8080&#x2F;hsp&#x2F;zs.action localhost:8080&#x2F;hsp&#x2F;ls.action</p><p>提示: @WebServlet(“&#x2F;*.action”) , 不能带 &#x2F; , 否则 tomcat 报错</p><h4 id="8-6-2-4-任意匹配"><a href="#8-6-2-4-任意匹配" class="headerlink" title="8.6.2.4 任意匹配"></a>8.6.2.4 任意匹配</h4><p>配置路径 : @WebServlet(“&#x2F;“) @WebServlet(“&#x2F;**”)*</p><p>访问文件: localhost:8080&#x2F;hsp&#x2F;aaa localhost:8080&#x2F;hsp&#x2F;bbb localhost:8080&#x2F;hsp&#x2F;ccc</p><p>提醒： &#x2F; 和 &#x2F;*的配置， 会匹配所有的请求， 这个比较不实用</p><h4 id="8-6-2-5-注意事项和使用细节"><a href="#8-6-2-5-注意事项和使用细节" class="headerlink" title="8.6.2.5 注意事项和使用细节"></a>8.6.2.5 注意事项和使用细节</h4><p>1、 当 Servlet 配置了 “&#x2F;“, 会覆盖 tomcat 的 DefaultServlet,（当其他的 utl-pattern 都匹配不上时 ，都会走这个 Servlet, 这样可以拦截到其它静态资源,比如D:\hspedu_javaweb_temp\hspedu_servlet\web\hi.html [举例]查看：tomcat&#x2F;conf&#x2F;web.xml , 配置的 DefaultServlet</p><p>「The default servlet for all web applications, that serves static resources.这个默认的 servlet 是处理静态资源的，一旦拦截，静态资源不能处理」</p><p>2、当 Servelt 配置了 “&#x2F;**”, 表示可以匹配任意访问路径*</p><p>3、提示: 建议不要使用 &#x2F; 和 &#x2F;*, 建议尽量使用精确匹配</p><p>4、优先级遵守: 精确路径 &gt; 目录路径 &gt; 扩展名路径 &gt; &#x2F;* &gt; &#x2F;</p><h2 id="8-8-🌟关联篇：-HTTP-协议"><a href="#8-8-🌟关联篇：-HTTP-协议" class="headerlink" title="8.8 🌟关联篇： HTTP 协议"></a>8.8 🌟关联篇： HTTP 协议</h2><h3 id="8-8-1请求头、响应头介绍"><a href="#8-8-1请求头、响应头介绍" class="headerlink" title="8.8.1请求头、响应头介绍"></a>8.8.1请求头、响应头介绍</h3><p><a href="https://github.com/Tangjiayang/picodemo/blob/main/img/HTTP%E5%B8%B8%E8%A7%81%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%B4-%E8%AF%B4%E6%98%8E.pdf">https://github.com/Tangjiayang/picodemo/blob/main/img/HTTP%E5%B8%B8%E8%A7%81%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%B4-%E8%AF%B4%E6%98%8E.pdf</a></p><h3 id="8-8-2HTTP状态码"><a href="#8-8-2HTTP状态码" class="headerlink" title="8.8.2HTTP状态码"></a>8.8.2HTTP状态码</h3><p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。</p><p>HTTP状态码的英文为HTTP Status Code。</p><h4 id="下面是常见的HTTP状态码："><a href="#下面是常见的HTTP状态码：" class="headerlink" title="下面是常见的HTTP状态码："></a>下面是常见的HTTP状态码：</h4><p><strong>200 -</strong> <strong>请求成功</strong></p><p><strong>301 -</strong> <strong>资源（网页等）被永久转移到其它URL</strong></p><p><strong>404 -</strong> <strong>请求的资源（网页等）不存在</strong></p><p><strong>500 -</strong> <strong>内部服务器错误</strong></p><h4 id="HTTP状态码分类"><a href="#HTTP状态码分类" class="headerlink" title="HTTP状态码分类"></a>HTTP状态码分类</h4><p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：</p><table><thead><tr><th>HTTP状态码分类</th><th></th></tr></thead><tbody><tr><td><strong>分类</strong></td><td><strong>分类描述</strong></td></tr><tr><td><strong>1*</strong>*</td><td><strong>信息，服务器收到请求，需要请求者继续执行操作</strong></td></tr><tr><td><strong>2*</strong>*</td><td><strong>成功，操作被成功接收并处理</strong></td></tr><tr><td><strong>3*</strong>*</td><td><strong>重定向，需要进一步的操作以完成请求</strong></td></tr><tr><td><strong>4*</strong>*</td><td><strong>客户端错误，请求包含语法错误或无法完成请求</strong></td></tr><tr><td><strong>5*</strong>*</td><td><strong>服务器错误，服务器在处理请求的过程中发生了错误</strong></td></tr></tbody></table><h4 id="HTTP状态码列表"><a href="#HTTP状态码列表" class="headerlink" title="HTTP状态码列表:"></a>HTTP状态码列表:</h4><table><thead><tr><th>状态码</th><th><strong>状态码英文名称</strong></th><th><strong>中文描述</strong></th></tr></thead><tbody><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http100">100</a></strong></td><td><strong>Continue</strong></td><td><strong>继续。客户端应继续其请求</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http101">101</a></strong></td><td><strong>Switching Protocols</strong></td><td><strong>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http200">200</a></strong></td><td><strong>OK</strong></td><td><strong>请求成功。一般用于GET与POST请求</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http201">201</a></strong></td><td><strong>Created</strong></td><td><strong>已创建。成功请求并创建了新的资源</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http200">202</a></strong></td><td><strong>Accepted</strong></td><td><strong>已接受。已经接受请求，但未处理完成</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http203">203</a></strong></td><td><strong>Non-Authoritative Information</strong></td><td><strong>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http204">204</a></strong></td><td><strong>No Content</strong></td><td><strong>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http205">205</a></strong></td><td><strong>Reset Content</strong></td><td><strong>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http206">206</a></strong></td><td><strong>Partial Content</strong></td><td><strong>部分内容。服务器成功处理了部分GET请求</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http300">300</a></strong></td><td><strong>Multiple Choices</strong></td><td><strong>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http301">301</a></strong></td><td><strong>Moved Permanently</strong></td><td><strong>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http302">302</a></strong></td><td><strong>Found</strong></td><td><strong>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http303">303</a></strong></td><td><strong>See Other</strong></td><td><strong>查看其它地址。与301类似。使用GET和POST请求查看</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http304">304</a></strong></td><td><strong>Not Modified</strong></td><td><strong>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http305">305</a></strong></td><td><strong>Use Proxy</strong></td><td><strong>使用代理。所请求的资源必须通过代理访问</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http306">306</a></strong></td><td><strong>Unused</strong></td><td><strong>已经被废弃的HTTP状态码</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http307">307</a></strong></td><td><strong>Temporary Redirect</strong></td><td><strong>临时重定向。与302类似。使用GET请求重定向</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http400">400</a></strong></td><td><strong>Bad Request</strong></td><td><strong>客户端请求的语法错误，服务器无法理解</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http401">401</a></strong></td><td><strong>Unauthorized</strong></td><td><strong>请求要求用户的身份认证</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http402">402</a></strong></td><td><strong>Payment Required</strong></td><td><strong>保留，将来使用</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http403">403</a></strong></td><td><strong>Forbidden</strong></td><td><strong>服务器理解请求客户端的请求，但是拒绝执行此请求</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http404">404</a></strong></td><td><strong>Not Found</strong></td><td><strong>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http405">405</a></strong></td><td><strong>Method Not Allowed</strong></td><td><strong>客户端请求中的方法被禁止</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http406">406</a></strong></td><td><strong>Not Acceptable</strong></td><td><strong>服务器无法根据客户端请求的内容特性完成请求</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http407">407</a></strong></td><td><strong>Proxy Authentication Required</strong></td><td><strong>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http408">408</a></strong></td><td><strong>Request Time-out</strong></td><td><strong>服务器等待客户端发送的请求时间过长，超时</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http409">409</a></strong></td><td><strong>Conflict</strong></td><td><strong>服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http410">410</a></strong></td><td><strong>Gone</strong></td><td><strong>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http411">411</a></strong></td><td><strong>Length Required</strong></td><td><strong>服务器无法处理客户端发送的不带Content-Length的请求信息</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http412">412</a></strong></td><td><strong>Precondition Failed</strong></td><td><strong>客户端请求信息的先决条件错误</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http413">413</a></strong></td><td><strong>Request Entity Too Large</strong></td><td><strong>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http414">414</a></strong></td><td><strong>Request-URI Too Large</strong></td><td><strong>请求的URI过长（URI通常为网址），服务器无法处理</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http415">415</a></strong></td><td><strong>Unsupported Media Type</strong></td><td><strong>服务器无法处理请求附带的媒体格式</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http416">416</a></strong></td><td><strong>Requested range not satisfiable</strong></td><td><strong>客户端请求的范围无效</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http417">417</a></strong></td><td><strong>Expectation Failed</strong></td><td><strong>服务器无法满足Expect的请求头信息</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http500">500</a></strong></td><td><strong>Internal Server Error</strong></td><td><strong>服务器内部错误，无法完成请求</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http501">501</a></strong></td><td><strong>Not Implemented</strong></td><td><strong>服务器不支持请求的功能，无法完成请求</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http502">502</a></strong></td><td><strong>Bad Gateway</strong></td><td><strong>充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http503">503</a></strong></td><td><strong>Service Unavailable</strong></td><td><strong>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http504">504</a></strong></td><td><strong>Gateway Time-out</strong></td><td><strong>充当网关或代理的服务器，未及时从远端服务器获取请求</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http505">505</a></strong></td><td><strong>HTTP Version not supported</strong></td><td><strong>服务器不支持请求的HTTP协议的版本，无法完成处理</strong></td></tr></tbody></table><h3 id="GET请求行和请求头解析："><a href="#GET请求行和请求头解析：" class="headerlink" title="GET请求行和请求头解析："></a>GET请求行和请求头解析：</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230710100130745.png" alt="image-20230710100130745"></p><h3 id="POST请求行和请求头解析："><a href="#POST请求行和请求头解析：" class="headerlink" title="POST请求行和请求头解析："></a>POST请求行和请求头解析：</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230710101351184.png" alt="image-20230710101351184"></p><h3 id="何时使用-get-x2F-post-？"><a href="#何时使用-get-x2F-post-？" class="headerlink" title="何时使用 get &#x2F; post ？"></a>何时使用 get &#x2F; post ？</h3><p>get和post方法功能类似的，使用建议：<br>1、get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式；<br>2、在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；</p><p>区别表现如下：</p><ol><li>get是从服务器上获取数据，post是向服务器传送数据。</li><li>get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。</li><li>对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。</li><li>get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。</li><li>get安全性非常低，post安全性较高。但是执行效率却比Post方法好。</li></ol><p><strong>若符合下列任一情况，则用POST方法：</strong></p><ul><li>请求的结果有持续性的副作用，例如，数据库内添加新的数据行。</li><li>若使用GET方法，则表单上收集的数据可能让URL过长。</li><li>要传送的数据不是采用7位的ASCII编码。</li></ul><p><strong>若符合下列任一情况，则用GET方法：</strong></p><ul><li>请求是为了查找资源，HTML表单数据仅用来帮助搜索。</li><li>请求结果无持续性的副作用。</li><li>收集的数据及HTML表单内的输入字段名称的总长不超过1024个字符。</li></ul><p>原文链接：<a href="https://blog.csdn.net/qq_47443027/article/details/114696716">https://blog.csdn.net/qq_47443027/article/details/114696716</a></p><h3 id="响应体："><a href="#响应体：" class="headerlink" title="响应体："></a>响应体：</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230710211832628.png" alt="image-20230710211832628"></p><h3 id="常见状态码说明："><a href="#常见状态码说明：" class="headerlink" title="常见状态码说明："></a>常见状态码说明：</h3><h4 id="302"><a href="#302" class="headerlink" title="302"></a>302</h4><p>​资源被转移了，返回给你302 还告诉你该去哪里找不见的资源，因此浏览器需要发送两次请求才能访问到原来的资源(只发生一次302的情况)</p><h4 id="304"><a href="#304" class="headerlink" title="304"></a>304</h4><p>(在浏览器允许缓存的情况下)浏览器在请求某资源时，如果有该资源的缓存，就会把该资源的最后修改日期也发给服务器。</p><p>如果最后修改日期 &#x3D; 服务器端该资源的最后修改日期，则服务器告诉浏览器请求的资源未修改过，返回304，不返回资源给浏览器，让浏览器去自己的缓存去找。</p><h4 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h4><h5 id="MIME-介绍："><a href="#MIME-介绍：" class="headerlink" title="MIME 介绍："></a>MIME 介绍：</h5><ol><li><p>MIME 是 HTTP 协议中数据类型。 MIME 的英文全称是”Multipurpose Internet Mail Extensions” 多功能 Internet 邮件扩充服务。 MIME 类型的格式是**”大类型&#x2F;小类型”**，并与某一种文件的扩展名相对应</p></li><li><p>在响应包的Content-Type 就有指定</p></li></ol><h5 id="常见的-MIME-类型："><a href="#常见的-MIME-类型：" class="headerlink" title="常见的 MIME 类型："></a>常见的 MIME 类型：</h5><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711083211146.png" alt="image-20230711083211146" style="zoom: 67%;" /><h2 id="8-9-ServletConfig"><a href="#8-9-ServletConfig" class="headerlink" title="8.9 ServletConfig"></a>8.9 ServletConfig</h2><h3 id="8-9-1-ServletConfig-基本介绍"><a href="#8-9-1-ServletConfig-基本介绍" class="headerlink" title="8.9.1 ServletConfig 基本介绍"></a>8.9.1 ServletConfig 基本介绍</h3><ol><li>ServletConfig 类是为 Servlet 程序的<strong>配置信息的类</strong></li><li>Servlet 程序和 ServletConfig 对象都是由 Tomcat 负责创建</li><li>Servlet 程序默认是第 1 次访问的时候创建， <u>ServletConfig 在 Servlet 程序创建时， 就创建一个对应的 ServletConfig 对象</u>(每个servlet都有一个对应的servletConfig)</li></ol><p>8.9.2 ServletConfig 类能干什么</p><ul><li><p>获取 Servlet 程序的 <strong>servlet-name</strong> 的值</p></li><li><p>获取<strong>初始化参数 init-param</strong></p></li><li><p>获取 <strong>ServletContext 对象</strong></p></li></ul><h3 id="8-9-3-ServletConfig"><a href="#8-9-3-ServletConfig" class="headerlink" title="8.9.3 ServletConfig"></a>8.9.3 ServletConfig</h3><p>应用实例</p><p>● 需求: 编写 DBServlet.java 完成如下功能</p><ol><li><p>在 web.xml 配置连接 mysql 的用户名和密码</p></li><li><p>在 DBServlet 执行 doGet()&#x2F;doPost() 时，可以获取到 web.xml 配置的用户名和密码</p></li><li><p>示意图(思路分析)</p></li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711084923867.png" alt="image-20230711084923867" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;DBServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.study.servlet.DBServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;username&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;donn&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;password&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;<span class="number">123456</span>&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">ServletConfig</span> <span class="variable">servletConfig</span> <span class="operator">=</span> getServletConfig();</span><br><span class="line">    System.out.println(servletConfig.getInitParameter(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">    System.out.println(servletConfig.getInitParameter(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-10-ServletContext"><a href="#8-10-ServletContext" class="headerlink" title="8.10 ServletContext"></a>8.10 ServletContext</h2><p><strong><u><em>——多个Servlet共享的数据空间</em></u></strong></p><h3 id="8-10-1-为什么需要-ServletContext"><a href="#8-10-1-为什么需要-ServletContext" class="headerlink" title="8.10.1 为什么需要 ServletContext"></a>8.10.1 为什么需要 ServletContext</h3><ol><li>先看一个需求： 如果我们希望统计某个 web 应用的所有 Servlet 被访问的次数， 怎么办?</li></ol><p>​方案1-DB:</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711091848410.png" alt="image-20230711091848410" style="zoom:50%;" /><p>​方案2-ServletContext：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711092040710.png" alt="image-20230711092040710"></p><h3 id="8-10-2-ServletContext-基本介绍"><a href="#8-10-2-ServletContext-基本介绍" class="headerlink" title="8.10.2 ServletContext 基本介绍"></a>8.10.2 ServletContext 基本介绍</h3><ol><li><p>ServletContext 是一个接口， 它表示 Servlet 上下文对象</p></li><li><p><strong>一个 web 工程，只有一个 ServletContext 对象实例</strong></p></li><li><p><strong>ServletContext 对象 是在 web 工程启动的时候创建，在 web 工程停止的时销毁</strong>  </p></li><li><p>ServletContext 对象可以通过 <strong>ServletConfig.getServletContext 方法</strong>获得对 ServletContext对象的引用，也可以通过 **this.getServletContext()**来获得其对象的引用。</p></li><li><p>由于一个 WEB 应用中的所有 Servlet 共享同一个 ServletContext 对象，因此 Servlet 对象之间可以通过 ServletContext 对象来实现多个 Servlet 间通讯。<strong>ServletContext 对象通常也被称之为域对象</strong>。【示意图】</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711092825430.png" alt="image-20230711092825430"></p><h3 id="8-10-3-ServletContext-可以做什么"><a href="#8-10-3-ServletContext-可以做什么" class="headerlink" title="8.10.3 ServletContext 可以做什么"></a>8.10.3 ServletContext 可以做什么</h3><ol><li><p>获取 web.xml 中配置的上下文参数 context-param [信息和整个 web 应用相关， 而不是属于某个 Servlet]</p></li><li><p><strong>获取当前的工程路径</strong>，格式: &#x2F;工程路径 &#x3D;&#x3D;&gt; 比如 &#x2F;servlet.          <strong>其实就是&#x2F;工程名</strong></p></li><li><p>获取<strong>工程部署后在服务器硬盘上的绝对路径</strong>( 比 如 :D:\hspedu_javaweb\servlet\out\artifacts\servlet_war_exploded)</p></li><li><p>像 Map 一样存取数据, 多个 Servlet 共享数据</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711093633773.png" alt="image-20230711093633773"></p><p>8.10.4 应用实例 </p><p>1-获取工程相关信息</p><p>● 需求如下：</p><ol><li>获取 web.xml 中配置的上下文参数 context-param</li><li>获取当前的工程路径， 格式: &#x2F;工程路径</li><li>获取工程部署后在服务器硬盘上的绝对路径</li></ol><p>● 代码实现 - 具体看 项目中的代码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">ServletConfig</span> <span class="variable">servletConfig</span> <span class="operator">=</span> getServletConfig();</span><br><span class="line">    System.out.println(servletConfig.getInitParameter(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">    System.out.println(servletConfig.getInitParameter(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;公共数据：&quot;</span> + servletConfig.getServletContext().getInitParameter(<span class="string">&quot;website&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;工程路径&quot;</span> + servletConfig.getServletContext().getContextPath());</span><br><span class="line">  <span class="comment">// “/”表示项目发布后的根目录(out目录中)</span></span><br><span class="line">    System.out.println(<span class="string">&quot;绝对路径&quot;</span> + servletConfig.getServletContext().getRealPath(<span class="string">&quot;/&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-10-5-应用实例-2-简单的网站访问次数计数器"><a href="#8-10-5-应用实例-2-简单的网站访问次数计数器" class="headerlink" title="8.10.5 应用实例 2-简单的网站访问次数计数器"></a>8.10.5 应用实例 2-简单的网站访问次数计数器</h3><p>……</p><h2 id="8-11-HttpServletRequest"><a href="#8-11-HttpServletRequest" class="headerlink" title="8.11 HttpServletRequest"></a>8.11 HttpServletRequest</h2><h3 id="8-11-1-HttpServletRequest-介绍"><a href="#8-11-1-HttpServletRequest-介绍" class="headerlink" title="8.11.1 HttpServletRequest 介绍"></a>8.11.1 HttpServletRequest 介绍</h3><p><strong><u>——http请求中的信息都被封装在HttpServletRequest中</u></strong></p><ol><li>HttpServletRequest 对象代表客户端的请求</li><li>当客户端&#x2F;浏览器通过 HTTP 协议访问服务器时，<strong>HTTP 请求头中的所有信息都封装在这个对象中</strong></li><li>通过这个对象的方法，可以获得客户端这些信息。</li></ol><h3 id="8-11-2-HttpServletRequest-类图"><a href="#8-11-2-HttpServletRequest-类图" class="headerlink" title="8.11.2 HttpServletRequest 类图"></a>8.11.2 HttpServletRequest 类图</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711102743263.png" alt="image-20230711102743263"></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711102808631.png" alt="image-20230711102808631" style="zoom:50%;" /><h3 id="8-11-3-HttpServletRequest-常用方法"><a href="#8-11-3-HttpServletRequest-常用方法" class="headerlink" title="8.11.3 HttpServletRequest 常用方法"></a>8.11.3 HttpServletRequest 常用方法</h3><ol><li><p>getRequestURI() 获取请求的<strong>资源路径</strong></p><p>即  <a href="http://localhost:8080/servlet/loginServlet%E4%B8%AD%E7%9A%84%E3%80%8Cservlet/loginServlet%E3%80%8D">http://localhost:8080/servlet/loginServlet中的「servlet/loginServlet」</a></p></li><li><p>getRequestURL() 获取请求的统一资源定位符 （ 绝 对 路 径 ）<a href="http://localhost:8080/servlet/loginServlet">http://localhost:8080/servlet/loginServlet</a></p></li><li><p>getRemoteHost() 获取客户端的主机, getRemoteAddr()</p></li><li><p>getHeader() 获取请求头                <strong>request.getHeader(“Cookie(例)”) 可以获取http请求头中的任意信息</strong></p></li><li><p>getParameter() 获取请求的参数</p></li><li><p>getParameterValues() 获取请求的参数（多个值的时候使用） , 比如 checkbox, 返回的数组</p><p><strong>可以获取前端表单传来的数据，根据键(前端标签中的name属性)获取值</strong></p></li><li><p>getMethod() 获取请求的方式 GET 或 POST</p></li><li><p>setAttribute(key, value); <strong>设置域数据</strong></p></li><li><p>getAttribute(key); <strong>获取域数据</strong></p></li><li><p>🌟getRequestDispatcher() <u><strong>获取请求转发对象, 请求转发的核心对象</strong></u></p></li></ol><h3 id="8-11-4-HttpServletRequest-应用实例"><a href="#8-11-4-HttpServletRequest-应用实例" class="headerlink" title="8.11.4 HttpServletRequest 应用实例"></a>8.11.4 HttpServletRequest 应用实例</h3><p>……</p><h3 id="8-11-5-HttpServletRequest-注意事项和细节"><a href="#8-11-5-HttpServletRequest-注意事项和细节" class="headerlink" title="8.11.5 HttpServletRequest 注意事项和细节"></a>8.11.5 HttpServletRequest 注意事项和细节</h3><ol><li>获 取 doPost 参数中文乱码解决方案 , 注 意 setCharacterEncoding(“utf-8”) 要 写 在request.getParameter()前(在接受参数前设置字体 )。</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711110015613.png" alt="image-20230711110015613" style="zoom:50%;" /><ol start="2"><li>注意：如果通过 PrintWriter writer, 有返回数据给浏览器，建议将<strong>获取参数代码写在writer.print() 之前</strong>，否则可能获取不到参数值(doPost)</li><li>处理 http <strong>响应数据中文乱码</strong>问题 (改变编码为utf-8)</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711110448507.png" alt="image-20230711110448507" style="zoom:50%;" /><ol start="4"><li>再次理解 Http 协议响应 Content-Type 的含义, 比如 text&#x2F;plain(以文本方式解析)    application&#x2F;x-tar(表示返回的是文件，浏览器会以下载文件的方式处理)</li></ol><h3 id="8-11-7-请求转发"><a href="#8-11-7-请求转发" class="headerlink" title="8.11.7 请求转发"></a>8.11.7 请求转发</h3><h4 id="8-11-7-1-为什么需要请求转发"><a href="#8-11-7-1-为什么需要请求转发" class="headerlink" title="8.11.7.1 为什么需要请求转发"></a>8.11.7.1 为什么需要请求转发</h4><ol><li>目前我们学习的都是一次请求， 对应一个 Servlet， 如图</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711111006356.png" alt="image-20230711111006356" style="zoom: 50%;" /><ol start="2"><li>但是在实际开发中，往往业务比较复杂，需要在一次请求中，<strong>使用到多个 Servlet 完成一个任务(Servlet 链, 流水作业)</strong> 如图:</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711111046853.png" alt="image-20230711111046853"></p><h4 id="8-11-7-2-请求转发说明"><a href="#8-11-7-2-请求转发说明" class="headerlink" title="8.11.7.2 请求转发说明"></a>8.11.7.2 请求转发说明</h4><ol><li><p>实现请求转发： 请求转发指一个 web 资源收到客户端请求后， 通知服务器去调用另外一个 web 资源进行处理</p></li><li><p>HttpServletRequest 对象(也叫 Request 对象)提供了一个 getRequestDispatcher 方法，该方法返回一个 RequestDispatcher 对象，<strong>调用这个对象的 forward 方法可以实现请求转发</strong></p></li><li><p>request 对象同时也是一个域对象，开发人员通过 request 对象在实现转发时，把数据通过 request 对象带给其它 web 资源处理</p><ul><li><p>setAttribute方法</p></li><li><p>getAttribute方法</p></li><li><p>removeAttribute方法</p></li><li><p>getAttributeNames方法</p></li></ul></li></ol><h4 id="8-11-7-3-实现请求转发"><a href="#8-11-7-3-实现请求转发" class="headerlink" title="8.11.7.3 实现请求转发"></a>8.11.7.3 实现请求转发</h4><p>请求转发原理示意图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711134908152.png" alt="image-20230711134908152"></p><h4 id="8-11-7-4-请求转发应用实例"><a href="#8-11-7-4-请求转发应用实例" class="headerlink" title="8.11.7.4 请求转发应用实例"></a>8.11.7.4 请求转发应用实例</h4><p>……</p><p>请求转发中，各个servlet可以共享request域对象的原因：</p><p>​因为请求转发的方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  “/manageServlet”为发送的对象(转发给谁)</span></span><br><span class="line"><span class="comment">//其中:“/” 会被解析成“/项目名” (前面一定是表示该服务器的http://工程名：端口)</span></span><br><span class="line"><span class="comment">//manageServlet为资源名</span></span><br><span class="line"><span class="comment">//🌟因此，请求转发是不能转发到外网的(只能在服务器主机内部进行转发)</span></span><br><span class="line"><span class="type">RequestDispatcher</span> <span class="variable">requestDispatcher</span> <span class="operator">=</span> request.getRequestDispatcher(<span class="string">&quot;/manageServlet&quot;</span>);</span><br><span class="line"><span class="comment">//而此处的request将被传给下一个servlet，所以可以共享request对象中的数据！！！！</span></span><br><span class="line">requestDispatcher.forward(request, response);</span><br></pre></td></tr></table></figure><h4 id="8-11-7-5-请求转发注意事项和细节"><a href="#8-11-7-5-请求转发注意事项和细节" class="headerlink" title="8.11.7.5 请求转发注意事项和细节"></a>8.11.7.5 请求转发注意事项和细节</h4><ol><li><p>🌟<strong>浏览器地址不会变化(地址会保留在第 1 个 servlet 的 url)</strong></p></li><li><p>在同一次 HTTP 请求中，进行多次转发，仍然是一次 HTTP 请求</p></li><li><p>在同一次 HTTP 请求中，进行多次转发，多个 Servlet 可以共享 request 域&#x2F;对象的数据(因为始终是同一个 request 对象)</p></li><li><p>可以转发到 WEB-INF 目录下(后面做项目使用)</p></li><li><p><strong>不能访问当前 WEB 工程外的资源</strong></p></li><li><p><u>因为浏览器地址栏会停止在第一个 servlet ,如果你刷新页面，会再次发出请求(并且会带数据), 所以在支付页面情况下，不要使用请求转发，否则会造成重复支付</u></p></li></ol><h3 id="8-11-8-课后作业"><a href="#8-11-8-课后作业" class="headerlink" title="8.11.8 课后作业"></a>8.11.8 课后作业</h3><p>……</p><h2 id="8-12-HttpServletResponse"><a href="#8-12-HttpServletResponse" class="headerlink" title="8.12 HttpServletResponse"></a>8.12 HttpServletResponse</h2><h3 id="8-12-1-HttpServletResponse-介绍"><a href="#8-12-1-HttpServletResponse-介绍" class="headerlink" title="8.12.1 HttpServletResponse 介绍"></a>8.12.1 HttpServletResponse 介绍</h3><ol><li><p>每次 HTTP 请求， Tomcat 会创建一个 HttpServletResponse 对象传递给 Servlet 程序去使用。</p></li><li><p><strong>HttpServletRequest 表示请求过来的信息</strong>，<strong>HttpServletResponse 表示所有<u>响应</u>的信息</strong>，如果<u>需要设置返回给客户端的信息</u>，通过 HttpServletResponse 对象来进行设置即可</p></li></ol><h3 id="8-12-2-HttpServletResponse-类图"><a href="#8-12-2-HttpServletResponse-类图" class="headerlink" title="8.12.2 HttpServletResponse 类图"></a>8.12.2 HttpServletResponse 类图</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711152642270.png" alt="image-20230711152642270"></p><h3 id="8-12-3-向客户端返回数据方法"><a href="#8-12-3-向客户端返回数据方法" class="headerlink" title="8.12.3 向客户端返回数据方法"></a>8.12.3 向客户端返回数据方法</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711152728428.png" alt="image-20230711152728428"></p><ol><li>字节流 getOutputStream(); <strong>常用于下载</strong>（处理二进制数据）</li><li>字符流 getWriter(); 常用于<strong>回传</strong>字符串</li><li>(细节：)两个流<strong>同时只能使用一个</strong>。 使用了字节流，就不能再使用字符流，反之亦然，否则就会报错</li></ol><h3 id="8-12-4-向客户端返回数据应用实例"><a href="#8-12-4-向客户端返回数据应用实例" class="headerlink" title="8.12.4 向客户端返回数据应用实例"></a>8.12.4 向客户端返回数据应用实例</h3><ol><li>需求： 浏览器请求 , 返回 hello, world</li></ol><p>……</p><h3 id="8-12-5-向客户端返回数据注意事项和细节"><a href="#8-12-5-向客户端返回数据注意事项和细节" class="headerlink" title="8.12.5 向客户端返回数据注意事项和细节"></a>8.12.5 向客户端返回数据注意事项和细节</h3><ol><li>处理中文乱码问题-方案 1</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711153139236.png" alt="image-20230711153139236" style="zoom:50%;" /><ol start="2"><li>处理中文乱码问题-方案 2(常用，方便)</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711153202800.png" alt="image-20230711153202800" style="zoom:50%;" /><h3 id="8-12-6-请求重定向"><a href="#8-12-6-请求重定向" class="headerlink" title="8.12.6 请求重定向"></a>8.12.6 请求重定向</h3><h4 id="8-12-6-1-请求重定向介绍"><a href="#8-12-6-1-请求重定向介绍" class="headerlink" title="8.12.6.1 请求重定向介绍"></a>8.12.6.1 请求重定向介绍</h4><ol><li><p>请求重定向指： 一个 web 资源收到客户端请求后， <u><strong>通知客户端去访问另外一个 web资源</strong></u>， 这称之为请求重定向</p></li><li><p>请求重定向原理示意图</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711153900776.png" alt="image-20230711153900776"></p><h4 id="8-12-6-2-请求重定向应用实例"><a href="#8-12-6-2-请求重定向应用实例" class="headerlink" title="8.12.6.2 请求重定向应用实例"></a>8.12.6.2 请求重定向应用实例</h4><ol><li>需 求 ： 演示请求重定向的使用当访问 DownServlet 下 载 文 件 ， 重定向到DownServletNew 下载文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. sendRedirect 本质就会 返回 302 状态码 Location: /servlet/downservletNew</span></span><br><span class="line"><span class="comment">//2．因此 302和/servlet/downservletNew 是浏览器解析，而不是服务器</span></span><br><span class="line"><span class="comment">//3．浏览器在解析 /servlet/downservletnew =&gt; http://localhost:8080/downServletNew</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1:</span></span><br><span class="line">response.sendRedirect(<span class="string">&quot;/servlet/downServletNew&quot;</span>);</span><br><span class="line"><span class="comment">//方法2:</span></span><br><span class="line">response.setStatus(<span class="number">302</span>);</span><br><span class="line">response.setHeader(<span class="string">&quot;Location&quot;</span>,<span class="string">&quot;/servlet/downServletNew&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="8-12-6-3-请求重定向注意事项和细节"><a href="#8-12-6-3-请求重定向注意事项和细节" class="headerlink" title="8.12.6.3 请求重定向注意事项和细节"></a>8.12.6.3 请求重定向注意事项和细节</h4><ol><li><p>最佳应用场景：网站迁移， 比如原域名是 <a href="http://www.hsp.com/">www.hsp.com</a> 迁移到 <a href="http://www.hsp.cn/">www.hsp.cn</a> ， 但是百度抓取的还是原来网址.</p></li><li><p>浏览器地址会发生变化，本质是两次 http 请求.</p></li><li><p><strong>不能共享 Request 域中的数据，本质是两次 http 请求，会生成两个 HttpServletRequest对象</strong></p></li><li><p><u>不能重定向到 &#x2F;WEB-INF 下的资源</u></p></li><li><p>可以重定向到 Web 工程以外的资源， 比如 到 <a href="http://www.baidu.com/">www.baidu.com</a> </p></li><li><p>重定向有两种方式, <strong>推荐使用第 1 种.</strong></p></li><li><p>动态获取到 application context(这个是指该项目在tomcat上运行时的项目名称，重定向时每次都需要填上，因此在修改时会比较麻烦，我们可以采取动态获取的方式简化它</p><p>使用方法：getServletContext().getContextPath()获取即可)</p></li></ol><h3 id="8-12-7-课后作业"><a href="#8-12-7-课后作业" class="headerlink" title="8.12.7 课后作业"></a>8.12.7 课后作业</h3><ol><li><p>编写一个 MyPayServlet , 能够接收到提交的数据</p></li><li><p>编写一个简单的支付页面 pay.html(如图)</p></li><li><p>如果支付金额大于 100, 则重定向到 payok.html, 否则重定向到原来的 pay.html</p></li></ol><p>​……</p><h1 id="10-手动实现-Tomcat-底层机制-自己设计-Servlet"><a href="#10-手动实现-Tomcat-底层机制-自己设计-Servlet" class="headerlink" title="10 手动实现 Tomcat 底层机制+ 自己设计 Servlet"></a>10 手动实现 Tomcat 底层机制+ 自己设计 Servlet</h1><h2 id="10-1-先看一个小案例，-引出对-Tomcat-底层实现思考"><a href="#10-1-先看一个小案例，-引出对-Tomcat-底层实现思考" class="headerlink" title="10.1 先看一个小案例， 引出对 Tomcat 底层实现思考"></a>10.1 先看一个小案例， 引出对 Tomcat 底层实现思考</h2><h3 id="10-1-1-完成小案例"><a href="#10-1-1-完成小案例" class="headerlink" title="10.1.1 完成小案例"></a>10.1.1 完成小案例</h3><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230712184414696.png" alt="image-20230712184414696" style="zoom:50%;" /><ol start="0"><li>我们准备使用 Maven 来创建一个 WEB 项目, 老师先简单给小伙伴介绍一下 Maven 是什么, 更加详细的使用，我们还会细讲, 现在先使用一把</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230712184444044.png" alt="image-20230712184444044" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230712184525975.png" alt="image-20230712184525975" style="zoom:67%;" /><ol><li>先创建一个 Maven 的 Web 项目 hsp-tomcat</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230712185354190.png" alt="image-20230712185354190" style="zoom:50%;" /><ul><li>配置阿里 maven 镜像</li></ul><p>​在maven的settings.xml文件中修改mirror标签中的内容即可</p><ol start="2"><li>修改 D:\java_projects2\hsp\pom.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.donn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mytomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>mytomcat Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--1.引入javax.servlet-api.jar，为了开发servlet</span></span><br><span class="line"><span class="comment">          2.&lt;dependency&gt;标签表示引入一个包</span></span><br><span class="line"><span class="comment">          3.groudId：包的公司信息：javax.servlet</span></span><br><span class="line"><span class="comment">          4.artifactId：项目名：javax.servlet-api</span></span><br><span class="line"><span class="comment">            groupId+artifactId 将以目录形式体现(在仓库中组成jar包路径</span></span><br><span class="line"><span class="comment">          5.version：版本信息</span></span><br><span class="line"><span class="comment">          6.scope：表示引入包的作用范围</span></span><br><span class="line"><span class="comment">            在什么地方、在什么阶段生效</span></span><br><span class="line"><span class="comment">            &lt;scope&gt;provided&lt;/scope&gt; 表示tomcat本身有jar包，</span></span><br><span class="line"><span class="comment">            在编译、测试时有效，但是打包发布后不要带上这个包</span></span><br><span class="line"><span class="comment">            (意思就是打包时，项目会有自带的该jar包，</span></span><br><span class="line"><span class="comment">            但是编译、测试时没有，provided指只在编译测试时添加该jar包)</span></span><br><span class="line"><span class="comment">          7.下载的包在指定的本地仓库</span></span><br><span class="line"><span class="comment">          --&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>mytomcat<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>创建 D:\java_projects2\hsp\src\main\webapp\cal.html</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>计算器<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>计算器<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/calServlet&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    num1:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;num1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    num2:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;num2&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li><p>创建 java 目录，存放 java 源文件.</p></li><li><p>创建 CalServlet.java</p></li><li><p>修改 web.xml , 配置 Servlet</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">web-app</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>CalServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.donn.servlet.CalServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>CalServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/calServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="7"><li>修改CalServlet.java, 完成计算任务</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.donn.servlet; <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/7/12</span></span><br><span class="line"><span class="comment"> * 22:27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.donn.utils.WebUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//接受提交的数据进行计算</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">num1</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;num1&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">num2</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;num2&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> WebUtils.parseInt(num1, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> WebUtils.parseInt(num2, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> i1 + i2;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        writer.print(<span class="string">&quot;&lt;h1&gt;&quot;</span> + i1 + <span class="string">&quot;+&quot;</span> + i2 + <span class="string">&quot;=&quot;</span> + res + <span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>创 建 工 具 类\utils\WebUtils.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.donn.utils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/7/12</span></span><br><span class="line"><span class="comment"> * 22:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个字符串数字，转成 int, 如果转换失败，就返回传入 defaultVal</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strNum</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> defaultVal</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">parseInt</span><span class="params">(String strNum, <span class="type">int</span> defaultVal)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(strNum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            System.out.println(strNum + <span class="string">&quot; 格式不对，转换失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> defaultVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-1-3-完成测试"><a href="#10-1-3-完成测试" class="headerlink" title="10.1.3 完成测试"></a>10.1.3 完成测试</h3><h4 id="10-1-3-1-配置-tomcat"><a href="#10-1-3-1-配置-tomcat" class="headerlink" title="10.1.3.1 配置 tomcat"></a>10.1.3.1 配置 tomcat</h4><h4 id="10-1-3-2-启动-tomcat"><a href="#10-1-3-2-启动-tomcat" class="headerlink" title="10.1.3.2 启动 tomcat"></a>10.1.3.2 启动 tomcat</h4><h4 id="10-1-3-3-浏览器访问-http-localhost-8080-cal-html"><a href="#10-1-3-3-浏览器访问-http-localhost-8080-cal-html" class="headerlink" title="10.1.3.3 浏览器访问: http://localhost:8080/cal.html"></a>10.1.3.3 浏览器访问: <a href="http://localhost:8080/cal.html">http://localhost:8080/cal.html</a></h4><h3 id="10-1-4-思考问题-Tomcat-底层实现-和-调用到-Servlet-流程"><a href="#10-1-4-思考问题-Tomcat-底层实现-和-调用到-Servlet-流程" class="headerlink" title="10.1.4 思考问题: Tomcat 底层实现 和 调用到 Servlet 流程?"></a>10.1.4 思考问题: Tomcat 底层实现 和 调用到 Servlet 流程?</h3><h3 id="10-1-5-我们的目标"><a href="#10-1-5-我们的目标" class="headerlink" title="10.1.5 我们的目标:"></a>10.1.5 我们的目标:</h3><p><u><strong>不用 Tomcat, 不用系统提供的 Servlet, 模拟 Tomcat 底层实现并能调用我们自己设计的 Servle, 也能完成相同的功能</strong></u></p><h2 id="10-2-🌟Tomcat-整体架构分析"><a href="#10-2-🌟Tomcat-整体架构分析" class="headerlink" title="10.2 🌟Tomcat 整体架构分析"></a>10.2 🌟Tomcat 整体架构分析</h2><h3 id="10-2-1-一图胜千言"><a href="#10-2-1-一图胜千言" class="headerlink" title="10.2.1 一图胜千言"></a>10.2.1 一图胜千言</h3><p>● 说明: Tomcat 有三种运行模式（BIO, NIO, APR） , 因为老师核心讲解的是 <strong>Tomcat 如何接收客户端请求， 解析请求, 调用 Servlet ,</strong> 并返回结果的机制流程, 采用 BIO 线程模型来模拟.[绘图]</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230713085315598.png" alt="image-20230713085315598"></p><h2 id="10-4-手动实现-Tomcat-底层机制-自己设计-Servlet"><a href="#10-4-手动实现-Tomcat-底层机制-自己设计-Servlet" class="headerlink" title="10.4 手动实现 Tomcat 底层机制+ 自己设计 Servlet"></a>10.4 手动实现 Tomcat 底层机制+ 自己设计 Servlet</h2><h3 id="10-4-1-实现任务阶段-1-编写自己-Tomcat-能给浏览器返回-Hi-Hspedu"><a href="#10-4-1-实现任务阶段-1-编写自己-Tomcat-能给浏览器返回-Hi-Hspedu" class="headerlink" title="10.4.1 实现任务阶段 1- 编写自己 Tomcat, 能给浏览器返回 Hi, Hspedu"></a>10.4.1 实现任务阶段 1- 编写自己 Tomcat, 能给浏览器返回 Hi, Hspedu</h3><h4 id="10-4-1-1-基于-socket-开发服务端-流程"><a href="#10-4-1-1-基于-socket-开发服务端-流程" class="headerlink" title="10.4.1.1 基于 socket 开发服务端-流程"></a>10.4.1.1 基于 socket 开发服务端-流程</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230713090001942.png" alt="image-20230713090001942" style="zoom:50%;" /><h4 id="10-4-1-2-需求分析"><a href="#10-4-1-2-需求分析" class="headerlink" title="10.4.1.2 需求分析"></a>10.4.1.2 需求分析</h4><ol><li>需求分析如图, 浏览器请求 <a href="http://localhost:8080/">http://localhost:8080/</a>??, 服务端返回 hi , donn</li></ol><h4 id="10-4-1-3-分析-代码实现"><a href="#10-4-1-3-分析-代码实现" class="headerlink" title="10.4.1.3 分析+代码实现"></a>10.4.1.3 分析+代码实现</h4><h4 id="●-分析示意图"><a href="#●-分析示意图" class="headerlink" title="● 分析示意图"></a>● 分析示意图</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230713093415805.png" alt="image-20230713093415805" style="zoom:50%;" /><p>● 代码实现</p><ol><li>创 建DonnTomcatV1.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.donn.tomcat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/7/13</span></span><br><span class="line"><span class="comment"> * 09:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 接受客户端请求，并返回相关信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DonnTomcatV1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8081</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;mytomcat在8081端口监听&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!serverSocket.isClosed())&#123;</span><br><span class="line">            <span class="comment">//等待浏览器的连接</span></span><br><span class="line">            <span class="comment">//如果有连接来，就创建一个socket</span></span><br><span class="line">            <span class="comment">//这个socket就是服务器和浏览器连接的通道</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="comment">//先接受浏览器发送的数据</span></span><br><span class="line">            <span class="comment">//inputStream是字节流 =BufferedReader为字符流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            <span class="type">String</span> <span class="variable">mes</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//循环地读取</span></span><br><span class="line">            System.out.println(<span class="string">&quot;接受到浏览器发送的数据&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (((mes = bufferedReader.readLine()) != <span class="literal">null</span>))&#123;</span><br><span class="line">                <span class="comment">//判断mes的长度是否为0</span></span><br><span class="line">                <span class="keyword">if</span>(mes.length() == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(mes);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//tomcat回送httpResponse</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="comment">//构建一个 http 响应的头</span></span><br><span class="line">            <span class="comment">// \r\n 表示换行</span></span><br><span class="line">            <span class="comment">// http 响应体，需要前面有两个换行 \r\n\r\n</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">respHeader</span> <span class="operator">=</span> <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;Content-Type: text/html;charset=utf-8\r\n\r\n&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">resp</span> <span class="operator">=</span> respHeader + <span class="string">&quot;hi, donn&quot;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;========我们的 tomcat 给浏览器会送的数据======&quot;</span>);</span><br><span class="line">            System.out.println(resp);</span><br><span class="line">            outputStream.write(resp.getBytes());</span><br><span class="line">            <span class="comment">//将 resp 字符串以 byte[] 方式返回</span></span><br><span class="line">            outputStream.flush();</span><br><span class="line">            outputStream.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-4-1-4-测试-浏览器-：-http-localhost-8081"><a href="#10-4-1-4-测试-浏览器-：-http-localhost-8081" class="headerlink" title="10.4.1.4 测试 浏览器 ： http://localhost:8081/"></a>10.4.1.4 测试 浏览器 ： <a href="http://localhost:8081/">http://localhost:8081/</a></h4><h4 id="10-4-1-5-问题分析：-没有使用-BIO-线程模型，-没有实现多线程，-性能差"><a href="#10-4-1-5-问题分析：-没有使用-BIO-线程模型，-没有实现多线程，-性能差" class="headerlink" title="10.4.1.5 问题分析： 没有使用 BIO 线程模型， 没有实现多线程， 性能差"></a>10.4.1.5 问题分析： 没有使用 BIO 线程模型， 没有实现多线程， 性能差</h4><h3 id="10-4-2-实现任务阶段-2-使用-BIO-线程模型，-支持多线程"><a href="#10-4-2-实现任务阶段-2-使用-BIO-线程模型，-支持多线程" class="headerlink" title="10.4.2 实现任务阶段 2__ 使用 BIO 线程模型， 支持多线程"></a>10.4.2 实现任务阶段 2__ 使用 BIO 线程模型， 支持多线程</h3><h4 id="10-4-2-1-BIO-线程模型介绍"><a href="#10-4-2-1-BIO-线程模型介绍" class="headerlink" title="10.4.2.1 BIO 线程模型介绍"></a>10.4.2.1 BIO 线程模型介绍</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230713093624025.png" alt="image-20230713093624025"></p><h4 id="10-4-2-2-需求分析-x2F-图解"><a href="#10-4-2-2-需求分析-x2F-图解" class="headerlink" title="10.4.2.2 需求分析&#x2F;图解"></a>10.4.2.2 需求分析&#x2F;图解</h4><ol><li>需求分析如图, 浏览器请求 <a href="http://localhost:8081/">http://localhost:8081</a>, 服务端返回 hi , donn, 后台donntomcat 使用 BIO 线程模型,支持多线程&#x3D;&gt; 对前面的开发模式进行改造</li></ol><h4 id="10-4-2-3-分析-代码实现"><a href="#10-4-2-3-分析-代码实现" class="headerlink" title="10.4.2.3 分析+代码实现"></a>10.4.2.3 分析+代码实现</h4><p>示意图：</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230713100725181.png" alt="image-20230713100725181" style="zoom:50%;" /><p>创建线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.donn.tomcat.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/7/13</span></span><br><span class="line"><span class="comment"> * 09:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * DonnRequestHandler对象是一个线程对象</span></span><br><span class="line"><span class="comment"> * 处理一个http请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DonnRequestHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DonnRequestHandler</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//在这里，我们对客户端进行交互</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="comment">//转换成字符流,方便按行读取</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;==donnTomcatV2接收到的数据如下==&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">mes</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//输出消息</span></span><br><span class="line">            <span class="keyword">while</span> (((mes = bufferedReader.readLine()) != <span class="literal">null</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(mes.length() == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(mes);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//构建http响应头</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">respHeader</span> <span class="operator">=</span> <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;Content-Type: text/html;charset=utf-8\r\n\r\n&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">resp</span> <span class="operator">=</span> respHeader + <span class="string">&quot;&lt;h1&gt;bye～ donn&lt;/h1&gt;&quot;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;V2返回的数据&quot;</span>);</span><br><span class="line">            <span class="comment">//返回数据给我们的浏览器 -&gt; 封装成http响应</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            outputStream.write(resp.getBytes());</span><br><span class="line">            outputStream.flush();</span><br><span class="line">            outputStream.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.donn.tomcat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.donn.tomcat.handler.DonnRequestHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/7/13</span></span><br><span class="line"><span class="comment"> * 09:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DonnTomcatV2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8081</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;myTomcatV2在8081端口监听&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!serverSocket.isClosed())&#123;</span><br><span class="line">            <span class="comment">//等待浏览器的连接</span></span><br><span class="line">            <span class="comment">//如果有连接来，就创建一个socket</span></span><br><span class="line">            <span class="comment">//这个socket就是服务器和浏览器连接的通道</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DonnRequestHandler</span>(socket)).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-4-2-5-问题分析：-HspTomcat-只是简单返回结果，-没有和-Servlet、-web-xml-关联"><a href="#10-4-2-5-问题分析：-HspTomcat-只是简单返回结果，-没有和-Servlet、-web-xml-关联" class="headerlink" title="10.4.2.5 问题分析： HspTomcat 只是简单返回结果， 没有和 Servlet、 web.xml 关联"></a>10.4.2.5 问题分析： HspTomcat 只是简单返回结果， 没有和 Servlet、 web.xml 关联</h4><h3 id="10-4-3-实现任务阶段-3-处理-Servlet"><a href="#10-4-3-实现任务阶段-3-处理-Servlet" class="headerlink" title="10.4.3 实现任务阶段 3- 处理 Servlet"></a>10.4.3 实现任务阶段 3- 处理 Servlet</h3><h4 id="10-4-3-1-Servlet-生命周期-回顾"><a href="#10-4-3-1-Servlet-生命周期-回顾" class="headerlink" title="10.4.3.1 Servlet 生命周期-回顾"></a>10.4.3.1 Servlet 生命周期-回顾</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230713101011930.png" alt="image-20230713101011930" style="zoom:50%;" /><h4 id="10-4-3-2-需求分析-x2F-图解"><a href="#10-4-3-2-需求分析-x2F-图解" class="headerlink" title="10.4.3.2 需求分析&#x2F;图解"></a>10.4.3.2 需求分析&#x2F;图解</h4><p>● 需求分析如图, 浏览器请求 <a href="http://localhost:8080/hspCalServlet">http://localhost:8080/hspCalServlet</a>, 提交数据， 完成计算任务， 如果 servlet 不存在， 返回 404</p><h4 id="10-4-3-3-分析-代码实现"><a href="#10-4-3-3-分析-代码实现" class="headerlink" title="10.4.3.3 分析+代码实现"></a>10.4.3.3 分析+代码实现</h4><p>● 分析示意图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230713101359727.png" alt="image-20230713101359727"></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230713101431086.png" alt="image-20230713101431086" style="zoom:50%;" /><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.donn.tomcat.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/7/13</span></span><br><span class="line"><span class="comment"> * 10:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 1. DonnRequest的作用是封装http请求的数据</span></span><br><span class="line"><span class="comment"> * 2. 比如method(GET)、uri(资源名)、参数列表(num1=10&amp;num2=30)</span></span><br><span class="line"><span class="comment"> * 3. DonnRequest的作用等价原生servlet中的HttpServletRequest</span></span><br><span class="line"><span class="comment"> * 4. 这里先只考虑get请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DonnRequest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这三个参数都存在于http请求中的第一行中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line">    <span class="keyword">private</span> String uri;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放参数列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String,String&gt; parametersMapping = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getParameter</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(parametersMapping.containsKey(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> parametersMapping.get(name);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     * inputStream与http请求的socket关联</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DonnRequest</span><span class="params">(InputStream inputStream)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            <span class="comment">//读取第一行</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">readLine</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">            method = readLine.split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> readLine.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>].indexOf(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (index == -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//说明没有参数列表</span></span><br><span class="line">                uri = readLine.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                uri = readLine.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>].substring(<span class="number">0</span>,index);</span><br><span class="line">                <span class="comment">//获取参数列表</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">parameters</span> <span class="operator">=</span> readLine.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>].substring(index + <span class="number">1</span>);</span><br><span class="line">                String[] parametersPair = parameters.split(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(parametersPair != <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (String parameter :parametersPair) &#123;</span><br><span class="line">                        String[] split = parameter.split(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span>(split.length == <span class="number">2</span>)&#123;</span><br><span class="line">                            parametersMapping.put(split[<span class="number">0</span>],split[<span class="number">1</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里不能关闭，inputStream和socket关联</span></span><br><span class="line"><span class="comment">//            inputStream.close();</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回顾-Tomcat-工作架构图"><a href="#回顾-Tomcat-工作架构图" class="headerlink" title="回顾 Tomcat 工作架构图"></a>回顾 Tomcat 工作架构图</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230713101359727.png" alt="image-20230713101359727"></p><h1 id="11-WEB-工程路径专题"><a href="#11-WEB-工程路径专题" class="headerlink" title="11 WEB 工程路径专题"></a>11 WEB 工程路径专题</h1><h2 id="11-3-WEB-工程路径注意事项和细节"><a href="#11-3-WEB-工程路径注意事项和细节" class="headerlink" title="11.3 WEB 工程路径注意事项和细节"></a>11.3 WEB 工程路径注意事项和细节</h2><h3 id="11-3-1-注意事项和细节说明"><a href="#11-3-1-注意事项和细节说明" class="headerlink" title="11.3.1 注意事项和细节说明"></a>11.3.1 注意事项和细节说明</h3><ol><li>Web 工程的相对路径和绝对路径：</li></ol><p>相对路径：</p><p>● .表示当前目录</p><p>● ..表示上一级目录</p><p>● 资源名 表示当前目录的资源名</p><p>绝对路径： <a href="http://ip:port/工程路径/资源路径">http://ip:port/工程路径/资源路径</a></p><ol start="2"><li><p>在实际开发中， 路径都使用绝对路径， 而不是相对路径</p></li><li><p>在 web 中 &#x2F; 斜杠 如果被浏览器解析， 得到的地址是： <strong><a href="http://ip[域名]:port/">http://ip[域名]:port/</a></strong></p><p>比如:  &lt;ahref&#x3D;”&#x2F;“&gt;斜杠</a></p></li><li><p>在 web 中 &#x2F; 斜杠如果被服务器解析，得到的地址是: **<a href="http://ip[域名]:port/工程路径/**，你也可以理解成">http://ip[域名]:port/工程路径/**，你也可以理解成</a> &#x2F;工程路径&#x2F; </p><p>下面的几种情况就是如此:</p></li></ol><p>​● <url-pattern>&#x2F;servelturl</url-pattern></p><p>​● servletContext.getRealPath(“&#x2F;“); &#x3D;&#x3D;&gt; 是得到执行路径&#x2F;工作路径</p><p>​● request.getRequestDispatcher(“&#x2F;“);</p><ol start="5"><li><p>在 javaWeb 中 路径<u><strong>最后</strong></u>带 &#x2F; 和不带 &#x2F; 含义不同, 一定要小心,比如</p><p> &lt; a href&#x3D;”&#x2F;a&#x2F;servlet03”&gt;网址</a> 中的<strong>servlet03 表示资源</strong></p><p>&lt; a href&#x3D;”&#x2F;a&#x2F;servlet03&#x2F;“&gt;网址</a> 中的<strong>servlet03 表示路径</strong></p></li><li><p>🌟特别说明： 重定向 response.sendRediect(“&#x2F;“); 这条语句虽然是在服务器执行的， 但是,服务器是把斜杠 &#x2F; 发送给浏览器解析。 因此得到地址 <a href="http://ip[域名]:port/">http://ip[域名]:port/</a></p></li></ol><p><strong>小结</strong>： 在<strong>编写资源路径时</strong> , 考虑这么几点</p><p>(1) 这个路径前面有没有 &#x2F;</p><p>(2) <strong>这个路径在哪里被解析</strong> [服务器还是浏览器] , 如果前面有 &#x2F; , 并且是在 浏览器被解析的 被解析成 <a href="http://ip:port/">http://ip:port/</a> , 如果在服务器端被解析 , 被解析成 &#x2F;工程路径&#x2F;</p><p>(3) 如果这个路径， 前面没有 &#x2F; , 并且在浏览器被解析， 则以浏览器当前的地址栏 去掉资源部分， 作为一个相对路径，再拼接这条路径.</p><p>(4) 这个路径， 最后有没有 &#x2F; , 如果最后有&#x2F; 表示路径， 如果没有 &#x2F; 表示资源</p><h1 id="12-Web-开发会话技术-Cookie-amp-Session"><a href="#12-Web-开发会话技术-Cookie-amp-Session" class="headerlink" title="12 Web 开发会话技术 Cookie&amp;Session"></a>12 Web 开发会话技术 Cookie&amp;Session</h1><h2 id="12-1-会话"><a href="#12-1-会话" class="headerlink" title="12.1 会话"></a>12.1 会话</h2><h3 id="12-1-1-基本介绍"><a href="#12-1-1-基本介绍" class="headerlink" title="12.1.1 基本介绍"></a>12.1.1 基本介绍</h3><ol><li><p>什么是会话？</p><p>​会话可简单理解为：<u>用户开一个浏览器，点击多个超链接，访问服务器多个 web 资源，然后关闭浏览器</u>，整个过程称之为一个会话。</p></li><li><p>会话过程中要解决的一些问题？</p><p>每个用户在使用浏览器与服务器进行会话的过程中，不可避免各自会产生一些数据，服务器要想办法为每个用户保存这些数据</p><p>例如：多个用户点击超链接通过一个 servlet 各自购买了一个商品，服务器应该想办法把每一个用户购买的商品保存在各自的地方，以便于这些用户点结帐 servlet 时，结帐servlet 可以得到用户各自购买的商品为用户结帐</p></li></ol><h3 id="12-1-2-会话的两种技术"><a href="#12-1-2-会话的两种技术" class="headerlink" title="12.1.2 会话的两种技术"></a>12.1.2 会话的两种技术</h3><h4 id="12-1-2-1-Session"><a href="#12-1-2-1-Session" class="headerlink" title="12.1.2.1 Session"></a>12.1.2.1 Session</h4><h4 id="12-1-2-2-Cookie"><a href="#12-1-2-2-Cookie" class="headerlink" title="12.1.2.2 Cookie"></a>12.1.2.2 Cookie</h4><h2 id="12-2-Cookie-有什么用"><a href="#12-2-Cookie-有什么用" class="headerlink" title="12.2 Cookie 有什么用"></a>12.2 Cookie 有什么用</h2><p>思考问题 1-抛砖引玉☞</p><p>​大家在访问某个网站的时候，是否能看到提示你上次登录网站的时间,而且要注意的是不同用户上次登录的时间肯定是不一样的，这是怎么实现的?</p><p>思考问题 2-抛砖引玉☞</p><p>​大家在访问某个购物网站的时候，是否能看到提示你曾经浏览过的商品，不同用户浏览过的商品肯定不一样，这是怎么实现的?</p><p>解决之道—cookie 技术</p><p>​Cookie(小甜饼)是客户端技术，<strong>服务器把每个用户的数据以 cookie 的形式写给用户各自的浏览器</strong>。当用户使用浏览器再去访问服务器中的 web 资源时，就会带着各自的数据去。这样，web 资源处理的就是用户各自的数据了。【简单示意图】</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230713193537687.png" alt="image-20230713193537687"></p><h2 id="12-3-cookie-介绍"><a href="#12-3-cookie-介绍" class="headerlink" title="12.3 cookie 介绍"></a>12.3 cookie 介绍</h2><h3 id="12-3-1-二说-cookie"><a href="#12-3-1-二说-cookie" class="headerlink" title="12.3.1 二说 cookie"></a>12.3.1 二说 cookie</h3><ol><li>Cookie 是服务器在客户端保存用户的信息， 比如登录名， 浏览历史等, 就可以以 cookie方式保存.</li><li>Cookie 信息就像是小甜饼(cookie 中文)一样，数据量并不大，服务器端在需要的时候可以从客户端&#x2F;浏览器读取(http 协议)，可以通过图来理解</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230713193754793.png" alt="image-20230713193754793" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230713194449881.png" alt="image-20230713194449881" style="zoom:50%;" /><ol start="3"><li>再次说明: <strong>cookie 数据是保存在浏览器的</strong></li></ol><h3 id="12-3-2-cookie-可以用来做啥"><a href="#12-3-2-cookie-可以用来做啥" class="headerlink" title="12.3.2 cookie 可以用来做啥"></a>12.3.2 cookie 可以用来做啥</h3><ol><li><p>保存上次登录时间等信息</p></li><li><p>保存用户名，密码, 在一定时间不用重新登录</p></li><li><p>网站的个性化，比如定制网站的服务，内容</p></li></ol><h2 id="12-4-cookie-基本使用"><a href="#12-4-cookie-基本使用" class="headerlink" title="12.4 cookie 基本使用"></a>12.4 cookie 基本使用</h2><h3 id="12-4-1-文档：-java-ee-api-中英文对照版-chm"><a href="#12-4-1-文档：-java-ee-api-中英文对照版-chm" class="headerlink" title="12.4.1 文档： java_ee_api_中英文对照版.chm"></a>12.4.1 文档： java_ee_api_中英文对照版.chm</h3><h3 id="12-4-2-cookie-常用方法"><a href="#12-4-2-cookie-常用方法" class="headerlink" title="12.4.2 cookie 常用方法"></a>12.4.2 cookie 常用方法</h3><ol><li><p>Cookie 有点象一张表(K-V)， 分两列， 一个是名字， 一个是值， 数据类型都是 String </p></li><li><p>如何创建一个 Cookie(在服务端创建的)</p></li></ol><p>​Cookie c&#x3D;new Cookie(String name,String val);    c.setMaxAge();&#x2F;&#x2F;保存时间</p><ol start="3"><li><p>如何将一个 Cookie 添加到客户端</p><p>response.addCookie(c);</p></li><li><p>如何读取 cookie(在服务器端读取到 cookie 信息)</p><p>request.getCookies();</p></li></ol><h2 id="12-7-cookie-生命周期"><a href="#12-7-cookie-生命周期" class="headerlink" title="12.7 cookie 生命周期"></a>12.7 cookie 生命周期</h2><h3 id="12-7-1-介绍"><a href="#12-7-1-介绍" class="headerlink" title="12.7.1 介绍"></a>12.7.1 介绍</h3><ol><li>Cookie 的生命周期指的是如何管理 Cookie 什么时候被销毁（删除）</li><li>setMaxAge()</li></ol><p>​● 正数，表示在指定的秒数后过期  <strong>过期后，浏览器不会删除该cookie，只是不再携带该cookie</strong></p><p>​● 负数，表示浏览器关闭， Cookie 就会被删除（默认值是-1）</p><p>​● 0， 表示马上删除 Cookie<strong>设置为0后，浏览器会把该cookie直接删除</strong></p><h2 id="12-8-cookie-有效路径"><a href="#12-8-cookie-有效路径" class="headerlink" title="12.8 cookie 有效路径"></a>12.8 cookie 有效路径</h2><h3 id="12-8-1-有效路径规则"><a href="#12-8-1-有效路径规则" class="headerlink" title="12.8.1 有效路径规则"></a>12.8.1 有效路径规则</h3><ol><li>Cookie 有效路径 Path 的设置</li><li>Cookie 的 path 属性可以有效的<strong>过滤哪些 Cookie 可以发送给服务器，哪些不发</strong>。 path属性是通过请求的地址来进行有效的过滤</li><li>规则如下:</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230714164006880.png" alt="image-20230714164006880" style="zoom: 67%;" /><p><strong>没设置默认为项目工程路径</strong></p><h2 id="12-10-Cookie-注意事项和细节"><a href="#12-10-Cookie-注意事项和细节" class="headerlink" title="12.10 Cookie 注意事项和细节"></a>12.10 Cookie 注意事项和细节</h2><ol><li>一个 Cookie 只能标识一种信息， 它至少含有一个标识该信息的名称（NAME） 和设置值（VALUE） 。</li><li><strong>一个 WEB 站点可以给一个浏览器发送多个 Cookie，一个浏览器也可以存储多个 WEB 站点提供的 Cookie。</strong></li><li>cookie 的总数量没有限制，但是每个域名的 COOKIE 数量和每个 COOKIE 的大小是有限制的 (不同的浏览器限制不同, 知道即可) , <strong>Cookie 不适合存放数据量大的信息</strong>。</li><li>注意，删除 cookie 时，path 必须一致，否则不会删除</li><li>Java servlet 中 cookie <strong>中文乱码</strong>解决</li></ol><p>​如果存放中文的 cookie, 默认报错, <u>可以通过 URL 编码和解码来解决</u>, <strong>不建议存放中文的 cookie 信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过将中文转化成utf-8形式的String，便可以将转化的结果放入cookie中了</span></span><br><span class="line"><span class="type">String</span> <span class="variable">urlName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;韩顺平教育&quot;</span>, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是这样的话，在获取cookie中信息时，我们对读出的cookie数据进行解码，从而转换成中文</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="comment">//处理的中文乱码问题</span></span><br><span class="line"><span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">  writer.println( cookie.getName()+ URLDecoder.decode(cookie.getValue(),<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-11-session-有什么用"><a href="#12-11-session-有什么用" class="headerlink" title="12.11 session 有什么用"></a>12.11 session 有什么用</h2><p>思考两个问题—抛砖引玉</p><ol><li>不同的用户登录网站后，不管该用户浏览该网站的哪个页面，都可显示登录人的名字，还可以随时去查看自己的购物车中的商品, 是如何实现的?</li><li>也就是说，一个用户在浏览网站不同页面时，服务器是如何知道是张三在浏览这个页面，还是李四在浏览这个页面?</li></ol><ul><li>方案1  :  可以把每个用户的信息都存到服务器的一个数据库中，再用一个‘🔑’来确定哪个用户对应db中的哪条记录</li><li>方案2  :  也可以将用户信息直接保存到cookie中，但是当切换用户后cookie内容不变，不安全；而且cookie作为传输的数据容易泄露，不便于传输敏感信息</li></ul><p>解决之道—session 技术</p><ol><li><p>Session 是服务器端技术，服务器在运行时为每一个用户的浏览器创建一个其独享的session 对象&#x2F;集合( 其实相当于前面说的方案1 )</p></li><li><p>由于 session 为各个用户浏览器独享，所以用户在访问服务器的不同页面时，可以从各自的 session 中读取&#x2F;添加数据, 从而完成相应任务</p></li></ol><h2 id="12-12-session-基本原理"><a href="#12-12-session-基本原理" class="headerlink" title="12.12 session 基本原理"></a>12.12 session 基本原理</h2><h3 id="12-12-1-Sesson-原理示意图"><a href="#12-12-1-Sesson-原理示意图" class="headerlink" title="12.12.1 Sesson 原理示意图"></a>12.12.1 Sesson 原理示意图</h3><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230714220951863.png" alt="image-20230714220951863" style="zoom:50%;" /><ol><li>当用户打开浏览器，访问某个网站, 操作 session 时，服务器就会在内存(在服务端)为该浏览器分配一个 session 对象，该 session 对象被这个浏览器独占, 如图⬆️</li><li>这个 session 对象也可看做是一个容器&#x2F;集合,session 对象默认存在时间为 30min(这是在tomcat&#x2F;conf&#x2F;web.xml)，也可修改</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230714221054233.png" alt="image-20230714221054233" style="zoom: 50%;" /><h3 id="12-12-2-Session-可以做什么"><a href="#12-12-2-Session-可以做什么" class="headerlink" title="12.12.2 Session 可以做什么"></a>12.12.2 Session 可以做什么</h3><ol><li>网上商城中的购物车</li><li>保存登录用户的信息</li><li>将数据放入到 Session 中， 供用户在访问不同页面时， 实现跨页面访问数据</li><li>防止用户非法登录到某个页面</li><li>…..</li></ol><h3 id="12-12-3-如何理解-Session"><a href="#12-12-3-如何理解-Session" class="headerlink" title="12.12.3 如何理解 Session"></a>12.12.3 如何理解 Session</h3><ol><li>session 存储结构示意图</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230714221456503.png" alt="image-20230714221456503" style="zoom: 50%;" /><ol start="2"><li>你可以把 session 看作是一容器类似 HashMap，有两列(K-V)，每一行就是 session 的一个属性。</li><li>每个属性包含有两个部分，一个是该属性的名字(String)，另外一个是它的值(Object)</li></ol><h2 id="12-13-session-常用方法"><a href="#12-13-session-常用方法" class="headerlink" title="12.13 session 常用方法"></a>12.13 session 常用方法</h2><h3 id="12-13-1-网上去找文档"><a href="#12-13-1-网上去找文档" class="headerlink" title="12.13.1 网上去找文档"></a>12.13.1 网上去找文档</h3><h4 id="12-13-2-Session-的基本使用"><a href="#12-13-2-Session-的基本使用" class="headerlink" title="12.13.2 Session 的基本使用"></a>12.13.2 Session 的基本使用</h4><ol><li><p><strong>创建</strong>&#x2F;<strong>获取</strong> Session， API 一样</p><ul><li>HttpSession session &#x3D; request.<strong>getSession();</strong></li><li><u>第 1 次调用是创建 Session 会话， 之后调用是获取创建好的 Session 对象</u></li></ul></li><li><p>向 session 添加属性session.setAttribute(String name,Object val);</p></li><li><p>从 session 得到某个属性Object obj&#x3D;session.getAttribute(String name);</p></li><li><p>从 session 删除调某个属性:</p><ul><li>hs.removeAttribute(String name);</li></ul></li><li><p>isNew(); 判断是不是刚创建出来的 Session</p></li><li><p>每个 Session 都有 1 个唯一标识 Id 值。 通过 getId() 得到 Session 的会话 id 值，<br><strong>即cookie中的JSESSIONID</strong></p></li></ol><h2 id="12-14-session-底层实现机制"><a href="#12-14-session-底层实现机制" class="headerlink" title="12.14 session 底层实现机制"></a>12.14 session 底层实现机制</h2><h3 id="12-14-1-原理分析图-一图胜千言"><a href="#12-14-1-原理分析图-一图胜千言" class="headerlink" title="12.14.1 原理分析图(一图胜千言)"></a>12.14.1 原理分析图(一图胜千言)</h3><p>● session 底层实现机制图解(重要)</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230714222324161.png" alt="image-20230714222324161" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230714222400458.png" alt="image-20230714222400458" style="zoom:60%;" /><p><strong>如果在本次会话中，服务器为浏览器创建了session空间(说明产生了一组新的「sessionId + session体」的结构出现)，那么服务器会让浏览器将set sessionid信息放入cookie中</strong></p><h3 id="12-14-3-Session-实现原理动画"><a href="#12-14-3-Session-实现原理动画" class="headerlink" title="12.14.3 Session 实现原理动画"></a>12.14.3 Session 实现原理动画</h3><p>● 服务器是如何实现一个 session 为一个用户浏览器服务的</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230715092237931.png" alt="image-20230715092237931" style="zoom:50%;" /><h2 id="12-15-session-生命周期"><a href="#12-15-session-生命周期" class="headerlink" title="12.15 session 生命周期"></a>12.15 session 生命周期</h2><h3 id="12-15-1-Session-生命周期-说明"><a href="#12-15-1-Session-生命周期-说明" class="headerlink" title="12.15.1 Session 生命周期-说明"></a>12.15.1 Session 生命周期-说明</h3><ol><li><p>public void <strong>setMaxInactiveInterval</strong>(int interval) 设置 Session 的超时时间（以<strong>秒</strong>为单位） ，超过指定的时长， Session 就会被销毁。</p></li><li><p>值为正数的时候，设定 Session 的超时时长。</p></li><li><p><strong>负数表示永不超时</strong></p></li><li><p>public int **getMaxInactiveInterval()**获取 Session 的超时时间</p></li><li><p>public void <strong>invalidate() 让当前 Session 会话立即无效</strong></p></li><li><p>如果没有调用 setMaxInactiveInterval() 来指定 Session 的生命时长，Tomcat 会以 Session默认时长为准，<strong>Session 默认的超时为 30 分钟</strong>， 可以在 <strong>tomcat 的 web.xml 设置</strong></p></li><li><p>Session 的生命周期指的是 ：客户端&#x2F;浏览器<strong>两次请求最大间隔时长</strong>，而不是累积时长。**<u>即当客户端访问了自己的 session，session 的生命周期将从 0 开始重新计算。</u>**(解读: 指的是同一个会话两次请求之间的间隔时间)</p></li><li><p>🌟底层: <strong>Tomcat 用一个线程来轮询会话状态，如果某个会话的空闲时间超过设定的最大值，则将该会话销毁</strong></p></li></ol><h1 id="14-JavaWeb-三大组件之监听器-Listener"><a href="#14-JavaWeb-三大组件之监听器-Listener" class="headerlink" title="14 JavaWeb 三大组件之监听器 Listener"></a>14 JavaWeb 三大组件之监听器 Listener</h1><h2 id="14-1-官方文档"><a href="#14-1-官方文档" class="headerlink" title="14.1 官方文档"></a>14.1 官方文档</h2><h3 id="14-1-1-文档……"><a href="#14-1-1-文档……" class="headerlink" title="14.1.1 文档……"></a>14.1.1 文档……</h3><h2 id="14-2-Listener-监听器介绍"><a href="#14-2-Listener-监听器介绍" class="headerlink" title="14.2 Listener 监听器介绍"></a>14.2 Listener 监听器介绍</h2><ol><li><p>Listener 监听器它是 JavaWeb 的三大组件之一。 JavaWeb 的三大组件分别是： Servlet 程序、 Listener 监听器、 Filter 过滤器</p></li><li><p>Listener 是 JavaEE 的规范，就是接口</p></li><li><p><strong>监听器的作用是，监听某种变化(一般就是<u>对象创建&#x2F;销毁, 属性变化</u>), 触发对应方法完成相应的任务</strong></p></li><li><p>JavaWeb 中的监听器（共八个）, 目前最常用的是 <strong>ServletContextListener</strong></p></li></ol><h2 id="14-3-JavaWeb-的监听器"><a href="#14-3-JavaWeb-的监听器" class="headerlink" title="14.3 JavaWeb 的监听器"></a>14.3 JavaWeb 的监听器</h2><h3 id="14-3-1-ServletContextListener-监听器"><a href="#14-3-1-ServletContextListener-监听器" class="headerlink" title="14.3.1 ServletContextListener 监听器"></a>14.3.1 ServletContextListener 监听器</h3><ol><li><p>作用： 🌟<strong>监听 ServletContext 创建或销毁</strong>(当我们 <strong>Web 应用启动时， 就会创建 ServletContext</strong>)，即生命周期监听， 应用场景</p><ol><li>加载初始化的配置文件； 比如 spring 的配置文件</li><li>任务调度（配合定时器 Timer&#x2F;TimerTask)</li></ol></li><li><p>相关方法</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> <span class="comment">//创建 Servletcontext 时触发 </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> <span class="comment">//销毁 Servletcontext 时触发</span></span><br></pre></td></tr></table></figure><ol start="3"><li>应 用 实 例 创 建  MyServletContextListener.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServletContextListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent servletContextEvent&#123;</span></span><br><span class="line"><span class="params">  System.out.println(<span class="string">&quot;ServletContext 创建，完成 WEB 项目初始化的工作..&quot;</span>)</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent servletContextEvent)</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;ServletContext 销毁, 完成资源回收工作..&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>在 web.xml 配置 MyServletContextListener</li></ol><h3 id="14-3-2-ServletContextAttributeListener-监听器"><a href="#14-3-2-ServletContextAttributeListener-监听器" class="headerlink" title="14.3.2 ServletContextAttributeListener 监听器"></a>14.3.2 ServletContextAttributeListener 监听器</h3><ol><li>作用： 🌟<strong>监听 ServletContext 属性变化</strong></li><li>相关方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">attributeAdded</span><span class="params">(ServletContextAttributeEvent event)</span> <span class="comment">//添加属性时调用</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">attributeReplaced</span><span class="params">(ServletContextAttributeEvent event)</span> <span class="comment">//替换属性时调用</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">attributeRemoved</span><span class="params">(ServletContextAttributeEvent event)</span> <span class="comment">//移除属性时调用</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>使用少</strong>,再给大家举个例(后面的监听器类似)</li></ol><p>创 建MyServletContextAttributeListener.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServletContextAttributeListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextAttributeListener</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeAdded</span><span class="params">(ServletContextAttributeEvent servletContextAttributeEvent)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;添加了 servletContext 属性名= &quot;</span>+servletContextAttributeEvent.getName() + <span class="string">&quot; 属 性 值 =&quot;</span> +servletContextAttributeEvent.getValue());</span><br><span class="line">&#125; </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeRemoved</span><span class="params">(ServletContextAttributeEvent servletContextAttributeEvent)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;删除了 servletContext 属性&quot;</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeReplaced</span><span class="params">(ServletContextAttributeEvent servletContextAttributeEvent)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;替换了 servletContext 属性 &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-3-3-其它监听器-使用较少"><a href="#14-3-3-其它监听器-使用较少" class="headerlink" title="14.3.3 其它监听器-使用较少"></a>14.3.3 其它监听器-使用较少</h3><h4 id="14-3-3-1-HttpSessionListener-监听器"><a href="#14-3-3-1-HttpSessionListener-监听器" class="headerlink" title="14.3.3.1 HttpSessionListener 监听器"></a>14.3.3.1 HttpSessionListener 监听器</h4><ol><li>作用： 🌟<strong>监听 Session <u>创建或销毁</u>， 即生命周期监听</strong></li><li>相关方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sessionCreated</span><span class="params">(HttpSessionEvent se)</span>  <span class="comment">//创建 session 时调用 </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sessionDestroyed</span><span class="params">(HttpSessionEvent se)</span><span class="comment">//销毁 session 时调用</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用方法和前面一样, <strong><u>可以用于监控用户上线，离线</u></strong></li></ol><h4 id="14-3-3-2-HttpSessionAttributeListener-监听器"><a href="#14-3-3-2-HttpSessionAttributeListener-监听器" class="headerlink" title="14.3.3.2 HttpSessionAttributeListener 监听器"></a>14.3.3.2 HttpSessionAttributeListener 监听器</h4><ol><li>作用： 🌟<strong>监听 Session <u>属性的变化</u></strong></li><li>相关方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">attributeAdded</span><span class="params">(ServletRequestAttributeEvent srae)</span> <span class="comment">//添加属性时</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">attributeReplaced</span><span class="params">(ServletRequestAttributeEvent srae)</span> <span class="comment">//替换属性时</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">attributeRemoved</span><span class="params">(ServletRequestAttributeEvent srae)</span> <span class="comment">//移除属性时</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用少 ， 使用方法和前面一样。</li></ol><h4 id="14-3-3-3-ServletRequestListener-监听器"><a href="#14-3-3-3-ServletRequestListener-监听器" class="headerlink" title="14.3.3.3 ServletRequestListener 监听器"></a>14.3.3.3 ServletRequestListener 监听器</h4><ol><li><p>ServletRequestListener 监听器</p></li><li><p>作用：<strong>监听 Request 创建或销毁，即 Request 生命周期监听</strong></p></li><li><p>🌟<strong>可以用来监控, 某个 IP 访问我们网站的频率, 日志记录 ,访问资源的情况</strong></p></li></ol><h4 id="14-3-3-4-ServletRequestAttributeListener-监听器"><a href="#14-3-3-4-ServletRequestAttributeListener-监听器" class="headerlink" title="14.3.3.4 ServletRequestAttributeListener 监听器"></a>14.3.3.4 ServletRequestAttributeListener 监听器</h4><ol><li>作用： 监听 Request 属性变化</li></ol><p>……</p><h4 id="14-3-3-5-HttpSessionBindingListener-感知监听器"><a href="#14-3-3-5-HttpSessionBindingListener-感知监听器" class="headerlink" title="14.3.3.5 HttpSessionBindingListener 感知监听器"></a>14.3.3.5 HttpSessionBindingListener 感知监听器</h4><p>……</p><h4 id="14-3-3-6-HttpSessionActivationListener-感知监听器"><a href="#14-3-3-6-HttpSessionActivationListener-感知监听器" class="headerlink" title="14.3.3.6 HttpSessionActivationListener 感知监听器"></a>14.3.3.6 HttpSessionActivationListener 感知监听器</h4><p>……</p><h1 id="15-JavaWeb-三大组件之-过滤器-Filter"><a href="#15-JavaWeb-三大组件之-过滤器-Filter" class="headerlink" title="15 JavaWeb 三大组件之 过滤器 Filter"></a>15 JavaWeb 三大组件之 过滤器 Filter</h1><h2 id="15-1-官方文档"><a href="#15-1-官方文档" class="headerlink" title="15.1 官方文档"></a>15.1 官方文档</h2><h3 id="15-1-1-文档：-……"><a href="#15-1-1-文档：-……" class="headerlink" title="15.1.1 文档： ……"></a>15.1.1 文档： ……</h3><h2 id="15-2-Filter-过滤器说明"><a href="#15-2-Filter-过滤器说明" class="headerlink" title="15.2 Filter 过滤器说明"></a>15.2 Filter 过滤器说明</h2><h3 id="15-2-1-为啥要过滤器-需求示意图"><a href="#15-2-1-为啥要过滤器-需求示意图" class="headerlink" title="15.2.1 为啥要过滤器-需求示意图"></a>15.2.1 为啥要过滤器-需求示意图</h3><p>● 一图胜千言 </p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230715181935717.png" alt="image-20230715181935717"></p><h3 id="15-2-2-过滤器介绍"><a href="#15-2-2-过滤器介绍" class="headerlink" title="15.2.2 过滤器介绍"></a>15.2.2 过滤器介绍</h3><ol><li>Filter 过滤器它是 JavaWeb 的三大组件之一(Servlet 程序、 Listener 监听器、 Filter 过滤器)</li><li>Filter 过滤器是 JavaEE 的规范，是接口<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230715182105900.png" alt="image-20230715182105900" style="zoom: 50%;" /></li><li>Filter 过滤器它的作用是：拦截请求，过滤响应。</li><li>应用场景</li></ol><ul><li>权限检查</li><li>日志操作</li><li>事务管理</li></ul><h2 id="15-3-Filter-过滤器基本原理"><a href="#15-3-Filter-过滤器基本原理" class="headerlink" title="15.3 Filter 过滤器基本原理"></a>15.3 Filter 过滤器基本原理</h2><p>● 一图胜千言</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230715182618162.png" alt="image-20230715182618162" style="zoom:50%;" /><h2 id="15-4-Filter-过滤器快速入门"><a href="#15-4-Filter-过滤器快速入门" class="headerlink" title="15.4 Filter 过滤器快速入门"></a>15.4 Filter 过滤器快速入门</h2><p>● 需求: 在 web 工程下， 有后台管理目录 manage， 要求该目录下所有资源（html、 图片、jsp 、 Servlet 等） <strong>用户登录后才能访问</strong></p><p>听老师说明, <strong>完成模块的套路&#x2F;流程</strong>[多年的体会]</p><ol><li>先完成一个正确的流程-看到一个效果-&gt; 写后面代码就可以验证</li><li>加入其它的功能[加入 session,验证合法性]</li><li>完善功能</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 老韩解读</span></span><br><span class="line"><span class="comment"> * 1. filter在web项目启动时, 由tomcat 来创建filter实例, 只会创建一个</span></span><br><span class="line"><span class="comment"> * 2. 会调用filter默认的无参构造器, 同时会调用 init方法, 只会调用一次</span></span><br><span class="line"><span class="comment"> * 3. 在创建filter实例时，同时会创建一个FilterConfig对象,并通过init方法传入</span></span><br><span class="line"><span class="comment"> * 4. 通过FilterConfig对象，程序员可以获取该filter的相关配置信息</span></span><br><span class="line"><span class="comment"> * 5. 当一个http请求和该filter的的url-patter匹配时，就会调用doFilter方法</span></span><br><span class="line"><span class="comment"> * 6. 在调用doFilter方法时,tomcat会同时创建ServletRequest 和 ServletResponse 和 FilterChain对象</span></span><br><span class="line"><span class="comment"> * , 并通过doFilter传入.</span></span><br><span class="line"><span class="comment"> * 7. 如果后面的请求目标资源(jsp,servlet..) 会使用到request，和 response，那么会继续传递</span></span><br><span class="line"><span class="comment"> * 8. 老师的提醒:到javaweb - ssm - springboot , 有 浏览器和 web服务器(tomcat)参与, 而这两个部分不是我们</span></span><br><span class="line"><span class="comment"> *    程序员自己写，所以理解起来比 java se要困难!!!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ManageFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">//当Tomcat 创建 Filter创建，就会调用该方法，进行初始化</span></span><br><span class="line">        <span class="comment">//老韩提醒：回忆我们自己实现tomcat底层机制+servlet程序， 就会了然</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ManageFilter init被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest,</span></span><br><span class="line"><span class="params">                         ServletResponse servletResponse,</span></span><br><span class="line"><span class="params">                         FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;ManageFilter doFilter() 被调用=&quot;</span> + (++count));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//到每次调用该filter时，doFilter就会被调用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果这里，没有调用继续请求的方法，则就停止</span></span><br><span class="line">        <span class="comment">//如果继续访问目标资源-&gt; 等价于放行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//老师说明：在调用过滤器前，servletRequest对象=request已经被创建并封装</span></span><br><span class="line">        <span class="comment">//所以：我们这里就可以通过servletRequest获取很多信息, 比如访问url , session</span></span><br><span class="line">        <span class="comment">//比如访问的参数 ... 就可以做事务管理，数据获取，日志管理等</span></span><br><span class="line">        <span class="comment">//获取到session</span></span><br><span class="line">        <span class="comment">//可以继续使用 httpServletRequest 方法.</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入密码=&quot;</span> + httpServletRequest.getParameter(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> httpServletRequest.getSession();</span><br><span class="line">        <span class="comment">//获取username session对象, 还可以继续使用</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">username</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (username != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//老韩解读filterChain.doFilter(servletRequest, servletResponse)</span></span><br><span class="line">            <span class="comment">//1. 继续访问目标资源url</span></span><br><span class="line">            <span class="comment">//2. servletRequest 和 servletResponse 对象会传递给目标资源/文件</span></span><br><span class="line">            <span class="comment">//3. 一定要理解filter传递的两个对象，再后面的servlet/jsp 是同一个对象(指的是在一次http请求)</span></span><br><span class="line">            System.out.println(<span class="string">&quot;servletRequest=&quot;</span> + servletRequest);</span><br><span class="line">            System.out.println(<span class="string">&quot;日志信息==&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;访问的用户名=&quot;</span> + username.toString());</span><br><span class="line">            System.out.println(<span class="string">&quot;访问的url=&quot;</span> + httpServletRequest.getRequestURL());</span><br><span class="line">            System.out.println(<span class="string">&quot;访问的IP=&quot;</span> + httpServletRequest.getRemoteAddr());</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//说明没有登录过..回到登录页面</span></span><br><span class="line">            servletRequest.getRequestDispatcher(<span class="string">&quot;/login.jsp&quot;</span>).</span><br><span class="line">                    forward(servletRequest, servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//当filter被销毁时，会调用该方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ManageFilter destroy()被调用..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>●在 web.xml 配置过滤器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--老师解读:filter一般写在其它servlet的前面</span></span><br><span class="line"><span class="comment">        1. 观察我们发现filter 配置和 servlet 非常相似. filter也是被tomcat管理和维护</span></span><br><span class="line"><span class="comment">        2. url-pattern 就是当请求的url 和 匹配的时候，就会调用该filter</span></span><br><span class="line"><span class="comment">        3. /manage/* 第一个 / 解析成 http://ip:port/工程路径</span></span><br><span class="line"><span class="comment">        4. 完整的路径就是 http://ip:port/工程路径/manage/* 当请求的资源url满足该条件时</span></span><br><span class="line"><span class="comment">        都会调用filter , /manage/admin.jsp</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ManageFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.hspedu.filter.ManageFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ManageFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/manage/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="15-5-Filter-过滤器-url-pattern"><a href="#15-5-Filter-过滤器-url-pattern" class="headerlink" title="15.5 Filter 过滤器 url-pattern"></a>15.5 Filter 过滤器 url-pattern</h2><p>1、 url-pattern : Filter 的拦截路径, 即<strong>浏览器在请求什么位置的资源时， 过滤器会进行拦截过滤</strong> </p><p>2、<strong>精确匹配</strong> <url-pattern>&#x2F;a.jsp</url-pattern> 对应的 请求地址 <a href="http://ip[域名]:port/工程路径/a.jsp">http://ip[域名]:port/工程路径/a.jsp</a> 会拦截</p><p>3、 <strong>目录匹配</strong> <url-pattern>&#x2F;manage&#x2F;*</url-pattern>对应的 请求地址 <a href="http://ip[域名]:port/工程路径/manage/xx">http://ip[域名]:port/工程路径/manage/xx</a> , 即 web 工程 manage 目录下所有资源 会拦截</p><p>4、 <strong>后缀名匹配</strong> <url-pattern>*.jsp</url-pattern> 后缀名可变， 比如 *.action *.do 等等对应的 请求地址 <a href="http://ip[域名]:port/工程路径/xx.jsp">http://ip[域名]:port/工程路径/xx.jsp</a> , 后缀名为 .jsp 请求会拦截</p><p><strong>5、 Filter 过滤器它只关心请求的地址是否匹配， 不关心请求的资源是否存在</strong></p><h2 id="15-6-Filter-过滤器生命周期"><a href="#15-6-Filter-过滤器生命周期" class="headerlink" title="15.6 Filter 过滤器生命周期"></a>15.6 Filter 过滤器生命周期</h2><p>● Filter 生命周期图解</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230716085623113.png" alt="image-20230716085623113"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 老韩解读</span></span><br><span class="line"><span class="comment"> * 1. filter在web项目启动时, 由tomcat 来创建filter实例, 只会创建一个</span></span><br><span class="line"><span class="comment"> * 2. 会调用filter默认的无参构造器, 同时会调用 init方法, 只会调用一次</span></span><br><span class="line"><span class="comment"> * 3. 在创建filter实例时，同时会创建一个FilterConfig对象,并通过init方法传入</span></span><br><span class="line"><span class="comment"> * 4. 通过FilterConfig对象，程序员可以获取该filter的相关配置信息</span></span><br><span class="line"><span class="comment"> * 5. 当一个http请求和该filter的的url-patter匹配时，就会调用doFilter方法</span></span><br><span class="line"><span class="comment"> * 6. 在调用doFilter方法时,tomcat会同时创建ServletRequest 和 ServletResponse 和 FilterChain对象</span></span><br><span class="line"><span class="comment"> * , 并通过doFilter传入.</span></span><br><span class="line"><span class="comment"> * 7. 如果后面的请求目标资源(jsp,servlet..) 会使用到request，和 response，那么会继续传递</span></span><br><span class="line"><span class="comment"> * 8. 老师的提醒:到javaweb - ssm - springboot , 有 浏览器和 web服务器(tomcat)参与, 而这两个部分不是我们</span></span><br><span class="line"><span class="comment"> *    程序员自己写，所以理解起来比 java se要困难!!!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ManageFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">//当Tomcat 创建 Filter创建，就会调用该方法，进行初始化</span></span><br><span class="line">        <span class="comment">//老韩提醒：回忆我们自己实现tomcat底层机制+servlet程序， 就会了然</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ManageFilter init被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest,</span></span><br><span class="line"><span class="params">                         ServletResponse servletResponse,</span></span><br><span class="line"><span class="params">                         FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;ManageFilter doFilter() 被调用=&quot;</span> + (++count));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//到每次调用该filter时，doFilter就会被调用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果这里，没有调用继续请求的方法，则就停止</span></span><br><span class="line">        <span class="comment">//如果继续访问目标资源-&gt; 等价于放行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//老师说明：在调用过滤器前，servletRequest对象=request已经被创建并封装</span></span><br><span class="line">        <span class="comment">//所以：我们这里就可以通过servletRequest获取很多信息, 比如访问url , session</span></span><br><span class="line">        <span class="comment">//比如访问的参数 ... 就可以做事务管理，数据获取，日志管理等</span></span><br><span class="line">        <span class="comment">//获取到session</span></span><br><span class="line">        <span class="comment">//可以继续使用 httpServletRequest 方法.</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入密码=&quot;</span> + httpServletRequest.getParameter(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> httpServletRequest.getSession();</span><br><span class="line">        <span class="comment">//获取username session对象, 还可以继续使用</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">username</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (username != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//老韩解读filterChain.doFilter(servletRequest, servletResponse)</span></span><br><span class="line">            <span class="comment">//1. 继续访问目标资源url</span></span><br><span class="line">            <span class="comment">//2. servletRequest 和 servletResponse 对象会传递给目标资源/文件</span></span><br><span class="line">            <span class="comment">//3. 一定要理解filter传递的两个对象，再后面的servlet/jsp 是同一个对象(指的是在一次http请求)</span></span><br><span class="line">            System.out.println(<span class="string">&quot;servletRequest=&quot;</span> + servletRequest);</span><br><span class="line">            System.out.println(<span class="string">&quot;日志信息==&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;访问的用户名=&quot;</span> + username.toString());</span><br><span class="line">            System.out.println(<span class="string">&quot;访问的url=&quot;</span> + httpServletRequest.getRequestURL());</span><br><span class="line">            System.out.println(<span class="string">&quot;访问的IP=&quot;</span> + httpServletRequest.getRemoteAddr());</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//说明没有登录过..回到登录页面</span></span><br><span class="line">            servletRequest.getRequestDispatcher(<span class="string">&quot;/login.jsp&quot;</span>).</span><br><span class="line">                    forward(servletRequest, servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//当filter被销毁时，会调用该方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ManageFilter destroy()被调用..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>🌟 <strong>如果后面的请求目标资源(jsp,servlet..) 会使用到request 和 response，那么会继续传递——即使访问的url不同了，但是只要还是被这个filter拦截，那么就是传递相同的request 和 response</strong></p><h2 id="15-7-FilterConfig"><a href="#15-7-FilterConfig" class="headerlink" title="15.7 FilterConfig"></a>15.7 FilterConfig</h2><p>● FilterConfig 接口图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230716090922457.png" alt="image-20230716090922457" style="zoom:50%;" /><p>● FilterConfig 说明</p><ol><li>FilterConfig 是 Filter 过滤器的配置类</li><li>Tomcat 每次创建 Filter 的时候，也会创建一个 FilterConfig 对象，这里包含了 Filter 配置文件的配置信息。</li><li>FilterConfig 对象作用是<strong>获取 filter 过滤器的配置内容</strong></li></ol><p>● 应用实例 FilterConfig_.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 老师解读： 演示FilterConfig使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HspFilterConfig</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String ip; <span class="comment">//从配置获取的ip</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HspFilterConfig init() 被调用..&quot;</span>);</span><br><span class="line">        <span class="comment">//通过filterConfig 获取相关的参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filterName</span> <span class="operator">=</span> filterConfig.getFilterName();</span><br><span class="line">        ip = filterConfig.getInitParameter(<span class="string">&quot;ip&quot;</span>);</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> filterConfig.getServletContext();</span><br><span class="line">        <span class="comment">//可以获取到该filter所有的配置参数名</span></span><br><span class="line">        Enumeration&lt;String&gt; initParameterNames =</span><br><span class="line">                filterConfig.getInitParameterNames();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历枚举</span></span><br><span class="line">        <span class="keyword">while</span> (initParameterNames.hasMoreElements()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;名字=&quot;</span> + initParameterNames.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;filterName= &quot;</span> + filterName);</span><br><span class="line">        System.out.println(<span class="string">&quot;ip= &quot;</span> + ip);</span><br><span class="line">        System.out.println(<span class="string">&quot;servletContext= &quot;</span> + servletContext);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过forbidden ip 来进行控制</span></span><br><span class="line">        <span class="comment">//先获取到访问ip</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">remoteAddr</span> <span class="operator">=</span> servletRequest.getRemoteAddr();</span><br><span class="line">        <span class="keyword">if</span>(remoteAddr.contains(ip)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;封杀该网段..&quot;</span>);</span><br><span class="line">            servletRequest.getRequestDispatcher(<span class="string">&quot;/login.jsp&quot;</span>).</span><br><span class="line">                    forward(servletRequest,servletResponse);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//继续访问目标资源</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 web.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HspFilterConfig<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.hspedu.filter.HspFilterConfig<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这里就是给该filter配置的参数-有程序员根据业务逻辑来设置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>ip<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>127.0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>port<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>8888<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>email<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>hsp@sohu.com<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HspFilterConfig<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/abc/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="15-8-FilterChain-过滤器链"><a href="#15-8-FilterChain-过滤器链" class="headerlink" title="15.8 FilterChain 过滤器链"></a>15.8 FilterChain 过滤器链</h2><h3 id="15-8-1-一句话-FilterChain-在处理某些复杂业务时，-一个过滤器不够，-可以设计多个过滤器共同完成过滤任务，-形成过滤器链。"><a href="#15-8-1-一句话-FilterChain-在处理某些复杂业务时，-一个过滤器不够，-可以设计多个过滤器共同完成过滤任务，-形成过滤器链。" class="headerlink" title="15.8.1 一句话: FilterChain: 在处理某些复杂业务时， 一个过滤器不够， 可以设计多个过滤器共同完成过滤任务， 形成过滤器链。"></a>15.8.1 一句话: FilterChain: 在处理某些复杂业务时， 一个过滤器不够， 可以设计多个过滤器共同完成过滤任务， 形成过滤器链。</h3><h4 id="15-8-2-基本原理示意图"><a href="#15-8-2-基本原理示意图" class="headerlink" title="15.8.2 基本原理示意图"></a>15.8.2 基本原理示意图</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230716093408721.png" alt="image-20230716093408721"></p><h3 id="15-8-3-应用实例-AFilter-java-BFilter-java-hi-jsp-web-xml"><a href="#15-8-3-应用实例-AFilter-java-BFilter-java-hi-jsp-web-xml" class="headerlink" title="15.8.3 应用实例 AFilter.java BFilter.java hi.jsp web.xml"></a>15.8.3 应用实例 AFilter.java BFilter.java hi.jsp web.xml</h3><ol><li>需求： 演示过滤器链的使用</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230716093621006.png" alt="image-20230716093621006"></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230716094326928.png" alt="image-20230716094326928" style="zoom: 50%;" /><p>15.8.4 FilterChain 注意事项和细节</p><ol><li><p><strong>多个 filter 和目标资源</strong>在<u>一次 http 请求</u>， <u>在同一个线程中</u></p></li><li><p>当一个请求 url 和 filter 的 url-pattern 匹配时, 才会被执行, 如果有多个匹配上， 就会顺序执行， 形成一个 filter 调用链(底层可以使用一个数据结构搞定)</p></li><li><p>多个 filter 共同执行时,因为是一次 http 请求, <strong>使用同一个 request 对象</strong></p></li><li><p>多个 filter <strong>执行顺序</strong>， <strong>和 web.xml 配置顺序保持一致.</strong></p></li><li><p>chain.doFilter(req, resp)方法 <strong>将执行下一个过滤器的 doFilter 方法, 如果后面没有过滤器，则执行目标资源。</strong></p></li></ol><p><strong>小结</strong>： 注意执行过滤器链时, 顺序是(用前面的案例分析) Http请求 -&gt; A 过滤器 dofilter()-&gt; A 过滤器前置代码 -&gt; A 过滤器 chain.doFilter() -&gt; B 过滤器 dofilter() -&gt; B 过滤器前置代码 -&gt; B过滤器 chain.doFilter() -&gt; 目标文件 -&gt; B过滤器后置代码 -&gt; A过滤器后置代码 -&gt;返回给浏览器页面&#x2F;数据</p><p>🌟<strong>后置代码指：过滤器中 doFilter()方法中，chain.doFilter()之后的代码</strong></p><h1 id="18-线程数据共享和安全-ThreadLocal"><a href="#18-线程数据共享和安全-ThreadLocal" class="headerlink" title="18 线程数据共享和安全 -ThreadLocal"></a>18 线程数据共享和安全 -ThreadLocal</h1><h2 id="18-1-什么是-ThreadLocal"><a href="#18-1-什么是-ThreadLocal" class="headerlink" title="18.1 什么是 ThreadLocal"></a>18.1 什么是 ThreadLocal</h2><ol><li>ThreadLocal 的作用， 可以实现在同一个线程数据共享, 从而解决多线程数据安全问题.</li><li>ThreadLocal 可以给当前线程关联一个数据(普通变量、对象、数组)set 方法 [源码!]</li><li>ThreadLocal 可以像 Map 一样存取数据，key 为当前线程, get 方法</li><li>每一个 ThreadLocal 对象，只能为当前线程关联一个数据，如果要为当前线程关联多个数据，就需要使用多个 ThreadLocal 对象实例</li><li>每个 ThreadLocal 对象实例定义的时候，一般为 static 类型</li><li>ThreadLocal 中保存数据，在线程销毁后，会自动释放</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230716164123672.png" alt="image-20230716164123672" style="zoom: 67%;" /><h2 id="18-2-快速入门-ThreadLocal"><a href="#18-2-快速入门-ThreadLocal" class="headerlink" title="18.2 快速入门 ThreadLocal"></a>18.2 快速入门 ThreadLocal</h2><p>● 需求: 演示 ThreadLocal (作用： 在一个线程中, 共享数据(线程安全))的使用-画图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建ThreadLocal对象, 做成public static.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Object&gt; threadLocal1 = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Object&gt; threadLocal2 = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Task 是线程类 -&gt; 内部类 / 线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">            <span class="type">Pig</span> <span class="variable">pig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pig</span>();</span><br><span class="line">            <span class="comment">//给threadLocal1 对象放入set dog , 隔山打牛</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Task 放入了 dog= &quot;</span> + dog);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                老韩解读</span></span><br><span class="line"><span class="comment">                public void set(T value) &#123;</span></span><br><span class="line"><span class="comment">                    //1. 获取当前线程, 关联到当前线程!</span></span><br><span class="line"><span class="comment">                    Thread t = Thread.currentThread();</span></span><br><span class="line"><span class="comment">                    //2. 通过线程对象, 获取到ThreadLocalMap</span></span><br><span class="line"><span class="comment">                    //   ThreadLocalMap 类型 ThreadLocal.ThreadLocalMap</span></span><br><span class="line"><span class="comment">                    ThreadLocalMap map = getMap(t);</span></span><br><span class="line"><span class="comment">                    //3. 如果map不为null, 将数据(dog,pig..) 放入map </span></span><br><span class="line"><span class="comment">                    -key:threadLocal value:存放的数据</span></span><br><span class="line"><span class="comment">                    //从这个源码我们已然看出一个threadlocal只能关联一个数据，如果你set, 就会替换</span></span><br><span class="line"><span class="comment">                    //4. 如果map为null, 就创建一个和当前线程关联的ThreadLocalMap, 并且该数据放入</span></span><br><span class="line"><span class="comment">                    if (map != null)</span></span><br><span class="line"><span class="comment">                        map.set(this, value);</span></span><br><span class="line"><span class="comment">                    else</span></span><br><span class="line"><span class="comment">                        createMap(t, value);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            threadLocal1.set(dog);</span><br><span class="line">            <span class="comment">//threadLocal1.set(pig);//替换</span></span><br><span class="line">            threadLocal2.set(pig);<span class="comment">//这个数据就会threadLocal2关联，并且都被当前Thread管理</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Task 在run 方法中 线程=&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">T1Service</span>().update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>()).start();<span class="comment">//主线程启动一个新的线程,注意不是主线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-3-ThreadLocal-源码解读-画图"><a href="#18-3-ThreadLocal-源码解读-画图" class="headerlink" title="18.3 ThreadLocal 源码解读+画图"></a>18.3 ThreadLocal 源码解读+画图</h2><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230716181639550.png" alt="image-20230716181639550"></p><ol start="3"><li>老韩说明: 这里涉及到的弱引用，涉及到知识点很多，暂不深入</li></ol><p>一个Thread有一个 threadLocals(TheadLocalMap类型) ，threadLocals中有一个table，table中有许多桶，每个桶都是Entry类型，（Entry的key是ThreadLocal类型，value是你存进去的数据)</p><h3 id="⚠️疑问："><a href="#⚠️疑问：" class="headerlink" title="⚠️疑问："></a>⚠️疑问：</h3><p>！！！threadLocals中只有一个table，table中存着该线程存放的许多Entry，问：为什么不把Entry直接放在threadLocals下面，而是要多加一层table？</p><p>​分层、用于未来扩展吧？</p>]]></content>
      
      
      <categories>
          
          <category> Web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2023/06/20/Linux/"/>
      <url>/2023/06/20/Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux学习🚀"><a href="#Linux学习🚀" class="headerlink" title="Linux学习🚀"></a>Linux学习🚀</h1><p>操作系统文件时一定要记得先备份！！！</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620231850984.png" alt="image-20230620231850984" style="zoom:50%;" /><h2 id="Linux入门："><a href="#Linux入门：" class="headerlink" title="Linux入门："></a>Linux入门：</h2><h3 id="linux的应用领域："><a href="#linux的应用领域：" class="headerlink" title="linux的应用领域："></a>linux的应用领域：</h3><ul><li><strong>个人桌面领域</strong><ul><li>此领域是传统Linux应用薄弱的环节，近些年来随着ubuntu、fedora等优秀桌面环境的兴起，Linux在个人桌面领域的占有率正在逐渐的提高</li></ul></li><li><strong>服务器领域</strong><ul><li>linux在<u>服务器领域的应用是最强的</u>。</li><li>linux <u><em>免费、稳定、高效</em></u> 等特点在这里得到了很好的体现，尤其在一些高端领域尤为广泛( c&#x2F;c+ + &#x2F;php&#x2F;java&#x2F;python) .</li></ul></li><li><strong>嵌入式领域</strong><ul><li>linux运行稳定、对网络的良好支持性，低成本，且<strong>可以根据需要进行软件裁剪</strong>，内核最小可以达到几百KB等特点，使其近些年来在嵌入式领域的应用得到非常大的提高；</li><li>主要应用：机顶盒、数宇电视、网络电话、程控交换机、手机、PDA、智能家居、智能硬件等都是其应用领域。以后在物联网中应用会更加广泛。</li></ul></li></ul><h3 id="网络连接的三种方式："><a href="#网络连接的三种方式：" class="headerlink" title="网络连接的三种方式："></a>网络连接的三种方式：</h3><ol><li><p>桥接模式</p></li><li><p>NAT模式</p></li><li><p>主机模式</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/IMG_31492E73D3F2-1.jpeg" alt="IMG_31492E73D3F2-1"></p><h3 id="虚拟机克隆-方便快速构建集群"><a href="#虚拟机克隆-方便快速构建集群" class="headerlink" title="虚拟机克隆(方便快速构建集群)"></a>虚拟机克隆(方便快速构建集群)</h3><p>​如果你已经安装了一合linux操作系统，你还想再更多的，老韩提示大家：没有必要再重新安装，你只需要克隆就可以。</p><ul><li>方式1：直接拷贝一份安装好的虛拟机文件</li><li>方式2：使用vmware的克隆操作，注意，克隆时，需要先关闭linux系统</li></ul><h3 id="虚拟机快照"><a href="#虚拟机快照" class="headerlink" title="虚拟机快照"></a>虚拟机快照</h3><p>如果你在使用虛拟机系统的时候(比如linux），你想<strong>回到原先的某一个状态</strong>，也就是说你担心可能有些误操作造成系统异常，需要回到原先某个正常运行的状态，vmware也提供了这样的功能，就叫快照管理。</p><h2 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h2><h3 id="命令行结构："><a href="#命令行结构：" class="headerlink" title="命令行结构："></a>命令行结构：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@iZbp1cmlu7iso80jlaxx2uZ:~# pwd</span><br><span class="line">/root</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>root</code>：表示用户名；</li><li><code>iZbp1cmlu7iso80jlaxx2uZ</code>：表示主机名；</li><li><code>~</code>：表示目前所在目录为家目录，其中 <code>root</code> 用户的家目录是 <code>/root</code> 普通用户的家目录在 <code>/home</code> 下；</li><li><code>#</code>：指示你所具有的权限（ <code>root</code> 用户为 <code>#</code> ，普通用户为 <code>$</code> ）。</li></ul><h3 id="一些快捷键："><a href="#一些快捷键：" class="headerlink" title="一些快捷键："></a>一些快捷键：</h3><ul><li>通过上下方向键 ↑ ↓ 来调取过往执行过的 <code>Linux</code> 命令；</li><li>命令或参数仅需输入前几位就可以用 <code>Tab</code> 键补全；</li><li><code>Ctrl + R</code> ：用于查找使用过的命令（<code>history</code> 命令用于列出之前使用过的所有命令，然后输入 <code>!</code> 命令加上编号( <code>!2</code> )就可以直接执行该历史命令）；</li><li><code>Ctrl + L</code>：清除屏幕并将当前行移到页面顶部；</li><li><code>Ctrl + C</code>：中止当前正在执行的命令；</li><li><code>Ctrl + U</code>：从光标位置剪切到行首；</li><li><code>Ctrl + K</code>：从光标位置剪切到行尾；</li><li><code>Ctrl + W</code>：剪切光标左侧的一个单词；</li><li><code>Ctrl + Y</code>：粘贴 <code>Ctrl + U | K | Y</code> 剪切的命令；</li><li><code>Ctrl + A</code>：光标跳到命令行的开头；</li><li><code>Ctrl + E</code>：光标跳到命令行的结尾；</li><li><code>Ctrl + D</code>：关闭 <code>Shell</code> 会话；</li></ul><h3 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h3><h4 id="which："><a href="#which：" class="headerlink" title="which："></a>which：</h4><p>——查看命令的可执行文件所在路径</p><p>​<code>Linux</code> 下，每一条命令其实都对应一个可执行程序，在终端中输入命令，按回车的时候，就是执行了对应的那个程序， <code>which</code> 命令本身对应的程序也存在于 <code>Linux</code> 中。</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20231219111417608.png" alt="image-20231219111417608"></p><h4 id="cat"><a href="#cat" class="headerlink" title="cat:"></a>cat:</h4><p>一次性显示文件所有内容，更适合查看小的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat cloud-init.log</span><br></pre></td></tr></table></figure><p>【常用参数】</p><ul><li><code>-n</code> 显示行号。</li></ul><h4 id="less："><a href="#less：" class="headerlink" title="less："></a>less：</h4><p>分页显示文件内容，更适合查看大的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less cloud-init.log</span><br></pre></td></tr></table></figure><h4 id="head："><a href="#head：" class="headerlink" title="head："></a>head：</h4><p>显示文件的开头几行（默认是10行）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head cloud-init.log</span><br></pre></td></tr></table></figure><p>【参数】</p><ul><li><code>-n</code> 指定行数 <code>head cloud-init.log -n 2</code></li></ul><p>(要看几行，而不是看第几行)</p><h4 id="tail："><a href="#tail：" class="headerlink" title="tail："></a>tail：</h4><p>显示文件的结尾几行（默认是10行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail cloud-init.log复制代码</span><br></pre></td></tr></table></figure><p>【参数】</p><ul><li><code>-n</code> 指定行数 <code>tail cloud-init.log -n 2</code></li><li><code>-f</code> 会每过1秒检查下文件是否有更新内容，也可以用 <code>-s</code> 参数指定间隔时间 <code>tail -f -s 4 xxx.log</code></li></ul><h4 id="touch："><a href="#touch：" class="headerlink" title="touch："></a>touch：</h4><p>创建一个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch new_file</span><br></pre></td></tr></table></figure><h4 id="mkdir："><a href="#mkdir：" class="headerlink" title="mkdir："></a>mkdir：</h4><p>创建一个目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> new_folder</span><br></pre></td></tr></table></figure><p>【常用参数】</p><ul><li><code>-p</code> 递归的创建目录结构 <code>mkdir -p one/two/three</code></li></ul><h4 id="cp："><a href="#cp：" class="headerlink" title="cp："></a>cp：</h4><p>拷贝文件和目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> file file_copy </span><br><span class="line">--&gt; file 是目标文件，file_copy 是拷贝出来的文件</span><br><span class="line"><span class="built_in">cp</span> file one --&gt; 把 file 文件拷贝到 one 目录下，并且文件名依然为 file</span><br><span class="line"><span class="built_in">cp</span> file one/file_copy --&gt; 把 file 文件拷贝到 one 目录下，文件名为file_copy</span><br><span class="line"><span class="built_in">cp</span> *.txt folder --&gt; 把当前目录下所有 txt 文件拷贝到 folder 目录下</span><br></pre></td></tr></table></figure><p>【常用参数】</p><ul><li><code>-r</code> 递归的拷贝，常用来拷贝一整个目录</li></ul><h4 id="mv："><a href="#mv：" class="headerlink" title="mv："></a>mv：</h4><p>移动（重命名）文件或目录，与cp命令用法相似。</p><h4 id="rm："><a href="#rm：" class="headerlink" title="rm："></a>rm：</h4><p>删除文件和目录，由于 <code>Linux</code> 下没有回收站，一旦删除非常难恢复，因此需要谨慎操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> new_file  --&gt; 删除 new_file 文件</span><br><span class="line"><span class="built_in">rm</span> f1 f2 f3  --&gt; 同时删除 f1 f2 f3 3个文件</span><br></pre></td></tr></table></figure><p>【常用参数】</p><ul><li><code>-i</code> 向用户确认是否删除；</li><li><code>-f</code> 文件强制删除；</li><li><code>-r</code> 递归删除文件夹，著名的删除操作 <code>rm -rf</code> 。</li></ul><h4 id="ln："><a href="#ln：" class="headerlink" title="ln："></a>ln：</h4><p>英文 <code>Link</code> 的缩写，表示创建链接。</p><p>学习创建链接之前，首先要理解链接是什么，我们先来看看 <code>Linux</code> 的文件是如何存储的：</p><p><code>Linux</code> 文件的存储方式分为3个部分，文件名、文件内容以及权限，其中文件名的列表是存储在硬盘的其它地方和文件内容是分开存放的，每个文件名通过 <code>inode</code> 标识绑定到文件内容。</p><p>Linux 下有两种链接类型：硬链接和软链接。</p><h5 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h5><p>使链接的两个文件共享同样文件内容，就是同样的 <code>inode</code> ，一旦文件1和文件2之间有了硬链接，那么修改任何一个文件，修改的都是同一块内容，它的缺点是，只能创建指向文件(文件内容)的硬链接，不能创建指向目录的（其实也可以，但比较复杂）而软链接都可以，因此软链接使用更加广泛。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> file1 file2  --&gt; 创建 file2 为 file1 的硬链接</span><br></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz/9aPYe0E1fb12HhSLxYibr9w8y4GKAfhTDefy14gyK7BcCLpEdwOKzTXcOStZOVy1mfY4AS462pbQ6iaOj5pqEoNQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">图片</p><p>如果我们用 <code>rm file1</code> 来删除 <code>file1</code> ，对 <code>file2</code> 没有什么影响，对于硬链接来说，删除任意一方的文件，共同指向的文件内容并不会从硬盘上删除。只有同时删除了 <code>file1</code> 与<code>file2</code> 后，它们共同指向的文件内容才会消失。</p><h5 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h5><p>软链接就类似 <code>windows</code> 下快捷方式。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s file1 file2</span><br></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz/9aPYe0E1fb12HhSLxYibr9w8y4GKAfhTDnmrlUBQiaRyufJdTZnSoDUYlBgPQWnbGzyJl9NB9hPUfZtPOlQM5Yibg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">图片</p><p>执行 <code>ls -l</code> 命名查看当前目录下文件的具体信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total 0-rw-r--r-- 1 root root 0 Jan 14 06:29 </span><br><span class="line">file1lrwxrwxrwx 1 root root 5 Jan 14 06:42 </span><br><span class="line">file2 -&gt; file1  # 表示file2 指向 file1复制代码</span><br></pre></td></tr></table></figure><p>其实 <code>file2</code> 只是 <code>file1</code> 的一个快捷方式，它指向的是 <code>file1</code> ，所以显示的是 <code>file1</code> 的内容，但其实 <code>file2</code> 的 <code>inode</code> 与 <code>file1</code> 并不相同。如果我们删除了 <code>file2</code> 的话， <code>file1</code>是不会受影响的，但如果删除 <code>file1</code> 的话， <code>file2</code> 就会变成死链接，因为指向的文件不见了。</p><h3 id="用户与权限："><a href="#用户与权限：" class="headerlink" title="用户与权限："></a>用户与权限：</h3><p>linux操作系统中，root用户是超级用户，拥有最高权限</p><p>普通用户需要更高权限来执行操作时，可以使用<code>sudo</code>命令</p><h4 id="创建、删除用户："><a href="#创建、删除用户：" class="headerlink" title="创建、删除用户："></a>创建、删除用户：</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useradd lion --&gt; 添加一个lion用户，添加完之后在 /home 路径下可以查看</span><br><span class="line">passwd lion --&gt; 修改lion用户的密码</span><br><span class="line"></span><br><span class="line">userdel lion --&gt; 只会删除用户名，不会从/home中删除对应文件夹</span><br><span class="line">userdel lion -r --&gt; 会同时删除/home下的对应文件夹</span><br></pre></td></tr></table></figure><h4 id="su："><a href="#su：" class="headerlink" title="su："></a>su：</h4><p>切换用户，需要 <code>root</code> 用户权限</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo su --&gt; 切换为root用户（<span class="built_in">exit</span> 命令或 CTRL + D 快捷键都可以使普通用户切换为 root 用户）</span><br><span class="line">su lion --&gt; 切换为普通用户</span><br><span class="line">su - --&gt; 切换为root用户</span><br></pre></td></tr></table></figure><h4 id="群组的管理："><a href="#群组的管理：" class="headerlink" title="群组的管理："></a>群组的管理：</h4><p><code>Linux</code> 中每个用户都属于一个特定的群组，如果你不设置用户的群组，默认会创建一个和它的用户名一样的群组，并且把用户划归到这个群组。</p><h5 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h5><p>创建群组，用法和 <code>useradd</code> 类似。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd friends</span><br></pre></td></tr></table></figure><h5 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h5><p>删除一个已存在的群组</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel foo  --&gt; 删除foo群组</span><br></pre></td></tr></table></figure><h5 id="groups"><a href="#groups" class="headerlink" title="groups"></a>groups</h5><p>查看用户所在群组</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">groups</span> lion  --&gt; 查看 lion 用户所在的群组</span><br></pre></td></tr></table></figure><h5 id="usermod"><a href="#usermod" class="headerlink" title="usermod:"></a>usermod:</h5><p>用于修改用户的账户。</p><p>【常用参数】</p><ul><li><code>-l</code> 对用户重命名。需要注意的是 <code>/home</code> 中的用户家目录的名字不会改变，需要手动修改。</li><li><code>-g</code> 修改用户所在的群组，例如 <code>usermod -g friends lion</code>修改 <code>lion</code> 用户的群组为 <code>friends</code> 。</li><li><code>-G</code> 一次性让用户添加多个群组，例如 <code>usermod -G friends,foo,bar lion</code> 。</li><li><code>-a</code> <code>-G</code> 会让你离开原先的群组，如果你不想这样做的话，就得再添加 <code>-a</code> 参数，意味着<code>append</code> 追加的意思。</li></ul><h5 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h5><p>用于修改文件的群组。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chgrp</span> bar file.txt --&gt; file.txt文件的群组修改为bar</span><br></pre></td></tr></table></figure><h5 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h5><p>改变文件的所有者，需要 <code>root</code> 身份才能运行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> lion file.txt --&gt; 把其它用户创建的file.txt转让给lion用户</span><br><span class="line"><span class="built_in">chown</span> lion:bar file.txt --&gt; 把file.txt的用户改为lion，群组改为bar</span><br></pre></td></tr></table></figure><p>【常用参数】</p><ul><li><code>-R</code> 递归设置子目录和子文件， <code>chown -R lion:lion /home/frank</code> 把 <code>frank</code> 文件夹的用户和群组都改为 <code>lion</code> 。</li></ul><h3 id="文件权限管理："><a href="#文件权限管理：" class="headerlink" title="文件权限管理："></a>文件权限管理：</h3><h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod:"></a>chmod:</h4><p>修改访问权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 740 file.txt</span><br></pre></td></tr></table></figure><p>【常用参数】</p><ul><li><code>-R</code> 可以递归地修改文件访问权限，例如 <code>chmod -R 777 /home/lion</code></li></ul><p>修改权限的确简单，但是理解其深层次的意义才是更加重要的。下面我们来系统的学习<code>Linux</code> 的文件权限。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@iZbp1cmlu7iso80jlaxx2uZ:/tangjy<span class="comment"># ll</span></span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x  2 root root 4096 Dec 19 14:40 ./</span><br><span class="line">drwxr-xr-x 20 root root 4096 Dec 19 14:08 ../</span><br><span class="line">-rw-r--r--  1 root root    0 Dec 19 14:40 file1</span><br><span class="line">lrwxrwxrwx  1 root root    5 Dec 19 14:40 file2 -&gt; file1</span><br></pre></td></tr></table></figure><p>其中 <code>drwxr-xr-x</code> 表示文件或目录的权限。让我们一起来解读它具体代表什么？</p><ul><li><code>d</code> ：表示目录，就是说这是一个目录，普通文件是 <code>-</code> ，链接是 <code>l</code> 。</li><li><code>r</code> ：<code>read</code> 表示文件可读。</li><li><code>w</code> ：<code>write</code> 表示文件可写，一般有写的权限，就有删除的权限。</li><li><code>x</code> ：<code>execute</code> 表示文件可执行。</li><li><code>-</code> ：表示没有相应权限。</li></ul><p>权限的整体是按用户来划分的，如下图所示：</p><p><img src="https://mmbiz.qpic.cn/mmbiz/9aPYe0E1fb12HhSLxYibr9w8y4GKAfhTDNHjwSKdibbHRmf7PrjuxDSSGmlJcw3TibY3dxFU9hm783e6bibg3jzpsw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">图片</p><p>现在再来理解这句权限 <code>drwxr-xr-x</code> 的意思：</p><ul><li>它是一个文件夹；</li><li>它的<strong>所有者</strong>具有：读、写、执行权限；</li><li>它的<strong>群组用户</strong>具有：读、执行的权限，没有写的权限；</li><li>它的<strong>其它用户</strong>具有：读、执行的权限，没有写的权限。</li></ul><p>现在理解了权限，我们使用 <code>chmod</code> 来尝试修改权限。<code>chmod</code> 它不需要是 <code>root</code> 用户才能运行的，<u>只要你是此文件所有者，就可以用 <code>chmod</code> 来修改文件的访问权限。</u></p><h5 id="数字分配权限"><a href="#数字分配权限" class="headerlink" title="数字分配权限"></a>数字分配权限</h5><table><thead><tr><th align="left">权限</th><th align="left">数字</th></tr></thead><tbody><tr><td align="left">r</td><td align="left">4</td></tr><tr><td align="left">w</td><td align="left">2</td></tr><tr><td align="left">x</td><td align="left">1</td></tr></tbody></table><p>因此要改变权限，只要做一些简单的加法就行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 640 hello.c <span class="comment"># 分析6 = 4 + 2 + 0 表示所有者具有 rw 权限4 = 4 + 0 + 0 表示群组用户具有 r 权限0 = 0 + 0 + 0 表示其它用户没有权限对应文字权限为：-rw-r-----</span></span><br></pre></td></tr></table></figure><h5 id="用字母来分配权限"><a href="#用字母来分配权限" class="headerlink" title="用字母来分配权限"></a>用字母来分配权限</h5><ul><li><code>u</code> ：<code>user</code> 的缩写，用户的意思，表示所有者。</li><li><code>g</code> ：<code>group</code> 的缩写，群组的意思，表示群组用户。</li><li><code>o</code> ：<code>other</code> 的缩写，其它的意思，表示其它用户。</li><li><code>a</code> ：<code>all</code> 的缩写，所有的意思，表示所有用户。</li><li><code>+</code> ：加号，表示添加权限。</li><li><code>-</code> ：减号，表示去除权限。</li><li><code>=</code> ：等于号，表示分配权限。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u+rx file <span class="comment"># --&gt; 文件file的所有者增加读和运行的权限</span></span><br><span class="line"><span class="built_in">chmod</span> g+r file  <span class="comment"># --&gt; 文件file的群组用户增加读的权限</span></span><br></pre></td></tr></table></figure><h3 id="查找文件："><a href="#查找文件：" class="headerlink" title="查找文件："></a>查找文件：</h3><h4 id="find命令："><a href="#find命令：" class="headerlink" title="find命令："></a>find命令：</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &lt;何处(哪个文件夹下)&gt; &lt;条件，可以同时设置多个&gt; &lt;做什么(可选)&gt;</span><br></pre></td></tr></table></figure><p>其中条件可以有多种，可以根据文件的名字来查找，也可以根据其大小来查找，还可以根据其最近访问时间来查找……</p><p>例如：</p><ul><li>-name “file.txt”</li><li>-size +10M </li><li>-atime -7     #近7天内访问过的</li></ul><h3 id="阅读手册"><a href="#阅读手册" class="headerlink" title="阅读手册"></a>阅读手册</h3><h4 id="man"><a href="#man" class="headerlink" title="man:"></a>man:</h4><p><code>Linux</code> 命令种类繁杂，我们凭借记忆不可能全部记住，因此学会查用手册是非常重要的。</p><p>查阅阅读手册的命令为<code>man</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man 待查阅的命令名称</span><br><span class="line"><span class="comment">#如：</span></span><br><span class="line">man <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><h4 id="help"><a href="#help" class="headerlink" title="help:"></a>help:</h4><p><code>man</code> 命令像新华词典一样可以查询到命令或函数的详细信息，但其实我们还有更加快捷的方式去查询， <code>command --help</code> 或 <code>command -h</code> ，它没有 <code>man</code> 命令显示的那么详细，但是它更加易于阅读。</p><h3 id="文本操作："><a href="#文本操作：" class="headerlink" title="文本操作："></a>文本操作：</h3><h4 id="grep："><a href="#grep：" class="headerlink" title="grep："></a>grep：</h4><p>全局搜索一个正则表达式，并且打印到屏幕。简单来说就是，在文件中查找关键字，并显示关键字所在行。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程</title>
      <link href="/2023/06/07/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
      <url>/2023/06/07/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><h2 id="Chapter1-Introduction"><a href="#Chapter1-Introduction" class="headerlink" title="Chapter1 Introduction"></a>Chapter1 Introduction</h2><h3 id="软件工程学科产生的背景："><a href="#软件工程学科产生的背景：" class="headerlink" title="软件工程学科产生的背景："></a>软件工程学科产生的背景：</h3><h4 id="软件危机："><a href="#软件危机：" class="headerlink" title="软件危机："></a>软件危机：</h4><h5 id="从结果来看，软件危机体现在："><a href="#从结果来看，软件危机体现在：" class="headerlink" title="从结果来看，软件危机体现在："></a>从结果来看，软件危机体现在：</h5><ul><li>软件质量差、可靠性难以保证</li><li>成本难以控制</li><li>开发进度难以把握</li><li>可维护性较差</li></ul><h5 id="从原因来看，软件危机由以下两点导致："><a href="#从原因来看，软件危机由以下两点导致：" class="headerlink" title="从原因来看，软件危机由以下两点导致："></a>从原因来看，软件危机由以下两点导致：</h5><ol><li>不断增长的系统复杂性</li><li>未有效采用软件工程方法进行开发</li></ol><h3 id="Frequently-asked-questions-about-software-engineering"><a href="#Frequently-asked-questions-about-software-engineering" class="headerlink" title="Frequently asked questions about software engineering"></a><strong>Frequently asked questions about software engineering</strong></h3><table><thead><tr><th><strong>Question</strong></th><th><strong>Answer</strong></th></tr></thead><tbody><tr><td>What  is software?</td><td><strong>Computer  programs</strong> and <strong>associated documentation</strong>. Software products may be developed for  a particular customer or may be developed for a general market.</td></tr><tr><td>What  are the attributes of good software?</td><td>Good  software should deliver the required functionality and performance to the  user and should be maintainable, dependable and usable.</td></tr><tr><td>What  is software engineering?</td><td>Software  engineering is an engineering discipline that is concerned with all aspects  of software production.</td></tr><tr><td>What  are the fundamental software engineering activities?</td><td>Software  specification(规范), software development, software validation(验证) and software  evolution(演进).</td></tr><tr><td>What  is the difference between software engineering and computer science?</td><td>Computer  science focuses on theory and fundamentals; software engineering is concerned  with the practicalities of developing and delivering useful software.</td></tr><tr><td>What  is the difference between software engineering and system engineering?</td><td>System  engineering is concerned with all aspects of computer-based systems  development including hardware, software and process engineering. Software  engineering is part of this more general process.</td></tr><tr><td>What are the key challenges facing  software engineering?</td><td>Coping with increasing diversity,  demands for reduced delivery times and developing trustworthy software.</td></tr><tr><td>What  are the costs of software engineering?</td><td>Roughly  60% of software costs are development costs, 40% are testing costs. For  custom software, evolution costs often exceed development costs.</td></tr><tr><td>What  are the best software engineering techniques and methods?</td><td>While  all software projects have to be professionally managed and developed,  <strong>different techniques are appropriate for different types of system</strong>. For  example, games should always be developed using a series of prototypes  whereas safety critical control systems require a complete and analyzable  specification to be developed. You can’t, therefore, say that one method is  better than another.</td></tr></tbody></table><h3 id="好的软件的基本属性"><a href="#好的软件的基本属性" class="headerlink" title="好的软件的基本属性"></a>好的软件的基本属性</h3><ul><li>可接受性(满足用户的需求，用户能用，好用)</li><li>可依赖性和信息安全性</li><li>效率高</li><li>可维护性</li></ul><h3 id="软件过程——四项基本活动"><a href="#软件过程——四项基本活动" class="headerlink" title="软件过程——四项基本活动"></a>软件过程——四项基本活动</h3><ol><li><strong>软件规格说明</strong>（like 需求分析</li><li><strong>软件开发</strong></li><li><strong>软件确认</strong>（like 验收</li><li><strong>软件演化</strong>（like 维护</li></ol><h2 id="Chapter2-软件过程"><a href="#Chapter2-软件过程" class="headerlink" title="Chapter2 软件过程"></a>Chapter2 软件过程</h2><h3 id="2-1软件过程模型"><a href="#2-1软件过程模型" class="headerlink" title="2.1软件过程模型"></a>2.1软件过程模型</h3><h4 id="瀑布模型："><a href="#瀑布模型：" class="headerlink" title="瀑布模型："></a>瀑布模型：</h4><p>​如果每阶段做的事是正确的，就能保证最终结果的正确</p><p>​系统需求&lt;&#x3D;&gt;软件需求&lt;&#x3D;&gt;需求分析&lt;&#x3D;&gt;设计&lt;&#x3D;&gt;编码&lt;&#x3D;&gt;测试&lt;&#x3D;&gt;运行</p><h5 id="瀑布模型的优点："><a href="#瀑布模型的优点：" class="headerlink" title="瀑布模型的优点："></a>瀑布模型的优点：</h5><p>虽然瀑布模型是一个比较 “老”的。甚至过时的开发模型，但其优点为：</p><ul><li><p>在决定系统怎样做之前，存在一个需求阶段。<strong>鼓励对系统“做什么” 进行规约</strong>（即设计之前的规约）。</p></li><li><p>在建造构件之前。存在一个设计阶段，<strong>鼓励规划系统结构</strong>（即编码之前的设计）。</p></li><li><p><u>在每一阶段结束时进行复审，允许获取方和用户的参与。</u></p></li><li><p>前一步工作产品可作为下一步被认可的。文档化的基线。允许基线和配置早期接受控制。</p></li></ul><h5 id="瀑布模型的缺点："><a href="#瀑布模型的缺点：" class="headerlink" title="瀑布模型的缺点："></a>瀑布模型的缺点：</h5><p>瀑布模型下，客户和开发者可能会过早地冻结了需求，这样的话后续就不能发生进一步的变化(除非返工)</p><ul><li><p>客户<u>必须能够完整、正确和清晰地表达他们的需求</u>：开发人员一开始就必须理解需求。</p></li><li><p>缺乏灵活性。一旦软件需求存在偏差，就会导致开发出的软件产品不能满足用户的实际要求(需要返工)。</p></li><li><p>在一个项目的早期阶段，过分地强调了基线和里程碑处的文档,可能要花费更多的时间，用于建立一些用处不大的文档。</p></li><li><p>直到项目结束之前，都不能演示系统的能力,增加了项目的风险。</p></li></ul><h4 id="增量模型："><a href="#增量模型：" class="headerlink" title="增量模型："></a>增量模型：</h4><p>​该模型有一个假设：假设需求可以分段，成为一系列增量产品，每一增量可以分别地开发。</p><p>系统开发体现为一系列的版本(增量)，每个版本在前一版本的基础上增加一些功能。</p><h5 id="增量模型的优点："><a href="#增量模型的优点：" class="headerlink" title="增量模型的优点："></a>增量模型的优点：</h5><p>作为瀑布模型的第一个变体，具有瀑布模型的所有优点。</p><p>此外，它还有以下优点：</p><ul><li><p>更容易获得用户的反馈</p></li><li><p>第一个可交付版本所需要的成本和时间是很少的：</p></li><li><p>开发由增量表示的小系统所承担的风险是不大的：</p></li><li><p>由于很快发布了第一个版本，因此可以减少用户需求的变更：</p></li><li><p>允许增量投资，即在项目开始时，可以仅对一个或两个增量投资。</p></li></ul><p>注：如果采用增量投资方式，那么客户就可以对一些增量进行招标。</p><p>然后，开发人员按提出的截止期限进行增量开发，这样客户就可以用多个契约来管理组织的资源和成本。</p><h5 id="增量模型的缺点："><a href="#增量模型的缺点：" class="headerlink" title="增量模型的缺点："></a>增量模型的缺点：</h5><p>如果增量模型不适于某些项目，或使用有误，则有以下缺点：</p><ul><li><p>﻿如果没有对用户的变更要求进行规划，那么产生的初始增量可能会造成后来增量的不稳定；</p></li><li><p>﻿如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发(返工)，重新发布：</p></li><li><p>管理发生的成本、进度和配置的复杂性，可能会超出一些组织的能力。</p></li><li><p>过程不可见：管理者需要定期交付成果来衡量进度。如果系统开发迅速，则生成反映系统每个版本的文档并不具有成本效益。</p></li></ul><h4 id="集成和配置："><a href="#集成和配置：" class="headerlink" title="集成和配置："></a>集成和配置：</h4><p>​该方法依赖于可复用的构件或系统。</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230610130513298.png" alt="image-20230610130513298"></p><h4 id="演化模型："><a href="#演化模型：" class="headerlink" title="演化模型："></a>演化模型：</h4><p>（针对一开始不能明确需求的情况：</p><p>是一种有弹性的过程模式，由一些小的开发步组成，每一步都历经<strong>需求分析、设计、实现和验证</strong></p><h4 id="喷泉模型："><a href="#喷泉模型：" class="headerlink" title="喷泉模型："></a>喷泉模型：</h4><p>​特征：<strong>迭代、无缝</strong></p><h2 id="chapter1-软件工程概论"><a href="#chapter1-软件工程概论" class="headerlink" title="chapter1 软件工程概论"></a>chapter1 软件工程概论</h2><h3 id="1-1-软件的定义及特点"><a href="#1-1-软件的定义及特点" class="headerlink" title="1.1 软件的定义及特点"></a>1.1 软件的定义及特点</h3><h3 id="1-2-软件工程的起源和概念"><a href="#1-2-软件工程的起源和概念" class="headerlink" title="1.2 软件工程的起源和概念"></a>1.2 软件工程的起源和概念</h3><h3 id="1-3-软件开发的本质和基本手段"><a href="#1-3-软件开发的本质和基本手段" class="headerlink" title="1.3 软件开发的本质和基本手段"></a>1.3 软件开发的本质和基本手段</h3><h3 id="1-4-软件工程框架"><a href="#1-4-软件工程框架" class="headerlink" title="1.4 软件工程框架"></a>1.4 软件工程框架</h3><h2 id="chapter2-软件过程"><a href="#chapter2-软件过程" class="headerlink" title="chapter2 软件过程"></a>chapter2 软件过程</h2><h3 id="2-1软件生存周期过程的概念"><a href="#2-1软件生存周期过程的概念" class="headerlink" title="2.1软件生存周期过程的概念"></a>2.1软件生存周期过程的概念</h3><h3 id="2-2软件生存周期过程的分类"><a href="#2-2软件生存周期过程的分类" class="headerlink" title="2.2软件生存周期过程的分类"></a>2.2软件生存周期过程的分类</h3><h3 id="2-3软件生存周期模型的概念"><a href="#2-3软件生存周期模型的概念" class="headerlink" title="2.3软件生存周期模型的概念"></a>2.3软件生存周期模型的概念</h3><h3 id="2-4常见的软件生存周期模型"><a href="#2-4常见的软件生存周期模型" class="headerlink" title="2.4常见的软件生存周期模型"></a>2.4常见的软件生存周期模型</h3><h4 id="瀑布模型：-1"><a href="#瀑布模型：-1" class="headerlink" title="瀑布模型："></a>瀑布模型：</h4><p>​如果每阶段做的事是正确的，就能保证最终结果的正确</p><p>​系统需求&lt;&#x3D;&gt;软件需求&lt;&#x3D;&gt;需求分析&lt;&#x3D;&gt;设计&lt;&#x3D;&gt;编码&lt;&#x3D;&gt;测试&lt;&#x3D;&gt;运行</p><h5 id="瀑布模型的优点：-1"><a href="#瀑布模型的优点：-1" class="headerlink" title="瀑布模型的优点："></a>瀑布模型的优点：</h5><p>虽然瀑布模型是一个比较 “老”的。甚至过时的开发模型，但其优点为：</p><ul><li><p>在决定系统怎样做之前，存在一个需求阶段。<strong>鼓励对系统“做什么” 进行规约</strong>（即设计之前的规约）。</p></li><li><p>在建造构件之前。存在一个设计阶段，<strong>鼓励规划系统结构</strong>（即编码之前的设计）。</p></li><li><p><u>在每一阶段结束时进行复审，允许获取方和用户的参与。</u></p></li><li><p>前一步工作产品可作为下一步被认可的。文档化的基线。允许基线和配置早期接受控制。</p></li></ul><h5 id="瀑布模型的缺点：-1"><a href="#瀑布模型的缺点：-1" class="headerlink" title="瀑布模型的缺点："></a>瀑布模型的缺点：</h5><ul><li><p>客户<u>必须能够完整、正确和清晰地表达他们的需求</u>：开发人员一开始就必须理解需求。</p></li><li><p>缺乏灵活性。一旦软件需求存在偏差，就会导致开发出的软件产品不能满足用户的实际要求。</p></li><li><p>在一个项目的早期阶段，过分地强调了基线和里程碑处的文档,可能要花费更多的时间，用于建立一些用处不大的文档。</p></li><li><p>直到项目结束之前，都不能演示系统的能力,增加了项目的风险。</p></li></ul><h4 id="增量模型：-1"><a href="#增量模型：-1" class="headerlink" title="增量模型："></a>增量模型：</h4><p>​该模型有一个假设：假设需求可以分段，成为一系列增量产品，每一增量可以分别地开发。</p><h5 id="增量模型的优点：-1"><a href="#增量模型的优点：-1" class="headerlink" title="增量模型的优点："></a>增量模型的优点：</h5><p>作为瀑布模型的第一个变体，具有瀑布模型的所有优点。</p><p>此外，它还有以下优点：</p><ul><li><p>第一个可交付版本所需要的成本和时间是很少的：</p></li><li><p>开发由增量表示的小系统所承担的风险是不大的：</p></li><li><p>由于很快发布了第一个版本，因此可以减少用户需求的变更：</p></li><li><p>允许增量投资，即在项目开始时，可以仅对一个或两个增量投资。</p></li></ul><p>注：如果采用增量投资方式，那么客户就可以对一些增量进行招标。</p><p>然后，开发人员按提出的截止期限进行增量开发，这样客户就可以用多个契约来管理组织的资源和成本。</p><h5 id="增量模型的缺点：-1"><a href="#增量模型的缺点：-1" class="headerlink" title="增量模型的缺点："></a>增量模型的缺点：</h5><p>如果增量模型不适于某些项目，或使用有误，则有以下缺点：</p><ul><li><p>﻿如果没有对用户的变更要求进行规划，那么产生的初始增量可能会造成后来增量的不稳定；</p></li><li><p>﻿如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布：</p></li><li><p>管理发生的成本、进度和配置的复杂性，可能会超出一些组织的能力。</p></li></ul><h4 id="演化模型：-1"><a href="#演化模型：-1" class="headerlink" title="演化模型："></a>演化模型：</h4><p>（针对一开始不能明确需求的情况：</p><p>是一种有弹性的过程模式，由一些小的开发步组成，每一步都历经<strong>需求分析、设计、实现和验证</strong></p><h4 id="喷泉模型：-1"><a href="#喷泉模型：-1" class="headerlink" title="喷泉模型："></a>喷泉模型：</h4><p>​特征：<strong>迭代、无缝</strong></p><h2 id="chapter3-软件需求与软件需求规约"><a href="#chapter3-软件需求与软件需求规约" class="headerlink" title="chapter3 软件需求与软件需求规约"></a>chapter3 软件需求与软件需求规约</h2><h3 id="3-1需求的作用"><a href="#3-1需求的作用" class="headerlink" title="3.1需求的作用"></a>3.1需求的作用</h3><p>​软件开发的工作基础</p><h3 id="3-2需求的定义"><a href="#3-2需求的定义" class="headerlink" title="3.2需求的定义"></a>3.2需求的定义</h3><p>​描述了待开发产品&#x2F;系统功能上的能力、性能参数或其他性质</p><p>需求的基本性质：</p><ul><li>必要性是要求的</li><li>无歧义性            是否只能用一种方式来解释</li><li>可测的 (测试)     能否进行测试，对一定的输入，会有相同的输出</li><li>可跟踪的            从一个开发阶段到另一个阶段能否进行跟踪</li><li>可测量的            能否测量</li></ul><h3 id="3-3需求的分类"><a href="#3-3需求的分类" class="headerlink" title="3.3需求的分类"></a>3.3需求的分类</h3><h4 id="功能需求："><a href="#功能需求：" class="headerlink" title="功能需求："></a>功能需求：</h4><ul><li><p>关于该功能输入的所有假定，或为了验证该功能输入有关检测的假定。</p></li><li><p>﻿功能内的任一次序，这一次序是与外部有关的。</p></li><li><p>﻿对异常条件的响应，包括所有内外部所产生的错误。</p></li><li><p>﻿需求的时序或优先程度。</p></li><li><p>﻿功能之间的互斥规则。</p></li><li><p>﻿系统内部状态的假定。</p></li><li><p>为了该功能的执行，所需要的输入和输出次序。</p></li><li><p>用于转换或内部计算所需要的公式。</p></li></ul><h4 id="性能需求："><a href="#性能需求：" class="headerlink" title="性能需求："></a>性能需求：</h4><p>​规约了一个系统或系统构建必须具有的<strong>性能特性</strong>(速度、准确率、并发等要求)</p><h4 id="外部接口需求："><a href="#外部接口需求：" class="headerlink" title="外部接口需求："></a>外部接口需求：</h4><p>​外部接口需求 (External interface requirement) 规约了系统或系统构件必须与之交互的硬件、软件或数据库元素。它也可能规约其格式、时间或其他因素。</p><ul><li><p>系统接口 (Systeminterfaces)：描述一个应用如何与系统的其他应用进行交互。</p></li><li><p>用户接口 (User interfaces)：规约了软件产品和用户之间接口的逻辑特性。即规约对给用户所显示的数据，对用户所要求的数据以及用户如何控制该用户接口。</p></li><li><p>硬件接口 (Hardware interfaces)：如果软件系统必须与硬件设备进行交互，那么就应说明所要求的支持和协议类型。</p></li><li><p>软件接口 (Software interfaces)：允许与其它软件产品进行交互，如，数据管理系统、操作系统或数学软件包。</p></li><li><p>通讯接口 (Communications interfaces)：规约待开发系统与通讯设施（如，局域网）之间的交互。如果通讯需求包含了系统必须使用的网络类型 (TCP&#x2F;IP. WindowsNT. Novell)，那么有关类型的信息就应包含在SRS中。</p></li></ul><p></p><h4 id="设计约束需求："><a href="#设计约束需求：" class="headerlink" title="设计约束需求："></a>设计约束需求：</h4><p>​设计约束<strong>限制了系统或系统构件</strong>的设计方案。就约束的本身而言。对其进行权衡或调整是相当困难的，甚至是不可能的。<u>它们必须予以满足</u>。这一性质是与其它需求的最主要差别。为了满足功能、性能和其它需求，许多设计约束将对软件项目规划、所需要的附加成本和工作产生直接影响。例如：</p><ul><li>系统必须用C++或其他面向对象语方编写。系统用户接口需要菜单……</li></ul><h4 id="质量属性："><a href="#质量属性：" class="headerlink" title="质量属性："></a>质量属性：</h4><p>​规约了软件产品必须具有的性质是否达到质量方面一个所期望的水平</p><p>​例如：</p><p>​可靠性软件系统在指定环境中没有失败而正常运行的概率。</p><p>​存活性当系统的某一部分系统不能运行时，该软件维续运行或支持关键功能的可能性。</p><p>​可维护性发現和改正一个软件故障或对特定的花明进行修改所要求的平均工作。</p><p>​用户友好性    学习和使用一个软件系统的容易程度。</p><p>​安全性在一个预定的时间内，使软件系统安全的可能性。</p><p>​可移植性软件系统运行的平台类型。</p><h3 id="3-4需求发现"><a href="#3-4需求发现" class="headerlink" title="3.4需求发现"></a>3.4需求发现</h3><p>​需求是怎么来的？</p><h4 id="自悟-Introspection"><a href="#自悟-Introspection" class="headerlink" title="自悟(Introspection)"></a>自悟(Introspection)</h4><p>​需求人员把自己作为系统的最终用户，审视该系统并提出问題：“如果是我使用这一系统，则我需要…”</p><h5 id="适用条件："><a href="#适用条件：" class="headerlink" title="适用条件："></a>适用条件：</h5><p>​需求工程师不能直接与用户进行交流，自悟似乎是一种比较有吸引力的方法，可能确实是必须的。</p><h5 id="成功条件："><a href="#成功条件：" class="headerlink" title="成功条件："></a>成功条件：</h5><p>​若使自悟是成功的，需求人员必须具有比最终用户还要多的应用领域和过程方面的知识，并具有良好的想象能力。</p><h4 id="交谈-Individual-interviews"><a href="#交谈-Individual-interviews" class="headerlink" title="交谈(Individual interviews)"></a>交谈(Individual interviews)</h4><p>为了确定系统应该提供的功能，需求人员通过提出问题，用户回答，直接询问用户想要的是一个什么样的系统。</p><h5 id="成功条件：-1"><a href="#成功条件：-1" class="headerlink" title="成功条件："></a>成功条件：</h5><p>交谈通常是一种比自悟更好的技术。这种途径成功与否依赖于：</p><p>一一需求人员是否具有“<u>正确提出问题</u>的的能力，</p><p>一一回答人员是否具有“<u>揭示需求本意</u>”的能力。</p><p>在在的风险：在交谈期间需求可能不断增长，或是以前没有认识到的合理需求的一种表现，说是“完美蠕行”(Creepingelegance)病症的体现，以至于很难予以控制，可能导致超出项目成本和进度的限制。</p><h5 id="应对措施："><a href="#应对措施：" class="headerlink" title="应对措施："></a>应对措施：</h5><p>项目管理人员和客户管理人员应该定期地对交谈过程的结果进行复車。其中具有挑战的问题是：</p><p>判断：</p><p>一一什么时候对这一增长划界：</p><p>一一什么时候将这一增长通知客户。</p><h4 id="观察-Observation"><a href="#观察-Observation" class="headerlink" title="观察(Observation)"></a>观察(Observation)</h4><p>通过观察用户执行其现行的任务和过程，或通过观察他们如何操作与所期望的新系统有关的现有系统，了解系统运行的环境，特别是了解要建的新系统与现存系统、过程以及工作方法之间必须进行的交互。尽管了解的这些信息可以通过交谈获取，但“第一手材料”一般总是能够比较好的符合现实的。</p><h5 id="存在的风险："><a href="#存在的风险：" class="headerlink" title="存在的风险："></a>存在的风险：</h5><p>一一客户可能抵触这一观察。其原因是他们认为开发者打扰了他们的正常业务。</p><p>一一客户还可能认为开发者在签约之前，就已经熟悉了他们的业务。</p><h4 id="小组会-Group-session"><a href="#小组会-Group-session" class="headerlink" title="小组会(Group session)"></a>小组会(Group session)</h4><p>举行客户和开发人员的联席会议，与客户组织的一些代表共同开发需求。其中：</p><p>一通常是由<u>开发组织的一个代表作为首席需求工程师或软件工程项目经理</u>，主持这一会议。但还可以采用其它形式，这依赖于其应用领城和主持人的能力。主持人的作用主要是掌握会议的进程。</p><p>一必须仔细地选择该小组的成员，不仅要考虑他们对现存的和未来运行环境的理解程度，还要考虑他们的人品。</p><h4 id="提炼-Extraction"><a href="#提炼-Extraction" class="headerlink" title="提炼(Extraction)"></a>提炼(Extraction)</h4><p>复审技术文档（例如，有关需要的陈达，功能和性能目标的陈述，系统规约接口标准，硬件设计文档以及ConOps文档），并提出相关的信息。</p><h5 id="适用条件：-1"><a href="#适用条件：-1" class="headerlink" title="适用条件："></a>适用条件：</h5><p>提炼方法是针对<u><strong>己经有了部分需求文档的情况</strong></u>。依据产品的本来情况，可能有很多文档需要复审，以确定其中是否包含相关联的信息。在有的情况，也可能只有少数文档需要复审。</p><p>在许多项目中，在任何交谈、观察、小组会或自悟之前，应该对该项目的背景文档进行复审，还应对系统规约进行复审，同时了解相关的标准和政策。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li>在任意特定的环境中，每项技术都有其自己的优点和不足。在实施上述任何一项技术时，都可以辅以其他</li></ul><p>方法，例如原型构造，在举行小组会时可以使用原型，方便人员之间的交流。</p><ul><li><p>依据需求工程人员的技能和产品、合同的实际情况，往往需要“组合”地使用这些技术来开发初始需求。</p></li><li><p>执行需求发现这项活动的人，其技能水平将对这项活动的成功具有重大的影响。</p></li><li><p>大型复杂项目和一些有能力的组织，在开发需求文档时，往往使用系统化的需求获取、分析技术和工具。</p></li></ul><p>一些方法提供了 系统化、自动化的功能，并可逐一验证单一需求所具有的五个性质，验证需求规约是否具</p><p>有四个性质。</p><h3 id="3-5需求规约-SRS"><a href="#3-5需求规约-SRS" class="headerlink" title="3.5需求规约(SRS)"></a>3.5需求规约(SRS)</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念:"></a>概念:</h4><p>一个需求规约是一个软件项&#x2F;产品&#x2F;系统所有需求陈述的正式文档，是一个软件产品&#x2F; 系统的概念模型。</p><h4 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质:"></a>基本性质:</h4><p>一般来说，SRS应必须具有以下4个性质：</p><ul><li><p>重要性和稳定性程度 (Banlked for importaance and stability).例如：基本需求、可送的需求和期望的需求。</p></li><li><p>可修改的 (Modifiable)：在不过多地影响其它需求的前提下，可以容易地修改一个单一需求.</p></li><li><p>完整的(Couplete)：没有被遗漏的需求.</p></li><li><p>一致的 (Consistent)：不存在互斥的需求.</p></li></ul><h4 id="格式"><a href="#格式" class="headerlink" title="格式:"></a>格式:</h4><p>引言……总体描述……特定需求……</p><h3 id="3-6需求规约的作用"><a href="#3-6需求规约的作用" class="headerlink" title="3.6需求规约的作用"></a>3.6需求规约的作用</h3><p>第一，是最重要的，作为软件开发组织和用户之间一份事实上的技术合同书；是产品功能及其环境的体现。</p><p>第二，对于项目的其余大多数工作，它是一个管理控制点。</p><p>第三，对于产品的设计，它是一个正式的、受控的起始点。</p><p>第四，是创建产品验收测试计划和用户指南的基础，即基于需求规约一般还会产生另外两个文档——<strong>初始</strong></p><p><strong>测试计划</strong>和<strong>用户系统操作描述</strong>。</p><h3 id="3-7项目的需求及需求规约"><a href="#3-7项目的需求及需求规约" class="headerlink" title="3.7项目的需求及需求规约"></a>3.7项目的需求及需求规约</h3><p>项目需求是客户和开发者之间有关技术合同-产品&#x2F;系统需求的理解，应记录在工作陈述SOW中或其他某一项目文档（例如，项目管理计划）中。</p><p>即<strong>需求规约</strong>(SRS)应只关注产品需求，即：</p><p>​产品&#x2F;系统需求一“交付给客户的产品是什么”</p><p><strong>项目的需求</strong>(SOW)应关注项目工作与管理，即：</p><p>​项目需求-“开发组要做的是什么”</p><h2 id="chapter4-结构化分析方法"><a href="#chapter4-结构化分析方法" class="headerlink" title="chapter4 结构化分析方法"></a>chapter4 结构化分析方法</h2><h3 id="结构化分析："><a href="#结构化分析：" class="headerlink" title="结构化分析："></a>结构化分析：</h3><p>​需求分析的目标<br>​对需求陈述进行分析，解决其中的歧义、不一致等问题以系统化的形式表达用户的需求，即给出问题的形式化或半形式化的描述(称为系统的概念模型，或系统的需求规约或需求规格说明)。作为开发人员和客户间技术契约的基础，并作为而后开发活动的一个基本输入。</p><p>2实现软件需求分析的目标对方法学的需求</p><ul><li>**提供一组术语(符号)**，指导需求抽象中需要关注的主要方面，并用于表达分析中所使用的信息。这些术语形成一个特定的抽象层，即需求层。</li><li>依据这些术语所形成的“空间”，<strong>给出表达模型的工具</strong>,支持表达系统功能形态。</li><li><strong>给出过程指导</strong>，以支持系统化地使用相关信息建造系统模型。</li></ul><p>基本术语：</p><p>模型表达工具</p><p>​数据流图：</p><p>​数据字典：定义数据流和数据存储</p><p>​加工小说明：</p><ul><li>结构化自然语言</li><li>判定表 </li><li>判定树</li></ul><h3 id="结构化方法："><a href="#结构化方法：" class="headerlink" title="结构化方法："></a>结构化方法：</h3><h4 id="结构化分析方法："><a href="#结构化分析方法：" class="headerlink" title="结构化分析方法："></a>结构化分析方法：</h4><p>​</p><h4 id="结构化设计方法"><a href="#结构化设计方法" class="headerlink" title="结构化设计方法"></a>结构化设计方法</h4><h4 id="结构化程序设计方法"><a href="#结构化程序设计方法" class="headerlink" title="结构化程序设计方法"></a>结构化程序设计方法</h4><h2 id="chapter5"><a href="#chapter5" class="headerlink" title="chapter5"></a>chapter5</h2><h2 id="chapter6"><a href="#chapter6" class="headerlink" title="chapter6"></a>chapter6</h2><h2 id="chapter7"><a href="#chapter7" class="headerlink" title="chapter7"></a>chapter7</h2><h2 id="chapter8-软件测试"><a href="#chapter8-软件测试" class="headerlink" title="chapter8 软件测试"></a>chapter8 软件测试</h2><h2 id="chapter9-软件项目管理"><a href="#chapter9-软件项目管理" class="headerlink" title="chapter9 软件项目管理"></a>chapter9 软件项目管理</h2><h2 id="Chapter10-软件开发工具与环境"><a href="#Chapter10-软件开发工具与环境" class="headerlink" title="Chapter10 软件开发工具与环境"></a>Chapter10 软件开发工具与环境</h2>]]></content>
      
      
      <categories>
          
          <category> 软件开发基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2023/06/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/06/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>(参照清华——操作系统课程)：</p><p>os：对硬件的管理和控制 本课程着重对<strong>kernel层</strong>的研究</p><h2 id="Chapter1-概述"><a href="#Chapter1-概述" class="headerlink" title="Chapter1 概述"></a>Chapter1 概述</h2><h4 id="什么是OS？"><a href="#什么是OS？" class="headerlink" title="什么是OS？"></a>什么是OS？</h4><p>CPU —–&gt; 进程</p><p>磁盘 —–&gt; 文件</p><p>内存 —–&gt; 地址空间</p><h5 id="用户角度："><a href="#用户角度：" class="headerlink" title="用户角度："></a>用户角度：</h5><ul><li>管理应用程序</li><li>为应用程序提供服务</li><li>杀死应用程序</li></ul><h5 id="资源角度："><a href="#资源角度：" class="headerlink" title="资源角度："></a>资源角度：</h5><ul><li>资源管理</li><li>管理外设、分配资源</li></ul><h4 id="Kernel层内部组件："><a href="#Kernel层内部组件：" class="headerlink" title="Kernel层内部组件："></a>Kernel层内部组件：</h4><ul><li>CPU调度器</li><li>物理内存管理</li><li>虚拟内存管理</li><li>文件系统管理</li><li>中断处理与设备驱动</li></ul><h4 id="OS-Kernel的特征："><a href="#OS-Kernel的特征：" class="headerlink" title="OS Kernel的特征："></a>OS Kernel的特征：</h4><ul><li><p>并发</p><ul><li>计算机系统中同时存在多个运行的程序，需要OS管理和调度</li></ul></li><li><p>共享</p><ul><li>互斥共享</li></ul></li><li><p>虚拟</p><ul><li>利用<strong>多道程序设计技术</strong>让每个用户都觉得有一个计算机专门为他服务。</li></ul></li><li><p>异步</p><ul><li>程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知</li><li>只要运行环境相同，OS需要保证程序的运行结果也相同</li></ul></li></ul><h2 id="Chapter2-操作系统基础操作"><a href="#Chapter2-操作系统基础操作" class="headerlink" title="Chapter2 操作系统基础操作"></a>Chapter2 操作系统基础操作</h2><h3 id="2-1-操作系统的启动"><a href="#2-1-操作系统的启动" class="headerlink" title="2.1 操作系统的启动"></a>2.1 操作系统的启动</h3><h4 id="开机顺序："><a href="#开机顺序：" class="headerlink" title="开机顺序："></a>开机顺序：</h4><p>​电脑开机后，将先执行bootstrap program程序(引导程序)，引导程序一般位于计算机的固件中，由它初始化系统的内核以及各个组件。</p><h3 id="2-2-中断、异常和系统调用"><a href="#2-2-中断、异常和系统调用" class="headerlink" title="2.2 中断、异常和系统调用"></a>2.2 中断、异常和系统调用</h3><h4 id="中断-from-外设"><a href="#中断-from-外设" class="headerlink" title="中断(from 外设)"></a>中断(from 外设)</h4><ul><li><p>来自不同的硬件设备的计时器和网络的中断</p></li><li><p>异步</p></li><li><p>对用户应用程序是透明的</p></li></ul><h5 id="中断的处理过程："><a href="#中断的处理过程：" class="headerlink" title="中断的处理过程："></a>中断的处理过程：</h5><h6 id="硬件："><a href="#硬件：" class="headerlink" title="硬件："></a>硬件：</h6><ul><li>设置中断标记[CPU初始化]<br>1. 将内部事件、外部事件设置中断标记<br>      1. CPU通过标记获得中断事件的ID(凭借中断向量表)</li></ul><p></p><h6 id="软件："><a href="#软件：" class="headerlink" title="软件："></a>软件：</h6><ul><li>保存当前处理状态</li><li>中断服务程序处理</li><li>清除中断标记</li><li>恢复之前保存的处理状态</li></ul><h4 id="异常-from-不良的应用程序"><a href="#异常-from-不良的应用程序" class="headerlink" title="异常(from 不良的应用程序)"></a>异常(from 不良的应用程序)</h4><ul><li><p>应用程序产生，由于非法指令或者其他坏的处理状态</p></li><li><p>同步</p></li><li><p>杀死或重新执行意想不到的应用程序指令</p></li></ul><h5 id="异常的处理过程："><a href="#异常的处理过程：" class="headerlink" title="异常的处理过程："></a>异常的处理过程：</h5><ul><li>保存现场</li><li>异常处理<ul><li>杀死异常程序</li><li>或者 重新执行异常命令</li></ul></li><li>恢复现场</li></ul><h4 id="系统调用-from-应用程序"><a href="#系统调用-from-应用程序" class="headerlink" title="系统调用(from 应用程序)"></a>系统调用(from 应用程序)</h4><ul><li><p>应用程序主动向OS发送服务请求</p></li><li><p>同步或异步</p></li><li><p>等待后继续执行</p></li></ul><h5 id="系统调用的处理过程："><a href="#系统调用的处理过程：" class="headerlink" title="系统调用的处理过程："></a>系统调用的处理过程：</h5><p>​调用系统函数 如printf()后，会触发系统调用，在屏幕上打印</p><p><u>将OS能提供的系统调用进行某种集成，形成各色各样的API供开发人员使用</u></p><ul><li><p>Win32 API 用于Windows</p></li><li><p>POSIX API 用于 POSIX-based systems(such as: UNIX、LINUX、MAX OS X)</p></li><li><p>Java API 用于 JVM</p><ol><li>通常情况下，每个系统调用有自己的序号，系统调用接口根据这些序号维护表的索引</li><li>系统调用接口 调用内核态中的系统调用，返回系统调用的状态和结果(其返回值)</li><li>用户不需要知道系统调用是如何实现的，只需要获取各个API的作用即可；操作系统接口的细节大部分隐藏在API中</li></ol></li></ul><p><strong>🌟用户从系统调用的库中调用系统调用接口，在调用系统调用接口时，会触发一个从用户态-&gt;内核态的转换，执行内核态中的系统调用。</strong></p><p>系统调用的开销会大于普通的函数调用，因为：</p><p>​系统调用会从用户态切换到内核态，需要两次建立函数空间，而函数调用只有自己唯一的栈空间</p><h4 id="跨越操作系统边界的开销-中断、异常、系统调用"><a href="#跨越操作系统边界的开销-中断、异常、系统调用" class="headerlink" title="跨越操作系统边界的开销(中断、异常、系统调用)"></a>跨越操作系统边界的开销(中断、异常、系统调用)</h4><p>在执行时间上开销超过应用程序</p><p>开销体现于：</p><ul><li>建立中断&#x2F;异常&#x2F;系统<strong>调用号 与 对应服务例程映射关系的初始化开销</strong>(因为你跨越了OS边界，不能把原本的状态带过去，所以需要一张映射表，由编号找到你需要做的事)</li><li>建立内核堆栈(因为在内核态进行操作，需要在内核态建立变量存储空间)</li><li>验证参数(内核态不信任用户态，需要进行验证)</li><li>内核态映射到用户态的地址空间(内核态产生的数据需要拷贝回用户态)</li><li>内核态独立地址空间(TLB)</li></ul><p>这些开销都是值得的，它们保证了OS的操作安全、可靠！</p><h2 id="Chapter3-连续式内存分配"><a href="#Chapter3-连续式内存分配" class="headerlink" title="Chapter3 连续式内存分配"></a>Chapter3 连续式内存分配</h2><h3 id="计算机体系结构及内存分层体系"><a href="#计算机体系结构及内存分层体系" class="headerlink" title="计算机体系结构及内存分层体系"></a>计算机体系结构及内存分层体系</h3><p>分层……计组里都学过</p><h4 id="操作系统的内存管理方面的四个目标"><a href="#操作系统的内存管理方面的四个目标" class="headerlink" title="操作系统的内存管理方面的四个目标"></a>操作系统的内存管理方面的四个目标</h4><ul><li>抽象<ul><li>逻辑地址空间</li></ul></li><li>保护<ul><li>独立地址空间</li></ul></li><li>共享<ul><li>访问相同内存</li></ul></li><li>虚拟化<ul><li>更多的地址空间</li></ul></li></ul><h3 id="地址空间与地址生成"><a href="#地址空间与地址生成" class="headerlink" title="地址空间与地址生成"></a>地址空间与地址生成</h3><h4 id="1-地址空间定义"><a href="#1-地址空间定义" class="headerlink" title="1.地址空间定义"></a>1.地址空间定义</h4><p>​物理地址空间：硬件支持的地址空间</p><p>​逻辑地址空间：一个运行的程序所拥有的内存范围</p><h4 id="2-地址生成"><a href="#2-地址生成" class="headerlink" title="2.地址生成"></a>2.地址生成</h4><p>​逻辑地址生成：从变量的符号，通过一系列操作(编译、汇编、链接、载入)变为逻辑地址</p><p>​物理地址生成：已知逻辑地址，通过硬件MMU将逻辑地址映射到物理地址</p><h4 id="3-地址安全检查"><a href="#3-地址安全检查" class="headerlink" title="3.地址安全检查"></a>3.地址安全检查</h4><p>​OS记录每一个程序能够访问的地址空间(开始位置和大小)</p><p>​这个表由OS维护，CPU要执行某个程序时，OS检查该程序的地址是否满足表中的限制(不与已占用空间冲突)，能满足则正常执行；否则CPU产生内存访问异常，让OS进行进一步处理。</p><h3 id="连续内存分配：内存碎片与分区的动态分配"><a href="#连续内存分配：内存碎片与分区的动态分配" class="headerlink" title="连续内存分配：内存碎片与分区的动态分配"></a>连续内存分配：内存碎片与分区的动态分配</h3><h4 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h4><p>空闲内存不能被利用</p><ul><li>外部碎片</li></ul><p>在**分配单元<u>间</u>**的未使用内存</p><ul><li>内部碎片</li></ul><p>在**分配单元<u>中</u>**的未使用内存</p><h4 id="分区的动态分配"><a href="#分区的动态分配" class="headerlink" title="分区的动态分配"></a>分区的动态分配</h4><h5 id="常见分配策略"><a href="#常见分配策略" class="headerlink" title="常见分配策略"></a>常见分配策略</h5><h6 id="第一适配"><a href="#第一适配" class="headerlink" title="第一适配"></a>第一适配</h6><p>​放在<strong>第一个</strong>能够满足需求的空闲块中</p><p>​<strong>简单实现：</strong></p><ul><li>对空闲块列表按地址排序</li><li>分配到第一个合适的分区</li><li>回收时进行检查，看看自由分区能不能与相邻的空闲分区合并<ul><li>缺点：产生外部碎片、不确定性</li></ul></li></ul><h6 id="最佳适配"><a href="#最佳适配" class="headerlink" title="最佳适配"></a>最佳适配</h6><p>​在能放下空闲块的分区中，寻找<strong>最小</strong>的分区（避免了分割大空闲块，为了最小化外部碎片产生的尺寸）</p><p>​<strong>简单实现：</strong></p><ul><li>按尺寸排列空闲块列表</li><li>分配时需要寻找最合适的分区</li><li>回收时进行检查，看看自由分区能不能与相邻的空闲分区合并<ul><li>优势：当大部分分配是小尺寸时十分有效</li><li>劣势：会产生外部碎片，重分配(回收)慢，容易产生很多很小的内部碎片</li></ul></li></ul><p></p><h6 id="最差适配"><a href="#最差适配" class="headerlink" title="最差适配"></a>最差适配</h6><p>​在能放下空闲块的分区中，寻找<strong>最大</strong>的分区（为了避免有太多微小的碎片）</p><p>​<strong>简单实现：</strong></p><ul><li>按尺寸排列空闲块列表(从大到小)</li><li>分配时需要寻找最合适的分区(找最大的，所以找非常快)</li><li>回收时进行检查，看看自由分区能不能与相邻的空闲分区合并<ul><li>优势：分配中等大小的块效果最好</li><li>劣势：重分配慢、外部碎片、每次都使用大空闲块可能导致大分区无法被分配</li></ul></li></ul><h4 id="压缩式碎片整理"><a href="#压缩式碎片整理" class="headerlink" title="压缩式碎片整理"></a>压缩式碎片整理</h4><p>​在程序处于等待状态时，将其进行移动，从而消除外部碎片————目的是消除外部碎片</p><h4 id="交换式碎片整理"><a href="#交换式碎片整理" class="headerlink" title="交换式碎片整理"></a>交换式碎片整理</h4><p>​如果运行中的程序需要比较大的内存空间，那么可以让它<u>抢占等待中的程序的内存空间(</u>先将占用了内存空间的等待中的程序转存到硬盘中)</p><p>​问题：将哪个等待中的程序换出呢？什么时候执行换入、换出的操作呢？</p><h2 id="Chapter4-非连续式内存分配"><a href="#Chapter4-非连续式内存分配" class="headerlink" title="Chapter4 非连续式内存分配"></a>Chapter4 非连续式内存分配</h2><h3 id="连续内存分配的缺点："><a href="#连续内存分配的缺点：" class="headerlink" title="连续内存分配的缺点："></a>连续内存分配的缺点：</h3><p>​分配给一个程序的物理内存是连续的、内存利用率较低、有外、内部碎片的问题</p><h3 id="非连续内存分配的优点："><a href="#非连续内存分配的优点：" class="headerlink" title="非连续内存分配的优点："></a>非连续内存分配的优点：</h3><ul><li>更好的内存利用和管理</li><li>允许共享代码与数据</li><li>支持动态加载和动态链接</li></ul><h3 id="非连续内存分配的缺点："><a href="#非连续内存分配的缺点：" class="headerlink" title="非连续内存分配的缺点："></a>非连续内存分配的缺点：</h3><ul><li>如何建立虚拟地址与物理地址之间的联系<ul><li>硬件方案<ul><li>分段(分段和分页的区别：段的大小可以改变、页的大小是固定的)</li><li>分页</li></ul></li><li>软件方案(开销大，不展开讨论)</li></ul></li></ul><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><h4 id="程序的分段地址空间"><a href="#程序的分段地址空间" class="headerlink" title="程序的分段地址空间"></a>程序的分段地址空间</h4><p>​有堆、栈、各种部分  逻辑空间是连续的，但实际上物理地址空间毫无关联(跟分配策略有关)</p><h4 id="分段寻址方案"><a href="#分段寻址方案" class="headerlink" title="分段寻址方案"></a>分段寻址方案</h4><h5 id="段访问机制："><a href="#段访问机制：" class="headerlink" title="段访问机制："></a>段访问机制：</h5><p>​s + addr （段号 + 段内偏移）多地址空间</p><p>​s与addr一起存 单地址空间</p><p>​s通过 <strong>segment table(段表)</strong> 根据段号 查询 段所对应的物理地址，再加上偏移量就 &#x3D; 物理地址段表由OS建立</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><ul><li>逻辑空间：页物理页面：帧</li><li>物理内存被分成大小相同的帧</li></ul><p>一个程序的逻辑地址空间被划分为大小相等的页</p><p>​<strong>🌟(页内偏移大小&#x3D;帧内偏移大小；页号大小 !&#x3D; 帧号大小{在页表中，通过页号得到帧号})</strong></p><ul><li>页映射到帧</li><li>页是连续的虚拟内存</li><li>帧是非连续的物理内存</li><li>不是所有的页都有对应的帧</li></ul><h4 id="分页地址空间"><a href="#分页地址空间" class="headerlink" title="分页地址空间"></a>分页地址空间</h4><p>​帧的物理地址&#x3D;帧号 + 帧内偏移</p><h4 id="页寻址方案——页表"><a href="#页寻址方案——页表" class="headerlink" title="页寻址方案——页表"></a>页寻址方案——页表</h4><h5 id="分页机制性能问题："><a href="#分页机制性能问题：" class="headerlink" title="分页机制性能问题："></a>分页机制性能问题：</h5><h6 id="访问一个内存单元需要2次内存访问"><a href="#访问一个内存单元需要2次内存访问" class="headerlink" title="访问一个内存单元需要2次内存访问"></a>访问一个内存单元需要2次内存访问</h6><p>​        1.用于获取页表项</p><p>​2.根据获得的页表项访问数据</p><h6 id="页表可能非常大"><a href="#页表可能非常大" class="headerlink" title="页表可能非常大"></a>页表可能非常大</h6><h5 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h5><h6 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h6><p>​TLB：缓存近期访问的页-帧转换表项(TLB存于Cache中)</p><h6 id="间接访问"><a href="#间接访问" class="headerlink" title="间接访问"></a>间接访问</h6><p>​二级、多级页表：多次寻址速度降低，但是缩减了页表(时间换空间，但是可以通过TLB提速！)</p><h6 id="反向页表-说实话没听明白，先挖个坑，回顾时填上"><a href="#反向页表-说实话没听明白，先挖个坑，回顾时填上" class="headerlink" title="反向页表(说实话没听明白，先挖个坑，回顾时填上)"></a><u>反向</u>页表(说实话没听明白，先挖个坑，回顾时填上)</h6><p>​程序的地址空间很大时，逻辑地址空间会大于内存的物理地址空间</p><p>​这时 我们<u>不是让页表与逻辑地址空间的大小相对应</u>，而是<strong>让页表与物理地址空间的大小相对应</strong></p><p>​利：</p><ul><li><p>转换表的大小相对于物理内存来说很小</p></li><li><p>转换表的大小跟逻辑地址空间的大小无关</p><p>弊：</p></li><li><p>需要的信息对调了，即现在只能根据帧号找到页号</p></li><li><p>如何转换回来？即如何根据页号找到帧号？</p></li><li><p>需要在反向页表中搜索想要的页号</p></li></ul><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*如何实现呢？</span></span><br><span class="line"><span class="comment">*对页号做hash计算，为了在“帧表”中获取对应的帧号</span></span><br><span class="line"><span class="comment">*页i被放置在“帧表”中f(i)的位置 #f为hash函数</span></span><br><span class="line"><span class="comment">*为了查找页i，执行以下操作：</span></span><br><span class="line"><span class="comment">*对于页i，计算f(i)并使用它作为页寄存器表的索引，获取对应的页寄存器</span></span><br><span class="line"><span class="comment">*检查寄存器标签是否包含i，如果包含，则代表成功获取帧号，否则失败。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Chapter5-虚拟内存"><a href="#Chapter5-虚拟内存" class="headerlink" title="Chapter5 虚拟内存"></a>Chapter5 虚拟内存</h2><h3 id="覆盖技术："><a href="#覆盖技术：" class="headerlink" title="覆盖技术："></a>覆盖技术：</h3><p>​为了在较小的内存中运行较大的程序，常用于多道程序系统，与分区存储管理配合使用</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h4><p>目标：把程序按照其自身逻辑结构，划分为若干个功能上相对独立的程序模块那些不会同时执行的模块共享同一块内存区域，按时间先后来运行。</p><ul><li><p>必要部分 (常用功能)的代码和数据<strong>常驻内存</strong></p></li><li><p>可选部分(不常用功能)在其他程序模块中实现,<u><em>平时存放在外存中，在需要用到时才装入内存</em></u>;</p><ul><li>不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖,即这些模块共用一个分区。</li></ul></li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>程序的划分复杂，费时费力</li><li>经常性的从外存读取数据，实际上是时间换空间</li><li>需要程序员自己把整个程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，增加了程序员的负担;</li></ul><h3 id="交换技术："><a href="#交换技术：" class="headerlink" title="交换技术："></a>交换技术：</h3><p>​多道程序在内存中时,让正在运行的程序或需要运行的程序获得更多的内存资源。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理:"></a>原理:</h4><ul><li>​可将暂时不能运行的程序送到外存，从而获得空闲内存空间。</li><li>​操作系统把一个进程的整个地址空间的内容保存到外存中(换出swap out)，而将外存中的某个进程的地址空间读入到内存中(换入swap in)。换入换出内容的大小为整个程序的地址空间。</li></ul><p></p><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><ul><li>何时交换？<ul><li>只有当内存不够或者有不够的风险时进行交换</li></ul></li><li>交换区的大小<ul><li>必须足够存放用户进程中所有内存映像的拷贝</li><li>必须能对这些内存映像进行直接存取</li></ul></li><li>交换技术:以进程作为交换的单位，需要把进程的整个地址空间都换进换出，增加了处理器的开销。</li></ul><h3 id="覆盖与交换的比较："><a href="#覆盖与交换的比较：" class="headerlink" title="覆盖与交换的比较："></a>覆盖与交换的比较：</h3><p><strong>覆盖技术</strong>只能发生在那些相互之间没有调用关系的程序模块之间。因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构。(移动的最小粒度为一个程序)</p><p><strong>交换技术</strong>是以在内存中的程序大小为单位来进行的，它不需要程序员给出各个模块之间的逻辑覆盖结构。(移动的最小粒度为程序的一个子模块)</p><p>换言之，交换发生在内存中程序与管理程序或操作系统之间，而覆盖则发生在运行程序的内部。</p><h3 id="虚存技术："><a href="#虚存技术：" class="headerlink" title="虚存技术："></a>虚存技术：</h3><p>像覆盖技术那样，<u>不是把程序的所有内容都放在内存中</u>，因而能够运行比当前的空闲内存空间还要大的程序。但做得更好，由<u>操作系统自动来完成，无须程序员的干涉;</u></p><p>像交换技术那样，能够实现进程在内存与外存之间的交换，因而获得更多的空闲内存空间。但做得更好，<u>只对进程的部分内容在内存和外存之间进行交换。</u></p><h4 id="程序的局部性原理-principle-of-locality"><a href="#程序的局部性原理-principle-of-locality" class="headerlink" title="程序的局部性原理(principle of locality):"></a>程序的局部性原理(principle of locality):</h4><p>​指程序在执行过程中的<strong>一个较短时期</strong>，所执行的指令地址和指令的操作数地址，分别<strong>局限于一定区域</strong>。这可以表现为:</p><ul><li><u>时间局部性</u>:一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内;</li><li><u>空间局部性</u>:当前指令和邻近的几条指令，当前访问的数据和邻近的几个数据都集中在一个较小区域内。</li></ul><p>程序的局部性原理表明，从理论上来说，虚拟存储技术是能够实现的，而且在实现了以后应该是能够取得一个满意的效果的。</p><h4 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h4><p>​可以在页式或段式内存管理的基础上实现</p><ul><li><p>在装入程序时，不必将其全部装入到内存，而只需将当前需要执行的部分页面或段装入到内存，就可让程序开始执行；</p></li><li><p>在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序；</p></li><li><p>另一方面，操作系统将内存中暂时不使用的页面或段调出保存在外存上，从而腾出更多空闲空间存放将要装入的程序以及将要调入的页面或段。</p></li></ul><h4 id="基本特征："><a href="#基本特征：" class="headerlink" title="基本特征："></a>基本特征：</h4><ul><li><p>大的用户空间：通过把物理内存与外存相结合，提供给用户的虚拟内存空间通常大于实际的物理内存，即实现了这两者的分离。如32位的虚拟地址理论上可以访问4GB，而可能计算机上仅 有256M的物理内存，但硬盘容量大于4GB。</p></li><li><p>部分交换：与交换技术相比较，虚拟存储的调入和调出是对部分虛拟地址空间进行的：</p></li><li><p>不连续性：物理内存分配的不连续，虚拟地址空间使用的不连续。</p></li></ul><h4 id="虚拟页式内存管理："><a href="#虚拟页式内存管理：" class="headerlink" title="虚拟页式内存管理："></a>虚拟页式内存管理：</h4><ul><li><p>大部分虚拟存储系统都采用虚拟页式存储管理技术，即在<strong>页式存储管理</strong>的基础上，<strong>增加</strong><u>请求调页和页面置换功能</u>。</p></li><li><p>基本思路：</p><ul><li>当一个用户程序要调入内存运行时，<u>不是将该程序的所有页面都装入内存，而是只装入部分的页面</u>，就可启动程序运行。</li><li>在运行的过程中，如果发现要运行的程序或要访问数据<u>不在内存，则向系统发出缺页中断请求</u>，系统在处理这个中断时，将外存中相应的页面调入内存，使得该程序能够继续运行。</li></ul></li></ul><h5 id="页表表项需要增加："><a href="#页表表项需要增加：" class="headerlink" title="页表表项需要增加："></a>页表表项需要增加：</h5><ol><li><strong>驻留位：1表示该页在内存中；0表示在外存中</strong></li><li><strong>保护位</strong>：表示允许对该页做何种类型的访问，如只读、可读写、可执行等</li><li><strong>修改位</strong>：表明此页在内存中是否被修改过。若修改过，在回收此页时需要把这个页的内容同步到外存。</li><li><strong>访问位</strong>：如果最近被访问过，置为1；用于页面置换算法</li></ol><h5 id="缺页中断处理过程："><a href="#缺页中断处理过程：" class="headerlink" title="缺页中断处理过程："></a>缺页中断处理过程：</h5><ol><li><p>如果在内存中有空闲的物理页面，则分配一物理页帧f，然后转第4步：否则转第2步：</p></li><li><p>采用某种页面置换算法，选择一个将被替换的物理页帧f，它所对应的逻辑页为q。如果该页在内存期间被修改过，则需把它写回外存；</p></li><li><p>对q所对应的页表项进行修改，把驻留位置为0；</p></li><li><p>将需要访问的页p裝入到物理页面f当中；</p></li><li><p>修改p所对应的页表项的内容，把驻留位置为1，把物理页帧号置为f</p></li><li><p>重新运行被中断的指令。</p></li></ol><h5 id="后备存储-Backing-Store"><a href="#后备存储-Backing-Store" class="headerlink" title="后备存储 Backing Store"></a>后备存储 Backing Store</h5><h6 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h6><ul><li><p>一个虚拟地址空间的页面可以被映射到一个文件（在二级存储中）中的某个位置</p></li><li><p>代码段：映射到可执行二进制文件</p></li><li><p>动态加载的共享库程序段：映射到动态调用的库文件</p></li><li><p>其它段：可能被映射到交换文件(swap file)</p></li></ul><p>​在何处保存未被映射的页？</p><ul><li><p>能够简单地识别在二级存储器中的页</p></li><li><p>交换空间（磁盘或者文件）：特殊格式，用于存储末被映射的页面</p></li></ul><h2 id="Chapter6-页面置换算法"><a href="#Chapter6-页面置换算法" class="headerlink" title="Chapter6 页面置换算法"></a>Chapter6 页面置换算法</h2><h3 id="局部页面置换算法"><a href="#局部页面置换算法" class="headerlink" title="局部页面置换算法"></a>局部页面置换算法</h3><h4 id="功能与目标"><a href="#功能与目标" class="headerlink" title="功能与目标"></a>功能与目标</h4><p><strong>功能</strong>：缺页，但主存满了，换谁出去？</p><p><strong>目标</strong>：<strong>尽可能减少页面更换的次数</strong>，(通常在局部性原理指导下依据过去的统计数据进行预测)</p><p>&lt;页面锁定&gt;:有些页面必须常驻于内存中，不应参与页面置换算法。(通过在页表中添加 ‘锁定标志位,lock bit’ 判断)</p><h4 id="6-1最优页面置换算法"><a href="#6-1最优页面置换算法" class="headerlink" title="6.1最优页面置换算法"></a>6.1最优页面置换算法</h4><p>​是一种理想情况下的页面置换算法, 该算法使用的前提是OS提前知道接下来要访问的页面，换出近期最不会被用到的页面。</p><p>无实际意义，但可以用于评价别的算法的性能，作为一个理想的标杆</p><h4 id="6-2FIFO算法"><a href="#6-2FIFO算法" class="headerlink" title="6.2FIFO算法"></a>6.2FIFO算法</h4><p>系统维护一个页面的链表，<strong>每次淘汰驻留时间最长的页面</strong>(一个已经在链表中的页面再次被使用并不会刷新该页面的驻留时间，而是继续按原来的计时)</p><p><strong>性能较差</strong>，调出的页面可能是经常被调用的页面，并且有**<u><em>Belady现象</em></u>**</p><h4 id="6-3最近最久未使用算法-LRU"><a href="#6-3最近最久未使用算法-LRU" class="headerlink" title="6.3最近最久未使用算法(LRU)"></a>6.3最近最久未使用算法(LRU)</h4><p>当缺页中断发生时，选择淘汰最久未使用的页面（根据历史，推测未来，依据程序的访问具有局部性</p><p>​LRU算法需要记录每个页面使用时间的先后顺序，<u><strong>开销比较大</strong></u></p><p>两种可能的实现方法：</p><ul><li>维护一个链表，运行新页面：则放在链表头；运行链表中出现过的页面：将该结点移动到链表头部；若要淘汰页面，则删除队尾的页面。</li><li>维护一个栈，刚使用的页面放在栈顶，如果栈中已经有该页面则还需要将栈中记录删去，若要淘汰页面，则删除栈底部的页面(ps:没啥区别啊)</li></ul><h4 id="6-4时钟页面置换算法"><a href="#6-4时钟页面置换算法" class="headerlink" title="6.4时钟页面置换算法"></a>6.4时钟页面置换算法</h4><ul><li>clock页面置换算法，LRU的近似，是对FIFO的一种改进：</li></ul><h5 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h5><ul><li><p>﻿﻿需要用到页表项当中的访问位，当一个页面被装入内存时，把该位初始化为0。然后如果这个页面被访问（读&#x2F;写)，则把该位置为1;</p></li><li><p>﻿把各个页面组织成环形链表（类似钟表面），把指针指向最老的页面（最<br> 先进来）；</p></li><li><p>当发生一个缺页中断时，考察指针所指向的最老页面，若它的访问位为0，立即淘汰：若访问位为1，则把该位置为0，然后指针往下移动一格。如此下去，直到找到被淘汰的页面，然后把指针移动到它的下一格。</p></li></ul><h4 id="6-5二次机会法"><a href="#6-5二次机会法" class="headerlink" title="6.5二次机会法"></a>6.5二次机会法</h4><p><strong>添加脏位</strong>(用于标识有没有被写过)，如果被淘汰的页只被读过，则直接删除；如果该页面被修改过，就需要将更新的数据同步至硬盘。</p><p>用访问位、脏位两个位来判断被淘汰的页面，只有都为0的页面才会立即被淘汰，有1的页面会首先失去一个1，幸免于本轮循环。(脏位由1变0时，也需要写回硬盘)</p><p>给修改过的页面更多的机会留在主存中(<u>其实只针对一种情况：访问位、脏位都为1时，页面被循环轮到后会先把访问位置为0，而不是改变脏位，这样就相当于给这个页面多一条命！</u>)——通过减少写回硬盘的次数来降低开销</p><h4 id="6-6最不常用法"><a href="#6-6最不常用法" class="headerlink" title="6.6最不常用法"></a>6.6最不常用法</h4><p>Least frequency used LFU:</p><h5 id="基本思路：-1"><a href="#基本思路：-1" class="headerlink" title="基本思路："></a>基本思路：</h5><p>​当一个缺页中断产生时，选择被访问次数最少的页面淘汰</p><p>​给主存中的每个页都安排一个计数器，淘汰计数器值最小的页面</p><p>缺点：计数器开销大</p><h4 id="6-7Belady现象"><a href="#6-7Belady现象" class="headerlink" title="6.7Belady现象"></a>6.7Belady现象</h4><p>​在采用FIFO算法时，有时会出现分配的物理页面数增加，缺页率反而提高的现象；</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230605214433150.png" alt="image-20230605214433150" style="zoom:30%;" /><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230605214507498.png" alt="image-20230605214507498" style="zoom:31%;" /><h4 id="6-8局部页面替换算法的问题、工作集模型"><a href="#6-8局部页面替换算法的问题、工作集模型" class="headerlink" title="6.8局部页面替换算法的问题、工作集模型"></a>6.8局部页面替换算法的问题、工作集模型</h4><p><strong>工作集：一个进程当前正在使用的逻辑页面集合，可以用一个二元函数w(t，∆)来表示</strong></p><ul><li><p>t是当前的执行时刻；</p></li><li><p>∆称为工作集窗口 (working set window），即一个定长的页面访问的时同窗口：</p></li><li><p>w(t，∆)一在当前时刻 t 之前的 ∆时间窗口当中的所有页面所组成的集合(随着 t 的变化，该集合也在不断地变化）</p></li><li><p>|w(t，∆）|指工作集的大小，即页面数目。</p></li></ul><p><strong>常驻集：是指在当前时刻，进程实际驻留在内存当中的页面集合。</strong></p><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ol><li><p>工作集是进程在运行过程中固有的性质，而常驻集取决于系统分配给进程的物理页面数日，以及所采用的页面置换算法；</p></li><li><p>如果一个进程的整个工作集都在内存当中，即常驻集&gt;&#x3D;工作集，那么进程将很顺利地运行，而不会造成太多的缺页中断（直到工作集发生剧烈变动，从而过渡到另一个状态）</p></li><li><p>当进程常驻集的大小达到某个数目之后，再给它分配更多的物理页面，缺页率也不会明显下降。</p></li></ol><h3 id="全局页面置换算法："><a href="#全局页面置换算法：" class="headerlink" title="全局页面置换算法："></a>全局页面置换算法：</h3><h4 id="1-工作集页面置换算法"><a href="#1-工作集页面置换算法" class="headerlink" title="1.工作集页面置换算法"></a>1.工作集页面置换算法</h4><p>​如果页面不在工作集中，那么即使没有发生缺页中断，也会把该页面换出。</p><p>​每次都看看自己的常驻集和工作集，常驻集里有，但工作集中没有的页面都会被移除</p><h4 id="2-缺页率页面置换算法"><a href="#2-缺页率页面置换算法" class="headerlink" title="2.缺页率页面置换算法"></a>2.缺页率页面置换算法</h4><h5 id="可变分配策路："><a href="#可变分配策路：" class="headerlink" title="可变分配策路："></a>可变分配策路：</h5><p>​常驻集大小可变，例如：每个进程在刚开始运行的时候，先根据程序大小给它分配一定数目的物理页面，然后在进程运行过程中，再<u>动态地调整常驻集的大小</u>。</p><ul><li>可采用全局页面置换的方式。当发生一个缺页中断时，被置换的页面可以是在其它进程当中，各个并发进程竞争地使用物理页面。</li><li>优缺点：性能较好。但增加了系统开销。</li><li>具体实现：可以使用<strong>缺页率算法</strong> (PPF, page fault freguency)来动态调整常驻集的大小。</li></ul><p><strong>🌟如何动态地调整常驻集的大小？</strong></p><p>​设置一个阈值k，将本次发生缺页的下标 - 上次发生缺页的下标 与 k 进行比较，</p><ul><li><p>如果k比较大，说明中断异常出现的太频繁了，直接将缺失页加入到工作集中(扩大工作集，降低缺页概率)</p></li><li><p>如果k比较小，说明不怎么出现中断，那么执行下述操作：将工作集中不在[t_last, t_current]区间内出现的页面移除   (t_last, t_current指上一次、这次出现中断异常的时间下标)</p></li></ul><h3 id="抖动问题："><a href="#抖动问题：" class="headerlink" title="抖动问题："></a>抖动问题：</h3><ul><li>﻿如果分配给一个进程的物理页面太少，不能包含整个的工作集，即常驻集＜ 工作集，那么进程将会造成很多的缺页中断，需要频繁地在内存与外存之间替换页面，从而使进程的运行速度变得很慢，我们把这种狀态称为 “抖动”。</li><li>﻿产生抖动的原因：随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减小，导致缺页率不断上升。所以<strong>os要选择一个适当的进程数目和进程需要的帧数</strong>，以便在并发水平和缺页率之间达到一个平衡。</li></ul><p>抖动问题在一些情况下可以被本地的页面置换算法改善</p><h2 id="Chapter7-进程和线程"><a href="#Chapter7-进程和线程" class="headerlink" title="Chapter7 进程和线程"></a>Chapter7 进程和线程</h2><h3 id="7-1进程-process-的描述"><a href="#7-1进程-process-的描述" class="headerlink" title="7.1进程(process)的描述"></a>7.1进程(process)的描述</h3><h4 id="进程定义："><a href="#进程定义：" class="headerlink" title="进程定义："></a>进程定义：</h4><p>​一个具有一定功能的程序在一个数据集合上的一次动态执行的过程</p><h4 id="进程组成："><a href="#进程组成：" class="headerlink" title="进程组成："></a>进程组成：</h4><p>包含了一个正在运行的程序的所有状态信息</p><pre><code>        1. 程序的代码        1. 程序处理的数据        1. 程序计数器的值，指示下一条即将运行的指令        1. 一组通用的寄存器的当前值，堆、栈        1. 一组系统资源(如打开的程序)</code></pre><h5 id="进程与程序的联系："><a href="#进程与程序的联系：" class="headerlink" title="进程与程序的联系："></a>进程与程序的联系：</h5><ul><li>﻿程序是产生进程的基础</li><li>﻿<u>程序的每次运行构成不同的进程</u></li><li>﻿进程是程序功能的体现</li><li>﻿通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序。</li></ul><h5 id="进程与程序的区别："><a href="#进程与程序的区别：" class="headerlink" title="进程与程序的区别："></a>进程与程序的区别：</h5><ul><li><p>进程是动态的，程序是静态的：程序是有序代码的集合；进程是程序的执行，进程有核心态&#x2F;用户态</p></li><li><p>进程是暂时的，程序的永久的：进程是一个状态变化的过程，程序可长久保存</p></li><li><p>进程与程序的组成不同：进程的组成包括**<u>程序、数据和进程控制块</u>**（即进程状态信息）</p></li></ul><h4 id="进程的特点："><a href="#进程的特点：" class="headerlink" title="进程的特点："></a>进程的特点：</h4><ul><li>﻿动态性：可动态地创建、结束进程；</li><li>﻿并发性：进程可以被独立调度并占用处理机运行；(并发-&gt;串、并行-&gt;并)</li><li>﻿独立性：不同进程的工作不相互影响：</li><li>﻿制约性：因访问共享数据&#x2F;资源或进程间同步而产生制约。</li></ul><h4 id="进程控制结构："><a href="#进程控制结构：" class="headerlink" title="进程控制结构："></a>进程控制结构：</h4><p>​程序 &#x3D; 算法 + 数据结构</p><p>​描述进程的数据结构：<strong>进程控制块</strong>(Process Control Block, PCB)</p><p>进程控制块：OS管理进程运行所用信息的集合，OS用PCB描述<u>进程的基本情况及运行变化的过程</u>，PCB是进程存在的<strong>唯一标志。</strong></p><h5 id="PCB中包含的内容："><a href="#PCB中包含的内容：" class="headerlink" title="PCB中包含的内容："></a>PCB中包含的内容：</h5><ol><li><p><strong>进程标识信息</strong>。如本进程的标识，本进程的产生者标识(父进程标识)；用户标识。</p></li><li><p><strong>处理机状态信息保存区</strong>。保存进程的运行现场信息：</p><ul><li><p>﻿用户可见寄存器，用户程序可以使用的数据，地址等寄存器。</p></li><li><p>﻿控制和状态寄存器，如程序计数器(PC)，程序状态字 (PSW)。</p></li><li><p>﻿栈指针，过程调用&#x2F;系统调用&#x2F;中断处理和返回时需要用到它。</p></li></ul></li><li><p><strong>进程控制信息</strong></p></li></ol><ul><li><p>调度和状态信息，用于操作系统调度进程并占用处理机使用。</p></li><li><p>进程间通信信息，为支持进程问的与通信相关的各种标识、信号、信件等，这些信息存在接收方的进程控制块中。</p></li><li><p>存储管理信息，包含有指向本进程映像存储空间的数据结构。</p></li><li><p>﻿进程所用资源，说明由进程打开、使用的系统资源，如打开的文件等。</p></li><li><p>﻿有关数据结构连接信息，进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB。</p></li></ul><h5 id="PCB的组织方式"><a href="#PCB的组织方式" class="headerlink" title="PCB的组织方式"></a>PCB的组织方式</h5><ul><li>链表(常用)：同一状态的进程其PCB成一链表，多个状态对应多个不同的链表</li></ul><p>各状态的进程形成不同的链表：就绪链表、阻塞链表</p><ul><li>索引表：同一状态的进程归入一个index表（由index指向PCB)，多个状态对应多个不同的index表</li></ul><p>各状态的进行形成不同的索引表：就绪索引表、阻塞索引表</p><h3 id="7-2进程状态"><a href="#7-2进程状态" class="headerlink" title="7.2进程状态"></a>7.2进程状态</h3><h4 id="进程生命周期管理"><a href="#进程生命周期管理" class="headerlink" title="进程生命周期管理"></a>进程生命周期管理</h4><h5 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h5><h6 id="引起进程创建的三个主要事件："><a href="#引起进程创建的三个主要事件：" class="headerlink" title="引起进程创建的三个主要事件："></a>引起进程创建的三个主要事件：</h6><pre><code>    1. 系统初始化时(创建init进程)    2. **用户请求**创建一个新进程    3. 正在运行的**进程执行**了创建进程的系统调用</code></pre><h5 id="进程运行"><a href="#进程运行" class="headerlink" title="进程运行"></a>进程运行</h5><h6 id="内核选择一个就绪的进程，让它占用处理机并执行"><a href="#内核选择一个就绪的进程，让它占用处理机并执行" class="headerlink" title="内核选择一个就绪的进程，让它占用处理机并执行"></a>内核选择一个就绪的进程<strong>，让它占用处理机</strong>并执行</h6><h5 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h5><h6 id="以下情况下，进程等待："><a href="#以下情况下，进程等待：" class="headerlink" title="以下情况下，进程等待："></a>以下情况下，进程等待：</h6><ol><li>﻿<strong>请求并等待系统服务</strong>，无法马上完成</li><li>﻿<strong>启动某种操作</strong>，无法马上完成</li><li>﻿<strong>需要的数据没有到达</strong></li></ol><p><u>进程只能自己阻塞自己，因为只有进程自身才能知道何时需要等待某种事件的发生。</u></p><h5 id="进程唤醒"><a href="#进程唤醒" class="headerlink" title="进程唤醒"></a>进程唤醒</h5><h6 id="唤醒进程的原因："><a href="#唤醒进程的原因：" class="headerlink" title="唤醒进程的原因："></a>唤醒进程的原因：</h6><ol><li>﻿被阻塞进程需要的资源可被满足</li><li>﻿被阻塞进程等待的事件到达</li><li>﻿将该进程的PCB插入到就绪队列</li></ol><p><u>进程只能被别的进程或操作系统唤醒。</u></p><h5 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h5><h6 id="在以下四种情形下，进程结束："><a href="#在以下四种情形下，进程结束：" class="headerlink" title="在以下四种情形下，进程结束："></a>在以下四种情形下，进程结束：</h6><ul><li><p>正常退出（自愿的）</p></li><li><p>错误退出（自愿的）</p></li><li><p>致命错误（强制性的）</p></li><li><p>被其他进程所杀（强制性的）</p></li></ul><h4 id="进程状态变化模型"><a href="#进程状态变化模型" class="headerlink" title="进程状态变化模型"></a>进程状态变化模型</h4><h5 id="进程的三种基本状态："><a href="#进程的三种基本状态：" class="headerlink" title="进程的三种基本状态："></a>进程的三种<u>基本</u>状态：</h5><p>​进程在生命结束前处于且仅处于三种基本状态之一</p><ul><li><p>运行状态(Running)：当一个进程正在处理机上运行时。</p></li><li><p>就绪状态(Ready)：一个进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。</p></li><li><p>等待状态（又称阻塞状态Blocked)：一个进程正在等待某一事件而暂停运行时。如等待某资源，等待输入&#x2F;输出完成。</p></li></ul><h5 id="进程其它的基本状态："><a href="#进程其它的基本状态：" class="headerlink" title="进程其它的基本状态："></a>进程其它的基本状态：</h5><ul><li><p>创建状态(New)：一个进程正在被创建，还没被转到就绪状态之前的状态。</p></li><li><p>结束状态(Exit)：一个进程正在从系统中消失时的状态，这是因为进程结束或由于其他原因所导致。</p></li></ul><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230606110651191.png" alt="image-20230606110651191" style="zoom:50%;" /><h4 id="进程挂起模型"><a href="#进程挂起模型" class="headerlink" title="进程挂起模型"></a>进程挂起模型</h4><p> 进程挂起：进程不占用内存空间，处于挂起状态的进程映像在磁盘上。</p><h5 id="挂起状态："><a href="#挂起状态：" class="headerlink" title="挂起状态："></a>挂起状态：</h5><ul><li>﻿阻塞挂起状态 (Blocked-suspend）：进程在外存并<strong>等待某事件的出现</strong>；</li><li>﻿就绪挂起状态 (Ready-suspend）：进程在外存，但<strong>只要进入内存，即可运行</strong>；</li></ul><h5 id="挂起-Suspend）：把一个进程从内存转到外存；可能有以下几种情况："><a href="#挂起-Suspend）：把一个进程从内存转到外存；可能有以下几种情况：" class="headerlink" title="挂起 (Suspend）：把一个进程从内存转到外存；可能有以下几种情况："></a>挂起 (Suspend）：把一个进程从内存转到外存；可能有以下几种情况：</h5><ul><li><p>﻿阻塞到阻塞挂起：没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以提交新进程或运行就绪进程；</p></li><li><p>﻿就绪到就绪挂起：当有高优先级阻塞(系统认为会很快就绪的）进程和低优先就绪进程时，系统会选择挂起低优先级就绪进程；</p></li><li><p>﻿运行到就绪挂起：对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态；</p></li></ul><h5 id="在外存时的状态转换："><a href="#在外存时的状态转换：" class="headerlink" title="在外存时的状态转换："></a>在外存时的状态转换：</h5><ul><li>﻿阻塞挂起到就绪挂起：当有阻塞挂起进程因相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程。</li></ul><h5 id="解挂-x2F-激活-Activate）：把一个进程从外存转到内存；可能有以下几种情况："><a href="#解挂-x2F-激活-Activate）：把一个进程从外存转到内存；可能有以下几种情况：" class="headerlink" title="解挂&#x2F;激活 (Activate）：把一个进程从外存转到内存；可能有以下几种情况："></a>解挂&#x2F;激活 (Activate）：把一个进程从外存转到内存；可能有以下几种情况：</h5><ul><li>﻿就绪挂起到就绪：没有就绪进程或挂起就绪进程优先级高于就绪进程时，会进行这种转换；</li><li>﻿阻塞挂起到阻塞：当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起（系统认为会很快出现所等待的事件）进程转换为阻塞进程；</li></ul><h5 id="OS如何通过PCB完成进程的调度？"><a href="#OS如何通过PCB完成进程的调度？" class="headerlink" title="OS如何通过PCB完成进程的调度？"></a>OS如何通过PCB完成进程的调度？</h5><h6 id="🌟状态队列"><a href="#🌟状态队列" class="headerlink" title="🌟状态队列"></a>🌟状态队列</h6><ul><li><p>﻿由操作系统来维护一组队列，用来表示系统当中所有进程的当前状态；</p></li><li><p>﻿<u><strong>不同的状态分别用不同的队列来表示</strong></u>(就绪队列、各种类型的阻塞队列）；</p></li><li><p>每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生变化时，它的PCB从一个状态队列中脱离出来，加入到另外一个队列。</p></li></ul><h3 id="7-3线程"><a href="#7-3线程" class="headerlink" title="7.3线程"></a>7.3线程</h3><h4 id="为什么需要线程？"><a href="#为什么需要线程？" class="headerlink" title="为什么需要线程？"></a>为什么需要线程？</h4><p>​处理并行操作时，如果使用<strong>多进程</strong>方式，会导致开销巨大(进程占用资源、进程切换占用时间、进程共享数据产生开销)</p><p>​因此，我们亟需提出一种实体，满足：1）实体之间可以并发运行；2）实体之间共享地址空间</p><p>​于是 <strong>线程</strong> 被提出！</p><h4 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h4><p>​＞<em>进程当中的一条执行流程。</em></p><p>从两个方面来重新理解进程</p><ul><li>﻿从资源组合的角度：<strong>进程</strong>把一组相关的资源组合起来，<strong>构成了一个资源平台（环境）</strong>，包括地址空间（代码段、数据段）、打开的文件等各种资源；</li><li>﻿从运行的角度：代码在这个资源平台上的一条执行流程（线程）。</li></ul><h5 id="线程的优点："><a href="#线程的优点：" class="headerlink" title="线程的优点："></a>线程的优点：</h5><ul><li>﻿一个进程中可以同时存在多个线程；</li><li>﻿各个线程之间可以并发地执行；</li><li>﻿各个线程之间可以共享地址空间和文件等资源。</li></ul><h5 id="线程的缺点："><a href="#线程的缺点：" class="headerlink" title="线程的缺点："></a>线程的缺点：</h5><ul><li><strong>一个线程崩溃，会导致其所属进程的所有线程崩溃</strong>。(因为线程间共享数据，因此一个线程的数据错误了，其他线程都要遭殃)</li></ul><h5 id="线程所需的资源："><a href="#线程所需的资源：" class="headerlink" title="线程所需的资源："></a>线程所需的资源：</h5><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230606161910704.png" alt="image-20230606161910704" style="zoom:50%;" /><h5 id="线程与进程的比较"><a href="#线程与进程的比较" class="headerlink" title="线程与进程的比较"></a>线程与进程的比较</h5><ul><li><p>﻿进程是资源分配单位，线程是CPU调度单位；</p></li><li><p>﻿进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</p></li><li><p>﻿线程同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系；</p></li><li><p>﻿线程能减少并发执行的时间和空间开销：</p><ul><li><p>线程的创建时间比进程短；(线程无需创建代码块、数据、文件的管理信息)</p></li><li><p>线程的终止时间比进程短；(线程无需创建代码块、数据、文件的管理信息)</p></li><li><p>同一进程内的线程切换时间比进程短；(在同一进程中的线程具有同一个页表，切换时无需切换页表)</p></li><li><p>由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信；</p></li></ul></li></ul><h4 id="线程的实现："><a href="#线程的实现：" class="headerlink" title="线程的实现："></a>线程的实现：</h4><p>​三种主要的实现方式：</p><pre><code> 1. 用户线程：在用户空间实现 2. 内核线程：在内核中实现 3. 轻量级线程：在内核中实现，支持用户线程</code></pre><h5 id="🌟用户线程："><a href="#🌟用户线程：" class="headerlink" title="🌟用户线程："></a>🌟用户线程：</h5><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230606163157885.png" alt="image-20230606163157885" style="zoom:50%;" /><p>OS看不到TCB，只能看到PCB，只知道进程信息，进程中的线程信息由线程库管理。</p><p>在用户空间实现的线程机制，它<strong>不依赖于操作系统的内核</strong>，<strong>由一组用户级的线程库函数来完成线程的管理</strong>，包括进程的创建、终止、同步和调度等。</p><h6 id="用户线程的优点："><a href="#用户线程的优点：" class="headerlink" title="用户线程的优点："></a>用户线程的优点：</h6><ul><li>﻿由于用户线程的维护由相应进程来完成 （通过线程库函数），不需要操作系统内核了解用户线程的存在，<u>可用于不支持线程技术的多进程操作系统；</u></li><li>﻿每个进程都需要它自己私有的线程控制块（TCB）列表，用来跟踪记录它的各个线程的状态信息 (PC、栈指针、寄存器），TCB由线程库函数来维护；</li><li>﻿用户线程的切换也是由线程库函数来完成．无需用户态&#x2F; 核心态切换，所以速度特别快；</li><li>﻿允许每个进程拥有自定义的线程调度算法。</li></ul><h6 id="用户线程的缺点："><a href="#用户线程的缺点：" class="headerlink" title="用户线程的缺点："></a>用户线程的缺点：</h6><ul><li>﻿阻塞性的系统调用如何实现？如果一个线程发起系统调用而阻塞，则整个进程在等待；(因为OS在内核态中只能管理进程，而不能单独地把进程中的某个线程阻塞)</li><li>﻿当一个线程开始运行后，除非它主动地交出CPU的使用权，否则它所在的进程当中的其他线程将无法运行；(同样，因为OS只能管理进程，因为只有OS有管理中断的权利，但是OS看不到线程)</li><li>﻿由于时间片分配给进程，故与其它进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢。</li></ul><h5 id="🌟内核线程："><a href="#🌟内核线程：" class="headerlink" title="🌟内核线程："></a>🌟内核线程：</h5><p>​<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230606164400117.png" alt="image-20230606164400117" style="zoom:50%;" /></p><p><strong>TCB也放在内核中</strong></p><p>是指在操作系统<u>的内核当中实现的一种线程机制</u>，由操作系统的内核来完成线程的创建、终止和管理。</p><ul><li>﻿在支持内核线程的操作系统中，**<u>由内核来维护进程和线程的上下文信息 （PCB和TCB）</u>**；</li><li>﻿线程的创建、终止和切换都是通过系统调用&#x2F;内核函数的方式来进行，由内核来完成，因此系统开销较大；</li><li>在一个进程当中，如果某个内核线程发起系统调用而被阳塞，井不会影响其他内核线程的运行：</li><li>时间片分配给线程，多线程的进程获得更多CPU时间；</li><li>Windows NT和windows 2000&#x2F;xP支持内核线程。</li></ul><h5 id="🌟轻量级进程-了解"><a href="#🌟轻量级进程-了解" class="headerlink" title="🌟轻量级进程(了解)"></a>🌟轻量级进程(了解)</h5><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230606164824053.png" alt="image-20230606164824053" style="zoom:30%;" /><h3 id="7-4上下文切换"><a href="#7-4上下文切换" class="headerlink" title="7.4上下文切换"></a>7.4上下文切换</h3><p>​停止当前运行进程(从运行状态改变成其他状态）并且调度其他进程（转变成运行状态）</p><ul><li>﻿必须在切换之前存储许多部分的进程上下文</li><li>﻿必须能够在之后恢复他们，所以进程不能显示它曾经被暂停过</li><li>﻿必须快速（上下文转换时非常频繁的）</li></ul><p>​需要存储什么上下文？</p><ul><li><p>寄存器(PC, SP， …)，CPU状态，……</p></li><li><p>一些时候可能会费时，所以我们应该尽可能避免</p></li></ul><h3 id="7-5进程控制"><a href="#7-5进程控制" class="headerlink" title="7.5进程控制"></a>7.5进程控制</h3><h4 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h4><p>fork函数：fork函数用于<u>从已经存在的进程中创建一个新的进程</u>。新的进程称为子进程，而原来的进程是父进程。</p><p><strong><u><em>返回值：子进程中返回0，父进程返回子进程id，出错返回-1</em></u></strong></p><p>当一个进程调用fork之后，就有两个二进制代码相同的进程。而且它们都运行到相同的地方。但每个进程都将可以开始它们自己的旅程</p><p>fork()的简单实现</p><ul><li>对子进程分配内存</li><li>复制父进程的内存和CPU寄存器到子进程</li><li>开销昂贵</li></ul><p>在99%的情况下,我们在调用fork()之后调用exec() —依据实际情况得出</p><ul><li>在fork()操作中内存复制是没有作用的（因为你fork完后立马去执行新的程序，会把你复制的东西都覆盖了</li><li>子进程将可能关闭打开的文件和连接</li><li>开销因此是最高的</li></ul><p>vfork()</p><ol><li><p>vfork用于创建一个子进程，子进程和父进程共享地址空间。(fork的子进程有独立的地址空间)</p></li><li><p>vfork保证子进程先运行，在子进程调用exec或exit之后父进程才可能被调度运行。</p></li></ol><ul><li>一个创建进程的系统调用,不需要创建一个同样的内存映像</li><li>一些时候称为轻量级fork()</li><li>子进程应该几乎立即调用exec()</li><li>现在不再使用如果我们使用 copy on write 技术(按需复制，不复制那些会被覆盖的部分，只复制进程创建必须的部分)</li></ul><h4 id="加载和执行进程"><a href="#加载和执行进程" class="headerlink" title="加载和执行进程"></a>加载和执行进程</h4><p>​exec()函数：让当前进程执行新的程序</p><p>​exec()调用允许一个进程”加载”一个不同的程序并且在main开始执行(事实上 _start)</p><p>​它允许一个进程指定参数的数量(argc)和它字符串参数数组(argv)</p><h4 id="等待和终止进程"><a href="#等待和终止进程" class="headerlink" title="等待和终止进程"></a>等待和终止进程</h4><p>​wait()系统调用 是被父进程用来等待子进程的结束</p><ul><li><p>一个子进程向父进程返回一个值，所以父进程必须接受这个值并处理</p></li><li><p>﻿wait()系统调用担任这个要求</p><ul><li><p>﻿它使父进程去睡眠来等待子进程的结果</p></li><li><p>﻿当一个子进程调用exit(的时候，操作系统解锁父进程，并且将通过exit()传递得到的返回值作为wait调用的一个结果(连同子进程的pid一起）如果这里没有子进程存活，wait()立刻返回</p></li><li><p>当然，如果这里有为父进程的僵尸等待，wait(立即返回其中一个值(并且解除僵尸状态）</p></li></ul></li><li><p>﻿进程结束执行之后，它调用exit()</p></li><li><p>﻿这个系统调用：</p><ul><li><p>﻿将这程序的 “结果” 作为一个参数</p></li><li><p>﻿关闭所有打开的文件，连接等等</p></li><li><p>﻿释放内存</p></li><li><p>﻿释放大部分支持进程的操作系统结构</p></li><li><p>﻿检查是否父进程是存活着的：</p><ul><li><p>﻿﻿如果是的话。它保留结果的值直到父进程需要它：在这种情况里。进程没有真正<br> 死亡，但是它进入了僵尸 (zombie&#x2F; defunct)状态</p></li><li><p>﻿如果没有，子进程将被init进程接管，init代替其父进程，释放其所有的数据结构</p></li></ul></li><li><p>﻿清理所有等待的僵尸进程</p></li></ul></li><li><p>﻿进程终止是最终的垃圾收集（资源回收）</p></li></ul><h4 id="进程状态图："><a href="#进程状态图：" class="headerlink" title="进程状态图："></a>进程状态图：</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230606200728246.png" alt="image-20230606200728246" style="zoom:50%;" /><h2 id="Chapter8-CPU调度"><a href="#Chapter8-CPU调度" class="headerlink" title="Chapter8 CPU调度"></a>Chapter8 CPU调度</h2><h3 id="8-1背景"><a href="#8-1背景" class="headerlink" title="8.1背景"></a>8.1背景</h3><h4 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h4><ul><li>从就绪队列中挑选一个进程&#x2F;线程作为CPU将要运行的下一个线程&#x2F;进程</li><li>调度程序：挑选进程&#x2F;线程的内核函数(通过一些调度策略)</li><li>什么时候执行调度？——线程、进程生命周期中状态的转化时，会进行调度</li></ul><p></p><h4 id="CPU调度时间"><a href="#CPU调度时间" class="headerlink" title="CPU调度时间"></a>CPU调度时间</h4><p>​满足一条即可：i): 一个进程从运行状态-&gt;等待状态; ii):一个进程被终结了</p><ul><li>不可抢占：<ul><li>调度程序必须等待事件结束</li></ul></li><li>可抢占：<ul><li>调度程序在中断被响应后执行</li><li>当前的进程从运行切换到就绪，或者一个进程从等待切换到就绪</li><li>当前运行的进程可以被换出</li></ul></li></ul><h3 id="8-2调度准则"><a href="#8-2调度准则" class="headerlink" title="8.2调度准则"></a>8.2调度准则</h3><h4 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h4><h4 id="程序执行模型"><a href="#程序执行模型" class="headerlink" title="程序执行模型"></a>程序执行模型</h4><p>​程序在CPU突发和I&#x2F;O中交替</p><ul><li>每个调度决定都是关于在下一个CPU突发时将哪个工作交给CPU</li><li>在时间分片机制下，线程可能在结束当前CPU突发前被迫放弃CPU</li></ul><h4 id="比较调度算法的准则"><a href="#比较调度算法的准则" class="headerlink" title="比较调度算法的准则"></a>比较调度算法的准则</h4><h5 id="1-CPU使用率"><a href="#1-CPU使用率" class="headerlink" title="1.CPU使用率"></a>1.CPU使用率</h5><ul><li>CPU处于忙状态所占时间的百分比</li></ul><h5 id="2-吞吐量"><a href="#2-吞吐量" class="headerlink" title="2.吞吐量"></a>2.吞吐量</h5><ul><li>在单位时间内完成的进程数量</li></ul><h5 id="3-周转时间"><a href="#3-周转时间" class="headerlink" title="3.周转时间"></a>3.周转时间</h5><ul><li><u>一个进程从初始化到结束，包括所有等待时间</u>所花费的时间</li></ul><h5 id="4-等待时间"><a href="#4-等待时间" class="headerlink" title="4.等待时间"></a>4.等待时间</h5><ul><li>进程在<u>就绪队列</u>中的总时间</li></ul><h5 id="5-响应时间"><a href="#5-响应时间" class="headerlink" title="5.响应时间"></a>5.响应时间</h5><ul><li>从一个请求<u>被提交</u>到<u>产生第一次响应</u>所花费的总时间</li></ul><p>​减少响应时间：及时处理用户的输出并且尽快将输出提供给用户</p><p>​减少平均响应时间波动：在交互系统中，可预测性比高低差异平均更重要</p><p>​增加吞吐量：i): 减少开销(操作系统开销，上下文切换) ii):系统资源的高效利用(CPU，I&#x2F;O设备)、</p><p>​减少等待时间</p><p>​低延迟利于系统与用户的交互</p><p>​即使存在许多交互任务，我们也需要保证吞吐量不受影响</p><p>​</p><h4 id="吞吐量vs延迟"><a href="#吞吐量vs延迟" class="headerlink" title="吞吐量vs延迟"></a>吞吐量vs延迟</h4><p>吞吐量是OS的计算带宽，响应时间是OS的计算延迟</p><h4 id="公平的目标"><a href="#公平的目标" class="headerlink" title="公平的目标"></a>公平的目标</h4><p>​保证每个进程占用相同的CPU时间——会增加平均响应时间(真的要设计成公平的吗？)</p><h3 id="8-3调度算法"><a href="#8-3调度算法" class="headerlink" title="8.3调度算法"></a>8.3调度算法</h3><h4 id="1-先来先服务-FCFS"><a href="#1-先来先服务-FCFS" class="headerlink" title="1.先来先服务(FCFS)"></a>1.先来先服务(FCFS)</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul><li>简单</li></ul><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>平均等待时间波动较大</li><li>花费时间少的任务可能排在花费时间长的任务后面</li><li>可能导致I&#x2F;0和CPU之间的重叠处理<ul><li>﻿CPU密集型进程会导致I&#x2F;0设备闲置时，I&#x2F;0密集型进程也在等待</li></ul></li></ul><h4 id="2-短进程优先-x2F-短剩余时间优先"><a href="#2-短进程优先-x2F-短剩余时间优先" class="headerlink" title="2.短进程优先&#x2F;短剩余时间优先"></a>2.短进程优先&#x2F;短剩余时间优先</h4><p><strong>有抢占式</strong>、<strong>非抢占式</strong>的两种方案</p><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><ul><li>最优的平均等待时间</li></ul><h5 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>可能导致饥饿<ul><li>连续的短任务流会<strong>使长任务饥饿</strong></li><li>短任务可用时，任何长任务的CPU时间都会增加平均等待时间</li></ul></li><li>需要预知未来<ul><li>我们怎么在运行进程之前就提前知道进程要运行多久？<ul><li>最简单的方法——询问用户，如果用户撒谎，就杀死进程</li><li>如果用于不能给出时间，那么OS进行预估(根据之前的记录)</li></ul></li></ul></li></ul><h4 id="3-最高响应比优先"><a href="#3-最高响应比优先" class="headerlink" title="3.最高响应比优先"></a>3.最高响应比优先</h4><p>​在2的基础上进行了改进，考虑R ( R &#x3D; (w + s) &#x2F; s ) w:等待时间 s:执行时间</p><h5 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h5><ul><li>不可抢占</li><li>关注进程等待了多长时间</li><li>防止无限期推迟</li></ul><h5 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>需要预知未来<ul><li>我们怎么在运行进程之前就提前知道进程要运行多久？<ul><li>最简单的方法——询问用户，如果用户撒谎，就杀死进程</li><li>如果用于不能给出时间，那么OS进行预估(根据之前的记录)</li></ul></li></ul></li></ul><h4 id="4-轮询-RR"><a href="#4-轮询-RR" class="headerlink" title="4.轮询(RR)"></a>4.轮询(RR)</h4><ul><li>﻿RR 花销：额外的<strong>上下文切换</strong>开销</li><li>﻿时间量子太大<ul><li>等待时间过长</li><li>极限情况退化成FCFS</li></ul></li><li>﻿时间量子太小<ul><li>反应迅速但是切换频繁，开销大</li><li>吞吐量由于大量的上下文切换开销受到影响</li></ul></li><li>﻿目标：<ul><li>选择一个合适的时间量子</li><li>经验规则：维持上下文切换开销处于1%以内</li></ul></li></ul><p>——RR的优化</p><ul><li>﻿就绪队列被划分成独立的队列：<ul><li>E.g. 前台（交互）, 后台（批处理）</li></ul></li><li>﻿每个队列拥有自己的调度策略<ul><li>E.g. 前台一RR，后台—FCFS</li></ul></li><li>﻿调度必须在队列间进行<ul><li>固定优先级</li><li>﻿先处理前台，然后处理后台</li><li>可能导致饥饿</li><li>时间切片<ul><li>每个队列都得到一个确定的能够调度其进程的CPU总时间</li><li>E.g. 80%给使用RR的前台，20%给使用FCFS的后台</li></ul></li></ul></li></ul><h4 id="5-多级反馈队列"><a href="#5-多级反馈队列" class="headerlink" title="5.多级反馈队列"></a>5.多级反馈队列</h4><ul><li>一个进程可以在不同队列中移动<ul><li>时间量子大小随优先级级别的增加而增加</li><li>如果任务在当前的时间量子中没有完成，则降到下一优先级</li></ul></li></ul><h5 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h5><ul><li>CPU密集型任务的优先级下降很快</li><li>I&#x2F;O密集型任务停留在高优先级</li></ul><h4 id="6-公平共享队列"><a href="#6-公平共享队列" class="headerlink" title="6.公平共享队列"></a>6.公平共享队列</h4><ul><li>FFS控制用户对系统资源的访问<ul><li>一些用户组比其他用户组更重要</li><li>保证不重要的组无法垄断资源</li><li>未使用的资源按照每个组所分配的资源的比例来分配</li><li>没有达到资源使用率目标的组获得更高的优先级</li></ul></li></ul><h3 id="8-4实时调度"><a href="#8-4实时调度" class="headerlink" title="8.4实时调度"></a>8.4实时调度</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>​正确性依赖于时间与功能两方面</p><p>​<u>需要保证<strong>及时性</strong></u>，速度和平均性能没那么重要</p><ul><li><p>强实时系统</p><ul><li>需要在<u>保证的时间内完成重要的任务</u>，必须完成</li></ul></li><li><p>弱实时系统</p><ul><li>要求<u>重要的进程的优先级更高</u>，尽量完成，并非必须</li></ul></li><li><p>硬时限</p><ul><li><p>如果错过了最后期限，可能会发生灾难性或非常严重的后果</p></li><li><p>必须验证：在最坏的情况下也能够满足时限吗？</p></li><li><p>保证确定性</p></li></ul></li><li><p>软时限</p><ul><li><p>理想情况下，时限应该被最大满足。如果有时限没有被满足，那么就相应地降低要求。</p></li><li><p>尽最大努力去保证</p></li></ul></li></ul><h4 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h4><p>​静态、动态优先级调度(在程序执行之前就确定进程的优先级&#x2F;在程序运行过程中，优先级会不断变化)</p><h3 id="8-5多处理器调度"><a href="#8-5多处理器调度" class="headerlink" title="8.5多处理器调度"></a>8.5多处理器调度</h3><ul><li>﻿多处理器的CPU调度更加复杂<ul><li>多个相同的单处理器组成一个多处理器</li><li>优点：负载共享</li></ul></li><li>﻿对称多处理器(SMP)<ul><li>每个处理器运行自己的调度程序</li><li>需要在调度程序中同步</li></ul></li></ul><h3 id="8-6优先级反转"><a href="#8-6优先级反转" class="headerlink" title="8.6优先级反转"></a>8.6优先级反转</h3><p>​现有优先级 T1 &lt; T2 &lt; T3，</p><p>T3和T1都需要用到一块共享资源，T3先执行，锁定了共享资源，T1再执行(抢占了T3)，虽然T1优先于T3，但是T3把T1要用到的资源锁住了，所以T1无法执行完毕，因此让T3继续执行，此时让T2再执行，会抢占T3，<u>这时候，T1需要等待T3，T3在等待T2，就出现了优先级反转问题！</u></p><p>解决方案：</p><ul><li>(当出现资源抢占现象时)低优先级任务继承高优先级任务的优先级</li><li>﻿优先级天花板：<ul><li>“资源” 的优先级和 “所有可以锁定该资源的任务中优先级最高的那个任务” 的优先级相同</li><li>除非优先级高于系统中所有被锁定的资源的优先级上限，否则任务尝试执行临界区的时候会被阻塞</li><li>﻿持有最高优先级上限信号量锁的任务，会继承被该锁所阳塞的任务的优先级</li></ul></li></ul><h2 id="Chapter9-同步"><a href="#Chapter9-同步" class="headerlink" title="Chapter9 同步"></a>Chapter9 同步</h2><h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><ul><li>﻿独立的线程：<ul><li>不和其他线程共享资源或状态</li><li>确定性：一输入状态决定结果</li><li>可重现：一 能够重现起始条件，I&#x2F;0</li><li>调度顺序不重要</li></ul></li><li>﻿合作线程：<ul><li>在多个线程中共享状态</li><li>不确定性</li><li>不可重现</li></ul></li><li>﻿不确定性和不可重现意味着bug可能是间歇性发生的</li></ul><p>进程间合作工作的原因：</p><ul><li>﻿进程&#x2F;线程，计算机&#x2F;设备需要合作</li><li>﻿优点1：共享资源<ul><li>一台电脑，多个用户</li><li>一个银行存款余额，多台ATM机</li><li>嵌入式系统（机器人控制：手臂和手的协调）</li></ul></li><li>﻿优点2：加速<ul><li>I&#x2F;0操作和计算可以重叠</li><li>多处理器 一 将程序分成多个部分井行执行</li></ul></li><li>﻿优点3：模块化<ul><li>将大程序分解成小程序</li></ul></li><li>﻿以编译为例，gcc会调用cpp, cc1, cc2. as, ld，使系统易于扩展</li></ul><p>但是进程并发会带来一些问题，接下来我们要对其进行解决</p><h3 id="一些概念："><a href="#一些概念：" class="headerlink" title="一些概念："></a>一些概念：</h3><h4 id="原子操作："><a href="#原子操作：" class="headerlink" title="原子操作："></a>原子操作：</h4><ul><li>﻿原子操作是指一次不存在任何中断或者失败的执行<ul><li>该执行成功结束</li><li>或者根本没有执行</li><li>并且不应该发现任何<strong>部分执行</strong>的状态</li></ul></li><li>﻿实际上操作往往不是原子的<ul><li>有些看上去是原子操作，实际上不是</li><li>连x++这样的简单语句，实际上是由3条指令构成的</li><li>有时候甚至连单条机器指令都不是原子的</li></ul></li></ul><h4 id="Critical-section-（临界区）"><a href="#Critical-section-（临界区）" class="headerlink" title="Critical section （临界区）"></a>Critical section （临界区）</h4><p>临界区是指进程中的一段需要访问共享资源并且当另一个进程处于相应代码区域时便不会被执行的代码区域</p><h4 id="Mutual-exclusion-（互斥）"><a href="#Mutual-exclusion-（互斥）" class="headerlink" title="Mutual exclusion （互斥）"></a>Mutual exclusion （互斥）</h4><p>当一个进程处于临界区井访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源</p><h4 id="Dead-lock-（死锁）"><a href="#Dead-lock-（死锁）" class="headerlink" title="Dead lock （死锁）"></a>Dead lock （死锁）</h4><p>两个或以上的进程，在相互等待完成特定任务，而最终没法将自身任务进行下去</p><h4 id="Starvation（饥饿）"><a href="#Starvation（饥饿）" class="headerlink" title="Starvation（饥饿）"></a>Starvation（饥饿）</h4><p>一个可执行的进程，被调度器持续忽略，以至于虽然处于可执行状态却不被执行</p><h4 id="Critical-section-临界区）"><a href="#Critical-section-临界区）" class="headerlink" title="Critical section  (临界区）"></a>Critical section  (临界区）</h4><p>临界区是指进程中的一段需要访问共享资源井且当另一个进程处于相应代码区域时便不会被执行的代码区域</p><ul><li>﻿互斥：同一时间临界区中最多存在一个线程</li><li>﻿Progress：如果一个线程想要进入临界区，那么它最终会成功</li><li>有限等待：如果一个线程i处于入口区，那么在i的请求被接受之前，其他线程进入临界区的时间是有限制的</li><li>﻿无忙等待（可选)：如果一个进程在等待进入临界区，那么<strong>在它可以进入之前会被挂起</strong></li></ul><h4 id="Mutual-exclusion（互斥）"><a href="#Mutual-exclusion（互斥）" class="headerlink" title="Mutual exclusion（互斥）"></a>Mutual exclusion（互斥）</h4><p>当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源</p><h3 id="实现对临界区代码的保护"><a href="#实现对临界区代码的保护" class="headerlink" title="实现对临界区代码的保护"></a>实现对临界区代码的保护</h3><h4 id="方案1——禁用硬件中断："><a href="#方案1——禁用硬件中断：" class="headerlink" title="方案1——禁用硬件中断："></a>方案1——禁用硬件中断：</h4><ul><li>﻿没有中断，没有上下文切换，因此没有并发<ul><li>硬件将中断处理延迟到中断被启用之后</li><li>大多数现代计算机体系结构都提供指令来完成</li></ul></li><li>﻿进入临界区<ul><li>禁用中断</li></ul></li><li>﻿离开临界区<ul><li>开启中断</li></ul></li></ul><h5 id="缺点：-4"><a href="#缺点：-4" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>﻿一旦中断被禁用，线程就无法被停止<ul><li>整个系统都会为你停下来</li><li>可能导致其他线程处于饥饿状态</li></ul></li><li>﻿要是临界区可以任意长怎么办<ul><li>无法限制响应中断所需的时间(可能存在硬件影响）</li></ul></li></ul><p>​要小心使用</p><ul><li>一般只能禁止单CPU的中断，那么面对多CPU的情况就无法使 禁用硬件中断失效</li></ul><h4 id="方案2——基于软件的解决方案"><a href="#方案2——基于软件的解决方案" class="headerlink" title="方案2——基于软件的解决方案:"></a>方案2——基于软件的解决方案:</h4><ul><li>﻿﻿Dekker算法 (1965）：第一个针对双线程例子的正确解决方案</li><li>﻿Bakery算法 ( Lamport 1979）：针对n线程的临界区问题解决方案</li><li>﻿复杂<ul><li>需要两个进程间的共享数据项</li></ul></li><li>﻿需要忙等待<ul><li>浪费CPU时间</li></ul></li><li>﻿没有硬件保证的情况下无真正的软件解决方案<ul><li>Peterson算法需要原子的LOAD和STORE指令</li></ul></li></ul><h4 id="方案3——更高级的抽象："><a href="#方案3——更高级的抽象：" class="headerlink" title="方案3——更高级的抽象："></a>方案3——更高级的抽象：</h4><ul><li>﻿大多数现代体系结构都提供特殊的原子操作指令<ul><li>通过特殊的内存访问电路，针对单处理器和多处理器</li></ul></li><li>﻿﻿Test-and-Set 测试和置位<ul><li>从内存中读取值</li><li>测试该值是否为1（然后返回真或假）</li><li>内存值设置为1</li></ul></li><li>﻿交换exchange<ul><li>交换内存中的两个值</li></ul></li></ul><p>我们可以通过Test-and-Set 或 exchange 来实现并发线程的管理</p><h5 id="优点：-4"><a href="#优点：-4" class="headerlink" title="优点："></a>优点：</h5><ul><li>适用于单处理器或者共享主存的多处理器中任意数量的迸程</li><li>简单并且容易证明</li><li>可以用于支持多临界区</li></ul><h5 id="缺点：-5"><a href="#缺点：-5" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>忙等待消耗处理器时间</li><li>当进程离开临界区并且多个进程在等待的时候可能导致<u>饥饿</u></li><li>死锁</li><li>﻿如果一个低优先级的进程拥有临界区并且一个高优先级进程也需求，那么高优先级进程会获得处理器并等待临界区</li></ul><h2 id="Chapter10-信号量和管程"><a href="#Chapter10-信号量和管程" class="headerlink" title="Chapter10 信号量和管程"></a>Chapter10 信号量和管程</h2><h3 id="背景：-1"><a href="#背景：-1" class="headerlink" title="背景："></a>背景：</h3><ul><li>﻿并发问题：竞争条件（竞态条件）<ul><li>多程序并发存在大的问题</li></ul></li><li>﻿同步<ul><li>多线程<strong>共享公共数据的协调执行</strong></li><li>包括互斥与条件同步</li><li>互斥：在同一时间只有一个线程可以执行临界区</li></ul></li><li>﻿确保同步正确很难？<ul><li>需要高层次的编程抽象（如：锁）</li><li>从底层硬件支持编译</li></ul></li></ul><h3 id="信号量："><a href="#信号量：" class="headerlink" title="信号量："></a>信号量：</h3><ul><li><p>是一个整形（sem），有两个原子操作</p></li><li><p>P () :   sem 减1，如果sem&lt;0， 等待，否则继续</p></li><li><p>V () ：sem 加1，如果 sem&lt;&#x3D;0，唤醒一个等待的P</p></li><li><p>﻿信号量是被保护的变量</p><ul><li>初始化完成后，唯一改变一个信号量的值的办法是通过P0和v0</li><li>操作必须是原子</li></ul></li><li><p>﻿P () 能够阻塞，V () 不会阻塞</p></li><li><p>﻿我们假定信号量是   公平的</p><ul><li>没有线程被阻塞在P () if  V () 被无限频繁调用（对于同一个信号量）</li><li>在实践中，FIFO经常被使用</li></ul></li><li><p>﻿两种类型信号量</p><ul><li>二进制信号量：可以是0或1</li><li>一般&#x2F;计数信号量：可取任何非负值</li><li>两者相互表现(给定一个可以实现另一个)</li></ul></li><li><p>﻿信号量可以用在2个方面</p><ul><li>互斥</li><li>条件同步(调度约束一一一个线程等待另一个线程的事情发生）</li></ul></li></ul><h3 id="信号量缺点："><a href="#信号量缺点：" class="headerlink" title="信号量缺点："></a>信号量缺点：</h3><ul><li>信号量的双用途<ul><li>互斥和条件同步</li><li>但等待条件是独立的互斥</li></ul></li><li>读&#x2F;开发代码比较困难<ul><li>程序员必须非常精通信号量</li></ul></li><li>容易出错<ul><li>使用的信号量己经被另一个线程占用</li><li>忘记释放信号量</li></ul></li><li>不能够处理死锁问题</li></ul><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><ul><li><p>﻿什么是管程</p><ul><li>一个锁：指定临界区</li><li>0或者多个条件变量：等待&#x2F;通知信号量用于管理并发访问共享数据</li></ul></li><li><p>﻿一般方法</p><ul><li>收集在对象&#x2F;模块中的相关共享数据</li><li>定义方法来访问共享数据</li></ul></li><li><p>﻿﻿Lock</p><ul><li>Lock::Acquire（ 一 等待直到锁可用，然后抢占锁</li><li>Lock::Release （一释放锁，唤醒等待者如果有</li></ul></li><li><p>﻿﻿Condition Variable</p><ul><li><p>允许等待状态进入临界区</p><ul><li>﻿允许处于等待（睡眠）的线程进入临界区</li><li>﻿某个时刻原子释放锁进入睡眠</li></ul></li><li><p>Wait () operation</p><ul><li>﻿释放锁，睡眠，重新获得锁返回后</li></ul></li><li><p>﻿﻿Signal () operation ( or broadcast () operation )</p><ul><li>唤醒等待者（或者所有等待者），如果有</li></ul></li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/IMG_C86C23D6FA1D-1.jpeg" alt="IMG_C86C23D6FA1D-1" style="zoom:50%;" /><h3 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h3><h4 id="读者—写者问题："><a href="#读者—写者问题：" class="headerlink" title="读者—写者问题："></a>读者—写者问题：</h4><ul><li><p>动机</p><ul><li>共享数据的访问</li></ul></li><li><p>两种类型使用者</p><ul><li>读者：不需要修改数据</li><li>写者：读取和修改数据</li></ul></li><li><p>问题的约束</p><ul><li>允许同一时间有多个读者，但在任何时候只有一个写者</li><li>当没有写者是读者才能访问数据</li><li>当没有读者和写者时写者才能访问数据</li><li>在任何时候只能有一个线程可以操作共享变量</li></ul></li><li><p>﻿多个并发进程的数据集共享</p><ul><li>读者一只读数据集；他们不执行任何更新</li><li>写者-可以读取和写入</li></ul></li><li><p>﻿共享数据</p><ul><li>数据集</li><li>信号量CountMutex初始化为1</li><li>信号量WriteMutex初始化为1</li><li>整数 Rcount 初始化为0</li></ul></li></ul><h5 id="读者优先实现-使用信号量方式-："><a href="#读者优先实现-使用信号量方式-：" class="headerlink" title="读者优先实现(使用信号量方式)："></a>读者优先实现(使用信号量方式)：</h5><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/IMG_4D5569A45E16-1.jpeg" alt="IMG_4D5569A45E16-1" style="zoom:50%;" /><h4 id="哲学家就餐问题："><a href="#哲学家就餐问题：" class="headerlink" title="哲学家就餐问题："></a>哲学家就餐问题：</h4><h2 id="Chapter11-死锁"><a href="#Chapter11-死锁" class="headerlink" title="Chapter11 死锁"></a>Chapter11 死锁</h2><h3 id="死锁问题："><a href="#死锁问题：" class="headerlink" title="死锁问题："></a>死锁问题：</h3><p>​一组阻塞的进程持有一种资源 等待获取 另一个进程所占有的一个资源。</p><h3 id="系统模型："><a href="#系统模型：" class="headerlink" title="系统模型："></a>系统模型：</h3><h4 id="可重复使用的资源"><a href="#可重复使用的资源" class="headerlink" title="可重复使用的资源"></a>可重复使用的资源</h4><ul><li><p>﻿在一个时间只能一个进程使用且不能被删除</p></li><li><p>﻿进程获得资源，后来释放由其他进程重用</p></li><li><p>﻿处理器，I&#x2F;O通道，主和副存储器，设备和数据结构，如文件，数据库和信号量</p></li><li><p>﻿如果每个进程拥有一个资源并请求其它资源，死锁可能发生</p><h4 id="使用资源"><a href="#使用资源" class="headerlink" title="使用资源"></a>使用资源</h4></li><li><p>﻿﻿创建和销毁</p></li><li><p>﻿在I&#x2F;O缓冲区的中断，信号，消息，信息</p></li><li><p>﻿如果接收消息阳塞可能会发生死锁</p></li><li><p>﻿可能少见的组合事件会引起死锁</p></li></ul><h3 id="死锁特征："><a href="#死锁特征：" class="headerlink" title="死锁特征："></a>死锁特征：</h3><p>死锁出现的必要条件：</p><h4 id="1、-互斥："><a href="#1、-互斥：" class="headerlink" title="1、 互斥："></a>1、 互斥：</h4><p>进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</p><h4 id="2、占用并等待："><a href="#2、占用并等待：" class="headerlink" title="2、占用并等待："></a>2、占用并等待：</h4><p>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p><h4 id="3、无抢占"><a href="#3、无抢占" class="headerlink" title="3、无抢占:"></a>3、无抢占:</h4><p>进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</p><h4 id="4、循环等待"><a href="#4、循环等待" class="headerlink" title="4、循环等待:"></a>4、循环等待:</h4><p>存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i&#x3D;0, 1, …, n-1)，Pn等待的资源被P0占有；</p><h3 id="死锁处理方法："><a href="#死锁处理方法：" class="headerlink" title="死锁处理方法："></a>死锁处理方法：</h3><h4 id="死锁预防："><a href="#死锁预防：" class="headerlink" title="死锁预防："></a>死锁预防：</h4><p>破坏任意死锁出现的必要条件：</p><ul><li><p>互斥——共享资源不是必须的，必须占用非共享资源。</p></li><li><p>占用并等待——必须保证当一个进程请求的资源，它不持有任何其他资源。</p><ul><li>需要进程请求并分配其所有资源，它开始执行之前或允许进程请求资源仅当进程没有资源。</li><li>资源利用率低;可能发生饥饿。</li></ul><p></p></li><li><p>无抢占</p><ul><li>如果进程占有某些资源，并请求其它不能被立即分配的资源，则释放当前正占有的资源</li><li>被抢占资源添加到资源列表中</li><li>只有当它能够获得旧的资源以及它请求新的资源，进程可以得到执行</li></ul></li><li><p>循环等待 —对所有资源类型进行<u><strong>排序</strong></u>，并<u><strong>要求每个进程按照资源的顺序进行申请</strong></u>。</p></li></ul><h4 id="死锁避免："><a href="#死锁避免：" class="headerlink" title="死锁避免："></a>死锁避免：</h4><p><u>需要系统具有一些额外的先验信息提供。</u></p><ul><li><p>﻿﻿最简单和最有效的模式是要求每个进程声明它可能需要的每个类型资源的<u>最大数目</u>。</p></li><li><p>﻿资源的分配状态是通过限定<u>提供</u>与<u>分配</u>的资源数量，和进程的<u>最大需求</u>。</p></li><li><p>﻿死锁避免算法<u>动态检查</u>的资源分配状态，以确保永远不会有一个环形等待状态。</p></li><li><p>﻿当一个进程请求可用资源，系统必须判断立即分配是否能<strong>使系统处于安全状态</strong>。</p></li><li><p>﻿系统处于安全状态指：针对所有进程，存在安全序列。</p></li><li><p>﻿序列&lt;P1，p2,……，PN&gt;是安全的：针对每个Pi, Pi要求的资源能够由当前可用的资源+所有的 Pj 持有的资源来满足，其中j&lt;i。</p><ul><li>如果 Pi 资源的需求不是立即可用，那么 Pi 可以等到所有 Pj 完成。</li><li>当 Pi 完成后，P i + 1 可以得到所需要的资源，执行，返回所分配的资源，并终止。</li><li>﻿用同样的方法。Pi+2, Pi+3，和 Pn 能获得其所需的资源。</li></ul></li></ul><h5 id="银行家算法-通过合理分配资源使得死锁避免"><a href="#银行家算法-通过合理分配资源使得死锁避免" class="headerlink" title="银行家算法(通过合理分配资源使得死锁避免)"></a>银行家算法(通过合理分配资源使得死锁避免)</h5><h4 id="死锁检测："><a href="#死锁检测：" class="headerlink" title="死锁检测："></a>死锁检测：</h4><p>​就是银行家算法，看看能不能在现有资源下，让所有进程都跑通(时间复杂度大、开销大)</p><h4 id="死锁恢复："><a href="#死锁恢复：" class="headerlink" title="死锁恢复："></a>死锁恢复：</h4><ul><li>﻿方法1：终止所有的死锁进程</li><li>﻿方法2：在一个时间内终止一个进程直到死锁消除<ul><li>终止进程的顺序应该是：<ul><li>进程的优先级</li><li>进程运行了多久以及需要多少时间才能完成</li><li>进程占用的资源</li><li>进程完成需要的资源</li><li>多少进程需要被终止</li><li>迸程是交互还是批处理</li></ul></li></ul></li></ul><h2 id="Chapter12进程间通信-IPC——Inter-Process-Communication"><a href="#Chapter12进程间通信-IPC——Inter-Process-Communication" class="headerlink" title="Chapter12进程间通信(IPC——Inter Process Communication)"></a>Chapter12进程间通信(IPC——Inter Process Communication)</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="通信模型"><a href="#通信模型" class="headerlink" title="通信模型"></a>通信模型</h4><ul><li><p>﻿进程通信的机制及同步</p></li><li><p>﻿不使用共享变量的迸程通信</p></li><li><p>﻿﻿IPC facility 提供2个操作：</p><ul><li>send(message）一消息大小固定或者可变</li><li>﻿﻿receive (message)</li></ul></li><li><p>﻿如果P和Q想通信，需要：</p><ul><li>在它们之间建立通信链路</li><li>通过 send&#x2F;receive交换消息</li></ul></li><li><p>﻿通信链路的实现</p><ul><li><p>物理（例如，<strong>共享内存</strong>，<strong>硬件总线</strong>）</p></li><li><p>﻿逻辑（例如，逻辑属性）</p></li></ul></li></ul><h4 id="直接与间接通信"><a href="#直接与间接通信" class="headerlink" title="直接与间接通信"></a>直接与间接通信</h4><h5 id="直接通信"><a href="#直接通信" class="headerlink" title="直接通信:"></a>直接通信:</h5><ul><li>进程必须正确的命名对方：<ul><li>send (P, message)        一 发送信息到进程P</li><li>receive (Q, messase） 一 从进程Q接受消息</li></ul></li><li>通信链路的属性:<ul><li>自动建立链路</li><li>一条链路恰好对应一对通信进程</li><li>每对进程之间只有一个链接存在</li><li>链接可以是单向的，但通常为双向的</li></ul></li></ul><h5 id="间接通信"><a href="#间接通信" class="headerlink" title="间接通信:"></a>间接通信:</h5><ul><li>﻿定向从消息队列接收消息<ul><li>每个消息队列都有一个唯一的ID</li><li>只有它们共享了一个消息队列，进程才能够通信</li></ul></li><li>﻿通信链路的属性<ul><li>只有进程共享一个共同的消息队列，才建立链路</li><li>链接可以与许多进程相关联</li><li>每对进程可以共享多个通信链路</li><li>连接可以是单向或双向</li></ul></li><li>﻿操作<ul><li>创建一个新的消息队列</li><li>通过消息队列发送和接收消息</li><li>销毁消息队列</li></ul></li><li>﻿原语的定义如下：<ul><li>send （A, message）一 发送消息到队列A</li><li>receive (A,message）一 从队列 A接受消息</li></ul></li></ul><h4 id="阻塞与非阻塞："><a href="#阻塞与非阻塞：" class="headerlink" title="阻塞与非阻塞："></a>阻塞与非阻塞：</h4><p>​阻塞：异步</p><p>​非阻塞：同步(发送方一定要等到接收方收到消息后再进行下一步操作)</p><h4 id="通信链路缓冲："><a href="#通信链路缓冲：" class="headerlink" title="通信链路缓冲："></a>通信链路缓冲：</h4><ul><li>队列的消息被附加到链路；可以是以下3种方式之一：</li></ul><ol><li><p>﻿﻿﻿0容量<br> 发送方必须等待接收方 (rendezvous)</p></li><li><p>﻿﻿有限容量 —— n messages的有限长度</p><p>​如果队列满，发送方必须等待</p></li><li><p>﻿﻿﻿无限容量——无限长度<br> 发送方不需要等待</p></li></ol><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><ul><li><p><u><strong>软件</strong></u>中断通知事件处理</p></li><li><p>Examples: SIGFPE, SIGKILL, SIGUSR1, SIGSTOP, SIGCONT</p></li><li><p>﻿接收到信号时会发生什么</p><ul><li>Catch:指定信号处理函数被调用</li><li>Ignore：依靠操作系统的默认操作</li></ul></li><li><p>﻿﻿Example: Abort, memory dump, suspend or resume process</p><ul><li>Mask：闭塞信号因此不会传送<ul><li>﻿可能是暂时的（当处理同样类型的信号）</li></ul></li></ul></li><li><p>﻿不足<br> 不能传输要交换的任何数据</p></li></ul><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>​主要是为了 实现使一个进程的输出作为另一个进程的输入(这两个进程都是shell进程的子进程，shell进程为它们之间的通信创建通道)</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>​<a href="https://tangjiayang.github.io/2023/06/02/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">https://tangjiayang.github.io/2023/06/02/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</a></p><p>​一种间接通信方式</p><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><ul><li><p>进程</p><ul><li>每个进程都有私有地址空间</li><li>在每个地址空间内，明确地设置了共享内存段</li></ul></li><li><p>﻿优点</p><ul><li>快速、方便地共享数据</li></ul></li><li><p>﻿不足</p><ul><li>必须同步数据访问</li></ul></li></ul><p></p><h2 id="Chapter13-文件系统"><a href="#Chapter13-文件系统" class="headerlink" title="Chapter13 文件系统"></a>Chapter13 文件系统</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="文件系统和文件"><a href="#文件系统和文件" class="headerlink" title="文件系统和文件"></a>文件系统和文件</h4><ul><li><p>文件系统：一种用于持久性存储的系统抽象</p><ul><li>在存储器上：组织、控制、导航、访问和检索数据</li><li>大多数计算机系统包含文件系统</li><li>个人电脑、服务器、笔记本电脑</li><li>iPod.Tivo &#x2F;机顶盒、手机&#x2F;掌上电脑</li><li>Google 可能是由一个文件系统构成的</li></ul></li><li><p>文件：文件系统中<strong>一个单元的相关数据在操作系统中的抽象</strong></p></li></ul><h5 id="文件系统的功能："><a href="#文件系统的功能：" class="headerlink" title="文件系统的功能："></a>文件系统的功能：</h5><ul><li>﻿分配文件磁盘空间<ul><li>管理<strong>文件块</strong>（哪一块属于哪一个文件）</li><li>管理<strong>空闲空间</strong>(哪一块是空闲的）</li><li>分配算法（策略）</li></ul></li><li>﻿管理文件集合<ul><li><strong>定位</strong>文件及其内容</li><li><strong>命名</strong>：通过名字找到文件的接口</li><li>最常见：分层文件系统</li><li>文件系统类型（组织文件的不同方式）</li></ul></li><li>﻿提供的便利及特征<ul><li><strong>保护</strong>：分层来保护数据安全</li><li><strong>可靠性&#x2F;持久性</strong>：保持文件的持久即使发生崩溃、媒体错误、攻击等</li></ul></li></ul><h5 id="文件和块："><a href="#文件和块：" class="headerlink" title="文件和块："></a>文件和块：</h5><ul><li>﻿文件属性：<ul><li>名称、类型、位置、大小，保护、创建者、创建时间、最近修改时间、…</li></ul></li><li>﻿文件头：<ul><li>在存储元数据中保存了每个文件的信息</li><li>保存文件的属性</li><li>跟踪哪一块存储块属于逻辑上文件结构的哪个偏移</li></ul></li></ul><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><ul><li><p>需要元数据数据来管理打开文件：</p><ul><li>文件指针：<u>指向最近的一次读写位置</u>，每个打开了这个文件的进程都有这个指针</li><li>文件打开计数：记录文件打开的次数——当最后一个进程关闭了文件时，允许将其从打开文件表中移除</li><li>文件磁盘位置：缓存数据访问信息</li><li>访问权限：每个程序访问模式信息</li></ul></li><li><p>﻿用户怎么访问文件</p><ul><li>在系统层面需要知道用户的访问模式：</li><li>﻿顺序访问：按字节依次读取<ul><li>几乎所有的访问都是这种方式</li></ul></li><li>﻿随机访问：从中间读写<ul><li>不常用，但是仍然重要．例如，虚拟内存支持文件：内存页存储在文件中</li><li>更加快速 一 不希望获取文件中间的内容的时候也必须先获取块内所有字节。</li></ul></li><li>基于内容访问：通过特征<ul><li>许多系统不提供此种访问方式，相反，数据库是建立在索引内容的磁盘访问上（需要高效的随机访问)</li></ul></li></ul></li><li><p>﻿﻿多用户系统中的文件共享：</p><ul><li>﻿访问控制<ul><li>谁能够获得哪些文件的哪些访问权限</li><li>访问模式：读、写、执行、删除、列举等</li></ul></li><li>﻿文件访问控制列表 (ACL)<ul><li>&lt;文件实体，权限&gt;</li></ul></li><li>﻿Unix 模式<ul><li>〈用户|组|所有人，读|写|可执行〉</li><li>用户ID识别用户，表明每个用户所允许的权限及保护模式</li><li>组ID允许用户组成组，并指定了组访问权限</li></ul></li><li>﻿指定多用户&#x2F;客户如何同时访问共享文件<ul><li>和过程同步算法相似</li><li>因磁盘I&#x2F;0和网络延迟而设计简单</li></ul></li><li>﻿﻿Unix 文件系统(UFS) 语义<ul><li>对打开文件的写入内容立即对其他打开同一文件的其他用户可见</li><li>共享文件指针允许多用户同时读取和写入文件</li></ul></li><li>﻿会话语义<ul><li>写入内容只有当文件关闭时可见</li></ul></li><li>﻿锁<ul><li>一些操作系统和文件系统提供该功能</li></ul></li></ul></li></ul><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li><p>文件以目录的方式组织起来</p></li><li><p>目录是一类特殊的文件</p><ul><li>每个目录都包含了一张表&lt;name, pointer to file header&gt;</li></ul></li><li><p>目录和文件的树型结构</p><ul><li>早期的文件系统是扁平的 （只有一层目录）</li></ul></li><li><p>﻿典型操作</p><ul><li>搜索文件</li><li>创建文件</li><li>删除文件</li><li>枚举目录</li><li>重命名文件</li><li>在文件系统中遍历一个路径</li></ul></li><li><p>﻿操作系统应该只允许内核模式修改目录</p><ul><li>确保映射的完整性</li><li>应用程序能够读目录 （如1s)</li></ul></li><li><p>﻿名字解析：逻辑名字转换成物理资源（如文件）的过程</p><ul><li>在文件系统中：到实际文件的文件名（路径）</li><li>遍历文件目录直到找到目标文件</li></ul></li><li><p>﻿举例：解析 “&#x2F;bin&#x2F;ls”</p><ul><li>读取root的文件头（在磁盘固定位置）</li><li>读取root的数据块：搜索 “bin” 项</li><li>读取bin的文件头</li><li>读取bin的数据块：搜索 “ls” 项</li><li>读取ls的文件头</li></ul></li><li><p>﻿当前工作目录</p><ul><li>每个进程都会指向一个文件目录用于解析文件名</li><li>允许用户指定相对路径来代替绝对路径</li></ul></li></ul><h4 id="文件别名"><a href="#文件别名" class="headerlink" title="文件别名"></a>文件别名</h4><h5 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h5><ul><li><p>两个或多个文件名关联同一个文件</p></li><li><p>﻿硬链接：<strong>多个文件项指向一个文件</strong></p></li><li><p>﻿软链接：以“快捷方式”指向其他文件(**“<u>快捷方式文件的内容是另一个文件的路径名</u>**”)</p></li><li><p>﻿通过存储真实文件的逻辑名称来实现</p></li></ul><h4 id="文件系统种类"><a href="#文件系统种类" class="headerlink" title="文件系统种类"></a>文件系统种类</h4><ul><li><p>﻿磁盘文件系统</p><ul><li>文件存储在数据存储设备上，如磁盘。</li><li>例如：FAT, NTFS, ext2&#x2F;3， IS09660，等</li></ul></li><li><p>﻿数据库文件系统</p><ul><li>文件根据其特征是可被寻址（辨识）的</li><li>例如：winFS</li></ul></li><li><p>﻿日志文件系统</p><ul><li>记录文件系统的修改&#x2F;事件</li><li>例如：journaling file system</li></ul></li><li><p>﻿网络&#x2F;分布式文件系统</p><ul><li><p>﻿文件可以通过网络被共享</p><ul><li>文件位于远程服务器</li><li>客户端远程挂载服务器文件系统</li><li>标准系统文件访问被转换成远程访问</li><li>标准文件共享协议：NFS for Unix, CIFS for windows</li></ul></li><li><p>﻿分布式文件系统的问题</p><ul><li>客户端和客户端上的用户辨别起来很复杂</li><li>例如，NFS是不安全的</li><li><strong>一致性问题</strong></li><li>错误处理模式</li></ul></li><li><p>例如：NFS, SMB, AFS, GFS</p></li></ul></li><li><p>﻿特殊&#x2F;虚拟文件系统</p></li></ul><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><ul><li><p>分层结构</p><ul><li>上层：虚拟(逻辑)文件系统</li><li>底层：特定文件系统模块</li></ul></li><li><p>﻿目的</p><ul><li>对所有不同文件系统的抽象(让上层使用统一的接口对不同的文件系统进行统一管理)</li></ul></li><li><p>﻿功能</p><ul><li>提供相同的文件和文件系统接口</li><li>管理所有文件和文件系统关联的数据结构</li><li>高效查询例程，遍历文件系统</li><li>与特定文件系统模块的交互</li></ul></li><li><p>实现</p><ul><li>﻿卷控制块 (Unix: “superblock”）<ul><li>每个文件系统一个</li><li>文件系统详细信息</li><li>块、块大小，空余块、计数&#x2F;指针等</li></ul></li><li>﻿文件控制块 (Unix： ”vnode” or “inode”）<ul><li>每个文件一个</li><li>文件详细信息</li><li>许可、拥有者、大小、数据库位置等</li></ul></li><li>﻿目录节点 (Linux: ”dentry”）<ul><li>每个目录项一个（目录和文件）</li><li>将目录项数据结构及树型布局编码成树型数据结构</li><li>指向文件控制块、父节点、项目列表等</li></ul></li></ul></li><li><p>文件系统数据结构</p><ul><li>卷控制块（每个文件系统一个）</li><li>文件控制块（每个文件一个）</li><li>目录节点(每个目录项一个)</li></ul></li><li><p>﻿持续存储在二级存储中</p><ul><li>分配在存储设备中的数据块中</li></ul></li><li><p>﻿当需要时加载进内存</p><ul><li>卷控制模块 ：当文件系统挂载时进入内存</li><li>文件控制块：当文件被访问时进入内存</li><li>目录节点：在遍历一个文件路径时进入内存</li></ul></li></ul><h3 id="数据块缓存"><a href="#数据块缓存" class="headerlink" title="数据块缓存"></a>数据块缓存</h3><ul><li>﻿数据块按需读入内存<ul><li>提供 read() 操作</li><li>预读：预选读取后面的数据块</li></ul></li><li>﻿数据块使用后被缓存<ul><li>假设数据将会再次被使用</li><li>写操作可能被缓存和延迟写入</li></ul></li><li>﻿两种数据块缓存方式<ul><li>普通缓冲区缓存</li><li>页缓存：统一缓存数据块和内存页<ul><li>﻿分页要求<ul><li>当需要一个页时才格其载入内存</li></ul></li><li>﻿支持存储<ul><li>一个页（在虚拟地址空间中）可以被映射到一个本地文件中（在二级存储中）</li></ul></li><li>文件数据块的页缓存<ul><li>在虚拟内存中文件数据块被映射成页</li><li>文件的读&#x2F;写操作被转换成对内存的访问</li><li>可能导致缺页和&#x2F;或设置为脏页</li></ul></li></ul></li></ul></li></ul><h3 id="打开文件的数据结构"><a href="#打开文件的数据结构" class="headerlink" title="打开文件的数据结构"></a>打开文件的数据结构</h3><ul><li>﻿打开文件描述<ul><li>文件状态信息</li><li>目录项、当前文件指针、文件操作设置等</li></ul></li><li>﻿打开文件表<ul><li>一个进程一个</li><li>系统级</li><li>每个卷控制块也会保存一个列表</li><li>所以如果有文件被打开将不能被卸载</li></ul></li></ul><h3 id="文件分配"><a href="#文件分配" class="headerlink" title="文件分配"></a>文件分配</h3><ul><li><p>﻿大多数文件都很小</p><ul><li>需要对小文件提供强力的支持</li><li>块空间不能太大</li></ul></li><li><p>﻿﻿一些文件非常大</p><ul><li>必须支持大文件 （64-bit 文件偏移）</li><li>大文件访问需要相当高效</li></ul></li><li><p>﻿如何为一个文件分配数据块</p><ul><li>﻿分配方式<ul><li>连续分配<ul><li>优点：<ul><li>文件读取表现好</li><li>高效的顺序和随机访问</li></ul></li><li>缺点：<ul><li>碎片</li><li>如文件增大，则不好处理</li></ul></li></ul></li><li>链式分配<ul><li>文件以数据块链表的方式存储</li><li>文件头包含了从第一块到最后一块的指针</li><li>优点：<ul><li>创建、增大、缩小容易</li><li>没有碎片</li></ul></li><li>缺点：<ul><li>不可能进行真正的随机访问(链表，所以只能串型访问)</li><li>可靠性(中途断电，导致链表被破坏)</li></ul></li></ul></li><li>索引分配<ul><li>﻿为每个文件创建一个名为索引数据块的非数据数据块<ul><li>到文件数据块的指针列表</li></ul></li><li>﻿文件头包含了索引数据块</li><li>﻿优点：<ul><li>创建、增大、缩小很容易</li><li>没有碎片</li><li>支持直接访问</li></ul></li><li>缺点：<ul><li>当文件很小时，存储索引的开销</li><li>如何处理大文件？</li></ul></li></ul></li></ul></li><li>﻿指标<ul><li>高效：如存储利用 （外部碎片）</li><li>表现：如访问速度</li></ul></li></ul></li></ul><h3 id="空闲空间列表"><a href="#空闲空间列表" class="headerlink" title="空闲空间列表"></a>空闲空间列表</h3><p>……</p><h3 id="多磁盘管理-RAID"><a href="#多磁盘管理-RAID" class="headerlink" title="多磁盘管理 -RAID"></a>多磁盘管理 -RAID</h3><p>磁盘阵列（Redundant Arrays of Independent Disks，RAID），”数块独立磁盘构成具有冗余能力的阵列”</p><p>磁盘阵列是<strong>由很多块独立的磁盘，组合成一个容量巨大的磁盘组</strong>，<u>利用个别磁盘提供数据所产生加成效果提升整个磁盘系统效能</u>。利用这项技术，<strong>将数据切割成许多区段，分别存放在各个硬盘上</strong>。</p><ul><li><p>﻿分区：硬件磁盘的一种适合操作系统指定格式的划分</p></li><li><p>﻿卷：一个拥有一个文件系统实例的可访问的存储空间</p><ul><li>通常常驻在磁盘的单个分区上</li></ul></li><li><p>﻿使用多个并行磁盘来增加</p><ul><li>吞吐量（通过并行)</li><li>可靠性和可用性（通过冗余，多存几份，防备意外）</li></ul></li><li><p>﻿RAID 一 冗余磁盘阵列</p><ul><li>各种磁盘管理技术</li><li>RAID levels：不同RAID 分类（如，RATD-0， RAID-1, RATD-5)</li></ul></li><li><p>﻿实现</p><ul><li>在操作系统内核：存储&#x2F;卷管理</li><li>RAID硬件控制器 (I&#x2F;0)</li></ul></li></ul><h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><ul><li>﻿读取或写入时，磁头必须被定位在期望的磁道，并从所期望的扇区的开始</li><li>﻿寻道时间<ul><li>定位到期望的磁道所花费的时间</li></ul></li><li>﻿旋转延迟<ul><li>从扇区的开始处到到达目的处花费的时间</li></ul></li></ul><h4 id="SCAN"><a href="#SCAN" class="headerlink" title="SCAN"></a>SCAN</h4><p>对于扫描算法，磁臂从磁盘的一端开始，向另一端移动；在移过每个柱面时，处理请求。当到达磁盘的另一端时，磁头移动方向反转，并继续处理。磁头连续来回扫描磁盘。SCAN 算法有时称为电梯算法，因为磁头的行为就像大楼里面的电梯，先处理所有向上的请求，然后再处理相反方向的请求。</p><h4 id="C-LOOK"><a href="#C-LOOK" class="headerlink" title="C-LOOK"></a>C-LOOK</h4><p>基于SCAN算法，C-LOOK移动磁头从磁盘一端到磁盘另一端（磁臂只需移到一个方向的最远请求为止），并且处理行程上的请求，然而，当磁头到达另一端时，它立即返回到磁盘<strong>另一端</strong>最远的请求，而并不处理任何回程上的请求，然后从该最远的请求开始，继续往同一方向移动磁盘处理请求。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2023/06/02/Redis/"/>
      <url>/2023/06/02/Redis/</url>
      
        <content type="html"><![CDATA[<p>本博客参考了韩顺平老师的 Redis 课程讲义！</p><h1 id="1-Redis-基础知识"><a href="#1-Redis-基础知识" class="headerlink" title="1 Redis 基础知识"></a>1 Redis 基础知识</h1><h2 id="1-1-相关资料"><a href="#1-1-相关资料" class="headerlink" title="1.1 相关资料"></a>1.1 相关资料</h2><h3 id="1-1-1-官网-https-redis-io"><a href="#1-1-1-官网-https-redis-io" class="headerlink" title="1.1.1 官网: https://redis.io"></a>1.1.1 官网: <a href="https://redis.io/">https://redis.io</a></h3><h3 id="1-1-2下载地址-https-redis-io-docs-getting-started-installation-install-redis-on-mac-os"><a href="#1-1-2下载地址-https-redis-io-docs-getting-started-installation-install-redis-on-mac-os" class="headerlink" title="1.1.2下载地址: https://redis.io/docs/getting-started/installation/install-redis-on-mac-os/"></a>1.1.2下载地址: <a href="https://redis.io/docs/getting-started/installation/install-redis-on-mac-os/">https://redis.io/docs/getting-started/installation/install-redis-on-mac-os/</a></h3><h2 id="1-2-为什么需要-Redis"><a href="#1-2-为什么需要-Redis" class="headerlink" title="1.2 为什么需要 Redis"></a>1.2 为什么需要 Redis</h2><h3 id="1-2-1-企业需求"><a href="#1-2-1-企业需求" class="headerlink" title="1.2.1 企业需求"></a>1.2.1 企业需求</h3><ul><li>高并发</li><li>高可用</li><li>高性能</li><li>海量用户</li></ul><h3 id="1-2-2-关系型数据库-如-MySQL-问题"><a href="#1-2-2-关系型数据库-如-MySQL-问题" class="headerlink" title="1.2.2 关系型数据库(如 MySQL)-问题"></a>1.2.2 关系型数据库(如 MySQL)-问题</h3><ul><li>性能瓶颈： 磁盘 IO 性能低下</li><li>扩展瓶颈： 数据关系复杂， 扩展性差， 不便于大规模集群</li></ul><h3 id="1-2-3-Redis-的优势"><a href="#1-2-3-Redis-的优势" class="headerlink" title="1.2.3 Redis 的优势"></a>1.2.3 Redis 的优势</h3><ul><li>内存存储-降低磁盘 IO 次数</li><li>不存储关系， 仅存储数据-数据间关系， 越简单越好</li></ul><h2 id="1-3-Redis-简介"><a href="#1-3-Redis-简介" class="headerlink" title="1.3 Redis 简介"></a>1.3 Redis 简介</h2><h3 id="1-3-1-简述"><a href="#1-3-1-简述" class="headerlink" title="1.3.1 简述:"></a>1.3.1 简述:</h3><p>Redis (Remote DIctionary Server) 是用 C 语言开发的一个<strong>开源的高性能键值对（key-value） 数据库</strong></p><h3 id="1-3-2-特征"><a href="#1-3-2-特征" class="headerlink" title="1.3.2 特征"></a>1.3.2 特征</h3><ul><li>数据间没有必然的关联关系</li><li>高性能——官方提供测试数据， 50 个并发执行 100000 个请求,读的速度是 110000 次&#x2F;s,写的速度是 81000 次&#x2F;s</li><li>多种数据结构支持<ul><li><em>String</em> 字符串类型</li><li><em>Hash</em>  列表类型</li><li><em>List</em> 散列类型</li><li><em>Set</em> 集合类型</li><li><em>SortedSet</em> 有序集合模型</li></ul></li><li>持久化支持——可以进行数据灾难恢复</li></ul><p></p><h3 id="1-3-3-应用场景"><a href="#1-3-3-应用场景" class="headerlink" title="1.3.3 应用场景"></a>1.3.3 应用场景</h3><p>● 为热点数据加速查询， 如热点商品、 热点新闻、 热点资讯、 推广类等高访问量信息等</p><p>● 任务队列，如秒杀、抢购、购票排队等</p><p>● 即时信息查询，如排行榜、各类网站访问统计</p><p>● 时效性信息控制，如验证码控制、投票控制等</p><p>● 分布式数据共享，如分布式集群架构中的 session 分离</p><p>● 消息队列</p><p>● 分布式锁</p><h1 id="2-NoSQL-数据库"><a href="#2-NoSQL-数据库" class="headerlink" title="2 NoSQL 数据库"></a>2 NoSQL 数据库</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>​<strong>Not-Only SQL（ 泛指非关系型的数据库）， 作为关系型数据库的补充</strong></p><h2 id="2-2-作用："><a href="#2-2-作用：" class="headerlink" title="2.2 作用："></a>2.2 作用：</h2><p>​ 应对在海量用户和海量数据的情况下， 带来的数据处理问题</p><h2 id="2-3特点"><a href="#2-3特点" class="headerlink" title="2.3特点"></a>2.3特点</h2><ul><li>可扩容， 可伸缩</li><li>大数据量下高性能</li><li>灵活的数据模型</li><li>高可用</li></ul><h3 id="SQL-关系型数据库-🆚-NoSQL-非关系型数据库"><a href="#SQL-关系型数据库-🆚-NoSQL-非关系型数据库" class="headerlink" title="SQL(关系型数据库) 🆚 NoSQL(非关系型数据库)"></a>SQL(关系型数据库) 🆚 NoSQL(非关系型数据库)</h3><table><thead><tr><th></th><th>SQL</th><th>NoSQL</th></tr></thead><tbody><tr><td>数据结构</td><td>结构化(建了表就不方便再改变)</td><td>非结构化</td></tr><tr><td>数据关联</td><td>关联的</td><td>无关联的</td></tr><tr><td>查询方式</td><td>SQL语句查询</td><td>非SQL语句</td></tr><tr><td>事务特性</td><td>ACID</td><td>BASE</td></tr><tr><td>存储方式</td><td>磁盘</td><td>内存</td></tr><tr><td>扩展性</td><td>垂直</td><td>水平</td></tr><tr><td>使用场景</td><td>1）数据结构固定<br />2）相关业务对数据安全性、一致性要求较高</td><td>1）数据结构不稳定<br />2）对一致性、安全性要求不高<br />3）对性能要求高</td></tr></tbody></table><h2 id="2-4-常见-Nosql-数据库"><a href="#2-4-常见-Nosql-数据库" class="headerlink" title="2.4 常见 Nosql 数据库"></a>2.4 常见 Nosql 数据库</h2><ul><li>Redis</li><li>memcache</li><li>HBase</li><li>MongoDB</li></ul><h1 id="3-Redis-使用"><a href="#3-Redis-使用" class="headerlink" title="3 Redis 使用"></a>3 Redis 使用</h1><h2 id="关于本机的redis信息："><a href="#关于本机的redis信息：" class="headerlink" title="关于本机的redis信息："></a>关于本机的redis信息：</h2><ul><li><p>redis.conf 地址：&#x2F;opt&#x2F;homebrew&#x2F;etc&#x2F;redis.conf</p></li><li><p>redis-server地址： &#x2F;opt&#x2F;homebrew&#x2F;opt&#x2F;redis&#x2F;bin&#x2F;redis-server</p></li></ul><p>​运行redis：redis-server    或    &#x2F;opt&#x2F;homebrew&#x2F;opt&#x2F;redis&#x2F;bin&#x2F;redis-server</p><p>​<strong>停止redis：redis-cli shutdown</strong></p><p>​密码设置成了 root 想要知道改了什么配置文件，请到&#x2F;opt&#x2F;homebrew&#x2F;etc&#x2F;redis.conf寻找#donn changed 20230411注释</p><h2 id="基于配置文件运行redis："><a href="#基于配置文件运行redis：" class="headerlink" title="基于配置文件运行redis："></a>基于配置文件运行redis：</h2><p>​redis-server &#x2F;opt&#x2F;homebrew&#x2F;etc&#x2F;redis.conf</p><h2 id="查找redis启用的进程："><a href="#查找redis启用的进程：" class="headerlink" title="查找redis启用的进程："></a>查找redis启用的进程：</h2><pre><code> ps axu | grep redis          </code></pre><p>可以通过杀死进程来关闭redis服务 kill -9 进程号</p><h2 id="redis-cli-使用："><a href="#redis-cli-使用：" class="headerlink" title="redis-cli 使用："></a>redis-cli 使用：</h2><p>​redis-cli -h 127.0.0.1 -p 6379 -a root</p><p>​-h 指定要连接redis结点的ip地址，默认为 127.0.0.1</p><p>​-p 指定要连接的redis节点的端口，默认为 6379</p><p>​-a 指定redis的访问密码(不建议在连接前就输入密码「不安全」) </p><p>​—-&gt; 建议先不输入密码，建立连接后输入 AUTH  用户名(本机未设置)  密码</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/redis-cli.png" style="zoom:100%;" /><h2 id="mac设置redis开机自启动："><a href="#mac设置redis开机自启动：" class="headerlink" title="mac设置redis开机自启动："></a>mac设置redis开机自启动：</h2><p>​1.sudo vim &#x2F;Library&#x2F;LaunchDaemons&#x2F;redis-server.plist     创建plist文档，用于记录redis启动的配置的路径(怎么填去网上找找就行)</p><p>​2.运行以下命令实现开机自启动：</p><p>​sudo launchctl load &#x2F;Library&#x2F;LaunchDaemons&#x2F;redis-server.plist </p><p>​(貌似是执行⬆️这条语句后，mac开机就会自动执行redis-server.plist，即自动开启redis)</p><p>​3.运行指令，若redis启动了即配置成功</p><p>​sudo launchctl start redis-server (模拟重启) </p><h2 id="图形化客户端演示"><a href="#图形化客户端演示" class="headerlink" title="图形化客户端演示"></a>图形化客户端演示</h2><p>​在网站下载Mac版：<a href="https://redis.com/thank-you/redisinsight-the-best-redis-gui-35/">https://redis.com/thank-you/redisinsight-the-best-redis-gui-35/</a>      🌟简单好用</p><h1 id="4-Redis-指令"><a href="#4-Redis-指令" class="headerlink" title="4 Redis 指令"></a>4 Redis 指令</h1><h2 id="4-1-指令文档"><a href="#4-1-指令文档" class="headerlink" title="4.1 指令文档:"></a>4.1 指令文档:</h2><p><a href="http://redis.cn/commands.html">http://redis.cn/commands.html</a></p><p>命令十分丰富， 包括的命令组有 Cluster、 Connection、 Geo、 Hashes、 HyperLogLog、Keys、 Lists、 Pub&#x2F;Sub、 Scripting、 Server、 Sets、 Sorted Sets、 Strings、 Transactions 一共 14个 redis 命令组两百多个 redis 命令</p><h2 id="4-2-基础操作"><a href="#4-2-基础操作" class="headerlink" title="4.2 基础操作"></a>4.2 基础操作</h2><h3 id="4-2-1-通用命令"><a href="#4-2-1-通用命令" class="headerlink" title="4.2.1 通用命令"></a>4.2.1 通用命令</h3><ul><li>help 命令名称      ——&gt;        会返回该命令的用法描述</li></ul><table><thead><tr><th align="center">KEYS</th><th align="center">查看所有符合模板的key(效率低，因此不建议在生产环境设备上使用)</th></tr></thead><tbody><tr><td align="center"><strong>DEL</strong></td><td align="center"><strong>删除指定的key   可以一次删除多个key(用空格隔开即可)</strong></td></tr><tr><td align="center"><strong>EXISTS</strong></td><td align="center"><strong>判断KEY是否存在</strong></td></tr><tr><td align="center"><strong>EXPIRE</strong></td><td align="center"><strong>Set a key’s time to live in seconds</strong>—–<strong>给一个key设置有效期，有效期到期会自动删除key</strong></td></tr><tr><td align="center"><strong>TTL</strong></td><td align="center"><strong>Get the time to live for a key in seconds</strong> (一个key的TTL &#x3D; -1表示永久有效，-2表示已过期)</td></tr><tr><td align="center"><strong>type</strong></td><td align="center"><strong>获取key的类型</strong></td></tr><tr><td align="center"><strong>unlink</strong></td><td align="center"><strong>根据 value 选择<u>非阻塞</u>删除【 仅将 keys 从 keyspace 元数据中删除， 真正的删除会在后续异步操作】</strong></td></tr></tbody></table><h3 id="4-2-2对-DB-数据库-操作"><a href="#4-2-2对-DB-数据库-操作" class="headerlink" title="4.2.2对 DB(数据库)操作"></a>4.2.2对 DB(数据库)操作</h3><ul><li><p><strong>select： 命令切换数据库</strong></p><pre><code> 1. redis 安装后， 默认有 16 个库, 0-15</code></pre><ol start="2"><li>默认操作的是 redis 的 0 号库</li></ol></li><li><p><strong>dbsize： 查看当前数据库的 key 的数量</strong></p></li><li><p><strong>flushdb： 清空当前库</strong></p></li><li><p><strong>flushall： 清空全部库</strong></p></li></ul><h1 id="5-Redis-五大数据类型-x2F-结构"><a href="#5-Redis-五大数据类型-x2F-结构" class="headerlink" title="5 Redis 五大数据类型&#x2F;结构"></a>5 Redis 五大数据类型&#x2F;结构</h1><h2 id="5-1-操作文档"><a href="#5-1-操作文档" class="headerlink" title="5.1 操作文档"></a>5.1 操作文档</h2><h3 id="5-1-1-官方文档-https-redis-io-commands"><a href="#5-1-1-官方文档-https-redis-io-commands" class="headerlink" title="5.1.1 官方文档 : https://redis.io/commands"></a>5.1.1 官方文档 : <a href="https://redis.io/commands">https://redis.io/commands</a></h3><h3 id="5-1-2-中文文档-http-redisdoc-com"><a href="#5-1-2-中文文档-http-redisdoc-com" class="headerlink" title="5.1.2 中文文档: http://redisdoc.com/"></a>5.1.2 中文文档: <a href="http://redisdoc.com/">http://redisdoc.com/</a></h3><h2 id="5-2-Redis-数据存储格式"><a href="#5-2-Redis-数据存储格式" class="headerlink" title="5.2 Redis 数据存储格式"></a>5.2 Redis 数据存储格式</h2><h3 id="5-2-1-一句话-redis-自身是一个-Map，-其中所有的数据都是采用-key-value-的形式存储"><a href="#5-2-1-一句话-redis-自身是一个-Map，-其中所有的数据都是采用-key-value-的形式存储" class="headerlink" title="5.2.1 一句话: redis 自身是一个 Map， 其中所有的数据都是采用 key : value 的形式存储"></a>5.2.1 一句话: redis 自身是一个 Map， 其中所有的数据都是采用 key : value 的形式存储</h3><h3 id="5-2-2-key-是字符串，-value-是数据，-数据支持多种类型-x2F-结构"><a href="#5-2-2-key-是字符串，-value-是数据，-数据支持多种类型-x2F-结构" class="headerlink" title="5.2.2 key 是字符串， value 是数据， 数据支持多种类型&#x2F;结构"></a>5.2.2 key 是字符串， value 是数据， 数据支持多种类型&#x2F;结构</h3><h2 id="5-3-Redis-数据类型-5-种常用"><a href="#5-3-Redis-数据类型-5-种常用" class="headerlink" title="5.3 Redis 数据类型-5 种常用"></a>5.3 Redis 数据类型-5 种常用</h2><ul><li><strong>string</strong></li><li><strong>hash</strong></li><li><strong>list</strong></li><li><strong>set</strong></li><li><strong>sorted_set</strong></li></ul><h2 id="5-4-String类型"><a href="#5-4-String类型" class="headerlink" title="5.4 String类型"></a>5.4 String类型</h2><h3 id="5-4-1-说明"><a href="#5-4-1-说明" class="headerlink" title="5.4.1 说明"></a>5.4.1 说明</h3><ol><li>String 是 Redis 最基本的类型， 一个 key 对应一个 value。</li><li>String 类型是二进制安全的, Redis 的 string 可以包含任何数据。 比如 jpg 图片或者序列化的对象。</li><li>String 类型是 Redis 基本的数据类型， 一个 Redis 中字符串 value 最多可以是 512M</li></ol><p>​<strong>String又可以细分</strong>为：    string普通字符串</p><p>​  int 整数类型，可以自增、自减</p><p>​  float  浮点类型，可以自增、自减</p><p><u>底层都是由字节数组存储，区别在于编码方式不同</u></p><ul><li><h5 id="String常见命令："><a href="#String常见命令：" class="headerlink" title="String常见命令："></a>String常见命令：</h5><table><thead><tr><th align="left">SET</th><th align="center">SET key value</th></tr></thead><tbody><tr><td align="left"><strong>GET</strong></td><td align="center"><strong>GET</strong> key</td></tr><tr><td align="left"><strong>append</strong></td><td align="center"><strong>append</strong> key value <strong>将给定的 value 追加到原值的末尾</strong><br/>(key不存在就创建)</td></tr><tr><td align="left"><strong>setnx</strong></td><td align="center"><strong>setnx</strong> key value<br/>只有在 key 不存在时 设置 key 的值</td></tr><tr><td align="left"><strong>INCR</strong>(若value为int，value++)</td><td align="center"><strong>INCR</strong> key</td></tr><tr><td align="left"><strong>DECR</strong>(若value为int，value+&#x3D;-1)</td><td align="center"><strong>DECR</strong> key</td></tr><tr><td align="left"><strong>INCRBY</strong>(若value为int，value+&#x3D; step)</td><td align="center"><strong>INCRBY</strong> key step（step可为任意非0整数）</td></tr><tr><td align="left"><strong>INCRBYFLOAT</strong>(若value为float，value +&#x3D; step)</td><td align="center"><strong>INCRBYFLOAT</strong> key step ( float类型 )</td></tr><tr><td align="left"><strong>MSET</strong>(批量添加键值对)</td><td align="center"><strong>MSET</strong> key1 value1 key2 value2 …</td></tr><tr><td align="left"><strong>MGET</strong>(批量查询values)</td><td align="center"><strong>MGET</strong> key1 key2 key3 …</td></tr><tr><td align="left"><strong>msetnx</strong></td><td align="center"><strong>msetnx</strong> <key1><value1><key2><value2><br/> 同时设置一个或多个 key-value 对， 当且仅当所有给定 key 都不存在, 原子性， 有一个失败则都失败</td></tr><tr><td align="left"><strong>getrange</strong></td><td align="center">getrange <key>&lt;起始位置&gt;&lt;结束位置&gt;<br/> 获得值的范围， 类似 java 中的 substring<br/>两边都是闭区间，下标从0开始，负数表示从后往前数</td></tr><tr><td align="left"><strong>setrange</strong></td><td align="center"><strong>setrange</strong><key>&lt;起始位置&gt;<value>  <br/>覆写<key>所储存的字符串值， 从&lt;起始位置&gt;开始(索引从 0 开始)。</td></tr><tr><td align="left"><strong>SETEX</strong></td><td align="center"><strong>setex</strong> <key>&lt;过期时间&gt;<value> <br/>设置键值的同时， 设置过期时间， 单位秒</td></tr><tr><td align="left"><strong>getset</strong></td><td align="center"><strong>getset</strong> <key><value> ,<br/>以新换旧， 设置了新值同时获得旧值</td></tr></tbody></table><h5 id="思考：Redis中没有table的概念，那么该如何区别不同类型的key呢？-比如一个学生的id-x3D-1，一门课程的id也为1"><a href="#思考：Redis中没有table的概念，那么该如何区别不同类型的key呢？-比如一个学生的id-x3D-1，一门课程的id也为1" class="headerlink" title="思考：Redis中没有table的概念，那么该如何区别不同类型的key呢？(比如一个学生的id &#x3D; 1，一门课程的id也为1)"></a>思考：Redis中没有table的概念，那么该如何区别不同类型的key呢？(比如一个学生的id &#x3D; 1，一门课程的id也为1)</h5><p>​Redis中 key 允许有多个单词(用于平替表的概念)形成层级结构，多个单词间用 ：隔开</p><p>​格式举例—&gt;     项目名 ：业务名 ：类型 ：你给key起的名称</p></li></ul><h2 id="5-5-List类型-类似java-中的LinkedList"><a href="#5-5-List类型-类似java-中的LinkedList" class="headerlink" title="5.5 List类型(类似java 中的LinkedList)"></a>5.5 List类型(类似java 中的LinkedList)</h2><h3 id="5-5-1-概要"><a href="#5-5-1-概要" class="headerlink" title="5.5.1 概要"></a>5.5.1 概要</h3><p>list 类型, 保存多个数据， 底层使用双向链表存储结构实现——(支持正向、反向检索)</p><h3 id="5-5-2-list-存储结构示意图"><a href="#5-5-2-list-存储结构示意图" class="headerlink" title="5.5.2 list 存储结构示意图"></a>5.5.2 list 存储结构示意图</h3><p>​● 双向链表示意图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727194906350.png" alt="image-20230727194906350"></p><p>​<u>有序、元素可重复、增删操作快、查找速度一般</u></p><p>● 老韩解图</p><pre><code>1. Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部(左边)或者尾部(右边)。2. 底层是个双向链表，对两端的操作性能高，通过索引下标的操作中间的节点性能较差</code></pre><h3 id="5-5-3-List类型常见命令："><a href="#5-5-3-List类型常见命令：" class="headerlink" title="5.5.3 List类型常见命令："></a>5.5.3 List类型常见命令：</h3><table><thead><tr><th align="left"><strong>LPUSH <key><value1><value2><value3> …</strong></th><th><strong>向列表<u>左侧</u>插入一个或多个元素(一个一个push，第一个在最右边)</strong></th></tr></thead><tbody><tr><td align="left"><strong>LPOP <key></strong></td><td><strong>移除并返回列表左侧的第一个元素，没有则返回nil</strong></td></tr><tr><td align="left"><strong>RPUSH ** <key><value1><value2><value3> …</strong>**</td><td><strong>向列表<u>右侧</u>插入一个或多个元素</strong></td></tr><tr><td align="left"><strong>RPOP <key></strong></td><td><strong>移除并返回列表右侧的第一个元素，没有则返回nil</strong></td></tr><tr><td align="left"><strong>rpoplpush</strong> <key1> <key2></td><td><strong>从<key1>列表右边吐出一个值， 插到<key2>列表左边</strong></td></tr><tr><td align="left"><strong>lrange</strong> <key><start><stop></td><td><strong>按照索引下标获得索引范围内的所有元素(从左到右)</strong></td></tr><tr><td align="left"><strong>lrange mylist 0 -1</strong></td><td>0 左边第一个， -1 右边第一个， （0-1 表示获取所有）</td></tr><tr><td align="left"><strong>lindex <key><index></strong></td><td><strong>按照索引下标<u>获得</u>元素(从左到右)</strong></td></tr><tr><td align="left"><strong>llen</strong> <key></td><td><strong>获得列表长度</strong></td></tr><tr><td align="left"><strong>linsert <key> before <value><newvalue></strong></td><td><strong>在<value>的前面插入<newvalue>插入值</strong></td></tr><tr><td align="left"><strong>lrem</strong> <key><n><value></td><td><strong>从左边删除 n 个 value(从左到右)</strong></td></tr><tr><td align="left"><strong>lset<key><index><value></strong></td><td><strong>将列表 key 下标为 index 的值替换成 value</strong></td></tr><tr><td align="left"><strong>BLPOP&#x2F;BRPOP <key> <time></strong></td><td><strong>与LPOP和RPOP类似，<u>只不过在没有元素时等待指定时间</u>，而不是直接返回nil</strong><br /><strong>阻塞一段时间，在指定的时间内还没能搜索到List中对应的数据，才算是找不到</strong></td></tr></tbody></table><h3 id="5-5-4-list-最佳实践"><a href="#5-5-4-list-最佳实践" class="headerlink" title="5.5.4 list 最佳实践"></a>5.5.4 list 最佳实践</h3><h4 id="5-5-4-1-redis-应用于具有操作先后顺序的数据控制"><a href="#5-5-4-1-redis-应用于具有操作先后顺序的数据控制" class="headerlink" title="5.5.4.1 redis 应用于具有操作先后顺序的数据控制"></a>5.5.4.1 redis 应用于具有操作先后顺序的数据控制</h4><h4 id="5-5-4-2-应用场景"><a href="#5-5-4-2-应用场景" class="headerlink" title="5.5.4.2 应用场景"></a>5.5.4.2 应用场景</h4><p>​● 系统通知， 按照时间顺序展示， 将最近的通知列在前面</p><p>​可用于(如你发了朋友圈，记录为您点赞的用户及其点赞顺序)</p><h2 id="5-6-Set类型-类似java-中的HashSet"><a href="#5-6-Set类型-类似java-中的HashSet" class="headerlink" title="5.6 Set类型(类似java 中的HashSet)"></a>5.6 Set类型(类似java 中的HashSet)</h2><h3 id="5-6-1-概要"><a href="#5-6-1-概要" class="headerlink" title="5.6.1 概要:"></a>5.6.1 概要:</h3><p> set 提供的功能与 list 类似是一个列表的功能， 特殊之处在于 set 是可以自动排重的, 即值是不允许重复的</p><p>​——<u>无序、元素不可重复、查找快、支持交并等集合操作</u></p><p>​像是用哈希表存储的集合</p><h3 id="5-6-2-set-常用指令-amp-使用"><a href="#5-6-2-set-常用指令-amp-使用" class="headerlink" title="5.6.2 set 常用指令&amp;使用"></a>5.6.2 set 常用指令&amp;使用</h3><h4 id="5-6-2-1-set-指令操作示意图"><a href="#5-6-2-1-set-指令操作示意图" class="headerlink" title="5.6.2.1 set 指令操作示意图"></a>5.6.2.1 set 指令操作示意图</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727202023870.png" alt="image-20230727202023870" style="zoom:50%;" /><h4 id="5-6-2-2-Set类型的常见命令："><a href="#5-6-2-2-Set类型的常见命令：" class="headerlink" title="5.6.2.2 Set类型的常见命令："></a>5.6.2.2 Set类型的常见命令：</h4><table><thead><tr><th><strong>SADD <key><value1><value2> …..</strong></th><th><strong>向set中添加一个或多个元素(一个key，任意多个元素)，若已存在，则忽略</strong></th></tr></thead><tbody><tr><td><strong>SMEMBERS <key></strong></td><td><strong>获取set中的所有元素</strong></td></tr><tr><td><strong>SISMEMBER <key> <member></strong></td><td><strong>判断一个元素是否存在于set中</strong></td></tr><tr><td><strong>SCARD <key></strong></td><td><strong>返回set中元素的个数</strong></td></tr><tr><td><strong>SREM <key><value1><value2> ….</strong></td><td><strong>移除set中的指定元素</strong></td></tr><tr><td><strong>spop <key></strong></td><td><strong>随机从该集合中吐出一个值。</strong></td></tr><tr><td><strong>srandmember <key><n></strong></td><td><strong>随机从该集合中取出 n 个值。 不会从集合中删除</strong></td></tr><tr><td><strong>smove <source><destination>value</strong></td><td><strong>把集合中一个值从一个集合移动到另一个集合</strong></td></tr><tr><td>**SINTER <key1> <key2> ** <br /><strong>SDIFF、SUNION…</strong></td><td><strong>求key1与key2的交集</strong><br /><strong>差集、并集…</strong></td></tr></tbody></table><h2 id="5-7-Hash类型-类似java-中的Map"><a href="#5-7-Hash类型-类似java-中的Map" class="headerlink" title="5.7 Hash类型(类似java 中的Map)"></a>5.7 Hash类型(类似java 中的Map)</h2><h3 id="5-7-1-概要"><a href="#5-7-1-概要" class="headerlink" title="5.7.1 概要:"></a>5.7.1 概要:</h3><p> Redis hash 是一个键值对集合， hash 适合用于存储对象， 类似 Java 里面的Map&lt;String,Object&gt;</p><h3 id="5-7-2-一图胜千言：-Redis-hash-存储结构简单示意图"><a href="#5-7-2-一图胜千言：-Redis-hash-存储结构简单示意图" class="headerlink" title="5.7.2 一图胜千言： Redis hash 存储结构简单示意图"></a>5.7.2 一图胜千言： Redis hash 存储结构简单示意图</h3><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727205233999.png" alt="image-20230727205233999" style="zoom:50%;" /><p>​无序字典，可以对对象中的每个字段独立存储，可以针对单个字段CRUD</p><p>​一条hash类型的记录有： 一个 <strong>key</strong> 和一些 <strong>field value</strong> 对</p><h3 id="5-7-3-Hash类型常见命令："><a href="#5-7-3-Hash类型常见命令：" class="headerlink" title="5.7.3 Hash类型常见命令："></a>5.7.3 Hash类型常见命令：</h3><table><thead><tr><th><strong>hset <key1><field1><value1><field2><value2></strong></th><th><strong>批量添加或者修改hash类型key的<u>一个</u>field的值</strong></th></tr></thead><tbody><tr><td><strong>hget <key1><field></strong></td><td><strong>获取<u>一个</u>hash类型key的field的值</strong></td></tr><tr><td><strong>hmset <key1><field1><value1><field2><value2>…</strong></td><td><strong>批量添加、修改hash类型key的多个field与value</strong></td></tr><tr><td><strong>hmget <key1><field1> <field2>…</strong></td><td><strong>批量获取hash类型key的多个field的值</strong></td></tr><tr><td><strong>hexists<key1><field></strong></td><td><strong>查看哈希表 key 中， 给定域 field 是否存在</strong></td></tr><tr><td><strong>hkeys <key></strong></td><td><strong>列出该 hash 集合的所有 field</strong></td></tr><tr><td><strong>hvals <key></strong></td><td><strong>列出该 hash 集合的所有 value</strong></td></tr><tr><td><strong>hincrby <key><field><increment></strong></td><td><strong>为哈希表 key 中的域 field 的值加上增量 increment</strong></td></tr><tr><td><strong>hsetnx <key><field><value></strong></td><td><strong>将哈希表 key 中的域 field 的值设置为 value ， 当且仅当域 field 不存在</strong></td></tr><tr><td><strong>HGETALL key</strong></td><td><strong>获取一个hash类型的key中的所有的field和value</strong></td></tr><tr><td><strong>HINCRBY key field</strong></td><td><strong>让一个hash类型key的字段值自增并指定步长</strong></td></tr><tr><td><strong>HSETNX key field value</strong></td><td><strong>添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</strong></td></tr></tbody></table><h2 id="5-8-SortedSet-Zset类型-功能类似java-中的TreeSet"><a href="#5-8-SortedSet-Zset类型-功能类似java-中的TreeSet" class="headerlink" title="5.8 SortedSet-Zset类型(功能类似java 中的TreeSet)"></a>5.8 SortedSet-Zset类型(功能类似java 中的TreeSet)</h2><h3 id="5-8-1-简介"><a href="#5-8-1-简介" class="headerlink" title="5.8.1 简介"></a>5.8.1 简介</h3><ol><li>Redis 有序集合 zset 与普通集合 set 非常相似， 是一个<strong>没有重复元素的字符串集合</strong>。</li><li>不同之处是<strong>有序集合的每个成员都关联了一个评分(score),这个评分(score)被用来按照从最低分到最高分的方式排序集合中的成员</strong>。 集合的成员是唯一的， 但是评分可以是重复的 。</li><li>因为元素是有序的, 所以也可以很快的根据评分(score)或者次序(position)来获取一个范围的元素。</li><li>访问有序集合的中间元素也是非常快的, 你能够使用有序集合作为一个没有重复成员的列表。</li></ol><p></p><p>​——<u>可排序、元素不重复、查询速度快</u></p><p>​常用于实现<u>排行榜</u>这样的功能</p><h3 id="5-8-2-SortedSet类型的常用命令："><a href="#5-8-2-SortedSet类型的常用命令：" class="headerlink" title="5.8.2 SortedSet类型的常用命令："></a>5.8.2 Sorted<u>Set</u>类型的常用命令：</h3><table><thead><tr><th><strong>zadd <key><score1><value1><score2><value2>…</strong></th><th><strong>添加一个或多个元素到sorted set ，如果value已经存在则更新其score值</strong></th></tr></thead><tbody><tr><td><strong>z(rev)range <key><start><stop> [WITHSCORES]</strong></td><td><strong>返回有序集 key 中， <u>下标</u>在<start><stop>之间的元素，带 WITHSCORES， 可以让分数一起和值返回到结果集(默认升序、rev表示反转，即降序)</strong></td></tr><tr><td><strong>zscore <key><member></strong></td><td><strong>获取sorted set中的指定元素的score值</strong></td></tr><tr><td><strong>z(rev)rangebyscore key min max [withscores]</strong></td><td><strong>返回有序集 key 中， 所有 score 值介于min 和 max 之间(包括等于 min 或 max )的成员。 有序集成员按 score 值递增(从小到大)次序排列</strong></td></tr><tr><td><strong>zincrby <key><increment><value></strong></td><td><strong>为元素的 score 加上增量</strong></td></tr><tr><td><strong>zrem <key><value></strong></td><td><strong>删除该集合下， 指定值的元素</strong></td></tr><tr><td><strong>zcount <key><min><max></strong></td><td><strong>统计该集合， 分数区间内的元素个数</strong></td></tr><tr><td><strong>zrank <key><value></strong></td><td><strong>返回该值在集合中的排名， 从 0 开始</strong></td></tr><tr><td><strong>Z(REV)RANK <key><value></strong></td><td><strong>获取sorted set 中的指定元素的排名</strong>(从0开始，默认升序)</td></tr><tr><td><strong>ZCARD <key></strong></td><td><strong>获取sorted set中的元素个数</strong></td></tr><tr><td><strong>ZCOUNT key min max</strong></td><td><strong>统计<u>score</u>值在给定范围内的所有元素的个数</strong></td></tr><tr><td><strong>ZDIFF、ZINTER、ZUNION</strong></td><td><strong>求差集、交集、并集</strong></td></tr></tbody></table><ul><li>🌟注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可</li></ul><h1 id="6-Redis-配置"><a href="#6-Redis-配置" class="headerlink" title="6 Redis 配置"></a>6 Redis 配置</h1><h2 id="6-1-配置文档"><a href="#6-1-配置文档" class="headerlink" title="6.1 配置文档"></a>6.1 配置文档</h2><h3 id="6-1-1-参考文档"><a href="#6-1-1-参考文档" class="headerlink" title="6.1.1 参考文档 :"></a>6.1.1 参考文档 :</h3><p><a href="https://www.cnblogs.com/nhdlb/p/14048083.html#_label0">https://www.cnblogs.com/nhdlb/p/14048083.html#_label0</a></p><h2 id="6-2-常规配置"><a href="#6-2-常规配置" class="headerlink" title="6.2 常规配置"></a>6.2 常规配置</h2><h3 id="6-2-1-设置密码"><a href="#6-2-1-设置密码" class="headerlink" title="6.2.1 设置密码"></a>6.2.1 设置密码</h3><h3 id="6-2-2-daemonize"><a href="#6-2-2-daemonize" class="headerlink" title="6.2.2 daemonize"></a>6.2.2 daemonize</h3><h3 id="6-2-3-loglevel"><a href="#6-2-3-loglevel" class="headerlink" title="6.2.3 loglevel"></a>6.2.3 loglevel</h3><h3 id="6-2-4-logfile"><a href="#6-2-4-logfile" class="headerlink" title="6.2.4 logfile"></a>6.2.4 logfile</h3><h3 id="6-2-5-设定库的数量"><a href="#6-2-5-设定库的数量" class="headerlink" title="6.2.5 设定库的数量"></a>6.2.5 设定库的数量</h3><h2 id="6-3-Units-单位"><a href="#6-3-Units-单位" class="headerlink" title="6.3 Units 单位"></a>6.3 Units 单位</h2><p>如图:</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728083451434.png" alt="image-20230728083451434"></p><p>1、 配置大小单位,开头定义了一些基本的度量单位， 只支持 bytes， 不支持 bit</p><p>2、 不区分大小写</p><h2 id="6-4-INCLUDES"><a href="#6-4-INCLUDES" class="headerlink" title="6.4 #INCLUDES#"></a>6.4 #INCLUDES#</h2><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728083845886.png" alt="image-20230728083845886"></p><p><strong>多实例的情况可以把公用的配置文件提取出来, 然后 include</strong></p><h2 id="6-5-NETWORK"><a href="#6-5-NETWORK" class="headerlink" title="6.5 #NETWORK#"></a>6.5 #NETWORK#</h2><h3 id="6-5-1-bind"><a href="#6-5-1-bind" class="headerlink" title="6.5.1 bind"></a>6.5.1 bind</h3><p> 如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728084509521.png" alt="image-20230728084509521"></p><ul><li>默认情况 bind&#x3D;127.0.0.1 只能接受本机的访问请求</li><li>如果服务器是需要远程访问的， 需要将其注释掉</li></ul><h3 id="6-5-2-protected-mode"><a href="#6-5-2-protected-mode" class="headerlink" title="6.5.2 protected-mode"></a>6.5.2 protected-mode</h3><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728084720819.png" alt="image-20230728084720819"></p><ul><li>默认是保护模式</li><li>如果服务器是需要远程访问的, 需要将 yes 设置为 no</li></ul><h3 id="6-5-3-port"><a href="#6-5-3-port" class="headerlink" title="6.5.3 port"></a>6.5.3 port</h3><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728084841445.png" alt="image-20230728084841445"></p><ul><li>Redis 服务默认端口 6379</li></ul><h3 id="6-5-4-timeout"><a href="#6-5-4-timeout" class="headerlink" title="6.5.4 timeout"></a>6.5.4 timeout</h3><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728084955938.png" alt="image-20230728084955938"></p><ul><li>一个空闲的客户端维持多少秒会关闭， 0 表示关闭该功能, 即永不超时</li></ul><h3 id="6-5-5-tcp-keepalive"><a href="#6-5-5-tcp-keepalive" class="headerlink" title="6.5.5 tcp-keepalive"></a>6.5.5 tcp-keepalive</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728085057878.png" alt="image-20230728085057878"></p><ul><li>tcp-keepalive 是<strong>对访问客户端的一种心跳检测</strong>， 每隔 n 秒检测一次, 单位为秒</li><li>如果设置为 0， 则不会进行 Keepalive 检测， 建议设置成 60</li><li>老韩说明: 为什么需要心跳检测机制<ul><li>TCP 协议中有长连接和短连接之分。 短连接环境下， 数据交互完毕后， 主动释放连接；</li><li>长连接的环境下， 进行一次数据交互后， 很长一段时间内无数据交互时， 客户端可能意外断开， 这些 TCP 连接并未来得及正常释放， 那么， 连接的另一方并不知道对端的情况，它会一直维护这个连接， 长时间的积累会导致非常多的半打开连接， 造成端系统资源的消耗和浪费， 且有可能导致在一个无效的数据链路层面发送业务数据， 结果就是发送失败。所以服务器端要做到快速感知失败， 减少无效链接操作， 这就有了 TCP 的 Keepalive(保活探测)机制</li></ul></li></ul><h2 id="6-6-GENERAL-通用"><a href="#6-6-GENERAL-通用" class="headerlink" title="6.6 #GENERAL 通用#"></a>6.6 #GENERAL 通用#</h2><h3 id="6-6-1-daemonize"><a href="#6-6-1-daemonize" class="headerlink" title="6.6.1 daemonize"></a>6.6.1 daemonize</h3><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728085407475.png" alt="image-20230728085407475"></p><ul><li>是否为后台进程， 设置为 yes</li><li>设置为 yes 后, 表示守护进程, 后台启动</li></ul><h3 id="6-6-2-pidfile"><a href="#6-6-2-pidfile" class="headerlink" title="6.6.2 pidfile"></a>6.6.2 pidfile</h3><p>如图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728085518957.png" alt="image-20230728085518957"></p><ul><li>存放 pid 文件的位置， 每个实例会产生一个不同的 pid 文件, <strong>记录 redis 的进程号</strong></li></ul><h3 id="6-6-3-loglevel"><a href="#6-6-3-loglevel" class="headerlink" title="6.6.3 loglevel"></a>6.6.3 loglevel</h3><p>如图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728085914809.png" alt="image-20230728085914809"></p><ul><li><p>redis 日志分为 4 个级别， 默认的设置为 notice, <strong>开发测试阶段可以用 debug</strong>(日志内容较多,不建议生产环境使用)， 生产模式一般选用 notice</p></li><li><p>redis 日志分为 4 个级别说明</p><ul><li>debug： 会打印出很多信息， 适用于开发和测试阶段；</li><li>verbose（冗长的）： 包含很多不太有用的信息， 但比 debug 要清爽一些；</li><li>notice： 适用于生产模式；</li><li>warning : 警告信息；</li></ul></li></ul><h3 id="6-6-4-logfile"><a href="#6-6-4-logfile" class="headerlink" title="6.6.4 logfile"></a>6.6.4 logfile</h3><p>如图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728090613879.png" alt="image-20230728090613879"></p><ul><li>logfile “” 就是说， 默认为控制台打印， 并没有日志文件生成</li><li>可以为 redis.conf 的 logfile 指定配置项</li></ul><h3 id="6-6-5-databases-16"><a href="#6-6-5-databases-16" class="headerlink" title="6.6.5 databases 16"></a>6.6.5 databases 16</h3><p>如图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728090759061.png" alt="image-20230728090759061"></p><ul><li>设定库的数量 默认 16， 默认数据库为 0 号</li><li>可以使用 SELECT <dbid>命令在连接上指定数据库 id</li></ul><h2 id="6-7-SECURITY-安全"><a href="#6-7-SECURITY-安全" class="headerlink" title="6.7 #SECURITY 安全#"></a>6.7 #SECURITY 安全#</h2><h3 id="6-7-1-设置密码"><a href="#6-7-1-设置密码" class="headerlink" title="6.7.1 设置密码"></a>6.7.1 设置密码</h3><h4 id="6-7-1-1-redis-conf-中设置密码"><a href="#6-7-1-1-redis-conf-中设置密码" class="headerlink" title="6.7.1.1 redis.conf 中设置密码"></a>6.7.1.1 redis.conf 中设置密码</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728090958792.png" alt="image-20230728090958792"></p><h4 id="6-7-1-2-命令行设置密码-密码只在本次启动过程中生效"><a href="#6-7-1-2-命令行设置密码-密码只在本次启动过程中生效" class="headerlink" title="6.7.1.2 命令行设置密码(密码只在本次启动过程中生效)"></a>6.7.1.2 命令行设置密码(密码只在本次启动过程中生效)</h4><p>在redis服务中，   config set requirepass 密码</p><p><strong>在命令中设置密码， 是临时的, 重启 redis 服务器， 密码就还原了</strong></p><h2 id="6-8-LIMITS-限制"><a href="#6-8-LIMITS-限制" class="headerlink" title="6.8 #LIMITS 限制#"></a>6.8 #LIMITS 限制#</h2><h3 id="6-8-1-maxclients"><a href="#6-8-1-maxclients" class="headerlink" title="6.8.1 maxclients"></a>6.8.1 maxclients</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728091350586.png" alt="image-20230728091350586"></p><ul><li>设置 redis 同时可以与多少个客户端进行连接</li><li>默认情况下为 10000 个客户端</li><li>如果达到了此限制， redis会拒绝新的连接请求， 并且向这些连接请求方发出”max numberof clients reached”</li></ul><h3 id="6-8-2-maxmemory"><a href="#6-8-2-maxmemory" class="headerlink" title="6.8.2 maxmemory"></a>6.8.2 maxmemory</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728091506781.png" alt="image-20230728091506781"></p><ul><li>在默认情况下, 对 32 位 实例会限制在 3 GB, 因为 32 位的机器最大只支持 4GB 的内存， 而系统本身就需要一定的内存资源来支持运行， 所以 32 位机器限制最大 3 GB 的可用内存是非常合理的， 这样可以避免因为内存不足而导致 Redis 实例崩溃</li><li>在默认情况下, 对于 64 位实例是没有限制</li><li>当用户开启了 redis.conf 配置文件的 maxmemory 选项， 那么 Redis 将限制选项的值不能小于 1 MB</li></ul><p><u><strong>对 maxmemory 设置的建议</strong></u></p><ol><li><p>Redis 的 maxmemory 设置取决于使用情况, 有些网站只需要 32MB， 有些可能需要 12GB。</p></li><li><p>maxmemory 只能根据具体的生产环境来调试， 不要预设一个定值， 从小到大测试，基本标准是不干扰正常程序的运行。</p></li><li><p>Redis 的最大使用内存跟搭配方式有关， 如果只是用 Redis 做纯缓存, 64-128M 对一般小型网站就足够了</p></li><li><p>如果使用 Redis 做数据库的话， 设置到物理内存的 1&#x2F;2 到 3&#x2F;4 左右都可以</p></li><li><p>如果使用了快照功能的话， 最好用到 50%以下， 因为快照复制更新需要双倍内存空间，如果没有使用快照而设置 redis 缓存数据库， 可以用到内存的 80%左右， 只要能保证 Java、NGINX 等其它程序可以正常运行就行了</p></li></ol><h3 id="6-8-3-maxmemory-policy"><a href="#6-8-3-maxmemory-policy" class="headerlink" title="6.8.3 maxmemory-policy"></a>6.8.3 maxmemory-policy</h3><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728092049334.png" alt="image-20230728092049334" style="zoom:70%;" /><p>policy 一览:</p><ul><li>volatile-lru： 使用 LRU 算法移除 key， 只对设置了过期时间的键； (最近最少使用)</li><li>allkeys-lru： 在所有集合 key 中， 使用 LRU 算法移除 key</li><li>volatile-random： 在过期集合中移除随机的 key， 只对设置了过期时间的键</li><li>allkeys-random： 在所有集合 key 中， 移除随机的 key</li><li>volatile-ttl： 移除那些 TTL 值最小的 key， 即那些最近要过期的 key</li><li>noeviction： 不进行移除。 针对写操作， 只是返回错误信息</li></ul><h3 id="6-8-4-maxmemory-samples"><a href="#6-8-4-maxmemory-samples" class="headerlink" title="6.8.4 maxmemory-samples"></a>6.8.4 maxmemory-samples</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728091924891.png" alt="image-20230728091924891"></p><ul><li>设置样本数量， LRU 算法和最小 TTL 算法都并非是精确的算法， 而是估算值， 所以你可以设置样本的大小， redis 默认会检查这么多个 key 并选择其中 LRU 的那个</li><li>一般设置 3 到 7 的数字， 数值越小样本越不准确， 但性能消耗越小</li></ul><h1 id="7-发布和订阅"><a href="#7-发布和订阅" class="headerlink" title="7 发布和订阅"></a>7 发布和订阅</h1><h2 id="7-1-发布和订阅是什么"><a href="#7-1-发布和订阅是什么" class="headerlink" title="7.1 发布和订阅是什么"></a>7.1 发布和订阅是什么</h2><h3 id="7-1-1-概述："><a href="#7-1-1-概述：" class="headerlink" title="7.1.1 概述："></a>7.1.1 概述：</h3><p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式： 发送者 (pub) 发送消息，订阅者 (sub) 接收消息</p><h3 id="7-1-2-Redis-客户端可以订阅任意数量的频道"><a href="#7-1-2-Redis-客户端可以订阅任意数量的频道" class="headerlink" title="7.1.2 Redis 客户端可以订阅任意数量的频道"></a>7.1.2 Redis 客户端可以订阅任意数量的频道</h3><h3 id="7-1-3-一图胜千言"><a href="#7-1-3-一图胜千言" class="headerlink" title="7.1.3 一图胜千言"></a>7.1.3 一图胜千言</h3><p>1、 客户端订阅频道示意图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728092654620.png" alt="image-20230728092654620" style="zoom: 67%;" /><p>2、当给这个频道发布消息后，消息就会发送给订阅的客户端</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728093005557.png" alt="image-20230728093005557" style="zoom:60%;" /><h2 id="7-2-如何理解发布和订阅模式"><a href="#7-2-如何理解发布和订阅模式" class="headerlink" title="7.2 如何理解发布和订阅模式"></a>7.2 如何理解发布和订阅模式</h2><h3 id="7-2-1-任务队列"><a href="#7-2-1-任务队列" class="headerlink" title="7.2.1 任务队列"></a>7.2.1 任务队列</h3><p>1、 顾名思义， 就是”传递消息的队列”</p><p>2、 与任务队列进行交互的实体有两类， 一类是生产者（ producer）， 另一类则是消费者（consumer）。 <strong>生产者将需要处理的任务放入任务队列中， 而消费者则不断地从任务队列中读入任务信息并执行</strong></p><h3 id="7-2-2-如何理解"><a href="#7-2-2-如何理解" class="headerlink" title="7.2.2 如何理解"></a>7.2.2 如何理解</h3><p>​可以这么简单的理解：</p><ol><li>Subscriber： 收音机， 可以收到多个频道， 并以队列方式显示</li><li>Publisher： 电台， 可以往不同的 FM 频道中发消息</li><li>Channel： 不同频率的 FM 频道</li></ol><p>从 Pub&#x2F;Sub 的机制来看， 它更像是一个广播系统， 多个订阅者（Subscriber） 可以订阅多个频道（Channel）， 多个发布者（Publisher） 可以往多个频道（Channel） 中发布消息</p><h2 id="7-3-发布订阅模式分类"><a href="#7-3-发布订阅模式分类" class="headerlink" title="7.3 发布订阅模式分类"></a>7.3 发布订阅模式分类</h2><p>——-发布：提供数据的</p><p>——-订阅：接受、处理数据的</p><h3 id="7-3-1-一个发布者，-多个订阅者"><a href="#7-3-1-一个发布者，-多个订阅者" class="headerlink" title="7.3.1 一个发布者， 多个订阅者"></a>7.3.1 一个发布者， 多个订阅者</h3><p>​-主要应用： <strong>通知、 公告</strong></p><p>​-可以<strong>作为消息队列或者消息管道</strong></p><p>​-示意图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728093416754.png" alt="image-20230728093416754"></p><h3 id="7-3-2-多个发布者，-一个订阅者"><a href="#7-3-2-多个发布者，-一个订阅者" class="headerlink" title="7.3.2 多个发布者， 一个订阅者"></a>7.3.2 多个发布者， 一个订阅者</h3><p>​-各应用程序作为 Publisher 向 Channel 中发送消息， Subscriber 端收到消息后执行相应的业务逻辑， 比如写数据库， 显示..</p><p>​-主要应用：<strong>排行榜、投票、计数</strong></p><p>​-示意图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728093709916.png" alt="image-20230728093709916"></p><h3 id="7-3-3-多个发布者，-多个订阅者"><a href="#7-3-3-多个发布者，-多个订阅者" class="headerlink" title="7.3.3 多个发布者， 多个订阅者"></a>7.3.3 多个发布者， 多个订阅者</h3><p>-可以向不同的 Channel 中发送消息， 由不同的 Subscriber 接收。</p><p>-主要应用：<strong>群聊、聊天</strong></p><p>-示意图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728093939273.png" alt="image-20230728093939273"></p><h2 id="7-4-命令行实现发布和订阅"><a href="#7-4-命令行实现发布和订阅" class="headerlink" title="7.4 命令行实现发布和订阅"></a>7.4 命令行实现发布和订阅</h2><h3 id="7-4-1-发布、订阅操作"><a href="#7-4-1-发布、订阅操作" class="headerlink" title="7.4.1 发布、订阅操作"></a>7.4.1 发布、订阅操作</h3><p>1、 <strong>PUBLISH channel msg</strong></p><p>将信息 message 发送到指定的频道 channel</p><p>2、 <strong>SUBSCRIBE channel [channel …]</strong></p><p>订阅频道， 可以同时订阅多个频道</p><p>3、 <strong>UNSUBSCRIBE [channel …]</strong></p><p>取消订阅指定的频道, 如果不指定频道， 则会取消订阅所有频道</p><p>4、 <strong>PSUBSCRIBE pattern [pattern …]</strong></p><p>订阅一个或多个符合给定模式的频道， 每个模式以 * 作为匹配符， 比如 it* 匹配所 有以 it 开头的频道( it.news 、 it.blog 、 it.tweets 等等)， news.* 匹配所有 以 news. 开头的频道( news.it 、 news.global.today 等等)， 诸如此类</p><p>5、 <strong>PUNSUBSCRIBE [pattern [pattern …]]</strong></p><p>退订指定的规则, 如果没有参数则会退订所有规则</p><h3 id="7-4-2-快速入门"><a href="#7-4-2-快速入门" class="headerlink" title="7.4.2 快速入门"></a>7.4.2 快速入门</h3><p>1、 打开一个客户端订阅 channel1</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728094614049.png" alt="image-20230728094614049" style="zoom:50%;" /><p>2、打开另一个客户端，给 channel1 发布消息 hello</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728094636960.png" alt="image-20230728094636960" style="zoom:50%;" /><p>3、返回的 1, 是订阅者数量</p><p>4、发布的消息没有持久化(关闭redis后就没了)</p><p>5、订阅的客户端, 只能收到订阅后发布的消息</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728094704271.png" alt="image-20230728094704271" style="zoom:50%;" /><h1 id="8-Jedis"><a href="#8-Jedis" class="headerlink" title="8 Jedis"></a>8 Jedis</h1><h2 id="8-1-API-文档"><a href="#8-1-API-文档" class="headerlink" title="8.1 API 文档"></a>8.1 API 文档</h2><h3 id="8-1-1-在线文档-https-www-mklab-cn-onlineapi-jedis"><a href="#8-1-1-在线文档-https-www-mklab-cn-onlineapi-jedis" class="headerlink" title="8.1.1 在线文档 : https://www.mklab.cn/onlineapi/jedis/"></a>8.1.1 在线文档 : <a href="https://www.mklab.cn/onlineapi/jedis/">https://www.mklab.cn/onlineapi/jedis/</a></h3><h2 id="8-2-Jedis-介绍"><a href="#8-2-Jedis-介绍" class="headerlink" title="8.2 Jedis 介绍"></a>8.2 Jedis 介绍</h2><p>-Java 程序操作 Redis 的工具</p><h2 id="8-3-Jedis-操作-Redis-数据"><a href="#8-3-Jedis-操作-Redis-数据" class="headerlink" title="8.3 Jedis 操作 Redis 数据"></a>8.3 Jedis 操作 Redis 数据</h2><p>​<strong>(以redis命名作为方法名称，学习成本低，但是线程不安全，多线程环境下需要基于连接池来使用)</strong></p><h3 id="8-3-1-快速入门"><a href="#8-3-1-快速入门" class="headerlink" title="8.3.1 快速入门"></a>8.3.1 快速入门</h3><h5 id="step1-引入依赖"><a href="#step1-引入依赖" class="headerlink" title="step1:  引入依赖"></a>step1:  引入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="step2：建立连接"><a href="#step2：建立连接" class="headerlink" title="step2：建立连接"></a>step2：建立连接</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 老师解读</span></span><br><span class="line"><span class="comment">* 1. 确保 ip:6379 是连通的, 需要打开防火墙的端口</span></span><br><span class="line"><span class="comment">* 2. 如果 redis 你设置了密码, 需要执行 jedis.auth(&quot;hspedu&quot;);进行权限验证</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">con</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;172.20.10.4&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        jedis.auth(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> jedis.ping();</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功，返回结果：&quot;</span> + res);</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="step3：使用Redis"><a href="#step3：使用Redis" class="headerlink" title="step3：使用Redis"></a>step3：使用Redis</h5><p> (Jedis中的API和redis中的命令一模一样！)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">key</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;172.20.10.4&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">       jedis.auth(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">       jedis.set(<span class="string">&quot;q1&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">       jedis.set(<span class="string">&quot;q2&quot;</span>,<span class="string">&quot;234&quot;</span>);</span><br><span class="line">       jedis.set(<span class="string">&quot;q3&quot;</span>,<span class="string">&quot;345&quot;</span>);</span><br><span class="line"></span><br><span class="line">       Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;key--&gt;&quot;</span> + key);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(jedis.exists(<span class="string">&quot;q1&quot;</span>));</span><br><span class="line">       System.out.println(jedis.ttl(<span class="string">&quot;q2&quot;</span>));</span><br><span class="line">       System.out.println(jedis.get(<span class="string">&quot;q2&quot;</span>));</span><br><span class="line">       jedis.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="step4：释放资源"><a href="#step4：释放资源" class="headerlink" title="step4：释放资源"></a>step4：释放资源</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="literal">null</span>)&#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-2-连接-Redis-注意事项"><a href="#8-3-2-连接-Redis-注意事项" class="headerlink" title="8.3.2 连接 Redis 注意事项"></a>8.3.2 连接 Redis 注意事项</h3><p>1、 确保 ip:6379 是连通的, 注意打开防火墙的 6379 端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">● 设置开放的端口号</span><br><span class="line">firewall-cmd --add-port=6379/tcp --permanent</span><br><span class="line">● 重启防火墙</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">● 查看防火墙</span><br><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure><p>2、如果 redis 你设置了密码, 需要执行 jedis.auth(“密码”);进行权限验证</p><h1 id="9-Spring-Boot2-整合-Redis"><a href="#9-Spring-Boot2-整合-Redis" class="headerlink" title="9 Spring Boot2 整合 Redis"></a>9 Spring Boot2 整合 Redis</h1><h2 id="9-1-需求分析-x2F-图解"><a href="#9-1-需求分析-x2F-图解" class="headerlink" title="9.1 需求分析&#x2F;图解"></a>9.1 需求分析&#x2F;图解</h2><ol><li>在 springboot 中 , 整合 redis</li><li>可以通过 <strong>RedisTemplate</strong> 完成对 redis 的操作, 包括设置数据&#x2F;获取数据</li><li>比如添加和读取数据</li></ol><h2 id="9-2-具体整合实现"><a href="#9-2-具体整合实现" class="headerlink" title="9.2 具体整合实现"></a>9.2 具体整合实现</h2><h3 id="9-2-1-创建-Maven-项目"><a href="#9-2-1-创建-Maven-项目" class="headerlink" title="9.2.1 创建 Maven 项目"></a>9.2.1 创建 Maven 项目</h3><h3 id="9-2-2-修改-pom-xml-引入相关依赖"><a href="#9-2-2-修改-pom-xml-引入相关依赖" class="headerlink" title="9.2.2 修改 pom.xml - 引入相关依赖"></a>9.2.2 修改 pom.xml - 引入相关依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- redis依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- spring2.X集成redis所需common-pool--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--不要带版本号,防止冲突, 使用版本仲裁即可--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.13.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="9-2-3-配置"><a href="#9-2-3-配置" class="headerlink" title="9.2.3 配置"></a>9.2.3 配置</h3><h4 id="9-2-3-1-application-properties"><a href="#9-2-3-1-application-properties" class="headerlink" title="9.2.3.1 application.properties"></a>9.2.3.1 application.properties</h4><p>– 完成 redis 的基本配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Redis服务器地址</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">172.20.10.4</span></span><br><span class="line"><span class="comment">#Redis服务器连接端口</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment">#Redis密码</span></span><br><span class="line"><span class="attr">spring.redis.password</span>=<span class="string">root</span></span><br><span class="line"><span class="comment">#Redis数据库索引(默认为0</span></span><br><span class="line"><span class="attr">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#连接超时时间(毫秒</span></span><br><span class="line"><span class="attr">spring.redis.timeout</span>=<span class="string">1800000</span></span><br><span class="line"><span class="comment">#连接池最大连接数(使用负值表示没有限制</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="comment">#最大阻塞等待时间(使用负值表示没有限制</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment">#连接池中最大空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="comment">#连接池中最小空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure><h4 id="9-2-3-2-redis-配置类"><a href="#9-2-3-2-redis-配置类" class="headerlink" title="9.2.3.2 redis 配置类"></a>9.2.3.2 redis 配置类</h4><p>1、 是<strong>对要使用的 RedisTemplate bean 对象的配置</strong>, 可以理解成是一个常规配置.</p><p>2、 同学们想一想我们以前学习过一个 JdbcTemplate,设计理念类似</p><p>3、 如果不配置, springboot 会使用默认配置, 这个默认配置, 会出现一些问题, 比如:redisTemplate 的 key 序列化等, 问题所以通常我们需要配置</p><p>4、创 建 RedisConfig.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        System.out.println(<span class="string">&quot;template=&gt;&quot;</span> + template);<span class="comment">//这里可以验证..</span></span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.activateDefaultTyping(</span><br><span class="line">                LaissezFaireSubTypeValidator.instance,</span><br><span class="line">                ObjectMapper.DefaultTyping.NON_FINAL,</span><br><span class="line">                JsonTypeInfo.As.WRAPPER_ARRAY);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">//key序列化方式</span></span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line">        <span class="comment">//value序列化</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//value hashmap序列化</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="comment">//解决查询缓存转换异常的问题</span></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.activateDefaultTyping(</span><br><span class="line">                LaissezFaireSubTypeValidator.instance,</span><br><span class="line">                ObjectMapper.DefaultTyping.NON_FINAL,</span><br><span class="line">                JsonTypeInfo.As.WRAPPER_ARRAY);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span></span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        <span class="type">RedisCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-2-3-3-注意事项和细节"><a href="#9-2-3-3-注意事项和细节" class="headerlink" title="9.2.3.3 注意事项和细节"></a>9.2.3.3 注意事项和细节</h4><p>1、 如果没有提供 RedisConfig 配置类 , springboot 会使用默认配置, 也可以使用,但是会存在问题</p><p>2、🌟 Unrecognized token ‘beijing’: was expecting (‘true’, ‘false’ or ‘null’)看报错，是 jason 转换异常，实际上是因为 <strong>redisTemplate 在做数据存储的时候会把存储的内容序列化，所以，redisTemplate 读取的时候也会反序列化，</strong><u>而在 <strong>redis 客户端</strong>set 的时候并不会做序列化，因此 set 的进去的值在用 redisTemplate 读的时候就会报类型转换异常了</u></p><p>—-解决方案 : 最简单的就是<strong>用程序</strong>重新 set 一遍即可</p><h4 id="9-2-3-4编写控制层，接收前端消息后进行redis存取操作"><a href="#9-2-3-4编写控制层，接收前端消息后进行redis存取操作" class="headerlink" title="9.2.3.4编写控制层，接收前端消息后进行redis存取操作"></a>9.2.3.4编写控制层，接收前端消息后进行redis存取操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//装配RedisTemplate</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写方法,演示如何操作list,hash,set,zset</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/t2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">t2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//list-存</span></span><br><span class="line">    redisTemplate.opsForList().leftPush(<span class="string">&quot;books&quot;</span>, <span class="string">&quot;笑傲江湖&quot;</span>);</span><br><span class="line">    redisTemplate.opsForList().leftPush(<span class="string">&quot;books&quot;</span>, <span class="string">&quot;hello,java&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//list-取出</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">books</span> <span class="operator">=</span> redisTemplate.opsForList().range(<span class="string">&quot;books&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">booksList</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (Object book : books) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book--&gt;&quot;</span> + book.toString());</span><br><span class="line">        booksList += book.toString() + <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//hash</span></span><br><span class="line">    <span class="comment">//redisTemplate.opsForHash()</span></span><br><span class="line">    <span class="comment">//set</span></span><br><span class="line">    <span class="comment">//redisTemplate.opsForSet()</span></span><br><span class="line">    <span class="comment">//zset</span></span><br><span class="line">    <span class="comment">//redisTemplate.opsForZSet()</span></span><br><span class="line">    <span class="keyword">return</span> booksList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RedisTemplate工具类的使用：</p><table><thead><tr><th align="center"><strong>API</strong></th><th align="center"><strong>返回值类型</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"><strong>redisTemplate</strong>.opsForValue()</td><td align="center">ValueOperations</td><td align="center">操作String类型数据</td></tr><tr><td align="center"><strong>redisTemplate</strong>.opsForHash()</td><td align="center">HashOperations</td><td align="center">操作Hash类型数据</td></tr><tr><td align="center"><strong>redisTemplate</strong>.opsForList()</td><td align="center">ListOperations</td><td align="center">操作List类型数据</td></tr><tr><td align="center"><strong>redisTemplate</strong>.opsForSet()</td><td align="center">SetOperations</td><td align="center">操作Set类型数据</td></tr><tr><td align="center"><strong>redisTemplate</strong>.opsForZSet()</td><td align="center">ZSetOperations</td><td align="center">操作SortedSet类型数据</td></tr><tr><td align="center"><strong>redisTemplate</strong></td><td align="center"></td><td align="center">通用的命令</td></tr></tbody></table><h1 id="10-Redis-持久化-RDB-记录数据"><a href="#10-Redis-持久化-RDB-记录数据" class="headerlink" title="10 Redis 持久化-RDB(记录数据)"></a>10 Redis 持久化-RDB(记录数据)</h1><h2 id="10-1-官方资料"><a href="#10-1-官方资料" class="headerlink" title="10.1 官方资料"></a>10.1 官方资料</h2><h3 id="10-1-1-在线文档-https-redis-io-topics-persistence"><a href="#10-1-1-在线文档-https-redis-io-topics-persistence" class="headerlink" title="10.1.1 在线文档 : https://redis.io/topics/persistence"></a>10.1.1 在线文档 : <a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a></h3><h2 id="10-2-持久化方案"><a href="#10-2-持久化方案" class="headerlink" title="10.2 持久化方案"></a>10.2 持久化方案</h2><h3 id="10-2-1-RDB（Redis-DataBase）"><a href="#10-2-1-RDB（Redis-DataBase）" class="headerlink" title="10.2.1 RDB（Redis DataBase）"></a>10.2.1 RDB（Redis DataBase）</h3><h3 id="10-2-2-AOF（Append-Of-File）"><a href="#10-2-2-AOF（Append-Of-File）" class="headerlink" title="10.2.2 AOF（Append Of File）"></a>10.2.2 AOF（Append Of File）</h3><h2 id="10-3-RDB-是什么"><a href="#10-3-RDB-是什么" class="headerlink" title="10.3 RDB 是什么?"></a>10.3 RDB 是什么?</h2><h3 id="10-3-1-在指定的时间间隔内将内存中的数据集快照写入磁盘，-也就-Snapshot-快照，-恢复时将快照文件读到内存"><a href="#10-3-1-在指定的时间间隔内将内存中的数据集快照写入磁盘，-也就-Snapshot-快照，-恢复时将快照文件读到内存" class="headerlink" title="10.3.1 在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就 Snapshot 快照， 恢复时将快照文件读到内存"></a>10.3.1 在指定的时间间隔内<u>将内存中的数据集快照写入磁盘</u>， 也就 Snapshot 快照， 恢复时将快照文件读到内存</h3><h2 id="10-4-RDB-持久化流程"><a href="#10-4-RDB-持久化流程" class="headerlink" title="10.4 RDB 持久化流程"></a>10.4 RDB 持久化流程</h2><h3 id="10-4-1-RDB-及其执行流程"><a href="#10-4-1-RDB-及其执行流程" class="headerlink" title="10.4.1 RDB 及其执行流程"></a>10.4.1 RDB 及其执行流程</h3><h4 id="1、-一图胜千言"><a href="#1、-一图胜千言" class="headerlink" title="1、 一图胜千言"></a>1、 一图胜千言</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729092028338.png" alt="image-20230729092028338"></p><h4 id="2、对上图的解读"><a href="#2、对上图的解读" class="headerlink" title="2、对上图的解读"></a>2、对上图的解读</h4><p>​具体流程如下：</p><pre><code>1) redis 客户端执行 bgsave 命令或者自动触发 bgsave 命令；2) 主进程判断当前是否已经存在正在执行的子进程，如果存在，那么主进程直接返回；3) 如果不存在正在执行的子进程，那么就 **fork 一个新的子进程进行持久化数据**，fork 过程是阻塞的，fork 操作完成后主进程即可执行其他操作；4) 子进程先将数据写入到临时的 rdb 文件中，**待快照数据写入完成后再原子替换**旧的 rdb文件</code></pre><ol start="5"><li>同时发送信号给主进程，通知主进程 rdb 持久化完成，主进程更新相关的统计信息</li></ol><h4 id="3、老师小结"><a href="#3、老师小结" class="headerlink" title="3、老师小结"></a>3、老师小结</h4><ol><li>整个过程中，主进程是不进行任何 IO 操作的(交给子进程)，这就确保了极高的性能</li><li>如果需要进行大规模数据的恢复, 且对于数据恢复的完整性不是非常敏感，那 RDB 方式要比 AOF 方式更加的高效</li><li>RDB 的缺点是最后一次持久化后的数据可能丢失(最后一次持久化期间进来的数据不会被记录到rdb文件中)</li></ol><ul><li>如果你是正常关闭 Redis , 关闭时会再进行一次持久化, 不会造成数据丢失</li><li>如果是 Redis 异常终止&#x2F;宕机, 就可能造成数据丢失</li><li>后面在讲解快照配置 , 还会举例说明</li></ul><h3 id="10-4-2-Fork-amp-Copy-On-Write"><a href="#10-4-2-Fork-amp-Copy-On-Write" class="headerlink" title="10.4.2 Fork&amp;Copy-On-Write"></a>10.4.2 Fork&amp;Copy-On-Write</h3><p>1、 Fork 的作用是复制一个与当前进程一样的进程。 新进程的所有数据(变量、 环境变量、程序计数器等) 数值都和原进程一致， 但是是一个全新的进程， 并作为原进程的子进程</p><p>——对进程进行深拷贝，并将结果作为原进程的子进程</p><p>2、 在 Linux 程序中， fork()会产生一个和父进程完全相同的子进程， 但子进程在此后多会exec 系统调用， 出于效率考虑， Linux 中引入了”写时复制技术 即: copy-on-write” , 有兴趣的参考: <a href="https://blog.csdn.net/Code_beeps/article/details/92838520">https://blog.csdn.net/Code_beeps/article/details/92838520</a></p><p>3、 一般情况父进程和子进程会共用同一段物理内存， 只有进程空间的各段的内容要发生变化时， 才会将父进程的内容复制一份给子进程。</p><h2 id="10-5-RDB-配置"><a href="#10-5-RDB-配置" class="headerlink" title="10.5 RDB 配置"></a>10.5 RDB 配置</h2><h3 id="10-5-1-dump-rdb-文件"><a href="#10-5-1-dump-rdb-文件" class="headerlink" title="10.5.1 dump.rdb 文件"></a>10.5.1 dump.rdb 文件</h3><h4 id="10-5-1-1-介绍"><a href="#10-5-1-1-介绍" class="headerlink" title="10.5.1.1 介绍"></a>10.5.1.1 介绍</h4><p>​在 redis.conf 中配置文件名称, 默认为 dump.rdb</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729093257075.png" alt="image-20230729093257075" style="zoom:50%;" /><h4 id="10-5-1-2-如何配置"><a href="#10-5-1-2-如何配置" class="headerlink" title="10.5.1.2 如何配置"></a>10.5.1.2 如何配置</h4><h4 id="1、-默认为-Redis-启动时命令行所在的目录下"><a href="#1、-默认为-Redis-启动时命令行所在的目录下" class="headerlink" title="1、 默认为 Redis 启动时命令行所在的目录下"></a>1、 默认为 Redis 启动时命令行所在的目录下</h4><p>​1) 如图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729094325579.png" alt="image-20230729094325579"></p><p>说明：dump.rdb文件存放着redis中的数据，你每次启动，都会到你设定的路径下的 dump.rdb 中寻找数据，如果此处设置的<strong>不是绝对路径而是相对路径</strong>，那么你在不同的目录下启动redis时，就会去不同的地方寻找备份的数据，即在不同目录下启动得到的备份数据源不同！</p><h3 id="10-5-2-相关配置-amp-参数-amp-操作"><a href="#10-5-2-相关配置-amp-参数-amp-操作" class="headerlink" title="10.5.2 相关配置&amp;参数&amp;操作"></a>10.5.2 相关配置&amp;参数&amp;操作</h3><h4 id="10-5-2-1-默认快照配置"><a href="#10-5-2-1-默认快照配置" class="headerlink" title="10.5.2.1 默认快照配置"></a>10.5.2.1 默认快照配置</h4><h5 id="1、-配置如图"><a href="#1、-配置如图" class="headerlink" title="1、 配置如图"></a>1、 配置如图</h5><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729095330539.png" alt="image-20230729095330539"></p><h5 id="2、注意理解这个时间段的概念"><a href="#2、注意理解这个时间段的概念" class="headerlink" title="2、注意理解这个时间段的概念"></a>2、注意理解这个时间段的概念</h5><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729095537814.png" alt="image-20230729095537814"></p><h5 id="3、如果我们没有开启-save-的注释-那么在退出-Redis-时-也会进行备份-更新-dump-db"><a href="#3、如果我们没有开启-save-的注释-那么在退出-Redis-时-也会进行备份-更新-dump-db" class="headerlink" title="3、如果我们没有开启 save 的注释, 那么在退出 Redis 时, 也会进行备份, 更新 dump.db"></a>3、如果我们没有开启 save 的注释, 那么在退出 Redis 时, 也会进行备份, 更新 dump.db</h5><h4 id="10-5-2-2-save-VS-bgsave"><a href="#10-5-2-2-save-VS-bgsave" class="headerlink" title="10.5.2.2 save VS bgsave"></a>10.5.2.2 save VS bgsave</h4><p>1、 save ： save 时只管保存， 其它不管， 全部阻塞。 手动保存, <strong>不建议</strong>。</p><p>2、 bgsave： <u>Redis 会在后台异步进行快照操作， 快照同时还可以响应客户端请求。</u></p><p>3、 可以通过 lastsave 命令获取最后一次成功执行快照的时间(<strong>unix 时间戳</strong>) , 可以使用工具转换</p><p><a href="https://tool.lu/timestamp/">https://tool.lu/timestamp/</a></p><h4 id="10-5-2-3-flushall"><a href="#10-5-2-3-flushall" class="headerlink" title="10.5.2.3 flushall"></a>10.5.2.3 flushall</h4><p>1、执行 flushall 命令， 也会产生 dump.rdb 文件, 数据为空</p><p>2、Redis Flushall 命令用于<strong>清空整个 Redis 服务器的数据(删除所有数据库的所有 key)</strong></p><p>10.5.2.4 Save</p><p>1、 格式： save 秒钟 写操作次数, 如图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729100520528.png" alt="image-20230729100520528"></p><p>2、RDB 是整个内存的压缩过的 Snapshot，RDB 的数据结构，可以配置复合的快照触发条件(即配合save)</p><p>3、禁用: 给 save 传入空字符串, 可以看文档</p><h4 id="10-5-2-5-stop-writes-on-bgsave-error"><a href="#10-5-2-5-stop-writes-on-bgsave-error" class="headerlink" title="10.5.2.5 stop-writes-on-bgsave-error"></a>10.5.2.5 stop-writes-on-bgsave-error</h4><p>1、 配置如图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729100830128.png" alt="image-20230729100830128"></p><p>2、当 Redis 无法写入磁盘的话(比如磁盘满了), 直接关掉 Redis 的写操作。推荐 yes</p><h4 id="10-5-2-6-rdbcompression"><a href="#10-5-2-6-rdbcompression" class="headerlink" title="10.5.2.6 rdbcompression"></a>10.5.2.6 rdbcompression</h4><p>1、 配置如图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729100916375.png" alt="image-20230729100916375"></p><p>2、对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis 会采用LZF 算法进行压缩。</p><p>3、如果你不想消耗 CPU 来进行压缩的话，可以设置为关闭此功能, 默认 yes</p><h4 id="10-5-2-7-rdbchecksum"><a href="#10-5-2-7-rdbchecksum" class="headerlink" title="10.5.2.7 rdbchecksum"></a>10.5.2.7 rdbchecksum</h4><p>1、 配置如图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729101019969.png" alt="image-20230729101019969"></p><p>2、在存储快照后, 还可以让 redis 使用 CRC64 算法来进行数据校验，保证文件是完整的</p><p>3、但是这样做会增加大约 10%的性能消耗，如果<strong>希望获取到最大的性能提升，可以关闭此功能</strong>, 推荐 yes</p><h4 id="10-5-2-8-动态停止-RDB"><a href="#10-5-2-8-动态停止-RDB" class="headerlink" title="10.5.2.8 动态停止 RDB"></a>10.5.2.8 动态停止 RDB</h4><p>1、 动态停止 RDB： redis-cli <strong>config set save “”</strong></p><p>2、说明: <strong>save 后给空值，表示禁用保存策略</strong></p><h3 id="10-5-3-实例演示"><a href="#10-5-3-实例演示" class="headerlink" title="10.5.3 实例演示"></a>10.5.3 实例演示</h3><p>1、 需求: 如果 Redis 的 key 在 30 秒内, 有 5 个 key 变化, 就自动进行 RDB 备份</p><p>修改redis.conf中的 save 30 5</p><h2 id="10-6-RDB-备份-amp-恢复"><a href="#10-6-RDB-备份-amp-恢复" class="headerlink" title="10.6 RDB 备份&amp;恢复"></a>10.6 RDB 备份&amp;恢复</h2><p>1、 关于 RDB 备份&amp;恢复, 老韩要说的</p><ul><li>老韩先说明：Redis 可以充当缓存, 对项目进行优化, 因此<strong>重要&#x2F;敏感的数据建议在 Mysql要保存一份</strong></li><li>从设计层面来说, Redis 的内存数据, 都是可以重新获取的(可能来自程序, 也可能来自Mysql)</li><li>因此我们这里说的备份&amp;恢复主要是给大家说明一下 <strong>Redis 启动时, 初始化数据是从dump.rdb 来的, 这个机制</strong></li></ul><ol><li><p>config get dir 查询 rdb 文件的目录</p></li><li><p><strong>将 dump.rdb 进行备份</strong>, 如果有必要可以写 shell 脚本来定时备份 [参考 Linux 课程 定时备份 Mysql 数据库, 视频地址 <a href="https://www.bilibili.com/video/BV1Sv411r7vd?p=105">https://www.bilibili.com/video/BV1Sv411r7vd?p=105</a> ] , 这里老师简单处理</p></li></ol><h2 id="10-7-RDB-持久化小结"><a href="#10-7-RDB-持久化小结" class="headerlink" title="10.7 RDB 持久化小结"></a>10.7 RDB 持久化小结</h2><h3 id="10-7-1-优势"><a href="#10-7-1-优势" class="headerlink" title="10.7.1 优势"></a>10.7.1 优势</h3><p>1、 适合大规模的数据恢复</p><p>2、对数据完整性和一致性要求不高更适合使用</p><p>3、节省磁盘空间</p><p>4、恢复速度快</p><h3 id="10-7-2-劣势"><a href="#10-7-2-劣势" class="headerlink" title="10.7.2 劣势"></a>10.7.2 劣势</h3><ol><li><p>虽然 Redis 在 fork 时使用了写时拷贝技术(Copy-On-Write), 但是如果数据庞大时还是比较消耗性能。</p></li><li><p>在备份周期在一定间隔时间做一次备份， 所以如果 Redis 意外 down 掉的话(如果正常关闭 Redis, 仍然会进行 RDB 备份, 不会丢失数据), 就会丢失最后一次快照后的所有修改</p></li></ol><h1 id="11-Redis-持久化-AOF-记录操作"><a href="#11-Redis-持久化-AOF-记录操作" class="headerlink" title="11 Redis 持久化-AOF(记录操作)"></a>11 Redis 持久化-AOF(记录操作)</h1><h2 id="11-1-官方资料"><a href="#11-1-官方资料" class="headerlink" title="11.1 官方资料"></a>11.1 官方资料</h2><h3 id="11-1-1-在线文档-https-redis-io-topics-persistence"><a href="#11-1-1-在线文档-https-redis-io-topics-persistence" class="headerlink" title="11.1.1 在线文档 : https://redis.io/topics/persistence"></a>11.1.1 在线文档 : <a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a></h3><h2 id="11-2-AOF-是什么"><a href="#11-2-AOF-是什么" class="headerlink" title="11.2 AOF 是什么?"></a>11.2 AOF 是什么?</h2><p>1、 AOF(Append Only File)</p><p>2、 <u>以日志的形式来记录每个写操作(增量保存)</u>， 将 Redis 执行过的所有写指令记录下来(比如 set&#x2F;del 操作会记录, 读操作 get 不记录) [后面演示]</p><p>3、 <strong>只许追加文件但不可以改写文件</strong></p><p>4、 redis <strong>启动之初会读取该文件重新构建数据</strong></p><p>5、 redis 重启的话就根据日志文件的内容**<u>将写指令从前到后执行一次以完成数据的恢复工作</u>**</p><h2 id="11-3-AOF-持久化流程"><a href="#11-3-AOF-持久化流程" class="headerlink" title="11.3 AOF 持久化流程"></a>11.3 AOF 持久化流程</h2><p>1、 持久化流程示意图</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230729155117545.png" alt="image-20230729155117545" style="zoom:50%;" /><p>2、解读</p><ol><li>客户端的请求写命令会被 append <strong>追加到 AOF 缓冲区</strong>内</li><li>AOF 缓冲区根据 AOF 持久化策略[always,everysec,no]将操作 sync <strong>同步到磁盘的 AOF 文件</strong>中 </li><li>AOF 文件大小超过重写策略或手动重写时，会对 AOF 文件 <strong>rewrite</strong> 重写，压缩 AOF 文件容量 </li><li>Redis 服务<strong>重启时，会重新 load 加载 AOF 文件中的写操作达到数据恢复的目的</strong></li></ol><h2 id="11-4-AOF-开启"><a href="#11-4-AOF-开启" class="headerlink" title="11.4 AOF 开启"></a>11.4 AOF 开启</h2><p>1、 在 redis.conf 中配置文件名称， 默认为 appendonly.aof</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729155850603.png" alt="image-20230729155850603"></p><p>2、<u><strong>AOF 文件的保存路径，同 RDB 的路径一致。</strong></u></p><p>3、AOF 和 RDB 同时开启，<strong>系统默认取 AOF 的数据</strong>（默认AOF优先级高，可手动修改）</p><p>4、当开启 AOF 后, Redis 从 AOF 文件取数据.</p><h2 id="11-5-AOF-实例演示"><a href="#11-5-AOF-实例演示" class="headerlink" title="11.5 AOF 实例演示"></a>11.5 AOF 实例演示</h2><p>…………</p><h2 id="11-6-AOF-启动-x2F-修复-x2F-恢复"><a href="#11-6-AOF-启动-x2F-修复-x2F-恢复" class="headerlink" title="11.6 AOF 启动&#x2F;修复&#x2F;恢复"></a>11.6 AOF 启动&#x2F;修复&#x2F;恢复</h2><h3 id="11-6-1-基本说明"><a href="#11-6-1-基本说明" class="headerlink" title="11.6.1 基本说明"></a>11.6.1 基本说明</h3><p>​AOF 的备份机制和性能虽然和 RDB 不同, 但是备份和恢复的操作同 RDB 一样, <strong>都是拷贝备份文件, 需要恢复时再拷贝到 Redis 工作目录下， 启动系统即加载</strong></p><h3 id="11-6-2-正常恢复"><a href="#11-6-2-正常恢复" class="headerlink" title="11.6.2 正常恢复"></a>11.6.2 正常恢复</h3><p>1、 修改默认的 appendonly no， 改为 yes</p><p><strong>2、将有数据的 aof 文件定时备份, 需要恢复时, 复制一份保存到对应目录(查看目录：config get dir)</strong></p><p>3、恢复：重启 redis 然后重新加载</p><p>4、和前面 RDB 备份&#x2F;恢复机制类似</p><h3 id="11-6-3-异常恢复"><a href="#11-6-3-异常恢复" class="headerlink" title="11.6.3 异常恢复"></a>11.6.3 异常恢复</h3><p>1、 如遇到 AOF 文件损坏， 通过 [&#x2F;usr&#x2F;local&#x2F;bin]# .&#x2F;redis-check-aof –fix appendonly.aof 进行恢复</p><p>2、建议先: 备份被写坏的 AOF 文件</p><p>3、恢复：重启 redis，然后重新加载</p><h2 id="11-7-同步频率设置"><a href="#11-7-同步频率设置" class="headerlink" title="11.7 同步频率设置"></a>11.7 同步频率设置</h2><p>1、 配置位置</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729161749574.png" alt="image-20230729161749574" style="zoom:50%;" /><p>2、老韩解读上图</p><p>​1)appendfsync always</p><p>​始终同步，每次 Redis 的写入都会立刻记入日志；性能较差但数据完整性比较好</p><p>​2)appendfsync everysec</p><p>​每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</p><p>​3)appendfsync noredis </p><p>​不主动进行同步，把同步时机交给操作系统</p><p>​<a href="https://baijiahao.baidu.com/s?id=1740774723808931509&wfr=spider&for=pc">https://baijiahao.baidu.com/s?id=1740774723808931509&amp;wfr=spider&amp;for=pc</a></p><h2 id="11-8-Rewrite-压缩"><a href="#11-8-Rewrite-压缩" class="headerlink" title="11.8 Rewrite 压缩"></a>11.8 Rewrite 压缩</h2><h3 id="1、-rewrite-重写介绍"><a href="#1、-rewrite-重写介绍" class="headerlink" title="1、 rewrite 重写介绍"></a>1、 rewrite 重写介绍</h3><pre><code>1) AOF 文件越来越大，**需要定期对 AOF 文件进行重写达到压缩**1) 旧的 AOF 文件含有&lt;u&gt;无效命令会被忽略，保留最新的数据命令&lt;/u&gt; , 比如 set a a1 ; set a b1 ;set a c1; 保留最后一条指令就可以了1) &lt;u&gt;多条写命令可以合并为一个 , 比如 set a c1 b b1 c c1&lt;/u&gt;1) AOF 重写降低了文件占用空间1) 更小的 AOF 文件可以更快的被 redis 加载</code></pre><h3 id="2、重写触发配置"><a href="#2、重写触发配置" class="headerlink" title="2、重写触发配置"></a>2、重写触发配置</h3><p>​1) 手动触发直接调用 bgrewriteaof 命令</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729162232144.png" alt="image-20230729162232144" style="zoom:50%;" /><p>​2）自动触发</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729162701336.png" alt="image-20230729162701336"></p><ul><li><strong>auto-aof-rewrite-min-size: AOF 文件最小重写大小</strong>, 只有当 AOF 文件大小大于该值时候才能重写, 默认配置 64MB</li><li>auto-aof-rewrite-percentage: 当前 AOF 文件大小和最后一次重写后的大小之间的比率等于或者大于指定的增长百分比，如 100 代表当前 AOF 文件是上次重写的两倍时候才重写</li></ul><p>系统载入时或者上次重写完毕时，Redis 会记录此时 AOF 大小，设为base_size, 如果 Redis 的 AOF 当前大小&gt;&#x3D; base_size +base_size*100% (默认)且当前大小&gt;&#x3D;64mb(默认)的情况下，Redis 会对 AOF 进行重写</p><h2 id="11-9-AOF-持久化小结"><a href="#11-9-AOF-持久化小结" class="headerlink" title="11.9 AOF 持久化小结"></a>11.9 AOF 持久化小结</h2><h3 id="11-9-1-优势"><a href="#11-9-1-优势" class="headerlink" title="11.9.1 优势"></a>11.9.1 优势</h3><p>1、 备份机制更稳健， 丢失数据概率更低。</p><p>2、可读的日志文本，通过操作 AOF 稳健，可以处理误操作</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729175239380.png" alt="image-20230729175239380" style="zoom:50%;" /><h3 id="11-9-2-劣势"><a href="#11-9-2-劣势" class="headerlink" title="11.9.2 劣势"></a>11.9.2 劣势</h3><p>1、 比起 RDB 占用更多的磁盘空间</p><p>2、恢复备份速度要慢</p><p>3、每次读写都同步的话，有一定的性能压力</p><h2 id="11-10-RDB-还是-AOF"><a href="#11-10-RDB-还是-AOF" class="headerlink" title="11.10 RDB 还是 AOF?"></a>11.10 RDB 还是 AOF?</h2><p>1、 官方文档地址: <a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a></p><p>2、<strong>官方推荐两个都启用</strong></p><p>3、如果只做缓存：如果你只希望你的数据在服务器运行的时候存在, 你也可以不使用任何持久化方式</p><h1 id="12-Redis事务-锁机制-秒杀"><a href="#12-Redis事务-锁机制-秒杀" class="headerlink" title="12 Redis事务_ 锁机制 _秒杀"></a>12 Redis事务_ 锁机制 _秒杀</h1><h2 id="12-1-Redis-的事务是什么"><a href="#12-1-Redis-的事务是什么" class="headerlink" title="12.1 Redis 的事务是什么?"></a>12.1 Redis 的事务是什么?</h2><p>​1、 Redis 事务是一个单独的隔离操作： 事务中的所有命令都会序列化、 按顺序地执行</p><p>​2、事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</p><p>​3、Redis 事务的主要作用就是串联多个命令防止别的命令插队</p><h2 id="12-2-Redis-事务三特性"><a href="#12-2-Redis-事务三特性" class="headerlink" title="12.2 Redis 事务三特性"></a>12.2 Redis 事务三特性</h2><h3 id="12-2-1-单独的隔离操作"><a href="#12-2-1-单独的隔离操作" class="headerlink" title="12.2.1 单独的隔离操作"></a>12.2.1 单独的隔离操作</h3><p>​1、 事务中的所有命令都会<u>序列化、 按顺序地执行</u></p><p>​2、 事务在执行的过程中， <u>不会被其他客户端发送来的命令请求所打断</u></p><h3 id="12-2-2-没有隔离级别的概念"><a href="#12-2-2-没有隔离级别的概念" class="headerlink" title="12.2.2 没有隔离级别的概念"></a>12.2.2 没有隔离级别的概念</h3><p>​队列中的命令(指令), <strong>在没有提交前都不会实际被执行</strong></p><h3 id="12-2-3-不保证原子性"><a href="#12-2-3-不保证原子性" class="headerlink" title="12.2.3 不保证原子性"></a>12.2.3 不保证原子性</h3><p>​事务执行过程中, 如果有指令执行失败， 其它的指令仍然会被执行, 没有回滚</p><h2 id="12-3-事务相关指令-Multi、-Exec、-discard"><a href="#12-3-事务相关指令-Multi、-Exec、-discard" class="headerlink" title="12.3 事务相关指令 Multi、 Exec、 discard"></a>12.3 事务相关指令 Multi、 Exec、 discard</h2><h3 id="12-3-1-一图胜千言"><a href="#12-3-1-一图胜千言" class="headerlink" title="12.3.1 一图胜千言"></a>12.3.1 一图胜千言</h3><p>1、 Redis 事务指令示意图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729180534083.png" alt="image-20230729180534083" style="zoom:50%;" /><p>2、解读上图:</p><ol><li><strong>从输入 Multi 命令开始，输入的命令都会依次进入命令队列中，但不会执行</strong>(类似 Mysql的 start transaction 开启事务)</li><li><strong>输入 Exec 后，Redis 会将之前的命令队列中的命令依次执行</strong>(类似 Mysql 的 commit 提交事务)</li><li>组队的过程中可以<strong>通过 discard 来放弃组队</strong>(类似 Mysql 的 rollback 回顾事务)</li><li>⚠️： Redis 事务和 Mysql 事务本质是完全不同的, 这里只是用 Mysql 的做类似说明, 是为了让小伙伴好理解</li></ol><h3 id="12-3-2-快速入门"><a href="#12-3-2-快速入门" class="headerlink" title="12.3.2 快速入门"></a>12.3.2 快速入门</h3><p>……</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729181130039.png" alt="image-20230729181130039"></p><h3 id="12-3-3-注意事项和细节"><a href="#12-3-3-注意事项和细节" class="headerlink" title="12.3.3 注意事项和细节"></a>12.3.3 注意事项和细节</h3><p>​1、 组队的过程中, 可以通过 discard 来放弃组队</p><p>​<strong>2、如果在组队阶段报错, 会导致 exec 失败, 那么事务的所有指令都不会被执行</strong>(这时候是有原子性的)</p><p>​3、如果组队成功, 但是指令有不能正常执行的, 那么 exec 提交, 会出现有成功有失败情况,也就是事务得到部分执行, <strong>这种情况下, Redis 事务不具备原子性.</strong></p><h2 id="12-4-事务冲突及解决方案"><a href="#12-4-事务冲突及解决方案" class="headerlink" title="12.4 事务冲突及解决方案"></a>12.4 事务冲突及解决方案</h2><h3 id="12-4-1-先看一个问题"><a href="#12-4-1-先看一个问题" class="headerlink" title="12.4.1 先看一个问题"></a>12.4.1 先看一个问题</h3><p>1、 经典的抢票问题(总共十张票)</p><p>​1) 一个请求想购买 6</p><p>​2) 一个请求想购买 5</p><p>​    3) 一个请求想购买 1</p><p>——如果没有控制, 会造成超卖现象    ;  如果 3 个指令, 都得到执行, 最后剩余的票数是 -2</p><h3 id="12-4-2-悲观锁"><a href="#12-4-2-悲观锁" class="headerlink" title="12.4.2 悲观锁"></a>12.4.2 悲观锁</h3><p>1、 工作示意图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729182017365.png" alt="image-20230729182017365"></p><p>2、解读上图</p><ol><li>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，<strong>每次去拿数据的时候都认为别人会修改，所以每次在获取数据的时候都会上锁</strong></li><li>这样别人&#x2F;其它请求想拿这个数据就会 block，直到拿到锁。</li><li>悲观锁是锁设计理念, 传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁.</li></ol><h3 id="12-4-3-乐观锁"><a href="#12-4-3-乐观锁" class="headerlink" title="12.4.3 乐观锁"></a>12.4.3 乐观锁</h3><p>1、 工作示意图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729182519566.png" alt="image-20230729182519566"></p><p>2、解读上图：</p><pre><code>1) 乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁1) 但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，**可以使用版本号等机制。**1) 乐观锁&lt;u&gt;**适用于多读的应用类型，这样可以提高吞吐量**&lt;/u&gt;。Redis 就是利用这种 check-and-set机制实现事务的1) 乐观锁是锁设计理念(**不用担心在修改版本的瞬间，别人正好读到版本——因为版本修改阶段是原子性的！**)</code></pre><h3 id="12-4-4-watch-amp-unwatch"><a href="#12-4-4-watch-amp-unwatch" class="headerlink" title="12.4.4 watch &amp; unwatch"></a>12.4.4 watch &amp; unwatch</h3><h4 id="12-4-4-1-watch"><a href="#12-4-4-1-watch" class="headerlink" title="12.4.4.1 watch"></a>12.4.4.1 watch</h4><p>1、 基本语法: watch key [key …]</p><p>2、在执行 multi 之前，<strong>先执行 watch key1 [key2],可以监视一个(或多个) key ，如果在事务执行之前这个(或这些) key <u>被其他命令所改动</u>，那么事务将被打断.</strong></p><p>3、这里可以结合乐观锁机制进行理解</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729183535766.png" alt="image-20230729183535766"></p><h4 id="12-4-4-2-unwatch"><a href="#12-4-4-2-unwatch" class="headerlink" title="12.4.4.2 unwatch"></a>12.4.4.2 unwatch</h4><p>1、 基本语法unwatch</p><p>2、取消 watch 命令对所有 key 的监视。</p><p>3、如果在执行 watch 命令后，exec 命令或 discard 命令先被执行了的话，那么就不需要再执行 unwatch 了</p><h2 id="12-5-火车票-抢票"><a href="#12-5-火车票-抢票" class="headerlink" title="12.5 火车票-抢票"></a>12.5 火车票-抢票</h2><h3 id="12-5-1-需求分析-x2F-图解"><a href="#12-5-1-需求分析-x2F-图解" class="headerlink" title="12.5.1 需求分析&#x2F;图解"></a>12.5.1 需求分析&#x2F;图解</h3><p>……</p><h3 id="12-5-2-思路分析"><a href="#12-5-2-思路分析" class="headerlink" title="12.5.2 思路分析"></a>12.5.2 思路分析</h3><p>​– 思路分析</p><p>​1、一个 user 只能购买一张票, 即<u>不能复购</u></p><p>​2、<u>不能出现超购</u>,也是就多卖了.</p><p>​3、不能出现火车票遗留问题&#x2F;库存遗留, 即*<u>火车票不能留下</u>*</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730102256386.png" alt="image-20230730102256386" style="zoom: 67%;" /><h3 id="12-5-3-版本-1：-完成基本购票流程-暂不考虑事务和并发问题"><a href="#12-5-3-版本-1：-完成基本购票流程-暂不考虑事务和并发问题" class="headerlink" title="12.5.3 版本 1： 完成基本购票流程, 暂不考虑事务和并发问题"></a>12.5.3 版本 1： 完成基本购票流程, 暂不考虑事务和并发问题</h3><p>​1、 创建 Java Web 项目, 参照以前讲过搭建 Java Web 项目流程即可</p><p>​2、引入相关的 jar 包 和 jquery</p><p>​3、创建 index.jsp(买票界面)</p><p>​4、创建 SecKillRedis.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 秒杀类: 完成秒杀,抢购</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecKillRedis</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写一个测试方法-看看是否能够连通到指定的Redis</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRedis</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.198.135&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">//jedis.auth(&quot;foobared&quot;);//如果需要认证, 就使用auth</span></span><br><span class="line">        System.out.println(jedis.ping());</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 秒杀过程/方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid      用户id - 在后台生成</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ticketNo 票的编号, 比如北京-成都的ticketNo 就是bj_cd</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">doSecKill</span><span class="params">(String uid, String ticketNo)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- uid 和 ticketNo进行非空校验</span></span><br><span class="line">        <span class="keyword">if</span> (uid == <span class="literal">null</span> || ticketNo == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//- 连接到Redis, 得到jedis对象</span></span><br><span class="line">        <span class="comment">//Jedis jedis = new Jedis(&quot;192.168.198.135&quot;, 6379);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- 通过连接池获取到jedis对象/连接</span></span><br><span class="line">        <span class="type">JedisPool</span> <span class="variable">jedisPoolInstance</span> <span class="operator">=</span> JedisPoolUtil.getJedisPoolInstance();</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPoolInstance.getResource();</span><br><span class="line">        System.out.println(<span class="string">&quot;---使用的连接池技术----&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- 拼接票的库存key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">stockKey</span> <span class="operator">=</span> <span class="string">&quot;sk:&quot;</span> + ticketNo + <span class="string">&quot;:ticket&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- 拼接秒杀用户要存放到的set集合对应的key,这个set集合可以存放多个userId</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userKey</span> <span class="operator">=</span> <span class="string">&quot;sk:&quot;</span> + ticketNo + <span class="string">&quot;:user&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//🎃监控库存</span></span><br><span class="line">        jedis.watch(stockKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- 获取到对应的票的库存, 判断是否为null</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">stock</span> <span class="operator">=</span> jedis.get(stockKey);</span><br><span class="line">        <span class="keyword">if</span> (stock == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;秒杀还没有开始, 请等待..&quot;</span>);</span><br><span class="line">            jedis.close(); <span class="comment">//如果jedis是从连接池获取的,则这里的close就是将jedis对象/连接释放到连接池</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- 判断用户是否重复秒杀/复购</span></span><br><span class="line">        <span class="keyword">if</span> (jedis.sismember(userKey, uid)) &#123;</span><br><span class="line">            System.out.println(uid + <span class="string">&quot; 不能重复秒杀...&quot;</span>);</span><br><span class="line">            jedis.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- 判断火车票，是否还有剩余</span></span><br><span class="line">        <span class="keyword">if</span> (Integer.parseInt(stock) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;票已经卖完了, 秒杀结束..&quot;</span>);</span><br><span class="line">            jedis.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">////- 可以购买</span></span><br><span class="line">        <span class="comment">////1. 将票的库存量-1</span></span><br><span class="line">        <span class="comment">//jedis.decr(stockKey);</span></span><br><span class="line">        <span class="comment">////2. 将该用户加入到抢购成功对应的set集合中</span></span><br><span class="line">        <span class="comment">//jedis.sadd(userKey, uid);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用事务,完成秒杀(防止超卖)</span></span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">multi</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//组队操作</span></span><br><span class="line">        multi.decr(stockKey);<span class="comment">//减去票的库存</span></span><br><span class="line">        multi.sadd(userKey, uid);<span class="comment">//将该用户加入到抢购成功对应的set集合中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行</span></span><br><span class="line">        List&lt;Object&gt; results = multi.exec();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(results == <span class="literal">null</span> || results.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;抢票失败...&quot;</span>);</span><br><span class="line">            jedis.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(uid + <span class="string">&quot; 秒杀成功..&quot;</span>);</span><br><span class="line">        jedis.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、创建SecKillServlet.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecKillServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1. 请求时,模拟生成一个userId</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10000</span>) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//2. 获取用户要购买的票的编号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ticketNo</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;ticketNo&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 调用秒杀的方法</span></span><br><span class="line">        <span class="comment">//boolean isOk = SecKillRedis.doSecKill(userId, ticketNo);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 调用lua脚本完成秒杀方法</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isOk</span> <span class="operator">=</span> SecKillRedisByLua.doSecKill(userId, ticketNo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 将结果返回给前端-这个地方可以根据业务需要调整</span></span><br><span class="line">        response.getWriter().print(isOk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-5-4-抢票并发模拟-出现超卖问题"><a href="#12-5-4-抢票并发模拟-出现超卖问题" class="headerlink" title="12.5.4 抢票并发模拟, 出现超卖问题"></a>12.5.4 抢票并发模拟, 出现超卖问题</h3><p>并发模拟</p><p>可以使用postman模拟</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730110008609.png" alt="image-20230730110008609" style="zoom:50%;" /><h3 id="12-5-5-连接池技术"><a href="#12-5-5-连接池技术" class="headerlink" title="12.5.5 连接池技术"></a>12.5.5 连接池技术</h3><h4 id="12-5-5-1-连接池介绍"><a href="#12-5-5-1-连接池介绍" class="headerlink" title="12.5.5.1 连接池介绍"></a>12.5.5.1 连接池介绍</h4><p>​1、 节省每次连接 redis 服务带来的消耗， <u><strong>把连接好的实例反复利用。</strong></u></p><p>​2、 链接池参数</p><pre><code>    - MaxTotal： 控制**一个 pool 可分配多少个 jedis 实例**， 通过 pool.getResource()来获取；如果赋值为-1， 则表示不限制    - maxIdle： 控制一个 pool 最多有**多少个状态为 idle(空闲)的 jedis 实例**</code></pre><ul><li><p>MaxWaitMillis： 表示当获取一个 jedis 实例时， 最大的等待毫秒数， 如果超过等待时间，则直接抛 JedisConnectionException</p></li><li><p>testOnBorrow： 获得一个 jedis 实例的时候是否检查连接可用性（ping()）； 如果为 true，则得到的 jedis 实例均是可用的</p></li></ul><h4 id="12-5-5-2-使用连接池-优化连接超时"><a href="#12-5-5-2-使用连接池-优化连接超时" class="headerlink" title="12.5.5.2 使用连接池, 优化连接超时"></a>12.5.5.2 使用连接池, 优化连接超时</h4><p>​1、 老师说明: 通过连接池， 可以指定连接超时时间, 这个连接超时时间， 也需要合理设置 ， 要考虑到用户的实际体验</p><p>​2 、 创 建 JedisPoolUtil.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用连接池的方式来获取Redis连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisPoolUtil</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//老师解读volatile作用</span></span><br><span class="line">    <span class="comment">//1. 线程的可见性: 当一个线程去修改一个共享变量时, 另外一个线程可以读取这个修改的值</span></span><br><span class="line">    <span class="comment">//2. 顺序的一致性: 禁止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">JedisPoolUtil</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保证每次调用返回的 jedisPool是单例-这里老师使用了双重校验</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JedisPool <span class="title function_">getJedisPoolInstance</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == jedisPool) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (JedisPoolUtil.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == jedisPool) &#123;</span><br><span class="line">                    <span class="type">JedisPoolConfig</span> <span class="variable">jedisPoolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">                    <span class="comment">//对连接池进行配置</span></span><br><span class="line">                    jedisPoolConfig.setMaxTotal(<span class="number">200</span>);</span><br><span class="line">                    jedisPoolConfig.setMaxIdle(<span class="number">32</span>);</span><br><span class="line">                    jedisPoolConfig.setMaxWaitMillis(<span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">                    jedisPoolConfig.setBlockWhenExhausted(<span class="literal">true</span>);</span><br><span class="line">                    jedisPoolConfig.setTestOnBorrow(<span class="literal">true</span>);</span><br><span class="line">                    jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jedisPoolConfig, <span class="string">&quot;192.168.198.135&quot;</span>, <span class="number">6379</span>, <span class="number">60000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jedisPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放连接资源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(Jedis jedis)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> != jedis) &#123;</span><br><span class="line">            jedis.close();<span class="comment">//如果这个jedis是从连接池获取的,这里jedis.close(),就是将jedis对象/连接，释放到连接池</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="🌟volatile："><a href="#🌟volatile：" class="headerlink" title="🌟volatile："></a>🌟volatile：</h4><p>这是因为 new 关键字创建对象不是原⼦操作，创建⼀个对象会经历下⾯<br>的步骤：</p><ol><li>在堆内存开辟内存空间</li><li>调⽤构造⽅法，初始化对象</li><li>引⽤变量指向堆内存空间</li></ol><p>​为了提⾼性能，编译器和处理器常常会对既定的代码执⾏顺序进⾏指令重排序，从源码到最终执⾏指令会经历如下流程：<br>源码编译器优化重排序指令级并⾏重排序内存系统重排序最终执⾏指令序列所以经过指令重排序之后，创建对象的执⾏顺序可能为 1 2 3 或者 1 3 2 ，因此当某个线程在乱序运⾏ 1 3 2 指令的时候，引⽤变量指向堆内存空间，这个对象不为 null，但是没有初始化，其他线程有可能这个时候进⼊了 getInstance 的第⼀个 if(instance &#x3D;&#x3D; null) 判断不为 nulll ，导致<strong>错误使⽤了没有初始化的⾮ null 实例</strong>，这样的话就会出现异常，这个就是著名的<br>DCL 失效问题。<br>当我们在引⽤变量上⾯添加 volatile 关键字以后，会通过在创建对象指令的前后添加内存屏障来禁⽌指令重排序，就可以避免这个问题，⽽且对volatile 修饰的变量的修改对其他任何线程都是可⻅的。</p><h3 id="12-5-6-利用-Reids-事务机制，-解决超卖"><a href="#12-5-6-利用-Reids-事务机制，-解决超卖" class="headerlink" title="12.5.6 利用 Reids 事务机制， 解决超卖"></a>12.5.6 利用 Reids 事务机制， 解决超卖</h3><p>1、 控制超卖-Redis 事务底层(乐观锁机制分析)</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730133348196.png" alt="image-20230730133348196"></p><p>2 、 修 改 SecKillRedis.java</p><p>😵‍💫见12.5.3 的完整代码</p><h3 id="12-5-7-抢票并发模拟-出现库存遗留问题"><a href="#12-5-7-抢票并发模拟-出现库存遗留问题" class="headerlink" title="12.5.7 抢票并发模拟,出现库存遗留问题"></a>12.5.7 抢票并发模拟,出现库存遗留问题</h3><h4 id="1、-先重置一下-redis-的数据，把库存量设的较大-为-600"><a href="#1、-先重置一下-redis-的数据，把库存量设的较大-为-600" class="headerlink" title="1、 先重置一下 redis 的数据，把库存量设的较大 , 为 600"></a>1、 先重置一下 redis 的数据，把库存量设的较大 , 为 600</h4><h4 id="2、执行指令"><a href="#2、执行指令" class="headerlink" title="2、执行指令"></a>2、执行指令</h4><p>​ab -n 1000 -c 300 -p ~&#x2F;postfile -T  application&#x2F;x-www-form-urlencoded<a href="http://ip:port/seckill/secKillServlet">http://ip:port/seckill/secKillServlet</a></p><p>​老韩解读:1) 这里我们并发数变大 -c 300</p><h4 id="3、执行结果"><a href="#3、执行结果" class="headerlink" title="3、执行结果"></a>3、执行结果</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730134144402.png" alt="image-20230730134144402" style="zoom:50%;" /><p>​可以看到, 剩余票数为 543, 并不是 0</p><h4 id="4、出现库存遗留问题的分析"><a href="#4、出现库存遗留问题的分析" class="headerlink" title="4、出现库存遗留问题的分析"></a>4、出现库存遗留问题的分析</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730134242569.png" alt="image-20230730134242569"></p><h3 id="12-5-8-LUA-脚本"><a href="#12-5-8-LUA-脚本" class="headerlink" title="12.5.8 LUA 脚本"></a>12.5.8 LUA 脚本</h3><h4 id="12-5-8-1-LUA-介绍"><a href="#12-5-8-1-LUA-介绍" class="headerlink" title="12.5.8.1 LUA 介绍"></a>12.5.8.1 LUA 介绍</h4><p>​1、 Lua 是一个小巧的脚本语言， Lua 脚本可以很容易的被 C&#x2F;C++ 代码调用， 也可以反过来调用 C&#x2F;C++的函数， Lua 并没有提供强大的库， 一个完整的 Lua 解释器不过 200k，所以 Lua 不适合作为开发独立应用程序的语言， 而是作为<strong>嵌入式脚本语言</strong>。</p><p>​2、很多应用程序、游戏使用 LUA 作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。</p><p>​3、将复杂的或者多步的 Redis 操作，写为一个脚本，一次提交给 redis 执行，减少反复连接 redis 的次数。提升性能。</p><p>​4、LUA 脚本是类似 Redis 事务，有一定的原子性，不会被其他命令插队，<strong>可以完成一些 redis 事务性的操作</strong></p><p>​5、Redis 的 lua 脚本功能，只有在 Redis 2.6 以上的版本才可以使用</p><p>​6、通过 lua 脚本解决争抢问题，实际上是 Redis 利用其单线程的特性，<strong>用任务队列的方式解决多任务并发问题</strong></p><h4 id="12-5-8-2-LUA-脚本-解决库存遗留-思路分析图"><a href="#12-5-8-2-LUA-脚本-解决库存遗留-思路分析图" class="headerlink" title="12.5.8.2 LUA 脚本, 解决库存遗留-思路分析图"></a>12.5.8.2 LUA 脚本, 解决库存遗留-思路分析图</h4><p>​一图胜千言</p><p>​<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730135547720.png" alt="image-20230730135547720"></p><p>对上图解读</p><pre><code>1) LUA 脚本是类似 Redis 事务，有一定的原子性，不会被其他命令插队，能完成 Redis事务性的操作 1) 通过 lua 脚本解决争抢问题，Redis 利用其单线程的特性，将请求形成任务队列, 从而解决多任务并发问题</code></pre><h4 id="12-5-8-3-LUA-脚本-解决库存遗留-代码实现"><a href="#12-5-8-3-LUA-脚本-解决库存遗留-代码实现" class="headerlink" title="12.5.8.3 LUA 脚本, 解决库存遗留-代码实现"></a>12.5.8.3 LUA 脚本, 解决库存遗留-代码实现</h4><p>1、 编写 lua 脚本文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Lua脚本完成秒杀</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecKillRedisByLua</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 老师说明</span></span><br><span class="line"><span class="comment">     * 1. 这个脚本字符串是在lua脚本上修改的, 但是要注意不完全是字符串处理</span></span><br><span class="line"><span class="comment">     * 2. 比如 : 这里我就使用了 \&quot; , 还有换行使用了 \r\n</span></span><br><span class="line"><span class="comment">     * 3. 这些都是细节，如果你直接把lua脚本粘贴过来，不好使,一定要注意细节</span></span><br><span class="line"><span class="comment">     * 4. 如果写的不成功，就在老师这个代码上修改即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">secKillScript</span> <span class="operator">=</span> <span class="string">&quot;local userid=KEYS[1];\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;local ticketno=KEYS[2];\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;local stockKey=&#x27;sk:&#x27;..ticketno..\&quot;:ticket\&quot;;\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;local usersKey=&#x27;sk:&#x27;..ticketno..\&quot;:user\&quot;;\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;local userExists=redis.call(\&quot;sismember\&quot;,usersKey,userid);\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;if tonumber(userExists)==1 then \r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;   return 2;\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;end\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;local num= redis.call(\&quot;get\&quot; ,stockKey);\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;if tonumber(num)&lt;=0 then \r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;   return 0;\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;else \r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;   redis.call(\&quot;decr\&quot;,stockKey);\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;   redis.call(\&quot;sadd\&quot;,usersKey,userid);\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;end\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;return 1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用lua脚本完成秒杀的核心方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">doSecKill</span><span class="params">(String uid,String ticketNo)</span> &#123;</span><br><span class="line">        <span class="comment">//先从redis连接池，获取连接</span></span><br><span class="line">        <span class="type">JedisPool</span> <span class="variable">jedisPoolInstance</span> <span class="operator">=</span> JedisPoolUtil.getJedisPoolInstance();</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPoolInstance.getResource();</span><br><span class="line">        <span class="comment">//就是将lua脚本进行加载</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sha1</span> <span class="operator">=</span> jedis.scriptLoad(secKillScript);</span><br><span class="line">        <span class="comment">//evalsha是根据指定的 sha1校验码, 执行缓存在服务器的脚本</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.evalsha(sha1, <span class="number">2</span>, uid, ticketNo);</span><br><span class="line">        <span class="type">String</span> <span class="variable">resString</span> <span class="operator">=</span> String.valueOf(result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据lua脚本执行返回的结果，做相应的处理</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;0&quot;</span>.equals(resString)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;票已经卖光了..&quot;</span>);</span><br><span class="line">            jedis.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;2&quot;</span>.equals(resString)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不能重复购买..&quot;</span>);</span><br><span class="line">            jedis.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(resString)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;抢购成功&quot;</span>);</span><br><span class="line">            jedis.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;购票失败..&quot;</span>);</span><br><span class="line">            jedis.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="13-主从复制"><a href="#13-主从复制" class="headerlink" title="13 主从复制"></a>13 主从复制</h1><h2 id="13-1-主从复制介绍"><a href="#13-1-主从复制介绍" class="headerlink" title="13.1 主从复制介绍"></a>13.1 主从复制介绍</h2><h3 id="13-1-1-分析单个-Redis-的问题"><a href="#13-1-1-分析单个-Redis-的问题" class="headerlink" title="13.1.1 分析单个 Redis 的问题"></a>13.1.1 分析单个 Redis 的问题</h3><h3 id="13-1-2-一图胜千言"><a href="#13-1-2-一图胜千言" class="headerlink" title="13.1.2 一图胜千言"></a>13.1.2 一图胜千言</h3><p>1、 Redis 主从复制的示意图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730230820880.png" alt="image-20230730230820880" style="zoom:67%;" /><p>2、对上图的解读</p><ol><li><p>上图描述了主机数据更新后, 自动同步到备机的 master&#x2F;slaver 机制</p></li><li><p>Master 以<strong>写</strong>为主，Slaver 以<strong>读</strong>为主</p></li><li><p>好处: 读写分离, 提升效率 (理解: 读写分离后, 将读和写操作分布到不同的 Reids, 减少单个 Redis 的压力, 提升效率)</p></li><li><p>好处: 容灾快速恢复 (理解: <u>如果某个 slaver , 不能正常工作, 可以切换到另一个 slaver</u>)</p></li><li><p>主从复制, 要求是 <strong>1 主多从</strong>, 不能有多个 Master( 理解: 如果有多个主服务器 Master,那么 slaver 不能确定和哪个 Master 进行同步, 出现数据紊乱)</p></li><li><p>要解决主服务器的高可用性, <u>可以使用 Redis 集群</u></p></li></ol><h2 id="13-2-搭建一主多从"><a href="#13-2-搭建一主多从" class="headerlink" title="13.2 搭建一主多从"></a>13.2 搭建一主多从</h2><p>1、 需求说明</p><ol><li>搭建主从复制结构</li><li>这里我们搭建 一主二从即可, 其它 slaver 可以依此完成</li><li>分析我搭建的思路&#x2F;认真理解</li></ol><p>把原来的redis.conf复制三份，分别进行配置，用它们来各自启动redis服务，再通过指令：「slaveof <master_ip> <master_port>」来设置主从关系，这样以后我们就搭建完毕了</p><p>注意：</p><ul><li>搭建完以后，在主服务中添加、修改数据，可以在从服务处读取</li><li>从服务无法添加、修改、删除数据，只能读取</li></ul><h2 id="13-3-主从复制-原理"><a href="#13-3-主从复制-原理" class="headerlink" title="13.3 主从复制-原理"></a>13.3 主从复制-原理</h2><p>1、 原理示意图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730233615428.png" alt="image-20230730233615428" style="zoom: 67%;" /><p>2、老师解读上图-主从复制流程</p><ul><li>Slave 启动成功连接到 master 后会发送一个 <strong>sync 命令</strong></li><li>Master 接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后, master 将传送整个数据文件到 slave,以完成一次完全同步</li><li>slave 服务在接收到数据库文件数据后，将其存盘并加载到内存中, 即 <strong>全量复制</strong></li><li>Master 数据变化了, 会将新的收集到的修改命令依次传给 slave, 完成同步, 即 <strong>增量复制</strong></li><li>但是只要是重新连接 master,一次完全同步（全量复制)将被自动执行</li></ul><p>总结：</p><p><strong><u>(第一次连 –&gt; 全量复制；连上后主服务数据变化 –&gt; 增量复制；断开后重新连上 –&gt; 全量复制)</u></strong></p><h2 id="13-4-一主二仆"><a href="#13-4-一主二仆" class="headerlink" title="13.4 一主二仆"></a>13.4 一主二仆</h2><p>1、 如果从服务器 down 了, 重新启动, 仍然可以获取 Master 的最新数据</p><p>2、如果主服务器 down 了, <u>从服务器并不会抢占为主服务器</u>, 当主服务器恢复后, 从服务器仍然指向原来的主服务器.</p><h2 id="13-5-薪火相传"><a href="#13-5-薪火相传" class="headerlink" title="13.5 薪火相传"></a>13.5 薪火相传</h2><p>1、 示意图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731082350913.png" alt="image-20230731082350913" style="zoom:50%;" /><p>2、老师解读上图</p><pre><code>1) 上一个 Slave 可以是下一个 slave 的 Master，Slave 同样可以接收其他 slaves 的连接和同步请求，那么该 &lt;u&gt;slave 作为了链条中下一个的 master, 可以有效减轻 master 的写压力,&lt;/u&gt;去中心化降低风险1) 用 **slaveof &lt;master_ip&gt;&lt;master_port&gt;     (从服务的ip、port)**</code></pre><ol start="3"><li>风险是一旦某个 slave 宕机，后面的 slave 都没法同步</li><li>主机挂了，从机还是从机，无法写数据了</li><li>作为别人master的从服务只是拥有了与其从服务同步数据的能力，并不能修改数据！</li></ol><h2 id="13-6-反客为主"><a href="#13-6-反客为主" class="headerlink" title="13.6 反客为主"></a>13.6 反客为主</h2><p>1、 在薪火相传的结构下, 当一个 master 宕机后, <u>指向 Master 的 slave 可以升为 master, 其后面的 slave 不用做任何修改</u></p><p>2、用 slaveof no one 将从机变为主机 (老韩说明: 后面可以使用哨兵模式, 自动完成切换.)</p><h2 id="13-7-哨兵模式-sentinel"><a href="#13-7-哨兵模式-sentinel" class="headerlink" title="13.7 哨兵模式(sentinel)"></a>13.7 哨兵模式(sentinel)</h2><h3 id="13-7-1-实例演示"><a href="#13-7-1-实例演示" class="headerlink" title="13.7.1 实例演示"></a>13.7.1 实例演示</h3><p>1、 工作示意图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731083436662.png" alt="image-20230731083436662" style="zoom:50%;" /><p>2、哨兵模式(如图): **<u>反客为主的自动版</u>**，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p><p>3、老韩实验</p><p>​1)调整为一主二仆模式，6379 带着 6380、6381 , 根据前面讲解的调整即可</p><p>​2)创建 sentinel.conf , 名字不能乱写, 按照指定的来</p><p>​<strong>写入</strong>：sentinel monitor redis_master 127.0.0.1 6379 1</p><p>​说明:</p><p>​<strong>redis_master</strong> 为监控对象起的服务器名称</p><p>​<strong>1</strong> 表示至少有多少个哨兵同意迁移的数量, 这里我配置1 表示只要有1个哨兵同意迁移就可以切换</p><p>​3) 启动哨兵, 注意看哨兵的端口是 26379</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731084427183.png" alt="image-20230731084427183"></p><p>​4) 当主机挂掉，从机选举中产生新的主机</p><p>​5) <strong><u>如果原来的主机重启, 会自动成为从机</u></strong></p><h3 id="13-7-2-注意事项和细节"><a href="#13-7-2-注意事项和细节" class="headerlink" title="13.7.2 注意事项和细节"></a>13.7.2 注意事项和细节</h3><p>1、 在哨兵模式下， 主机 down 后的执行流程分析</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731084948786.png" alt="image-20230731084948786"></p><p>2、解读上图 - 哨兵如何在从机中, 推选新的 Master 主机, 选择的条件依次为:</p><ol><li><strong>优先级</strong>在 redis.conf 中默认：replica-priority 100，值越小优先级越高</li><li><strong>偏移量</strong>是指获得原主机数据的量, 数据量最全的优先级高</li><li>每个 redis 实例启动后都会随机生成一个 40 位的 <strong>runid</strong>, 值越小优先级越高</li></ol><h1 id="14-集群"><a href="#14-集群" class="headerlink" title="14 集群"></a>14 集群</h1><h2 id="14-1-为什么需要集群-高可用性"><a href="#14-1-为什么需要集群-高可用性" class="headerlink" title="14.1 为什么需要集群-高可用性"></a>14.1 为什么需要集群-高可用性</h2><p>1、 生产环境的实际需求和问题</p><ul><li><strong>容量不够</strong>，redis 如何进行扩容？</li><li><strong>并发</strong>写操作， redis 如何分摊？</li><li>主从模式，薪火相传模式，<u>主机宕机，会导致 ip 地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息</u></li></ul><h3 id="2、传统解决方案-代理主机来解决"><a href="#2、传统解决方案-代理主机来解决" class="headerlink" title="2、传统解决方案-代理主机来解决"></a>2、传统解决方案-代理主机来解决</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731090153302.png" alt="image-20230731090153302"></p><p>解读上图</p><ol><li><p>客户端请求先到代理服务器</p></li><li><p>由代理服务器进行<strong>请求转发</strong>到对应的业务处理服务器</p></li><li><p>为了高可用性, 代理服务、A 服务、B 服务、C 服务都需要搭建主从结构(至少是一主一从),这样就需求搭建至少 8 台服务器</p></li><li><p>这种方案的缺点是: <u>成本高，维护困难, 如果是一主多从, 成本就会更高</u></p></li></ol><h3 id="3、redis3-0-提供解决方案-无中心化集群配置"><a href="#3、redis3-0-提供解决方案-无中心化集群配置" class="headerlink" title="3、redis3.0 提供解决方案-无中心化集群配置"></a>3、redis3.0 提供解决方案-无中心化集群配置</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731090351617.png" alt="image-20230731090351617"></p><p>解读上图</p><pre><code>1) 各个 Redis 服务仍然采用主从结构2) 各个 Redis 服务是连通的, **任何一台服务器, 都可以作为请求入口**3) 各个 Redis 服务器因为是连通的, 可以进行请求转发4) 这种方式, 就无中心化集群配置, 可以看到，只需要 6 台服务器即可搞定</code></pre><ol start="5"><li>无中心化集群配置, 还会根据 key 值, 计算 slot , 把数据分散到不同的主机, 从而缓解单个主机的存取压力.[后面老师会演示和再说明]</li><li>Redis 推荐使用无中心化集群配置</li><li>在实际生成环境 各个 Redis 服务器, <u>应当部署到不同的机器</u>(防止机器宕机, 主从复制失效)</li></ol><h2 id="14-2-集群介绍"><a href="#14-2-集群介绍" class="headerlink" title="14.2 集群介绍"></a>14.2 集群介绍</h2><p>1、 Redis 集群实现了对 Redis 的水平扩容， 即启动 N 个 redis 节点， 将整个数据库分布存储在这 N 个节点中， 每个节点存储总数据的 1&#x2F;N。</p><p>2、 Redis 集群通过分区（partition） 来提供一定程度的<strong>可用性</strong>（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求</p><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><h4 id="1、修改主服务的conf文件中的配置："><a href="#1、修改主服务的conf文件中的配置：" class="headerlink" title="1、修改主服务的conf文件中的配置："></a>1、修改主服务的conf文件中的配置：</h4><p>​cluster-enabled yes 打开集群模式</p><p>​cluster-config-file nodes-6379.conf </p><p>​设定节点配置文件名cluster-node-timeout 15000 设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换</p><h4 id="2、启动服务"><a href="#2、启动服务" class="headerlink" title="2、启动服务"></a>2、启动服务</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731093504555.png" alt="image-20230731093504555"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731093522619.png" alt="image-20230731093522619"></p><h4 id="3、将六个节点合成一个集群"><a href="#3、将六个节点合成一个集群" class="headerlink" title="3、将六个节点合成一个集群"></a>3、将六个节点合成一个集群</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731093608968.png" alt="image-20230731093608968"></p><p>将六个节点合成一个集群 的指令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create --cluster-replicas 1 192.168.198.130:6379 192.168.198.130:6380 192.168.198.130:6381 192.168.198.130:6389192.168.198.130:6390 192.168.198.130:6391</span><br></pre></td></tr></table></figure><h5 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ol><li>组合之前，请确保所有 redis 实例启动后，nodes-xxxx.conf 文件都生成正常</li><li>此处不要用 127.0.0.1, 请用真实 IP 地址, 在真实生产环境, IP 都是独立的.</li><li>replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组</li><li>搭建集群如果没有成功, 把 sentinel 进程 kill 掉, 再试一下</li><li>分析主从对应关系</li></ol><h4 id="4、集群方式登录"><a href="#4、集群方式登录" class="headerlink" title="4、集群方式登录"></a>4、集群方式登录</h4><p>指令: <strong>redis-cli -c -p 6379</strong></p><p>指令: <strong><u>cluster nodes</u></strong> 命令查看集群信息, 主从的对应关系</p><h3 id="14-3-2-注意事项和细节"><a href="#14-3-2-注意事项和细节" class="headerlink" title="14.3.2 注意事项和细节"></a>14.3.2 注意事项和细节</h3><p>1、 一个集群至少要有三个主节点</p><p>2、 选项 <strong>–cluster-replicas 1</strong> 表示我们希望为集群中的<u>每个主节点创建一个从节点</u>。</p><p>3、 分配原则： <u><strong>尽量保证主服务器和从服务器各自运行在不同的 IP 地址(机器), 防止机器故障导致主从机制失效, 高可用性得不到保障</strong></u></p><h2 id="14-4-Redis-集群使用"><a href="#14-4-Redis-集群使用" class="headerlink" title="14.4 Redis 集群使用"></a>14.4 Redis 集群使用</h2><p>1、 什么是 slots</p><p>1）Redis 集群启动后, 你会看到如下提示</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731094714287.png" alt="image-20230731094714287"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731094732477.png" alt="image-20230731094732477"></p><p>2）一个 Redis 集群包含 16384 个插槽（hash slot），编号从 0-16383, <u>Reids 中的每个键都属于这 16384 个插槽的其中一个</u></p><p>3）集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731094808015.png" alt="image-20230731094808015"></p><p>4)<u><strong>集群中的每个节点负责处理一部分插槽</strong></u>。 举个例子， 如果一个集群可以有主节点， 其中：</p><ul><li>节点 A 负责处理 0 号至 5460 号插槽</li><li>节点 B 负责处理 5461 号至 10922 号插槽</li><li>节点 C 负责处理 10923 号至 16383 号插槽</li></ul><p>2、在集群中录入值</p><p>1）在 redis 每次录入、查询键值，redis 都会计算出该 key 应该送往的插槽，<u>如果不是该客户端对应服务器的插槽，redis 会告知应前往的 redis 实例地址和端口</u>。(因为你可以在集群的任意端启用redis服务)</p><p>2）redis-cli 客户端提供了 –c 参数实现<strong>自动重定向</strong>。</p><p>3）如 redis-cli -c –p 6379 登入后，再录入、查询键值对可以自动重定向</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731095430316.png" alt="image-20230731095430316" style="zoom: 50%;" /><p>4）**<u>不在一个 slot 下的键值</u>，是不能使用 mget,mset 等多键操作**</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731095522774.png" alt="image-20230731095522774" style="zoom:50%;" /><p>5）<strong>可以通过{}来定义组的概念，从而<u>使 key 中{}内相同内容的键值对放到一个 slot 中</u>去</strong>，可以对一个组的数据进行mget等多键操作</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731095552328.png" alt="image-20230731095552328" style="zoom:50%;" /><p>3、<u>查询集群中的值</u></p><p>1）指令: CLUSTER KEYSLOT <key> <strong>返回 key 对应的 slot 值</strong></p><p>2）指令: CLUSTER COUNTKEYSINSLOT <slot> <strong>返回 slot 有多少个 key</strong></p><p>3）指令: CLUSTER GETKEYSINSLOT <slot><count> <strong>返回 count 个 slot 槽中的键</strong></p><p> <img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731100125306.png" alt="image-20230731100125306"></p><h2 id="14-5-Redis-集群故障恢复"><a href="#14-5-Redis-集群故障恢复" class="headerlink" title="14.5 Redis 集群故障恢复"></a>14.5 Redis 集群故障恢复</h2><p>1、 如果主节点下线, <u>从节点会自动升为主节点</u>(注意 15 秒超时, 再观察比较准确)</p><p>—是该主节点的从节点提生成master，而不是其他节点替代这个节点</p><p>2、主节点恢复后，主节点回来变成从机</p><p>3、如果所有某一段插槽的主从节点都宕掉，Redis 服务是否还能继续, 要根据不同的配置而言</p><p>​1）如果某一段插槽的主从都挂掉，而 <strong>cluster-require-full-coverage</strong> 为 yes ，那么 ，整个集群都挂掉</p><p>​2）如果某一段插槽的主从都挂掉，而 <strong>cluster-require-full-coverage</strong> 为 no , 那么, 只是该插槽数据不能使用，也无法存储</p><p>​3）redis.conf 中的参数 cluster-require-full-coverage</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731100749215.png" alt="image-20230731100749215"></p><h2 id="14-6-集群的-Jedis-开发"><a href="#14-6-集群的-Jedis-开发" class="headerlink" title="14.6 集群的 Jedis 开发"></a>14.6 集群的 Jedis 开发</h2><p>1、 即使连接的不是主机， 集群会自动切换主机存储。 主机写， 从机读。</p><p>2、无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据</p><p>3、老韩实验</p><p>​1）将 Redis 相关的端口都打开(防火墙设置), 否则会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作Redis集群</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisCluster_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 这里的set可以加入多个入口</span></span><br><span class="line"><span class="comment">         * 2. 因为我们没有做日志配置，输出时，有些提示,但是不影响使用</span></span><br><span class="line"><span class="comment">         * 3. 如果我们使用的是集群，需要把相关的端口都打开，否则会报错</span></span><br><span class="line"><span class="comment">         * 4. JedisCluster的构造器有多个，也可以直接传入HostAndPort 代码如下</span></span><br><span class="line"><span class="comment">         * public JedisCluster(HostAndPort node) &#123;</span></span><br><span class="line"><span class="comment">         *         this(Collections.singleton(node));</span></span><br><span class="line"><span class="comment">         *     &#125;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Set&lt;HostAndPort&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;HostAndPort&gt;();</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.198.135&quot;</span>,<span class="number">6379</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">JedisCluster</span> <span class="variable">jedisCluster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisCluster</span>(set);</span><br><span class="line">        jedisCluster.set(<span class="string">&quot;address&quot;</span>,<span class="string">&quot;bj~北京&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> jedisCluster.get(<span class="string">&quot;address&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;address--&gt;&quot;</span> + address);</span><br><span class="line">        jedisCluster.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-7-Redis-集群的优缺点"><a href="#14-7-Redis-集群的优缺点" class="headerlink" title="14.7 Redis 集群的优缺点"></a>14.7 Redis 集群的优缺点</h2><h3 id="14-7-1-优点"><a href="#14-7-1-优点" class="headerlink" title="14.7.1 优点"></a>14.7.1 优点</h3><p>​1、 实现扩容</p><p>​2、分摊压力</p><p>​3、无中心配置相对简单</p><h3 id="14-7-2-缺点"><a href="#14-7-2-缺点" class="headerlink" title="14.7.2 缺点"></a>14.7.2 缺点</h3><p>​1、 多键操作是不被支持的</p><p>​2、 多键的 Redis 事务是不被支持的。 lua 脚本不被支持</p><p>​3、 由于集群方案出现较晚， 很多公司已经采用了其他的集群方案， 而其它方案想要迁移至 redis cluster， 需要整体迁移而不是逐步过渡， 复杂度较大</p><h1 id="15-缓存："><a href="#15-缓存：" class="headerlink" title="15 缓存："></a>15 缓存：</h1><h2 id="15-1缓存穿透"><a href="#15-1缓存穿透" class="headerlink" title="15.1缓存穿透"></a>15.1缓存穿透</h2><h3 id="15-1-1缓存穿透的原因"><a href="#15-1-1缓存穿透的原因" class="headerlink" title="15.1.1缓存穿透的原因"></a>15.1.1缓存穿透的原因</h3><p>​指客户端请求的数据在redis缓存中和数据库中都不存在，在redis中找不到数据，这些请求都会打到数据库，可能压垮数据库。</p><h3 id="15-1-2解决方案："><a href="#15-1-2解决方案：" class="headerlink" title="15.1.2解决方案："></a>15.1.2解决方案：</h3><h4 id="缓存空对象："><a href="#缓存空对象：" class="headerlink" title="缓存空对象："></a>缓存空对象：</h4><p>​我们把查不到的数据当作null存到redis中，防止再去数据库中找没有的值；我们需要给空结果的过期时间设得短一些，防止中途数据库中产生了刚刚查不到的数据，但是请求一直被卡在redis的情况</p><p>​优点：实现简单，维护方便</p><p>​缺点：额外的内存消耗、       可能造成短期的不一致</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230416215655097.png" alt="image-20230416215655097" style="zoom:50%;" /><h4 id="设置可访问的白名单"><a href="#设置可访问的白名单" class="headerlink" title="设置可访问的白名单"></a>设置可访问的白名单</h4><p>​只让一些选定的人访问，防止被刷</p><h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>​优点：内存占用较少，没有多余key</p><p>​缺点：实现复杂、                  存在误判可能(hash冲突)</p><h4 id="进行实时监控"><a href="#进行实时监控" class="headerlink" title="进行实时监控"></a>进行实时监控</h4><p>​当发现redis的命中率开始急速降低时，需要排查访问对象和访问的数据，需要专门派人监督，酌情使用黑名单或限制服务</p><h2 id="15-2缓存击穿"><a href="#15-2缓存击穿" class="headerlink" title="15.2缓存击穿"></a>15.2缓存击穿</h2><h3 id="15-2-1缓存击穿的原因"><a href="#15-2-1缓存击穿的原因" class="headerlink" title="15.2.1缓存击穿的原因"></a>15.2.1缓存击穿的原因</h3><p>1）<u>key对应的数据存在，但在redis中过期</u>，此时若有大量并发请求过来，这些请求发现缓存过期，会从后端DB加载数据并回设到缓存，这时大并发的请求可能会瞬间把后端DB压垮</p><p>2）比如某个热点数据，可能会在某些时问点，被超高并发地访问，容易出现缓存击穿</p><h3 id="15-2-2缓存击穿的现象-x2F-表象"><a href="#15-2-2缓存击穿的现象-x2F-表象" class="headerlink" title="15.2.2缓存击穿的现象&#x2F;表象"></a>15.2.2缓存击穿的现象&#x2F;表象</h3><p>1)数据库访问压力瞬时增加</p><p>2)Redis里面<u>没有出现大量key过期</u></p><p>3)Redis正常运行状态，但是数据库可能瘫痪了</p><h3 id="15-2-3解决方案"><a href="#15-2-3解决方案" class="headerlink" title="15.2.3解决方案"></a>15.2.3解决方案</h3><ul><li><p>预先设置热门数据</p><ul><li>在redis高峰访问之前，把一些数据提前存入Reids中，并加大这些数据的过期时间</li></ul></li><li><p>实时调整</p><ul><li>现场监控哪些数据热门，实时调整key的过期时长</li></ul></li><li><p>使用锁，如图：</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731145946233.png" alt="image-20230731145946233" style="zoom:50%;" /></li></ul><h2 id="15-3缓存雪崩"><a href="#15-3缓存雪崩" class="headerlink" title="15.3缓存雪崩"></a>15.3缓存雪崩</h2><h3 id="15-3-1缓存雪崩的原因"><a href="#15-3-1缓存雪崩的原因" class="headerlink" title="15.3.1缓存雪崩的原因"></a>15.3.1缓存雪崩的原因</h3><p>1）key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存</p><p>2）这个时候大并发的请求可能会瞬间把后端DB压垮。</p><p>3）缓存雪崩与缓存击穿的区别在于雪崩针对很多key缓存同时过期，前者则是某一个key</p><h3 id="15-3-2缓存雪崩的现象-x2F-表象"><a href="#15-3-2缓存雪崩的现象-x2F-表象" class="headerlink" title="15.3.2缓存雪崩的现象&#x2F;表象"></a>15.3.2缓存雪崩的现象&#x2F;表象</h3><p>1）数据库访问压力变大，服务器崩溃</p><p>2）在极短时间内，访问大量Key，而**<u>这些Key集中过期</u>**</p><h3 id="15-3-3解决方案"><a href="#15-3-3解决方案" class="headerlink" title="15.3.3解决方案"></a>15.3.3解决方案</h3><h5 id="1）构建多级缓存架构"><a href="#1）构建多级缓存架构" class="headerlink" title="1）构建多级缓存架构"></a>1）构建多级缓存架构</h5><p>nginx缓存＋redis缓存 ＋其他缓存(ehcache等），这种方式开发&#x2F; 维护成本较高</p><h5 id="2）使用锁或队列"><a href="#2）使用锁或队列" class="headerlink" title="2）使用锁或队列"></a>2）使用锁或队列</h5><p>用加锁或者队列的方式来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况。</p><h5 id="3）设置过期标志更新缓存"><a href="#3）设置过期标志更新缓存" class="headerlink" title="3）设置过期标志更新缓存"></a>3）设置过期标志更新缓存</h5><p>记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际key的缓存。</p><h5 id="4）将缓存失效时间分散开"><a href="#4）将缓存失效时间分散开" class="headerlink" title="4）将缓存失效时间分散开"></a>4）将缓存失效时间分散开</h5><h2 id="15-4分布式锁"><a href="#15-4分布式锁" class="headerlink" title="15.4分布式锁"></a>15.4分布式锁</h2><p>1、单体单机部署的系统被演化成分布式集群系统后，<u>由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效</u></p><p>3、单纯的Java API并不能提供分布式锁的能力</p><p>4、为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解決的问题</p><p>5、示意图（说明：我们探讨的分布式锁是<u>针对分布式项目&#x2F;架构</u>而言）</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731151840509.png" alt="image-20230731151840509" style="zoom: 50%;" /><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731152158961.png" alt="image-20230731152158961"></p><h3 id="15-4-1分布式锁主流实现方案："><a href="#15-4-1分布式锁主流实现方案：" class="headerlink" title="15.4.1分布式锁主流实现方案："></a>15.4.1分布式锁主流实现方案：</h3><ul><li>基于数据库实现</li><li>基于缓存(Redis等)——性能最高</li><li>基于Zookeeper———-可靠性最高</li></ul><h4 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h4><h5 id="命令：setnx-key-value"><a href="#命令：setnx-key-value" class="headerlink" title="命令：setnx key value"></a>命令：setnx key value</h5><p>​首先，当然是搭建一个最简单的实现方式，直接用Redis的setnx命令，这个命令的语法是：<strong>setnx key value</strong>如果key不存在，则会将key设置为value， 并返回1;如果key存在，不会有任务影响，返回0。</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731155434255.png" alt="image-20230731155434255" style="zoom:50%;" /><h5 id="⚠️：为了防止获取锁的服务挂掉，导致锁一直不被释放，我们需要为锁添加超时时间"><a href="#⚠️：为了防止获取锁的服务挂掉，导致锁一直不被释放，我们需要为锁添加超时时间" class="headerlink" title="⚠️：为了防止获取锁的服务挂掉，导致锁一直不被释放，我们需要为锁添加超时时间"></a>⚠️：为了防止获取锁的服务挂掉，导致锁一直不被释放，我们需要为锁添加超时时间</h5><p>命令： <strong>set key value nx ex seconds</strong>其中nx表示保证操作的原子性 ex表示增加了过期时间，seconds为秒数</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731160005527.png" alt="image-20230731160005527" style="zoom:50%;" /><h5 id="⚠️：同样的一把锁，服务A可能挂掉服务B的锁"><a href="#⚠️：同样的一把锁，服务A可能挂掉服务B的锁" class="headerlink" title="⚠️：同样的一把锁，服务A可能挂掉服务B的锁"></a>⚠️：同样的一把锁，服务A可能挂掉服务B的锁</h5><p>具体场景：A持有锁，A执行其业务，但由于业务流程长或者网络延迟导致锁过期了，这时候B拿到了锁，在B运行业务时，A做完业务回来了！并释放了锁！这就导致了上述情景。</p><p>解决方案：为🔒加上owner</p><p>命令： <strong>set key value  nx ex seconds</strong>——-这里都value就是owner！！！！</p><h5 id="⚠️：如果你获取锁的时候还是锁的owner，但是因为操作不具有原子性，正当你准备删除时，锁过期了并且被其他服务获取，这时执行删除会造成误删！"><a href="#⚠️：如果你获取锁的时候还是锁的owner，但是因为操作不具有原子性，正当你准备删除时，锁过期了并且被其他服务获取，这时执行删除会造成误删！" class="headerlink" title="⚠️：如果你获取锁的时候还是锁的owner，但是因为操作不具有原子性，正当你准备删除时，锁过期了并且被其他服务获取，这时执行删除会造成误删！"></a>⚠️：如果你获取锁的时候还是锁的owner，但是因为操作不具有原子性，正当你准备删除时，锁过期了并且被其他服务获取，这时执行删除会造成误删！</h5><p>业务执行完成之后，检查锁、删除锁这些操作不是原子化的，这会导致上述情况发生</p><p>我们要想办法把这些操作整合成原子操作——Lua</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731161136468.png" alt="image-20230731161136468" style="zoom:50%;" /><h5 id="⚠️：即便这样，可靠性还是没有得到保证"><a href="#⚠️：即便这样，可靠性还是没有得到保证" class="headerlink" title="⚠️：即便这样，可靠性还是没有得到保证"></a>⚠️：即便这样，可靠性还是没有得到保证</h5><p>​我们可以为redis配置从节点、哨兵模式等方式一定程度上提高可靠性</p><p>没有完全可靠的分布式锁，需要与业务联动配合，进行取舍，选择最合适的方案。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发组件 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列</title>
      <link href="/2023/06/02/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2023/06/02/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="1-MQ的相关概念-message-queue"><a href="#1-MQ的相关概念-message-queue" class="headerlink" title="1.MQ的相关概念(message queue)"></a>1.MQ的相关概念(message queue)</h2><h3 id="1-1什么是MQ："><a href="#1-1什么是MQ：" class="headerlink" title="1.1什么是MQ："></a>1.1什么是MQ：</h3><ul><li><p>​本质是个队列，只不过队列中的内容是message而已！</p></li><li><p>​用于上下游传递消息</p></li></ul><h3 id="1-2为什么要使用MQ"><a href="#1-2为什么要使用MQ" class="headerlink" title="1.2为什么要使用MQ"></a>1.2为什么要使用MQ</h3><h4 id="1-流量消峰："><a href="#1-流量消峰：" class="headerlink" title="1.流量消峰："></a>1.流量消峰：</h4><p>​在用户访问系统前添加MQ，对访问的消息进行排队，虽然排队会消耗时间但不会出现流量过大导致服务器宕机的情况。</p><h4 id="2-应用解耦："><a href="#2-应用解耦：" class="headerlink" title="2.应用解耦："></a>2.应用解耦：</h4><p>​如果没有MQ，比如用户在订单系统下单后，订单系统会立即调用物流系统，如果物流系统暂时出故障了，那么下单操作就会异常。</p><p>​如果使用了MQ，用户在订单系统下单后，如果物流系统暂时出故障了，物流系统需要处理的消息会被缓存在MQ中，等到物流系统故障修复完成，就可以从MQ中取出待处理的信息。这个过程中，用户不会感受到物流系统的故障，因此提升了系统的可用性。</p><h4 id="3-异步处理："><a href="#3-异步处理：" class="headerlink" title="3.异步处理："></a>3.异步处理：</h4><p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完。</p><p>以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api，B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅。</p><p>使用消息队列可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不用做这些操作，A 服务还能及时的得到异步处理成功的消息。</p><h2 id="2-RabbitMQ"><a href="#2-RabbitMQ" class="headerlink" title="2.RabbitMQ"></a>2.RabbitMQ</h2><h3 id="2-1-RabbitMQ概念："><a href="#2-1-RabbitMQ概念：" class="headerlink" title="2.1 RabbitMQ概念："></a>2.1 RabbitMQ概念：</h3><p>​RabbitMQ是一个消息中间件，能够接收、存储并转发消息</p><h3 id="2-2-四大核心概念："><a href="#2-2-四大核心概念：" class="headerlink" title="2.2 四大核心概念："></a>2.2 四大核心概念：</h3><h4 id="生产者："><a href="#生产者：" class="headerlink" title="生产者："></a>生产者：</h4><p>​产生数据，发送消息的程序成为生产者</p><h4 id="交换机："><a href="#交换机：" class="headerlink" title="交换机："></a>交换机：</h4><p>​接收来自生产者的消息，并将消息推送到队列中</p><p>​一个交换机可以与多个独立产生绑定关系binding(交换机需要知道将消息推送给特定队列、多个队列或是丢弃—由交换机类型决定)</p><h4 id="队列："><a href="#队列：" class="headerlink" title="队列："></a>队列：</h4><p>​队列  —–&gt;  一个大的消息缓冲区</p><p>​多个生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据</p><h4 id="消费者："><a href="#消费者：" class="headerlink" title="消费者："></a>消费者：</h4><p>​等待接收消息的程序</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230426204426849.png" alt="image-20230426204426849"></p><h3 id="rebbitmq服务的使用："><a href="#rebbitmq服务的使用：" class="headerlink" title="rebbitmq服务的使用："></a>rebbitmq服务的使用：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">brew services start rabbitmq<span class="comment">//开启服务</span></span><br><span class="line">brew services restart rabbitmq<span class="comment">//重启服务</span></span><br><span class="line">rabbitmqctl list_users<span class="comment">//查看用户</span></span><br><span class="line">rabbitmqctl add_user admin <span class="number">123</span><span class="comment">//添加用户用户名:admin 密码:123</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator<span class="comment">//将 admin 用户 设置为 administrator --&gt; 超级管理员</span></span><br><span class="line">rabbitmqctl set_permissions -p <span class="string">&quot;/&quot;</span> admin <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span><span class="comment">//为admin用户设置权限</span></span><br><span class="line"></span><br><span class="line">rabbitMQ可视化管理界面，即后台管理界面地址：localhost:<span class="number">15672</span>        ip:<span class="number">15672</span></span><br></pre></td></tr></table></figure><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><h2 id="引入依赖："><a href="#引入依赖：" class="headerlink" title="引入依赖："></a>引入依赖：</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>消息生产者发送消息到队列，消费者从队列中取出消息</p><h1 id="Work-Queues"><a href="#Work-Queues" class="headerlink" title="Work Queues"></a>Work Queues</h1><p>使用场景：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230427223442104.png" alt="image-20230427223442104"></p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2023/06/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/06/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h6 id="尚硅谷视频看到P43"><a href="#尚硅谷视频看到P43" class="headerlink" title="尚硅谷视频看到P43"></a>尚硅谷视频看到P43</h6><h1 id="设计模式七大原则："><a href="#设计模式七大原则：" class="headerlink" title="设计模式七大原则："></a>设计模式七大原则：</h1><h3 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h3><p>1） 代码重用性（即：相同功能的代码，不用多次编写）</p><p>2）可读性（即：编程规划性，便于其他程序员的阅读和理解）</p><p>3）可扩展性（即：当需要增加新的功能时，非常的方便，称为可维护)</p><p>4） 可靠性（即：当我们增加新的功能后，对原来的功能没有影响）</p><p>5） 使程序呈现高内聚，低耦合的特性</p><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>​「一个类只负责一项职责」</p><p>单一职责原则注意事项和细节：</p><p>​1. 降低类的复杂度，一个类只负责一项职责。</p><p>​2.提高类的可读性、可维护性。</p><p>​3.降低变更引起的风险。</p><p>​4.通常情况下，我们应该遵守单一职责原则。</p><p>​ ——只有<strong>逻辑足够简单</strong>时，才可以在<strong>代码级</strong>违反单一职责原则；</p><p>​ ——只有类型的<strong>方法数量足够少</strong>时，才可以才<strong>方法级别</strong>保持单一职责原则。</p><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>客户端不应该依赖它不需要的接口，<strong>一个类对另一个类的依赖应建立在最小的接口上</strong>。</p><p>​因为如果不是建立在最小的接口上，那么就说明有几个接口白白被实现了(实现但是没有被用)，违背了接口隔离原则！</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230523160645384.png" alt="image-20230523160645384" style="zoom:50%;" /><p>改进后：⬇️</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230523160702347.png" alt="image-20230523160702347" style="zoom:50%;" /><h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><ol><li><p>高层模块不应该依赖低层模块，二者都应该<strong>依赖其抽象</strong></p></li><li><p>抽象不应该依赖细节，细节应该依赖抽象</p></li><li><p>依赖倒转(倒置)的中心思想是<strong>「面向接口编程」</strong></p></li><li><p>依赖倒转原则是基于这样的设计理念：<u>相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多</u>。在java 中，抽象指的是接口或抽象类，细节就是具体的实现类</p></li><li><p>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</p></li></ol><p>依赖关系传递的三种方式：你通过什么方式把接口的实现类传给你要使用的类</p><ul><li>接口传递(直接将对象作为方法的形参)</li><li>构造方法传递(将对象在构造时存入待使用的类)</li><li>setter传递(set进去)</li></ul><p>注意事项：</p><ol><li>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好.</li><li>变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化</li><li>继承时遵循里氏替换原则</li></ol><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><ol><li>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，<strong>但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏</strong>。</li></ol><ol start="2"><li><strong>继承</strong>在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，<strong>增加对象间的耦合性</strong>，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障</li><li>问题提出：在编程中，如何正确的使用继承？&#x3D;＞里氏替换原则</li></ol><p>里氏替换原则的含义：所有引用基类的地方都能透明地使用其子类</p><p>​——子类尽量不重写父类的方法(重写后无法满足里氏替换原则)</p><p>​——如果你继承了然后还重写，那你何必继承呢？（除非迫不得已，不要重写父类方法）</p><p>在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性比较差。特别是运行多态比较频繁的时候。</p><p>通用的做法是：<strong>原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉</strong>，采用依赖，聚合，组合等</p><p>关系代替.</p><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><ul><li><p>是编程中最基础、最重要的设计原则</p></li><li><p>一个软件实体如类，模块和函数应该<u><strong>对扩展开放(对提供方)<strong>，</strong>对修改关闭(对使用方)</strong></u>。用抽象构建框架，用实现扩展细节。</p></li><li><p>当软件需要变化时，尽量通过<u><em><strong>扩展</strong></em></u>软件实体的行为来实现变化，而<strong>不是</strong>通过<strong>修改</strong>已有的代码来实现变化。</p></li><li><p><u>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</u></p></li></ul><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>​基本介绍</p><ol><li><p>一个对象应该<strong>对其他对象保持最少的了解</strong></p></li><li><p>类与类关系越密切，耦合度越大</p></li><li><p>迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息</p></li><li><p>迪米特法则还有个更简单的定义：只与直接的朋友通信</p></li><li><p>直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间</p></li></ol><p>是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现<strong>成员变量，方法参数，方法返</strong></p><p><strong>回值</strong>中的类为<u>直接的朋友</u>，而出现在<strong>局部变量中的类</strong>不是直接的朋友。也就是说，**<u>「陌生的类最好不要以局部变</u>**</p><p>**<u>量的形式出现在类的内部」</u>**。</p><h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>​<strong>原则是尽量使用合成&#x2F;聚合的方式，而不是使用继承</strong>(因为继承会增加耦合性)</p><p>场景：想让B使用A中的方法：</p><p>​我们当然可以让B继承A，但是这样会让A与B的耦合性增强</p><p>​我们可以采用以下方法：</p><ul><li>依赖：在B中添加以A为形参的方法，在该方法中使用A</li><li>聚合：将A作为B类中的一个成员变量(构造函数&#x2F;set方法)，在B的任意方法中使用A</li><li>组合：将A作为B类中的一个成员变量，在创建B的时候直接new A(), new一个</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>​设计原则的核心思想：</p><ul><li>找出应用中的<strong>可能需要变化之处</strong>，把他们<strong>独立</strong>出来，不要和那些不需要变化的代码混在一起</li><li><strong>针对接口编程</strong>，而不是针对实现编程</li><li>为了交互对象之间的<strong>松耦合设计</strong>而努力</li></ul><p></p><p>​</p><h1 id="UML图："><a href="#UML图：" class="headerlink" title="UML图："></a>UML图：</h1><ul><li><p>UML—Unified modeling language UML(统一建模语言)，是一种<strong>用于软件系统分析和设计的语言工具</strong>，它用于帮助软件开发人员进行思考和记录思路的结果</p></li><li><p>UML 本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如<strong>类、接口、实现、泛化、依赖、组合、聚合</strong>等</p></li></ul><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230524002012376.png" alt="image-20230524002012376" style="zoom:50%;" /><ol><li>用例图(use case)</li><li>静态结构图：<strong>类图</strong>、对象图、包图、组件图、部署图</li><li>动态行为图：交互图(时序图与协作图）、状态图、活动图</li></ol><p>类图用于描述类与类之间的关系，是UML图中的核心</p><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p>1） 用于描述系统中的<strong>类(对象)本身的组成</strong>和<strong>类(对象)之间的各种静态关系</strong>。</p><p>2） 类之间的关系：依赖、泛化(继承)、实现、关联、聚合与组合。</p><h3 id="依赖关系："><a href="#依赖关系：" class="headerlink" title="依赖关系："></a>依赖关系：</h3><p>​如果A类用到了B，则A与B存在依赖关系（如果没有对方，就无法编译通过）</p><ul><li>作为A的成员属性</li><li>是A中方法的返回类型</li><li>是A中方法的接收类型(形参类型)</li><li>在A的方法中使用到(作为局部变量)</li></ul><p>​<u>用<strong>虚线箭头</strong>描述关系</u></p><h3 id="泛化关系："><a href="#泛化关系：" class="headerlink" title="泛化关系："></a>泛化关系：</h3><p>​即继承关系，是依赖关系的特例</p><p><u>用<strong>实线+空心三角形</strong>描述</u></p><h3 id="实现关系："><a href="#实现关系：" class="headerlink" title="实现关系："></a>实现关系：</h3><p>​即接口的实现关系，也是依赖关系的特例<br><u>用<strong>虚线+空心三角形</strong>描述</u></p><h3 id="关联关系："><a href="#关联关系：" class="headerlink" title="关联关系："></a>关联关系：</h3><p>​指类与类之间的联系，是依赖关系的特例</p><p>用于描述两个类之间的关系是<strong>单向</strong>还是<strong>双向</strong>的</p><h3 id="聚合关系："><a href="#聚合关系：" class="headerlink" title="聚合关系："></a>聚合关系：</h3><p>​表示整体与部分的关系，***<u>整体和部分可以分开</u><em><strong>，是</strong>关联关系的特例</em>*</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>&#123;<span class="comment">//Computer中的Mouse可以为null</span></span><br><span class="line">Mouse mouse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>用<strong>实线+空心菱形</strong>描述</u></p><h3 id="组合关系："><a href="#组合关系：" class="headerlink" title="组合关系："></a>组合关系：</h3><p>​表示整体与部分的关系，***<u>整体和部分不可以分开</u>***，则是组合关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>&#123;<span class="comment">//Computer与Mouse 共创建、共销毁</span></span><br><span class="line"><span class="type">Mouse</span> <span class="variable">mouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mouse</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用实线+黑菱形描述</p><h1 id="设计模式概述："><a href="#设计模式概述：" class="headerlink" title="设计模式概述："></a>设计模式概述：</h1><h2 id="掌握设计模式的层次："><a href="#掌握设计模式的层次：" class="headerlink" title="掌握设计模式的层次："></a>掌握设计模式的层次：</h2><ul><li>第1层：刚开始学编程不久，听说过什么是设计模式</li><li>第2层：有很长时间的编程经验，自己写了很多代码，其中用到了设计模式，但是自己却不知道</li><li>第3层：学习过了设计模式，发现自己己经在使用了，并且发现了一些新的模式挺好用的</li><li>第4层：阅读了很多别人写的源码和框架，在其中看到别人设计模式，并且能够领会设计模式的精妙和带来的好处。</li><li>第5层：代码写着写着，自己都没有意识到使用了设计模式，并且熟练的写了出来。</li></ul><h2 id="设计模式介绍："><a href="#设计模式介绍：" class="headerlink" title="设计模式介绍："></a>设计模式介绍：</h2><ul><li>设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是某类问题的通用解決方案，设计模式 (Design pattern）代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</li><li>设计模式的本质提高 软件的维护性，通用性和扩展性，并降低软件的复杂度。</li><li>＜&lt;设计模式&gt;＞是经典的书，作者是 Erich Gamma、 Richard Helmn、 Ralph Johnson 和 John Vlissides Design （俗称“四人组 GOF”)</li><li>设计模式并不局限于某种语言，java，php，c++ 都有设计模式.</li></ul><h1 id="设计模式详解："><a href="#设计模式详解：" class="headerlink" title="设计模式详解："></a>设计模式详解：</h1><h2 id="创建型模式："><a href="#创建型模式：" class="headerlink" title="创建型模式："></a>创建型模式：</h2><p><strong>创建型： 在创建对象的同时隐藏创建逻辑，不使⽤ new 直接实例化对象，程序在判断需要创建哪些对象时更灵活。包括⼯⼚&#x2F;抽象⼯⼚&#x2F;单例&#x2F;建造者&#x2F;原型模式。</strong></p><h3 id="单例模式："><a href="#单例模式：" class="headerlink" title="单例模式："></a>单例模式：</h3><ol><li><p><strong>饿汉式(静态常量)</strong></p><ul><li><p>构造器私有化保证外部不能new</p></li><li><p>类的内部创建<strong>静态对象</strong>        在类的内部创建该类的静态对象，在类加载时自动生成</p></li><li><p>向外暴露一个静态的公共方法——getInstance</p><p>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</p><p>缺点：在<strong>类装载的时候就完成实例化</strong>，没有达到Lazy Loading 的效果。<u>如果从始至终从未使用过这个实例，则会造成内存的浪费</u>；正因为是在类加载时就会创建对象，我们可能在别的地方无意导致该类加载而不去使用，造成内存浪费。</p></li></ul></li><li><p><strong>饿汉式(静态代码块)</strong></p><ul><li><p>在类中定义该类的静态变量</p></li><li><p>在静态代码块中完成该类的静态变量的初始化</p><p>优缺点分析：</p><p>​这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点与上面方法一样</p><p>结论：这种单例模式可用，但是可能造成内存浪费</p></li></ul></li><li><p>懒汉式(线程不安全)</p><ul><li><p>构造器私有化 保证外部不能new</p></li><li><p>类的内部定义<strong>静态对象</strong>          创建对象，但是不创建(不 new)</p></li><li><p>向外暴露一个静态的公共方法——getInstance  在调用该方法时，才对该类的静态对象进行创建</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230524105503814.png" alt="image-20230524105503814" style="zoom:45%;" /><p>优缺点分析：</p><p>​起到了 Lazy Loading 的效果，但是只能在单线程下使用。</p><p>​如果在多线程下，一个线程进入了**if(singleton&#x3D;&#x3D; null)**判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。</p><p><strong>结论</strong>：在实际开发中，不要使用这种方式.</p></li></ul></li><li><p>懒汉式(线程安全，同步方法)</p><p>给 getInstance 添加 synchronize 修饰，保证同步</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230524112254631.png" alt="image-20230524112254631" style="zoom:40%;" /><p>优缺点分析：</p><p>​解决了线程安全问题</p><p>​<strong>效率太低了</strong>，<u>每个线程在想获得类的实例时候，执行 getinstance()方法都要进行同步</u>。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。方法进行同步效率太低</p><p><strong>结论</strong>：在实际开发中，<strong>不推荐</strong>使用这种方式</p></li><li><p>懒汉式(线程安全，同步代码块)</p><p>不可使用，因为不能保证单例</p></li><li><p><strong>双重检查</strong></p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230524114249721.png" alt="image-20230524114249721" style="zoom:50%;" /><p>​Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次if(singleton&#x3D;&#x3D; null)检查，这样就可以保证线程安全了。</p><p>​这样，实例化代码只用执行一次，后面再次访问时，判断if(singleton&#x3D;&#x3D;null)，直接 return 实例化对象，也避免的反复进行方法同步.</p><p>​线程安全；延迟加载；效率较高</p><p>结论：在实际开发中，<strong>推荐使用这种单例设计模式</strong></p><h4 id="🌟这⾥为什么要使⽤-volatile-？"><a href="#🌟这⾥为什么要使⽤-volatile-？" class="headerlink" title="🌟这⾥为什么要使⽤ volatile ？"></a>🌟这⾥为什么要使⽤ volatile ？</h4><p>这是因为 new 关键字创建对象不是原⼦操作，创建⼀个对象会经历下⾯的步骤：</p><ol><li>在堆内存开辟内存空间</li><li>调⽤构造⽅法，初始化对象</li><li>引⽤变量指向堆内存空间<br>为了提⾼性能，编译器和处理器常常会对既定的代码执⾏顺序进⾏指令重排序，从源码到最终执⾏指令会经历如下流程：<br>源码编译器优化重排序指令级并⾏重排序内存系统重排序最终执⾏指令序列所以经过**<u>指令重排序</u><strong>之后，创建对象的执⾏顺序可能为 1 2 3 或者 1 3 2 ，因此当某个线程在乱序运⾏ 1 3 2 指令的时候，引⽤变量指向堆内存空间，这个对象不为 null，但是没有初始化，其他线程有可能这个时候进⼊了 getInstance 的第⼀个 if(instance &#x3D;&#x3D; null) 判断不为 nulll ，导致</strong>错误使⽤了没有初始化的⾮ null 实例**，这样的话就会出现异常，这个就是著名的<br>DCL 失效问题。<br>当我们在引⽤变量上⾯添加 volatile 关键字以后，会通过在创建对象指令的前后添加内存屏障来禁⽌指令重排序，就可以避免这个问题，⽽且对volatile 修饰的变量的修改对其他任何线程都是可⻅的。</li></ol></li><li><p><strong>静态内部类</strong></p><ul><li><p>构造器私有化 保证外部不能new</p></li><li><p>构建一个静态内部类，内部类中有一个静态属性，如果加载了静态类，该属性也会创建对象</p></li><li><p>向外暴露一个静态的公共方法——getInstance  在调用该方法时，对静态内部类进行初始化，返回静态内部类属性</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230524115554993.png" alt="image-20230524115554993" style="zoom:50%;" /></li></ul><p>优缺点分析：</p><ul><li><p>这种方式采用了类装载的机制来保证初始化实例时只有一个线程。</p></li><li><p>静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用getinstance 方法，才会装载 Singletoninstance 类，从而完成 Singleton 的实例化。</p></li><li><p>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</p></li><li><p>优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</p></li><li><p>缺点：getInstance 还是被synchronized修饰了</p></li></ul><p><strong>结论</strong>：推荐使用．</p></li><li><p><strong>枚举</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过 Singleton.INSTANCE 来获取单例，获取的对象可以使用Singleton中的方法</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">  INSTANCE;<span class="comment">//属性</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>这借助 JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步 问题，而且还能防止反序列化重新创建</p></li><li><p>新的对象。</p></li><li><p>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式</p></li><li><p><strong>结论</strong>：推荐使用</p></li></ul><h4 id="单例模式注意事项："><a href="#单例模式注意事项：" class="headerlink" title="单例模式注意事项："></a>单例模式注意事项：</h4><ul><li><p>单例模式保证了 系统内存中该类只存在一个对象，<u>节省了系统资源</u>，<strong>对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</strong></p></li><li><p>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new</p></li><li><p>单例模式使用的场景：**<u><em>需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多（即：重量级对象），但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、session 工厂等）</em></u>**</p></li></ul></li></ol><h3 id="工厂模式："><a href="#工厂模式：" class="headerlink" title="工厂模式："></a>工厂模式：</h3><h4 id="简单工厂模式："><a href="#简单工厂模式：" class="headerlink" title="简单工厂模式："></a>简单工厂模式：</h4><p>「针对每种产品」</p><p><u>简单⼯⼚模式指由⼀个⼯⼚对象来创建实例，客户端不需要关注创建逻辑，只需提供传⼊⼯⼚的参数。</u></p><ul><li><p>简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式</p></li><li><p>简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为</p></li><li><p>在软件开发中，当我们<strong>用到大量的创建某种、某类或者某批对象</strong>时，就会使用到工厂模式.</p></li></ul><h4 id="工厂方法模式："><a href="#工厂方法模式：" class="headerlink" title="工厂方法模式："></a>工厂方法模式：</h4><p>「针对一类产品」</p><p>和简单⼯⼚模式中⼯⼚负责⽣产所有产品相⽐，⼯⼚⽅法模式将⽣成具体产品的任务分发给具体的产品⼯⼚。</p><p>其实就是在工厂这边再分层 逻辑为：总工厂&lt;–&gt;子工厂1&#x2F;2&#x2F;3…</p><p>​其中，总工厂定义了产品的生产接口，而生产接口由不同的子工厂进行实现。从而对工厂进行了进一步划分。</p><h4 id="抽象工厂模式："><a href="#抽象工厂模式：" class="headerlink" title="抽象工厂模式："></a>抽象工厂模式：</h4><p>「针对多类产品，每个类中还有多种产品！」</p><p>总工厂、子工厂都是抽象的。要生产某种产品，我们首先找到模版类似的子类，再对子类进行实现，从而进行创建。</p><h2 id="结构型模式："><a href="#结构型模式：" class="headerlink" title="结构型模式："></a>结构型模式：</h2><h3 id="适配器模式："><a href="#适配器模式：" class="headerlink" title="适配器模式："></a>适配器模式：</h3><p>概述：在我们的应⽤程序中我们可能需要将两个不同接⼝的类来进⾏通信，在不修改这两个的前提下我们可能会需要某个中间件来完成这个衔接的过程。这个中间件就是适配器。所谓适配器模式就是<strong>将⼀个类的接⼝，转换成客户期望的另⼀个接⼝</strong>。它<u>可以让原本两个不兼容的接⼝能够⽆缝完成对接</u>。</p><p>作为中间件的适配器将⽬标类和适配者解耦，增加了类的透明性和可复⽤性。</p><p>⽬标类和适配者不必有很大关联，可以通过适配器建立联系，从而实现解耦。</p><h5 id="类适配器："><a href="#类适配器：" class="headerlink" title="类适配器："></a>类适配器：</h5><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230524201128653.png" alt="image-20230524201128653" style="zoom:50%;" /><p><strong>对象适配器：</strong></p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230524201140631.png" alt="image-20230524201140631" style="zoom:50%;" /><ul><li><p>Target: 定义 Client 真正需要使⽤的接⼝。</p></li><li><p>Adaptee: 其中定义了⼀个已经存在的接⼝，也是我们需要进⾏适配的接⼝。</p></li><li><p>Adapter: 对 Adaptee 和 Target 的接⼝进⾏适配，保证对 target 中接⼝的调⽤可以间接转换为对 Adaptee 中接⼝进⾏调⽤。</p><ul><li>优点：</li></ul><ol><li>提⾼了类的复⽤；</li><li>组合若⼲关联对象形成对外提供统⼀服务的接⼝；</li><li>扩展性、灵活性好。</li></ol><ul><li>缺点：</li></ul><ol><li>过多使⽤适配模式容易造成代码功能和逻辑意义的混淆。</li><li>部分语⾔对继承的限制，可能⾄多只能适配⼀个适配者类，⽽且⽬标类必须是抽象类。</li></ol></li></ul><h3 id="装饰模式："><a href="#装饰模式：" class="headerlink" title="装饰模式："></a>装饰模式：</h3><p>装饰器模式主要对现有的类对象进⾏包裹和封装，以期望在不改变类对象及其类定义的情况下，为对象添加额外功能。是⼀种对象结构型模式。需要注意的是，该过程是通过调⽤被包裹之后的对象完成功能添加的，⽽不是直接修改现有对象的⾏为，相当于增加了中间层。(AOP???)</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230524204945734.png" alt="image-20230524204945734" style="zoom:50%;" /><p><strong>Component</strong>: 对象的接⼝类，定义装饰对象和被装饰对象的共同接⼝；<br><strong>ConcreteComponent</strong>: 被装饰对象的类定义；<br><strong>Decorator</strong>: 装饰对象的抽象类，<u><strong>持有⼀个具体的被修饰对象</strong></u>，并实现接⼝类继承的公共接⼝；<br><strong>ConcreteDecorator</strong>:具体的装饰器，负责往被装饰对象添加额外的功能；</p><h4 id="讲讲装饰器模式的应⽤场景"><a href="#讲讲装饰器模式的应⽤场景" class="headerlink" title="讲讲装饰器模式的应⽤场景"></a>讲讲装饰器模式的应⽤场景</h4><p>如果你希望在<u>⽆需修改代码的</u>情况下即可使⽤对象， 且希望在运⾏时<u>为对象新增额外的⾏为</u>， 可以使⽤装饰模式。装饰能将业务逻辑组织为层次结构， 你可为各层创建⼀个装饰， 在运⾏时<br>将各种不同逻辑组合成对象。 由于这些对象都遵循通⽤接⼝， 客户端代码能以相同的⽅式使⽤这些对象。如果⽤继承来扩展对象⾏为的⽅案难以实现或者根本不可⾏， 你可以使⽤该模式。许多编程语⾔使⽤ final 最终关键字来限制对某个类的进⼀步扩展。 复⽤最终类已有⾏为的唯⼀⽅法是使⽤装饰模式： ⽤封装器对其进⾏封装。</p><h3 id="代理模式："><a href="#代理模式：" class="headerlink" title="代理模式："></a>代理模式：</h3><p>代理模式的本质是⼀个中间件，主要⽬的是解耦合服务提供者和使⽤者。<strong>使⽤者通过代理间接地访问服务提供者</strong>，<u>便于后者的封装和控制</u>。是⼀种结构性模式。</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230524202229926.png" alt="image-20230524202229926" style="zoom:60%;" /><p>Subject: 定义 RealSubject 对外的接⼝，且这些接⼝必须被 Proxy 实现，这样外部调⽤ proxy 的接⼝最终都被转化为对 realsubject 的调⽤。<br>RealSubject: 真正的⽬标对象。<br>Proxy: ⽬标对象的代理，负责控制和管理⽬标对象，并间接地传递外部对⽬标对象的访问。</p><p>Remote Proxy: 对本地的请求以及参数进⾏序列化，向远程对象发送请求，并对响应结果进⾏反序列化，将最终结果反馈给调⽤者；<br>Virtual Proxy: 当⽬标对象的创建开销⽐较⼤的时候，可以使⽤延迟或者异步的⽅式创建⽬标对象；<br>Protection Proxy: 细化对⽬标对象访问权限的控制；</p><h4 id="静态代理和动态代理的区别"><a href="#静态代理和动态代理的区别" class="headerlink" title="静态代理和动态代理的区别:"></a>静态代理和动态代理的区别:</h4><ol><li>灵活性 ：动态代理更加灵活，不需要必须实现接⼝，可以直接代理实现类，并且可以不需要针对每个⽬标类都创建⼀个代理类。另外，静态代理中，接⼝⼀旦新增加⽅法，⽬标对象和代理对象都要进⾏修改，这是⾮常麻烦的！</li><li>JVM 层⾯ ：<u>静态代理在编译时就将接⼝、实现类、代理类这些都变成了⼀个个实际的 class ⽂件</u>。⽽动态代理是在运⾏时动态⽣成类字节码，并加载到 JVM 中的。</li></ol><h2 id="行为型模式："><a href="#行为型模式：" class="headerlink" title="行为型模式："></a>行为型模式：</h2><h3 id="观察者模式："><a href="#观察者模式：" class="headerlink" title="观察者模式："></a>观察者模式：</h3><p>观察者模式主要⽤于<u>处理对象间的⼀对多的关系</u>，是⼀种对象⾏为模式。</p><p>该模式的实际应⽤场景⽐较容易确认，当⼀个对象状态发⽣变化时，所有该对象的关注者均能收到状态变化通知，以进⾏相应的处理。(怎么这么像websocket啊)</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230524203754928.png" alt="image-20230524203754928" style="zoom:50%;" /><p><strong>Subject</strong>: 抽象被观察者，仅提供注册和删除观察者对象的接⼝声明。<br><strong>ConcreteSubject</strong>: 具体被观察者对象，该对象中收集了所有需要被通知的观察者，并可以动态的增删集合中的观察者。当其状态发⽣变化时会通知所有观察者对象。<br><strong>Observer</strong>: 抽象观察者，为所有观察者定义获得通知的统⼀接⼝；<br><strong>ConcreteObserver</strong>: 观察者对象，其关注对象为 Subject，能接受 Subject变化时发出的通知并更新⾃身状态。</p><ul><li>优点：</li></ul><ol><li>被观察者和观察者之间是抽象耦合的；</li><li>耦合度较低，两者之间的关联仅仅在于消息的通知；</li><li>被观察者⽆需关⼼他的观察者；</li><li>⽀持⼴播通信；</li></ol><ul><li>缺点：</li></ul><ol><li>观察者只知道被观察对象发⽣了变化，但<strong>不知变化的过程和缘由</strong>；</li><li><strong>观察者同时也可能是被观察者，消息传递的链路可能会过⻓，完成所有</strong><br><strong>通知花费时间较多</strong></li><li>如果观察者和被观察者之间产⽣循环依赖，或者消息传递链路形成闭<br>环，会<u>导致⽆限循环</u>；</li></ol><h4 id="你的项⽬是怎么⽤的观察者模式？"><a href="#你的项⽬是怎么⽤的观察者模式？" class="headerlink" title="你的项⽬是怎么⽤的观察者模式？"></a>你的项⽬是怎么⽤的观察者模式？</h4><p>在⽀付场景下，⽤户购买⼀件商品，当⽀付成功之后三⽅会回调⾃身，在这个时候系统可能会有很多需要执⾏的逻辑（如：更新订单状态，发送邮件通知，赠送礼品…），这些逻辑之间并没有强耦合，因此天然适合使⽤观察者模式去实现这些功能，当有更多的操作时，只需要添加新的观察者就能实现，完美实现了对修改关闭，对扩展开放的开闭原则。</p><h3 id="责任链模式："><a href="#责任链模式：" class="headerlink" title="责任链模式："></a>责任链模式：</h3><p>⼀个请求沿着⼀条“链”传递，直到该“链”上的某个处理者处理它为⽌。</p><h4 id="讲讲责任链模式的应⽤场景"><a href="#讲讲责任链模式的应⽤场景" class="headerlink" title="讲讲责任链模式的应⽤场景"></a>讲讲责任链模式的应⽤场景</h4><ul><li><p>当程序需要使⽤不同⽅式处理不同种类请求， ⽽且请求类型和顺序预先未知时， 可以使⽤责任链模式。该模式能将多个处理者连接成⼀条链。 接收到请求后， 它会 “询问” 每个处理者是否能够对其进⾏处理。这样所有处理者都有机会来处理请求。</p></li><li><p>当必须按顺序执⾏多个处理者时， 可以使⽤该模式。 ⽆论你以何种顺序将处理者连接成⼀条链， 所有请求都会严格按照顺序通过链上的处理者。</p></li></ul><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><h4 id="什么是策略模式？"><a href="#什么是策略模式？" class="headerlink" title="什么是策略模式？"></a>什么是策略模式？</h4><p>策略模式（Strategy Pattern）属于对象的⾏为模式。其⽤意是针对⼀组算法，将每⼀个算法封装到具有共同接⼝的独⽴的类中，从⽽使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发⽣变化。其主要⽬的是通过定义相似的算法，替换 if else 语句写法，并且可以随时相互替换。</p><h4 id="策略模式有什么好处？"><a href="#策略模式有什么好处？" class="headerlink" title="策略模式有什么好处？"></a>策略模式有什么好处？</h4><p>定义了⼀系列封装了算法、⾏为的对象，他们可以相互替换。举例： Java.util.List 就是定义了⼀个增（ add ）、删（ remove ）、改（ set ）、查（ indexOf ）策略，⾄于实现这个策略的ArrayList 、 LinkedList 等类，只是在具体实现时采⽤了不同的算法。但因为它们策略⼀样，不考虑速度的情况下，使⽤时完全可以互相替换使⽤。</p><h1 id="设计模式实例："><a href="#设计模式实例：" class="headerlink" title="设计模式实例："></a>设计模式实例：</h1><h2 id="Spring-使⽤了哪些设计模式？"><a href="#Spring-使⽤了哪些设计模式？" class="headerlink" title="Spring 使⽤了哪些设计模式？"></a>Spring 使⽤了哪些设计模式？</h2><ul><li>⼯⼚设计模式 : Spring 使⽤⼯⼚模式通过BeanFactory 、 ApplicationContext 创建 bean 对象。</li><li>代理设计模式 : Spring AOP 功能的实现(<strong>动态代理</strong>)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件开发基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/2023/06/02/SpringBoot/"/>
      <url>/2023/06/02/SpringBoot/</url>
      
        <content type="html"><![CDATA[<p>本博客是根据韩顺平老师的SpingBoot课程进行的知识总结！</p><h3 id="SpringBoot快速入门"><a href="#SpringBoot快速入门" class="headerlink" title="SpringBoot快速入门"></a>SpringBoot快速入门</h3><ul><li>简化了传统的SSM开发，简化整合步骤，提高开发效率</li><li>简化了Maven项目的pom.xml依赖导入，可以说是一键导入</li></ul><p>@SpringBootApplication:用于表示这是一个springboot应用&#x2F;项目</p><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>​pom.xml中</p><p>​导入了父工程</p><p>​1.spring-boot-starter-parent中还有父项目，声明了开发中常用的依赖的版本号</p><p>​2.会自行进行版本仲裁(程序员没有指定某个jar依赖的版本，则以父项目指定的版本为准)</p><p>​想要修改自动仲裁的版本：（依赖就近优先原则）</p><p>​方式1：在pom.xml自行显式引入依赖<dependency></p><p>​方式2：在pom.xml文件中的<properties>标签中执行版本号</p><h4 id="场景启动器"><a href="#场景启动器" class="headerlink" title="场景启动器"></a>场景启动器</h4><p>​<strong>官方</strong>给的starter形式为：spring-boot-starter-xxx</p><p>​场景启动器能够帮你把使用xxx时所需要的配置全都配好，比如web、redis、jdbc等</p><p>​<strong>第三方</strong>的starter形式为：xxx-spring-boot-starter</p><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><h4 id="自动配置了什么？"><a href="#自动配置了什么？" class="headerlink" title="自动配置了什么？"></a>自动配置了什么？</h4><p>​–Tomcat</p><p>​–SpringMVC</p><p>​–自动配置了Web常用功能如字符过滤器，并注入到容器中</p><p>​–🌟自动配置了默认扫描包结构：默认扫描 <strong>springboot主程序目录下及其子目录中</strong>的包包(可以自行配置)</p><h4 id="如何修改默认配置？"><a href="#如何修改默认配置？" class="headerlink" title="如何修改默认配置？"></a>如何修改默认配置？</h4><h5 id="修改默认扫描包结构-可以传入一个String数组，表示需要扫描多个不同的包"><a href="#修改默认扫描包结构-可以传入一个String数组，表示需要扫描多个不同的包" class="headerlink" title="修改默认扫描包结构(可以传入一个String数组，表示需要扫描多个不同的包)"></a>修改默认扫描包结构(可以传入一个String数组，表示需要扫描多个不同的包)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//scanBasePackages = &#123;&quot;com.study&quot;&#125;指定springboot要扫描的包及其子包</span></span><br><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages = &#123;&quot;com.study&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApp</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><h5 id="也可以在resources-x2F-application-properties文件中定义更多的-自定义配置"><a href="#也可以在resources-x2F-application-properties文件中定义更多的-自定义配置" class="headerlink" title="也可以在resources&#x2F;application.properties文件中定义更多的  自定义配置"></a>也可以在resources&#x2F;application.properties文件中定义更多的  <u>自定义配置</u></h5><pre><code> ⚠️我们在resources/application.properties中自定义了配置，那么springboot在哪读取这些配置的呢？</code></pre><p>​我们在application.properties中配置的信息会映射到该属性对应的某个类中(默认配置最终都会映射到对应的类中)，这个类会被注册进IOC容器中，因此配置才会生效！</p><p>​还可以自定义配置，类似于定义一个常量</p><p>配置的关系：application.properties  xxxProperties  xxxAutoConfiguration</p><p>xxxAutoConfiguration类中含有一个xxxProperties对象，xxxProperties对象中保存了默认配置的值，如果程序员在application.properties中进行了自定义的配置，会被反映到xxxProperties中，覆盖其中的默认值。于是xxxAutoConfiguration中携带的配置就是application.properties与xxxProperties中的信息了，xxxAutoConfiguration再被注册到IOC容器中，于是配置完成！</p><h3 id="SpringBoot容器功能"><a href="#SpringBoot容器功能" class="headerlink" title="SpringBoot容器功能"></a>SpringBoot容器功能</h3><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h4><p>​在SpringBoot中使用@Configuration添加&#x2F;注入组件</p><p>​配置类(被@Configuration修饰的类) 配置类也会注入到容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>      <span class="comment">//表示这是一个配置类</span></span><br><span class="line"><span class="comment">//在@Configuration注解的类中，程序员可以通过@Bean注解来注入bean对象到容器</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span><span class="comment">//默认为单例，可以在scope注解中设置为多例</span></span><br></pre></td></tr></table></figure><h5 id="proxyBeanMethods-代理bean的方法"><a href="#proxyBeanMethods-代理bean的方法" class="headerlink" title="proxyBeanMethods:代理bean的方法"></a>proxyBeanMethods:代理bean的方法</h5><p>​@Configuration(proxyBeanMethods &#x3D; false)&#x2F;&#x2F;表示每个@Bean方法被调用返回的组件<strong>都是新创建的</strong>，多例，代理方式 Lite模式</p><p>​@Configuration(proxyBeanMethods &#x3D; true) &#x2F;&#x2F;表示每个@Bean方法被调用返回的组件<strong>都是单实例的</strong>，单例，非代理方式 Full模式</p><p>​⬆️以上配置要生效，需要先获取BeanConfig组件，再调用方法</p><p>​如果直接通过容器获取，则以上设置无效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接通过容器获取：        </span></span><br><span class="line"><span class="type">Monster</span> <span class="variable">monster01</span> <span class="operator">=</span> ioc.getBean(<span class="string">&quot;monster01&quot;</span>, Monster.class);</span><br><span class="line">        <span class="type">Monster</span> <span class="variable">monster02</span> <span class="operator">=</span> ioc.getBean(<span class="string">&quot;monster01&quot;</span>, Monster.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;01---&quot;</span> + monster01 + <span class="string">&quot; &quot;</span> + monster01.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;02---&quot;</span> + monster02 + <span class="string">&quot; &quot;</span> + monster02.hashCode());</span><br><span class="line"><span class="comment">//获取BeanConfig组件，再调用方法：</span></span><br><span class="line">        <span class="type">BeanConfig</span> <span class="variable">beanConfig</span> <span class="operator">=</span> ioc.getBean(BeanConfig.class);</span><br><span class="line">        <span class="type">Monster</span> <span class="variable">monster01</span> <span class="operator">=</span> beanConfig.monster01();</span><br><span class="line">        <span class="type">Monster</span> <span class="variable">monster02</span> <span class="operator">=</span> beanConfig.monster01();</span><br><span class="line">        System.out.println(<span class="string">&quot;01---&quot;</span> + monster01 + <span class="string">&quot; &quot;</span> + monster01.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;02---&quot;</span> + monster02 + <span class="string">&quot; &quot;</span> + monster02.hashCode());</span><br></pre></td></tr></table></figure><h5 id="配置类——config文件可以有多个"><a href="#配置类——config文件可以有多个" class="headerlink" title="配置类——config文件可以有多个"></a>配置类——config文件可以有多个</h5><p>​每个类可以有多种Bean，给@Bean修饰的方法起不同的名字( id )即可</p><p>&#x2F;&#x2F;monster02为你为该bean设置的id，如果你没有为其在@bean的name属性中设置名称，那么默认为你修饰的构造<strong>方法名</strong><br>通过此步骤：ioc.getBean(“monster02”, Monster.class);</p><h4 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h4><p>修饰配置类，可以通过 .class的数组，来注入指定类型的Bean</p><p>​可以用于注入组件，例：@Import( {Dog.class, Cat.class} ) &#x2F;&#x2F;<strong><u><em>默认bean的ID为该类的全类名</em></u></strong></p><h4 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h4><p>​条件装配：满足Conditional指定的条件，则进行组件注入</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当容器中有一个bean，它的名字是 monster_nmw ,就注入这个bean；没有则不注入//只要名字ok就行，对类型不做要求</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(name = &quot;monster_nmw&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Dog <span class="title function_">dog01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果@Conditional修饰类，那么这个配置类中的所有组件<strong>都</strong>需要满足该条件</p><h4 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h4><p><strong>用于配置传统方式(xml文件)的bean</strong></p><p>​修饰某个配置类，将 .xml 文件中的配置导入到配置类中，并测试是否可以获得 .xml 文件中的组件</p><p>resources目录下的xml文件用 @ImportResource( locations &#x3D; “classpath:xxx.xml” )</p><h4 id="配置绑定："><a href="#配置绑定：" class="headerlink" title="配置绑定："></a>配置绑定：</h4><p>​将application.properties中指定的k-v值 与 JavaBean进行绑定！</p><p>​功能：获取JavaBean时，一些数据自动从application.properties获取</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置Furn的属性 k-v</span></span><br><span class="line"><span class="comment">#其中 furn01 用于指定/区分不同的绑定对象，这样可以在绑定不同的Furn bean属性值时</span></span><br><span class="line"><span class="comment">#通过furn01前缀进行区分</span></span><br><span class="line"><span class="comment">#furn01.id中的id是Furn bean的属性名</span></span><br><span class="line"><span class="attr">furn01.id</span>=<span class="string">100</span></span><br><span class="line"><span class="attr">furn01.name</span>=<span class="string">TV</span></span><br><span class="line"><span class="attr">furn01.price</span>=<span class="string">1000.9</span></span><br></pre></td></tr></table></figure><p>在对应的<strong>bean</strong>中添加注解：@ConfigurationProperties(prefix &#x3D; “furn01”)</p><h4 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h4><p>​修饰bean，直接将bean注册入容器</p><h3 id="SpringBoot底层机制分析"><a href="#SpringBoot底层机制分析" class="headerlink" title="SpringBoot底层机制分析"></a>SpringBoot底层机制分析</h3><h3 id="P32开始"><a href="#P32开始" class="headerlink" title="P32开始"></a>P32开始</h3><h3 id="跳到了P47"><a href="#跳到了P47" class="headerlink" title="跳到了P47"></a>跳到了P47</h3><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><p>简化Javabean的开发，javabean中的getter、setter、tostring均可通过Lombok实现</p><p>@Data 注解在类上，提供所有属性的getter、setter方法</p><p>@Getter</p><p>@Setter</p><p>@ToString</p><p>@NoargsConstructor</p><p>@AllargsConstructor</p><h3 id="Spring-Initializr"><a href="#Spring-Initializr" class="headerlink" title="Spring Initializr"></a>Spring Initializr</h3><p>程序员使用Maven Archetype 来生成Maven项目，项目原型相对简陋，需要手动配置</p><p>我们可以通过Spring Initialzr来构建Maven项目</p><h3 id="53-60跳了！"><a href="#53-60跳了！" class="headerlink" title="53-60跳了！"></a>53-60跳了！</h3><h3 id="yaml："><a href="#yaml：" class="headerlink" title="yaml："></a>yaml：</h3><h4 id="基本规则："><a href="#基本规则：" class="headerlink" title="基本规则："></a>基本规则：</h4><h5 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h5><p>​        key： value        (key + : + 一个空格 + value)<br>​大小写敏感<br>​使用缩进表示层级关系<br>​    缩进不允许使用Tab，只能使用空格<br>​    缩进的格数不重要，只要相同层级的元素左对齐即可<br>​    ‘#’ 表示注释<br>​字符串无需加引号：<br>​单引号会将 \n 作为字符串输出<br>​双引号会将 \n 作为换行输出</p><h5 id="表示对象："><a href="#表示对象：" class="headerlink" title="表示对象："></a>表示对象：</h5><p>​    k: {k1: v1,k2: v2,….}<br>或<br>​    k:<br>​      k1: v1<br>​      k2:v2<br>​      k3:v3<br>​      …</p><h5 id="表示数组："><a href="#表示数组：" class="headerlink" title="表示数组："></a>表示数组：</h5><p>​    k: [v1,v2,v3,…]<br>或<br>​    k:<br>​&#x2F;- v1<br>​&#x2F;-v2<br>​&#x2F;-v3<br>​……</p><!--    在yml文件中，输入自定javabean时需要提示，只需引入如下依赖    --><dependency>    <groupId>org.springframework.boot</groupId>    <artifactId>spring-boot-configuration-processor</artifactId>    <optional>true</optional></dependency><p>properties文件与yaml文件会被**逐个解析(按文件顺序)**，若定义了同样的东西，那么谁先定义就按谁的来</p><h3 id="WEB开发-静态资源访问"><a href="#WEB开发-静态资源访问" class="headerlink" title="WEB开发-静态资源访问"></a>WEB开发-静态资源访问</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><h5 id="默认静态资源目录："><a href="#默认静态资源目录：" class="headerlink" title="默认静态资源目录："></a>默认静态资源目录：</h5><p>​放在resource目录下的四种目录中，会被认为是静态资源：<br>​    1.&#x2F;static<br>​    2.&#x2F;public<br>​    3.&#x2F;resources<br>​    4.&#x2F;META-INF&#x2F;resources</p><p>​可自行更改成别的包，但没必要</p><p>🌟为什么是这几个包呢？因为在Spring容器中，WebProperties.java在IOC容器中被加载，而在其中定义了默认的静态资源路径！</p><h5 id="常见静态资源："><a href="#常见静态资源：" class="headerlink" title="常见静态资源："></a>常见静态资源：</h5><p>​.js .css 图片 字体文件等等</p><h5 id="访问方式："><a href="#访问方式：" class="headerlink" title="访问方式："></a>访问方式：</h5><p>​项目根路径&#x2F; + 静态资源名 (无需中间的路径，直接资源名即可)</p><p>​原因：在 WebProperties.java 中，帮你做了映射。当然，不满意的话也可以自定配置定义。</p><h5 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h5><h6 id="静态资源访问原理："><a href="#静态资源访问原理：" class="headerlink" title="静态资源访问原理："></a>静态资源访问原理：</h6><p>​静态映射是 &#x2F;**  也就是对所有请求拦截，当收到请求时，<strong>先看Controller能不能处理</strong>，若不能，再将请求交给<strong>静态资源处理器</strong>，如果静态资源中也无法匹配，则返回404错误   </p><p>​（即：<u>先看Controller中有无匹配，没有再看静态资源中有没有</u>）</p><p><strong>⚠️因此Controller中的请求可能和静态资源重名，导致意外的错误，因此我们有时需要将静态资源的默认访问前缀进行修改，从而避免冲突</strong></p><h6 id="修改静态资源访问前缀："><a href="#修改静态资源访问前缀：" class="headerlink" title="修改静态资源访问前缀："></a>修改静态资源访问前缀：</h6><p>​在 application.yaml 中配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改静态资源访问的路径/ 前缀</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/study/**</span></span><br></pre></td></tr></table></figure><h6 id="增加一个静态资源目录："><a href="#增加一个静态资源目录：" class="headerlink" title="增加一个静态资源目录："></a>增加一个静态资源目录：</h6><p>​…</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">static-locations:</span> [<span class="string">新的路径</span>]<span class="comment"># 如果原来的还想用，那么要把原来的也填进新的路径中</span></span><br></pre></td></tr></table></figure><h3 id="Rest风格请求处理"><a href="#Rest风格请求处理" class="headerlink" title="Rest风格请求处理"></a>Rest风格请求处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonsterController</span> &#123;</span><br><span class="line"><span class="comment">//    @RequestMapping(value = &quot;/monster&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/monster&quot;)</span><span class="comment">//两种写法作用相同！</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMonster</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GET-查询&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/monster&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">saveMonster</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;POST-保存&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/monster&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">putMonster</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PUT-修改&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/monster&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteMonster</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DELETE-删除&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>客户端是 PostMan 可以直接发送Put、Delete 请求，可以不设置Filter</p><p>如果要springboot支持<strong>页面表单</strong>的Rest功能，需要注意：</p><ul><li>Rest风格请求 核心Filter——HiddenHttpMethodFilter，表单请求会被其拦截，获取表单的 _method值，再判断是PUT&#x2F;DELETE&#x2F;PATCH</li><li>需要在application.yml中启动filter功能</li><li>修改application.yml，启用filter功能</li></ul><p>@RestController 与 @Controller：</p><p>​@Controller：会将方法返回的String交给视图解析器，再跳转到页面</p><p>​1.如果没有配置视图解析器，看有没有对应返回String的其他Controller，有，进入其他controller</p><p>​2.如果配置了视图解析器，则直接寻找有无对应视图解析器，有则使用视图解析器</p><p>​3.找不到则返回404</p><p>​@RestController：会直接返回String，不会寻找视图解析器进行跳转</p><h2 id="参数接收相关注解"><a href="#参数接收相关注解" class="headerlink" title="参数接收相关注解"></a>参数接收相关注解</h2><h3 id="Springboot接收参数注解介绍："><a href="#Springboot接收参数注解介绍：" class="headerlink" title="Springboot接收参数注解介绍："></a>Springboot接收参数注解介绍：</h3><h4 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h4><p>​接收url路径中的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParameterController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/monster/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pathVariable</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id,</span></span><br><span class="line"><span class="params">                               <span class="meta">@PathVariable(&quot;name&quot;)</span>String name,</span></span><br><span class="line"><span class="params">                               <span class="meta">@PathVariable</span> Map&lt;String, String&gt; map)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id:&quot;</span> + id);</span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;map:&quot;</span> + map);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h4><p>​获取http请求头中的全部或部分信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取http请求头中的host信息</span></span><br><span class="line"><span class="comment">//获取http请求头中的所有信息</span></span><br><span class="line"><span class="meta">@GetMapping</span> (<span class="string">&quot;/requestHeader&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestHeader</span><span class="params">(<span class="meta">@RequestHeader(&quot;Host&quot;)</span>String host,</span></span><br><span class="line"><span class="params">                            <span class="meta">@RequestHeader</span> Map&lt;String, String&gt;header)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;host-&quot;</span> + host);</span><br><span class="line">    System.out.println(<span class="string">&quot;header-&quot;</span> + header);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h4><h5 id="RequestAttribute"><a href="#RequestAttribute" class="headerlink" title="@RequestAttribute"></a>@RequestAttribute</h5><p>​获取request域属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/ok&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">ok</span><span class="params">(<span class="meta">@RequestAttribute(value = &quot;user&quot;,required = false)</span>String user)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user:&quot;</span> + user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="SessionAttribute"><a href="#SessionAttribute" class="headerlink" title="@SessionAttribute"></a>@SessionAttribute</h5><p>​获取session域属性，使用方法与@RequestAttribute相同</p><h4 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h4><p>​获取请求参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求信息：</span></span><br><span class="line">&lt;a href=<span class="string">&quot;/hi?name=xiaowoniu&amp;fruit=pear&amp;fruit=apple&quot;</span>&gt;<span class="meta">@RequestParam</span>-获取请求参数&lt;/a&gt;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@GetMapping(&quot;/hi&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hi</span><span class="params">(<span class="meta">@RequestParam(value=&quot;name&quot;)</span>String username,</span></span><br><span class="line"><span class="params">                 <span class="meta">@RequestParam(value = &quot;fruit&quot;)</span>List&lt;String&gt; fruits)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username-&quot;</span> + username);</span><br><span class="line">    System.out.println(<span class="string">&quot;fruits-&quot;</span> + fruits);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h4><p>​获取cookie中的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/cookie&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">cookie</span><span class="params">(<span class="meta">@CookieValue(value = &quot;cookie_key&quot;,required = false)</span>String cookie_value,        <span class="meta">@CookieValue(value = &quot;username&quot;,required = false)</span> Cookie cookie)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;cookie_value:&quot;</span> + cookie_value);</span><br><span class="line">    <span class="keyword">if</span> (cookie != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;username:&quot;</span> + cookie.getName() + <span class="string">&quot; - &quot;</span> + cookie.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h4><p>​获取  <strong>POST请求体</strong>  ，可以直接封装到javabean中(<strong>在自定义参数对象章节中teach</strong>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">postMethod</span><span class="params">(<span class="meta">@RequestBody</span> String content)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;content:&quot;</span> + content);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂参数"><a href="#复杂参数" class="headerlink" title="复杂参数"></a>复杂参数</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>controller中，如果有map、model形参，如果在方法过程中向其中放入了数据，那么request域中会保存map、model中的所有数据</p><h4 id="复杂参数应用实例"><a href="#复杂参数应用实例" class="headerlink" title="复杂参数应用实例"></a>复杂参数应用实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//响应一个复杂请求（注册请求</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/register&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">register</span><span class="params">(Map&lt;String, String&gt; map,</span></span><br><span class="line"><span class="params">                       Model model,</span></span><br><span class="line"><span class="params">                       HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="comment">//如果一个注册请求来了，我们会将注册的数据封装到map或者model中</span></span><br><span class="line">    <span class="comment">//map与model中的数据会被放入request中</span></span><br><span class="line">    map.put(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;tjy&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;job&quot;</span>, <span class="string">&quot;java engineer&quot;</span>);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;sal&quot;</span>, <span class="number">80000</span>);</span><br><span class="line">    <span class="comment">//一会再测试response的使用</span></span><br><span class="line">    <span class="comment">//演示创建 cookie，并通过response添加到浏览器</span></span><br><span class="line">    <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;123@qq.com&quot;</span>);</span><br><span class="line">    response.addCookie(cookie);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/registerOk&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/registerOk&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">registerOk</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user:&quot;</span> + request.getAttribute(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;job:&quot;</span> + request.getAttribute(<span class="string">&quot;job&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;sal:&quot;</span> + request.getAttribute(<span class="string">&quot;sal&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义对象参数-自动封装"><a href="#自定义对象参数-自动封装" class="headerlink" title="自定义对象参数-自动封装"></a>自定义对象参数-自动封装</h3><p>​SpringBoot在响应请求时，也支持自定义对象参数</p><p>​完成自动类型转换与格式化</p><p>​支持级联封装</p><p>​</p><h2 id="自定义转换器"><a href="#自定义转换器" class="headerlink" title="自定义转换器"></a>自定义转换器</h2><p>Convert</p><p>​SpringBoot在响应客户端请求时，<strong>将提交的数据封装成对象</strong>时，使用了<strong>内置的转化器</strong></p><p>​也支持自定义转换器</p><p>(用于将接收到的数据封装到javabean中时，自定义的类型转换——如：接收到了tom,123可以转换为Employee对象，tom -&gt; Employee.name; 123 -&gt; Employee.salary)  </p><p>SpringBoot在接受数据时 会对<strong>接收到的数据类型</strong>以及<strong>将要转换的数据类型</strong>寻找对应的转换器，所以如果没有自定义转换器，我们不能将目标数据类型设为自定义类型，除非你写了对应的自定义类型转换器</p><p>​<strong>写在Config包中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.springboot.config;</span><br><span class="line"><span class="keyword">import</span> com.study.springboot.bean.Car;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.convert.converter.Converter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.format.FormatterRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.ObjectUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/5/16</span></span><br><span class="line"><span class="comment"> * 11:05</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//自定义配置类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//表示WebConfig是一个配置类，启用了Lite模式</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于注入bean WebMvcConfigurer</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebMvcConfigurer <span class="title function_">webMvcConfigurer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFormatters</span><span class="params">(FormatterRegistry registry)</span> &#123;</span><br><span class="line">                <span class="comment">//1. 在这个方法中，我们添加一个自定义的转换器</span></span><br><span class="line">                <span class="comment">//2. String ——&gt; Car</span></span><br><span class="line">                <span class="comment">//3. 增加的自定义转换器会注册到Converters容器中</span></span><br><span class="line">                <span class="comment">//4. converter 底层结构是 ConcurrentHashMap 内置默认有124个转换器</span></span><br><span class="line">                registry.addConverter(<span class="keyword">new</span> <span class="title class_">Converter</span>&lt;String, Car&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Car <span class="title function_">convert</span><span class="params">(String source)</span> &#123;</span><br><span class="line">                        <span class="comment">//在此加入自定义的转换业务代码</span></span><br><span class="line">                        <span class="keyword">if</span>(!ObjectUtils.isEmpty(source))&#123;</span><br><span class="line">                            <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">                            String[] split = source.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                            car.setName(split[<span class="number">0</span>]);</span><br><span class="line">                            car.setPrice(Double.parseDouble(split[<span class="number">1</span>]));</span><br><span class="line">                            <span class="keyword">return</span> car;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Springboot使用HashMap存储所有转换器，其中 key由<strong>convert的原数据类型与目的数据类型组成</strong>，问题来了，如果对于一组数据类型，注册了多个转换器，怎么办呢？——————后来写的会把前面写的<u><strong>覆盖</strong></u>！</p><p>@Controller</p><p>对于return的String，在静态资源中寻找响应的页面</p><p>@ResponseBody</p><p>可以以json格式返回一个自定义对象</p><p>也可以直接在页面上返回String，而不会进行视图解析(可以修饰类，也可以修饰方法)</p><p>@RestController &#x3D; @Controller + @ResponseBody</p><h2 id="处理JSON格式数据"><a href="#处理JSON格式数据" class="headerlink" title="处理JSON格式数据"></a>处理JSON格式数据</h2><h2 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h2><p>​客户端发送器请求，请求中会携带一个ACCEPT字段，告诉服务端应该返回什么类型的数据</p><p>​在AbstractJackson2HttpMessageConverter.java 中， contentType字段会获取请求中的信息，从而知道应当返回什么类型的数据</p><p>🌟我们还可以对请求Header中的ACCEPT字段添加多种可以接受的数据类型，并赋予权重，这样就更加体现了内容协商的思想！</p><p>⬆️问题：postman中可以随意改变accept中的信息，那浏览器中不能修改，又该怎么办呢？</p><p>——开启 <strong>基于请求参数的内容协商功能</strong>⬇️</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">contentnegotiation:</span></span><br><span class="line">      <span class="attr">favor-parameter:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h2><p>​一种服务器渲染技术</p><p>thymeleaf页面无需服务器渲染也可以被浏览器运行，页面简洁</p><p>缺点：并不是一个高性能的引擎，适用于单体应用</p>]]></content>
      
      
      <categories>
          
          <category> Spring开发框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud</title>
      <link href="/2023/06/02/SpringCloud/"/>
      <url>/2023/06/02/SpringCloud/</url>
      
        <content type="html"><![CDATA[<p> 本博客参照了韩顺平老师的 Sping Cloud 课程讲义！</p><h1 id="1-Spring-Cloud-基本介绍"><a href="#1-Spring-Cloud-基本介绍" class="headerlink" title="1 Spring Cloud 基本介绍"></a><strong>1 Spring Cloud</strong> 基本介绍</h1><h2 id="1-1-官方文档"><a href="#1-1-官方文档" class="headerlink" title="1.1 官方文档"></a>1.1 官方文档</h2><h3 id="1-1-1"><a href="#1-1-1" class="headerlink" title="1.1.1"></a>1.1.1</h3><h3 id="地址-https-spring-io-projects-spring-cloud"><a href="#地址-https-spring-io-projects-spring-cloud" class="headerlink" title="地址**: https://spring.io/projects/spring-cloud**"></a>地址**: <a href="https://spring.io/projects/spring-cloud">https://spring.io/projects/spring-cloud</a>**</h3><h2 id="1-2-微服务引出"><a href="#1-2-微服务引出" class="headerlink" title="1.2 微服务引出"></a>1.2 微服务引出</h2><h3 id="1-没有微服务技术-是不是程序员就不能开发大型项目"><a href="#1-没有微服务技术-是不是程序员就不能开发大型项目" class="headerlink" title="1.没有微服务技术**,是不是程序员就不能开发大型项目?**"></a>1.没有微服务技术**,<strong>是不是程序员就不能开发大型项目</strong>?**</h3><p>​<strong>是可以的, 对大型项目进行模块划分,对各个模块进行实现, 模块之间更多的是以API调用完成,耦合度较高, 不利于扩展和维护。</strong></p><h3 id="2-标准的微服务解决方案-springcloud-和cloud-alibaba-出现原因和价值是什么"><a href="#2-标准的微服务解决方案-springcloud-和cloud-alibaba-出现原因和价值是什么" class="headerlink" title="2.标准的微服务解决方案(springcloud 和cloud alibaba)出现原因和价值是什么?"></a>2.标准的微服务解决方案(springcloud 和cloud alibaba)出现原因和价值是什么?</h3><p>​<strong>(1)</strong> **微服务可以根据业务不同，将一个大项目 , 分解成不同的服务(微服务，比如搜 索服务&#x2F;网关服务&#x2F;配置服务&#x2F;存储服务&#x2F;发现服务等等) **</p><p>​<strong>(2)各个服务通过分布式方式进行工 作，从而可以高效，快速，稳定的完成复杂的功能</strong></p><p>​<strong>(3) 如果小伙伴还不理解, 你也可以理解成就 将原来大项目的某些模块-&gt;抽出形成微服务-&gt;配合分布式工作方式-&gt;从而高效，快速，稳定的完成复杂业务功能。</strong></p><h3 id="3-一图胜千言"><a href="#3-一图胜千言" class="headerlink" title="3. 一图胜千言"></a>3. 一图胜千言</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519160836110.png" alt="image-20230519160836110"></p><h2 id="1-3-系统架构的演变过程"><a href="#1-3-系统架构的演变过程" class="headerlink" title="1.3 系统架构的演变过程"></a>1.3 系统架构的演变过程</h2><h3 id="1-3-1单体架构："><a href="#1-3-1单体架构：" class="headerlink" title="1.3.1单体架构："></a>1.3.1单体架构：</h3><p>​<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519161225897.png" alt="image-20230519161225897"></p><p>仅适合少量用户的情况</p><p>如果用户量大，server无法响应大量请求；大量操作数据库的语句冲垮DB</p><h3 id="1-3-2动静分离架构："><a href="#1-3-2动静分离架构：" class="headerlink" title="1.3.2动静分离架构："></a>1.3.2动静分离架构：</h3><p>​<u>静态缓存+文件存储</u></p><p>动静分离：</p><p>1.对静态资源、动态资源的请求进行分离过滤，对于静态资源的请求，直接找资源服务器响应；对于动态服务器的请求才找到应用服务器进行响应。</p><p>2.对请求的数据进行缓存，使用redis等，降低数据库等负荷。</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519162426761.png" alt="image-20230519162426761"></p><h3 id="1-3-3分布式架构："><a href="#1-3-3分布式架构：" class="headerlink" title="1.3.3分布式架构："></a>1.3.3分布式架构：</h3><p>​<u>业务拆分+负载均衡</u></p><p>​<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519163644982.png" alt="image-20230519163644982"></p><h3 id="1-3-4微服务架构："><a href="#1-3-4微服务架构：" class="headerlink" title="1.3.4微服务架构："></a>1.3.4微服务架构：</h3><p>​<u>使用Spring Cloud</u></p><p><img src="https://mp.processon.com/chart_image/id/5c77d08ae4b0628e8208c507.png" alt="点击查看图片来源"></p><ul><li><p><strong>“微服务” 一词源于 Martin Fowler 的名为Microservices 的博文，简单地说， 微服 务是系统架构上的一种设计风格，它的主旨是<u>将一个原本独立的系统拆分成多个小型服务，这些小型服务都在各自独立的进程中运行</u>，服务之间通过基于HTTP 的 RESTful API 进行通信协作。</strong></p></li><li><p><strong>被拆分成的每一个小型服务都国绕着系统中的某一项或一些耦合度较高的业务功能进行构建， 并且每个服务都维护着自身的数据存储、业务开发、自动化测试案例以及独立部署机制。 由于有轻量级的通信协作基础，所以这些微服务可以使用不同的语言来编写，这里我们使用 java。</strong></p></li></ul><h2 id="1-4-Spring-Colud全面说明"><a href="#1-4-Spring-Colud全面说明" class="headerlink" title="1.4 Spring Colud全面说明"></a>1.4 Spring Colud全面说明</h2><h4 id="1-Springcloud-来源于-Spring，是更高层次的、-架构视角的综合性大型项目，-目标旨在构建一套标准化的微服务解决方案，让架构师在使用微服务理念构建系统的时，-面对各环节的问题都可以找到相应的组件来处理"><a href="#1-Springcloud-来源于-Spring，是更高层次的、-架构视角的综合性大型项目，-目标旨在构建一套标准化的微服务解决方案，让架构师在使用微服务理念构建系统的时，-面对各环节的问题都可以找到相应的组件来处理" class="headerlink" title="1.Springcloud 来源于 Spring，是更高层次的、 架构视角的综合性大型项目， 目标旨在构建一套标准化的微服务解决方案，让架构师在使用微服务理念构建系统的时， 面对各环节的问题都可以找到相应的组件来处理"></a>1.Springcloud 来源于 Spring，是更高层次的、 架构视角的综合性大型项目， 目标旨在构建一套标准化的微服务解决方案，让架构师在使用微服务理念构建系统的时， 面对各环节的问题都可以找到相应的组件来处理</h4><h4 id="2-Spring-Cloud-是Spring-社区为微服务架构提供的一个-“全家桶”-套餐。套餐中各个组件之间的配合，可以减少在组件的选型和整合上花费的精力，可以快速构建起基础的微服务架构系统，是微服务架构的最佳落地方案"><a href="#2-Spring-Cloud-是Spring-社区为微服务架构提供的一个-“全家桶”-套餐。套餐中各个组件之间的配合，可以减少在组件的选型和整合上花费的精力，可以快速构建起基础的微服务架构系统，是微服务架构的最佳落地方案" class="headerlink" title="2.Spring Cloud 是Spring 社区为微服务架构提供的一个 “全家桶” 套餐。套餐中各个组件之间的配合，可以减少在组件的选型和整合上花费的精力，可以快速构建起基础的微服务架构系统，是微服务架构的最佳落地方案"></a>2.Spring Cloud 是Spring 社区为微服务架构提供的一个 “全家桶” 套餐。套餐中各个组件之间的配合，可以减少在组件的选型和整合上花费的精力，可以快速构建起基础的微服务架构系统，是微服务架构的最佳落地方案</h4><h4 id="3-Spirng-Cloud-天然支持-spring-Boot-有版本对应要求-，使用门槛较低"><a href="#3-Spirng-Cloud-天然支持-spring-Boot-有版本对应要求-，使用门槛较低" class="headerlink" title="3.Spirng Cloud 天然支持 spring Boot(有版本对应要求)，使用门槛较低"></a>3.Spirng Cloud 天然支持 spring Boot(有版本对应要求)，使用门槛较低</h4><h4 id="4-解决与分布式系统相关的复杂性-一网络问题，延迟开销，带宽向题，安全问题"><a href="#4-解决与分布式系统相关的复杂性-一网络问题，延迟开销，带宽向题，安全问题" class="headerlink" title="4.解决与分布式系统相关的复杂性 一网络问题，延迟开销，带宽向题，安全问题"></a>4.解决与分布式系统相关的复杂性 一网络问题，延迟开销，带宽向题，安全问题</h4><h4 id="5-处理服务发现的能力-一-服务发现允许集群中的进程和服务找到彼此并进行通信"><a href="#5-处理服务发现的能力-一-服务发现允许集群中的进程和服务找到彼此并进行通信" class="headerlink" title="5.处理服务发现的能力 一 服务发现允许集群中的进程和服务找到彼此并进行通信"></a>5.处理服务发现的能力 一 服务发现允许集群中的进程和服务找到彼此并进行通信</h4><h4 id="6-解決冗余问题-一-元余问题经常发生在分布式系统中"><a href="#6-解決冗余问题-一-元余问题经常发生在分布式系统中" class="headerlink" title="6.解決冗余问题 一 元余问题经常发生在分布式系统中"></a>6.解決冗余问题 一 元余问题经常发生在分布式系统中</h4><h4 id="7-解决负载均衡-一-改进跨多个计算资源（例如计算机集群，网络链接，中央处理单元）的工作负载分布"><a href="#7-解决负载均衡-一-改进跨多个计算资源（例如计算机集群，网络链接，中央处理单元）的工作负载分布" class="headerlink" title="7.解决负载均衡 一 改进跨多个计算资源（例如计算机集群，网络链接，中央处理单元）的工作负载分布"></a>7.解决负载均衡 一 改进跨多个计算资源（例如计算机集群，网络链接，中央处理单元）的工作负载分布</h4><h2 id="1-5-Spring-Cloud-核心组件图"><a href="#1-5-Spring-Cloud-核心组件图" class="headerlink" title="1.5 Spring Cloud 核心组件图"></a>1.5 Spring Cloud 核心组件图</h2><h3 id="1-5-1-文档-https-spring-io-projects-spring-cloud"><a href="#1-5-1-文档-https-spring-io-projects-spring-cloud" class="headerlink" title="1.5.1 文档 : https://spring.io/projects/spring-cloud"></a><strong>1.5.1</strong> 文档 <strong>: <a href="https://spring.io/projects/spring-cloud">https://spring.io/projects/spring-cloud</a></strong></h3><h3 id="1-5-2一图胜千言"><a href="#1-5-2一图胜千言" class="headerlink" title="1.5.2一图胜千言"></a>1.5.2一图胜千言</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519184405128.png" alt="image-20230519184405128"></p><h2 id="1-6-Spring-Cloud-分布式示意图"><a href="#1-6-Spring-Cloud-分布式示意图" class="headerlink" title="1.6 Spring Cloud 分布式示意图"></a>1.6 Spring Cloud 分布式示意图</h2><h3 id="1-6-1-文档-https-spring-io-microservices"><a href="#1-6-1-文档-https-spring-io-microservices" class="headerlink" title="1.6.1 文档 : https://spring.io/microservices"></a><strong>1.6.1</strong> 文档 <strong>: <a href="https://spring.io/microservices">https://spring.io/microservices</a></strong></h3><h3 id="1-6-2-一图胜千言"><a href="#1-6-2-一图胜千言" class="headerlink" title="1.6.2 一图胜千言"></a><strong>1.6.2</strong> 一图胜千言</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519185237018.png" alt="image-20230519185237018"></p><ol><li><p>Spring cloud 是微服务的落地</p></li><li><p>Spring cloud 体现了微服务的弹性设计</p></li><li><p>微服务的工作方式一般是基于分布式的。</p></li><li><p>Spring Cloud 仍然是 Spring 家族一员，可以解决微服务的分布式工作方式带来的各种问题</p></li><li><p>Spring Cloud 提供很多组件，比如 服务发现，负载均街，链路中断，分布式追踪和监控，甚至提供 API gateway 功能.</p></li></ol><h3 id="1-6-3-SpringCloud和SpringBoot版本对应关系"><a href="#1-6-3-SpringCloud和SpringBoot版本对应关系" class="headerlink" title="1.6.3 SpringCloud和SpringBoot版本对应关系"></a><strong>1.6.3 SpringCloud</strong>和<strong>SpringBoot</strong>版本对应关系</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519190708371.png" alt="image-20230519190708371"></p><h2 id="1-7-Spring-Cloud-组件选型"><a href="#1-7-Spring-Cloud-组件选型" class="headerlink" title="1.7 Spring Cloud 组件选型"></a>1.7 Spring Cloud 组件选型</h2><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519190901580.png" alt="image-20230519190901580"></p><h1 id="2-Spring-Cloud-Alibaba-基本介绍"><a href="#2-Spring-Cloud-Alibaba-基本介绍" class="headerlink" title="2 Spring Cloud Alibaba 基本介绍"></a><strong>2 Spring Cloud Alibaba</strong> 基本介绍</h1><h2 id="2-1-官方文档"><a href="#2-1-官方文档" class="headerlink" title="2.1 官方文档"></a>2.1 官方文档</h2><h3 id="2-1-1-英文地址-https-github-com-alibaba-spring-cloud-alibaba"><a href="#2-1-1-英文地址-https-github-com-alibaba-spring-cloud-alibaba" class="headerlink" title="2.1.1 英文地址**: https://github.com/alibaba/spring-cloud-alibaba**"></a><strong>2.1.1</strong> 英文地址**: <a href="https://github.com/alibaba/spring-cloud-alibaba">https://github.com/alibaba/spring-cloud-alibaba</a>**</h3><h3 id="2-1-2英-文-地-址-中-文-文-档-https-github-com-alibaba-spring-cloud-alibaba-blob-master-README-zh-md"><a href="#2-1-2英-文-地-址-中-文-文-档-https-github-com-alibaba-spring-cloud-alibaba-blob-master-README-zh-md" class="headerlink" title="2.1.2英 文 地 址 : 中 文 文 档 : https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md"></a><strong>2.1.2</strong>英 文 地 址 <strong>:</strong> 中 文 文 档 <strong>: <a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md">https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md</a></strong></h3><h2 id="2-2-SpringCloudAlibaba是什么"><a href="#2-2-SpringCloudAlibaba是什么" class="headerlink" title="2.2 SpringCloudAlibaba是什么"></a>2.2 SpringCloudAlibaba是什么</h2><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519192136898.png" alt="image-20230519192136898"></p><h2 id="2-3-主要功能一览"><a href="#2-3-主要功能一览" class="headerlink" title="2.3 主要功能一览"></a>2.3 主要功能一览</h2><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519192150299.png" alt="image-20230519192150299"></p><h2 id="2-4-Spring-Cloud-Alibaba-核心组件"><a href="#2-4-Spring-Cloud-Alibaba-核心组件" class="headerlink" title="2.4 Spring Cloud Alibaba 核心组件"></a>2.4 Spring Cloud Alibaba 核心组件</h2><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519192202912.png" alt="image-20230519192202912"></p><h2 id="2-5-分布式微服务技术选型"><a href="#2-5-分布式微服务技术选型" class="headerlink" title="2.5: 分布式微服务技术选型"></a>2.5: 分布式微服务技术选型</h2><h3 id="•Spring-Cloud-原生组件的几大痛点"><a href="#•Spring-Cloud-原生组件的几大痛点" class="headerlink" title="•Spring Cloud 原生组件的几大痛点"></a>•Spring Cloud 原生组件的几大痛点</h3><p>1.Spring Cloud 部分组件停止维护和更新，给开发带来不便</p><p>2.Spring cioud 部分环境搭建复杂，没有完善的可视化界面，我们需要大量的二次开发和定制</p><p>3.Spring Cloud 配置复杂，难以上手</p><h3 id="•Spring-Cloud-Alibaba-的优势"><a href="#•Spring-Cloud-Alibaba-的优势" class="headerlink" title="•Spring Cloud Alibaba 的优势"></a>•Spring Cloud Alibaba 的优势</h3><ol><li>阿里使用过的组件经历了考验（高并发，高性能，高可用，性能强悍，设计合理，现在开源</li></ol><p>出来供大家使用。</p><ol start="2"><li>搭配完善的可视化界面，给开发运维带来极大的便利搭建简单，学习曲线低。</li></ol><ul><li><h3 id="分布式微服务技术选型建议"><a href="#分布式微服务技术选型建议" class="headerlink" title="分布式微服务技术选型建议"></a><strong>分布式微服务技术选型建议</strong></h3></li></ul><p>以Spring Cloud Alibaba为主，以Spring Cloud 原生组件为辅。</p><h1 id="3-微服务基础环境搭建"><a href="#3-微服务基础环境搭建" class="headerlink" title="3 微服务基础环境搭建"></a>3 微服务基础环境搭建</h1><h2 id="3-1-创建父工程-，用于聚合其它微服务模块"><a href="#3-1-创建父工程-，用于聚合其它微服务模块" class="headerlink" title="3.1 创建父工程 ，用于聚合其它微服务模块"></a>3.1 创建父工程 ，用于聚合其它微服务模块</h2><h3 id="3-1-1-需求说明-x2F-图解"><a href="#3-1-1-需求说明-x2F-图解" class="headerlink" title="3.1.1 需求说明**&#x2F;**图解"></a><strong>3.1.1</strong> 需求说明**&#x2F;**图解</h3><h3 id="3-1-2-实现步骤"><a href="#3-1-2-实现步骤" class="headerlink" title="3.1.2 实现步骤"></a><strong>3.1.2</strong> 实现步骤</h3><h4 id="3-1-2-1-创建父项目-作为聚合其它微服务模块"><a href="#3-1-2-1-创建父项目-作为聚合其它微服务模块" class="headerlink" title="3.1.2.1 创建父项目, 作为聚合其它微服务模块"></a>3.1.2.1 创建父项目, 作为聚合其它微服务模块</h4><p>###我们先创建一个父项目**,** 该父项目会去管理多个微服务模块(module)</p><p>Maven创建项目 使用webapp Maven工件</p><h4 id="3-1-2-2-项目设置"><a href="#3-1-2-2-项目设置" class="headerlink" title="3.1.2.2 项目设置"></a>3.1.2.2 项目设置</h4><ol><li></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519194056058.png" alt="image-20230519194056058"></p><ol start="2"><li></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519194231324.png" alt="image-20230519194231324"></p><p>3.父项目本身不写代码，是用来进行管理的</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519194329079.png" alt="image-20230519194329079"></p><h4 id="3-1-2-4-配置父工程-pom-xml-作为聚合其它模块"><a href="#3-1-2-4-配置父工程-pom-xml-作为聚合其它模块" class="headerlink" title="3.1.2.4 配置父工程 pom.xml, 作为聚合其它模块"></a>3.1.2.4 配置父工程 pom.xml, 作为聚合其它模块</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.study.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>e-commerce-center<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--  表明是一个父工程，用于聚合管理其他模块--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>e-commerce-center Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      老师说明: 使用最新版本的 log4j , 防止安全漏洞</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>2.17.2<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span>1.18.20<span class="tag">&lt;/<span class="name">lombok.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>8.0.31<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">druid.version</span>&gt;</span>1.1.17<span class="tag">&lt;/<span class="name">druid.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis.spring.boot.version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">mybatis.spring.boot.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  1. dependencyManagement 作用: 子模块继承后, 锁定版本,</span></span><br><span class="line"><span class="comment">  子模块不用再写 version --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      老师解读:</span></span><br><span class="line"><span class="comment">      1. type: pom 和 scope import 配合使用</span></span><br><span class="line"><span class="comment">      2. 表示 父项目的子模块, 在引入 springboot 相关依赖时 锁定版本为</span></span><br><span class="line"><span class="comment">      3. 通过 pom + import 解决 maven 单继承机制</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;druid.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-1-3-注意事项和细节"><a href="#3-1-3-注意事项和细节" class="headerlink" title="3.1.3 注意事项和细节"></a><strong>3.1.3</strong> 注意事项和细节</h3><h4 id="3-1-3-1-Maven的dependencyManagement说明"><a href="#3-1-3-1-Maven的dependencyManagement说明" class="headerlink" title="3.1.3.1 Maven的dependencyManagement说明"></a>3.1.3.1 Maven的dependencyManagement说明</h4><p>1、Maven 使用 dependencyManagement 元素来提供了一种管理依赖版本号的方式。通常在项目</p><p>packaging 为 POM，中使用dependencvManadement 元素。</p><p>2、使用pom.xml 中的dependencyManagement 元素能让所有在子项目中引用一个依赖， Maven 会沿着父子层次向上走，直到找到一个拥有dependencyManagement 元素的项目，然后它就会使用这个dependencyManagement 元素中指定的版本号。</p><p>3、好处：如果有多个子项目都号1用同一样依赖，则可以避免在每个使用的子项目里都声明一个版本号，当开级或切换到另一个版本时，只需要在顶层父容器里更新，而不需要分别在子项目的修改;另外如果某个子项目需要另外的一个版本，只需要声明version 就可。</p><p>4、dependency Management 里只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。</p><p>5、如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version 和 scope 都读取自父 pom</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519202427190.png" alt="image-20230519202427190" style="zoom:50%;" /><p>6、如果子项目中指定了版本号，那么会使用子项目中指定的 jar 版本</p><h2 id="3-2-创建会员中心微服务模块-service-provider"><a href="#3-2-创建会员中心微服务模块-service-provider" class="headerlink" title="3.2 创建会员中心微服务模块 -service provider"></a>3.2 创建会员中心微服务模块 -service provider</h2><h3 id="3-2-1-需求说明"><a href="#3-2-1-需求说明" class="headerlink" title="3.2.1 需求说明"></a><strong>3.2.1</strong> 需求说明</h3><h4 id="1、通过浏览器可以获取会员信息-通过会员中心微服务模块"><a href="#1、通过浏览器可以获取会员信息-通过会员中心微服务模块" class="headerlink" title="1、通过浏览器可以获取会员信息**(通过会员中心微服务模块)**"></a><strong>1</strong>、通过浏览器可以获取会员信息**(<strong>通过会员中心微服务模块</strong>)**</h4><h3 id="3-2-2-思路分析"><a href="#3-2-2-思路分析" class="headerlink" title="3.2.2 思路分析"></a><strong>3.2.2</strong> 思路分析</h3><p>1、创建 Moduel &amp; 完成配置</p><p>2、创建数据库&#x2F;表</p><p>3、创建 entity-dao&#x2F;Mapper.xml-service-controller</p><p>4、完成测试</p><h3 id="3-2-3-实现步骤"><a href="#3-2-3-实现步骤" class="headerlink" title="3.2.3 实现步骤"></a><strong>3.2.3</strong> 实现步骤</h3><p>​application.yml:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">member-service-provider-10000</span><span class="comment">#名称，可以自己指定</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/booking?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">QWEASDzxc123</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span> <span class="comment">#后面 mapper 文件的位置</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.study.springcloud.entity</span>  <span class="comment">#实体类的包路径</span></span><br></pre></td></tr></table></figure><p>MemberMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.study.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>e-commerce-center<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>member-service-provider-10000<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;packaging&gt;war&lt;/packaging&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>member-service-provider-10000 Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        使用版本仲裁，从父项目中获取版本--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        springboot程序的监控系统，实现系统健康检测</span></span><br><span class="line"><span class="comment">            可以通过 http://localhost:10000/actuator 看到相关连接</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>member-service-provider-10000<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-4-🌟注意事项和细节"><a href="#3-2-4-🌟注意事项和细节" class="headerlink" title="3.2.4 🌟注意事项和细节"></a><strong>3.2.4</strong> 🌟注意事项和细节</h3><p><strong>传输javabean时</strong></p><p>1、我们的前端如果是以 <strong>json 格式</strong>来发送添加信息Member，那么我们<strong>需要使用@RequestBody</strong>,</p><p>才能将数据封裝到对应的 bean，同时保证 http 的请求头的 content-type 是对应的</p><p>2、如果前端是以 <strong>表单</strong> 或者 <strong>parameters</strong> 形式提交， 则一定不能使用@RequestBody， 才</p><p>会进行对象参数封装，同时保证http 的请求头的 content-type 是对应</p><p>3、在进行 SpringBoot 应用程序测试时，引入的 jUnit 是ore.junit.jupiter.api.Test</p><p>4、 在运行程序时，一定要确保你的 XxxxMapper.xml 文件被自动放到的 target 目录的</p><p>classes 指定目录。</p><h2 id="3-3-创建使用会员微服务模块-service-consumer"><a href="#3-3-创建使用会员微服务模块-service-consumer" class="headerlink" title="3.3 创建使用会员微服务模块 -service consumer"></a>3.3 创建使用会员微服务模块 -service consumer</h2><h3 id="3-3-1-需求说明-x2F-图解"><a href="#3-3-1-需求说明-x2F-图解" class="headerlink" title="3.3.1 需求说明**&#x2F;**图解"></a><strong>3.3.1</strong> 需求说明**&#x2F;**图解</h3><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230520114632421.png" alt="image-20230520114632421" style="zoom:30%;" /><p>-浏览器: <a href="http://localhost/member/consumer/get/1">http://localhost/member/consumer/get/1</a></p><p>-测试添加会员 : <a href="http://localhost/member/consumer/save">http://localhost/member/consumer/save</a></p><h3 id="3-3-2-思路分析-x2F-图解"><a href="#3-3-2-思路分析-x2F-图解" class="headerlink" title="3.3.2 思路分析**&#x2F;**图解"></a><strong>3.3.2</strong> 思路分析**&#x2F;**图解</h3><p>1、创建 Moduel(member-service-consumer-80) ＆ 完成配罝</p><p>2、创建 controller</p><p>3、完成测试</p><h3 id="3-3-3-实现步骤"><a href="#3-3-3-实现步骤" class="headerlink" title="3.3.3 实现步骤"></a><strong>3.3.3</strong> 实现步骤</h3><h4 id="3-3-3-1-创建-Moduel-amp-完成配置"><a href="#3-3-3-1-创建-Moduel-amp-完成配置" class="headerlink" title="3.3.3.1 创建 Moduel &amp; 完成配置"></a>3.3.3.1 创建 Moduel &amp; 完成配置</h4><h5 id="创建Moduel："><a href="#创建Moduel：" class="headerlink" title="创建Moduel："></a>创建Moduel：</h5><p>在创建Moduel后，其父工程的 pom.xml 会做相应变化，在<modules>标签中增加管理member-service-consumer-80微服务模块</p><h5 id="完成配置："><a href="#完成配置：" class="headerlink" title="完成配置："></a>完成配置：</h5><p>pom.xml &#x2F; application.yaml 可参考之前写的，取自己需要的即可。</p><h5 id="注入-RestTemplate："><a href="#注入-RestTemplate：" class="headerlink" title="注入 RestTemplate："></a>注入 RestTemplate：</h5><h6 id="RestTemplate基本介绍："><a href="#RestTemplate基本介绍：" class="headerlink" title="RestTemplate基本介绍："></a>RestTemplate基本介绍：</h6><p>​1、<strong>RestTemplate</strong> 是Spring 提供的用于访问 Rest 服务的模板类</p><p>​2、RestTerplate 提供了多种<strong>便捷访问远程 Http 服务</strong>的方法</p><p>​3、说明：可以这样理解，通过 RestTemplate，我们可以发出 http 请求(支持Restful 风格)，去调用Controller 提供的 API 接口，就像我们使用浏览器发出http 请求调用该 API接口一样。</p><p>​4、使用简单便捷</p><h6 id="官网地址："><a href="#官网地址：" class="headerlink" title="官网地址："></a>官网地址：</h6><p><a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html">https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html</a></p><h6 id="创建配置类-com-x2F-hspedu-x2F-springcloud-x2F-config-x2F-CustomizationBean-java"><a href="#创建配置类-com-x2F-hspedu-x2F-springcloud-x2F-config-x2F-CustomizationBean-java" class="headerlink" title="创建配置类: com&#x2F;hspedu&#x2F;springcloud&#x2F;config&#x2F;CustomizationBean.java"></a>创建配置类: com&#x2F;hspedu&#x2F;springcloud&#x2F;config&#x2F;CustomizationBean.java</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomizationBean</span> &#123;</span><br><span class="line">    <span class="comment">//配置注入RestTemplate bean 对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="创建-com-x2F-hspedu-x2F-springcloud-x2F-controller-x2F-MemberConsumerController-java"><a href="#创建-com-x2F-hspedu-x2F-springcloud-x2F-controller-x2F-MemberConsumerController-java" class="headerlink" title="创建:com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;MemberConsumerController.java"></a>创建:com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;MemberConsumerController.java</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberConsumerController</span> &#123;</span><br><span class="line">    <span class="comment">//url由（ip：端口）+（请求名称）两部分组成</span></span><br><span class="line">    <span class="comment">//定义member_service_provider_url</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MEMBER_SERVICE_PROVIDER_URL</span> <span class="operator">=</span></span><br><span class="line">            <span class="string">&quot;http://localhost:10000&quot;</span>;</span><br><span class="line">    <span class="comment">//方法/接口，添加member对象到数据库/表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//装配RestController</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;member/consumer/save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Member&gt; <span class="title function_">save</span><span class="params">(Member member)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;service-consumer member=&#123;&#125;&quot;</span>,member);</span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(</span><br><span class="line">                MEMBER_SERVICE_PROVIDER_URL+<span class="string">&quot;/member/save&quot;</span>,member, Result.class);</span><br><span class="line">        <span class="comment">//url,要save的对象，返回值的类型</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据id 调用服务接口，返回member对象信息</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/member/consumer/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Member&gt; <span class="title function_">getMemberById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(</span><br><span class="line">                MEMBER_SERVICE_PROVIDER_URL+<span class="string">&quot;/member/get/&quot;</span> + id,Result.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3-2-注意事项和使用细节"><a href="#3-3-3-2-注意事项和使用细节" class="headerlink" title="3.3.3.2 注意事项和使用细节"></a>3.3.3.2 注意事项和使用细节</h4><h5 id="添加会员数据库中为-null-的解决方案"><a href="#添加会员数据库中为-null-的解决方案" class="headerlink" title="添加会员数据库中为 null 的解决方案"></a>添加会员数据库中为 <strong>null</strong> 的解决方案</h5><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230520171355467.png" alt="image-20230520171355467" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230520171418620.png" alt="image-20230520171418620" style="zoom:50%;" /><h5 id="开启-Run-DashBoard"><a href="#开启-Run-DashBoard" class="headerlink" title="开启 Run DashBoard"></a>开启 <strong>Run DashBoard</strong></h5><p>​当springcloud 的服务有多个时，管理多个服务的启动使用run会不好管理，这样我们就可以使用 </p><p>RunDashboard.</p><p>找到 你的项目&#x2F;.idea&#x2F;workspace.xml 文件在其中添加下面的代码即可</p><p>添加在：原本第二行<project version="4">的下一行即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">&quot;RunDashboard&quot;</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">&quot;configurationTypes&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;SpringBootApplicationConfigurationType&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">&quot;ruleStates&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">RuleState</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ConfigurationTypeDashboardGroupingRule&quot;</span> /&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">RuleState</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">RuleState</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;StatusDashboardGroupingRule&quot;</span> /&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">RuleState</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">option</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重启项目 </p><p>​<strong>视图-工具窗口-服务</strong> 即可方便管理各个主程序！</p><h2 id="3-4-创建共用模块-供其它模块使用"><a href="#3-4-创建共用模块-供其它模块使用" class="headerlink" title="3.4 创建共用模块-供其它模块使用"></a>3.4 创建共用模块-供其它模块使用</h2><h3 id="3-4-1-需求说明-x2F-图解"><a href="#3-4-1-需求说明-x2F-图解" class="headerlink" title="3.4.1 需求说明**&#x2F;**图解"></a><strong>3.4.1</strong> 需求说明**&#x2F;**图解</h3><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230520185154382.png" alt="image-20230520185154382" style="zoom:50%;" /><h3 id="3-4-2-思路分析-x2F-图解"><a href="#3-4-2-思路分析-x2F-图解" class="headerlink" title="3.4.2 思路分析**&#x2F;**图解"></a><strong>3.4.2</strong> 思路分析**&#x2F;**图解</h3><p>1、创建 Moduel &amp; 完成配置</p><p>2、创建entity，把共用的实体类放到对应的包下</p><p>3、完成测试</p><h3 id="3-4-3-实现步骤"><a href="#3-4-3-实现步骤" class="headerlink" title="3.4.3 实现步骤"></a><strong>3.4.3</strong> 实现步骤</h3><h4 id="3-4-3-1-创建-Moduel-amp-完成配置"><a href="#3-4-3-1-创建-Moduel-amp-完成配置" class="headerlink" title="3.4.3.1 创建 Moduel &amp; 完成配置"></a>3.4.3.1 创建 Moduel &amp; 完成配置</h4><h5 id="3-4-3-1-1-创建-e-commerce-center-common-api"><a href="#3-4-3-1-1-创建-e-commerce-center-common-api" class="headerlink" title="3.4.3.1.1 创建 e_commerce_center-common-api"></a><strong>3.4.3.1.1</strong> 创建 <strong>e_commerce_center-common-api</strong></h5><h6 id="在pom-xml中提取公共依赖"><a href="#在pom-xml中提取公共依赖" class="headerlink" title="在pom.xml中提取公共依赖"></a>在pom.xml中提取公共依赖</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--老师解读&lt;optional&gt;true&lt;/optional&gt;:</span></span><br><span class="line"><span class="comment">    1. true 表示两个项目之间依赖不传递</span></span><br><span class="line"><span class="comment">    2. 小伙伴可以这里理解&lt;optional&gt;true&lt;/optional&gt;: 防止将该依赖传递到其他模块中</span></span><br><span class="line"><span class="comment">    说的再具体一点，比如 member-service-consumer-80 模块依赖了本项目,</span></span><br><span class="line"><span class="comment">    那么本项目不会把 lombok 传递给 member-service-consumer-80</span></span><br><span class="line"><span class="comment">    3. 不设置 optional 或者 optional 是 false，表示传递依赖</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="抽取共用-API-x2F-类"><a href="#抽取共用-API-x2F-类" class="headerlink" title="抽取共用 API&#x2F;类"></a>抽取共用 API&#x2F;类</h6><p>​写入公共的entity</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230520191145475.png" alt="image-20230520191145475" style="zoom:55%;" /><h6 id="使用-Maven-打包成-jar"><a href="#使用-Maven-打包成-jar" class="headerlink" title="使用 Maven 打包成 jar"></a>使用 Maven 打包成 jar</h6><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230520192050410.png" alt="image-20230520192050410" style="zoom:50%;" /><p>会在test目录中生成对应jar包</p><h6 id="工程重构"><a href="#工程重构" class="headerlink" title="工程重构"></a>工程重构</h6><p>​1.在 <strong>member-service-consumer-80</strong> 引入 <strong>e_commerce_center-common-api-1.0-SNAPSHOT.jar</strong></p><p>​删除原来的 <strong>entity</strong> 包</p><p>​修改 <strong>pom.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入 e_commerce_center-common-api --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hspedu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>e_commerce_center-common-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样就完成了！</p><h1 id="4-SpringCloud-Eureka-服务注册中心"><a href="#4-SpringCloud-Eureka-服务注册中心" class="headerlink" title="4 SpringCloud Eureka 服务注册中心"></a>4 SpringCloud Eureka 服务注册中心</h1><h2 id="4-1-Eureka介绍"><a href="#4-1-Eureka介绍" class="headerlink" title="4.1 Eureka介绍"></a>4.1 Eureka介绍</h2><h3 id="4-1-1-学-Eureka-前的说明"><a href="#4-1-1-学-Eureka-前的说明" class="headerlink" title="4.1.1 学 Eureka 前的说明"></a><strong>4.1.1</strong> 学 <strong>Eureka</strong> 前的说明</h3><h4 id="1、Spring-Cloud-组件选型图"><a href="#1、Spring-Cloud-组件选型图" class="headerlink" title="1、Spring Cloud 组件选型图"></a><strong>1</strong>、Spring Cloud 组件选型图</h4><p>![image-20230519190901580](&#x2F;Users&#x2F;donn&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230519190901580.png)</p><h4 id="2、从上图可以看出，目前主流的服务注册-amp-发现的组件是-Nacos，-但是-Eureka-作为一个老牌经典的-服务注册-amp-发现技术还是有必要学习一下，原因："><a href="#2、从上图可以看出，目前主流的服务注册-amp-发现的组件是-Nacos，-但是-Eureka-作为一个老牌经典的-服务注册-amp-发现技术还是有必要学习一下，原因：" class="headerlink" title="2、从上图可以看出，目前主流的服务注册&amp;发现的组件是 Nacos， 但是 Eureka 作为一个老牌经典的 服务注册&amp;发现技术还是有必要学习一下，原因："></a>2、从上图可以看出，目前主流的服务注册&amp;发现的组件是 Nacos， 但是 Eureka 作为一个老牌经典的 服务注册&amp;发现技术还是有必要学习一下，原因：</h4><p>（1） 一些早期的分布式 微服务项目使用的是 Eureka， 小伙伴在工作中，完全有可能遇到这种情况。</p><p>（2） 后期的服务注册&amp;发现组件&#x2F;技术，都参考了 Eureka 设计和理念，学习了Eureka 后，我们上手Nacos容易很多，而且理解的更深刻。</p><h3 id="4-1-2-当前项目架构问题分析-引出-Eureka"><a href="#4-1-2-当前项目架构问题分析-引出-Eureka" class="headerlink" title="4.1.2 当前项目架构问题分析 **-**引出 Eureka"></a><strong>4.1.2</strong> 当前项目架构问题分析 **-**引出 Eureka</h3><p>一图胜千言</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230521192330770.png" alt="image-20230521192330770"></p><p>1.在企业级项目中，服务消费访问请求会存在高并发 (一个服务提供模块可能无法承受)</p><p>2.如果只有一个会员中心-提供服务模块，可用性差 (如果只有一个服务提供模块，如果故障，系统将无法使用，可用性差)</p><p>3.所以，会员中心提供服务往往是一个集群，也就是说会有<strong>多个会员中心提供服务微服务模块</strong> ( 高可用 )  </p><p>4.那么这个时候，就存在一个问题：服务消费方，怎么去发现可以使用的服务 </p><p>5,当服务消费方，发现了可以使用的服务后(可能是多个，又存在一个问题：到底调用 A服务，还是B服务？ 这就引出了服务注册和负载均衡)</p><p>6.Eureka 就可以解决上述问题</p><h3 id="4-1-3-引入-Eureka-项目架构"><a href="#4-1-3-引入-Eureka-项目架构" class="headerlink" title="4.1.3 引入 Eureka 项目架构"></a><strong>4.1.3</strong> 引入 <strong>Eureka</strong> 项目架构</h3><h4 id="一图胜千言"><a href="#一图胜千言" class="headerlink" title="一图胜千言"></a>一图胜千言</h4><p>​<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230521193144050.png" alt="image-20230521193144050"></p><ol><li><p>会员中心-是提供服务的模块，在项目中，会做成集群，提供高可用</p></li><li><p>Eureka Server 有必要的话，也可以做成集群</p></li><li><p>Eureka 包含两个组件：Eureka Server和 Eureka Client</p></li><li><p>Eureka Server 提供注册服务，各个微服务节点通过配置启动后，会在 Eureka Server中迸行注册，这样 EurekaServer 中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。</p></li><li><p>Euretka Client 通过注册中心进行访问，是一个Java 客户端，用于简化 Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin） 负载算法的负载均衡器。在应用启动后，将会向 Eureka Server 发送心跳（默认周期为 30秒)。如果 Eureka Server 在多个心跳周期内没有接收到某个节点的心跳，EurekaServer 将会从服务注册表中把这个服务节点移除(默认90秒)</p></li></ol><h3 id="4-1-4-服务治理介绍"><a href="#4-1-4-服务治理介绍" class="headerlink" title="4.1.4 服务治理介绍"></a><strong>4.1.4</strong> 服务治理介绍</h3><h4 id="4-1-4-1-Eureka实现服务治理"><a href="#4-1-4-1-Eureka实现服务治理" class="headerlink" title="4.1.4.1 Eureka实现服务治理"></a>4.1.4.1 Eureka实现服务治理</h4><h4 id="4-1-4-2-在传统的-rpc-远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理困难，所以-需要治理服务之间依赖关系"><a href="#4-1-4-2-在传统的-rpc-远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理困难，所以-需要治理服务之间依赖关系" class="headerlink" title="4.1.4.2 在传统的 rpc 远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理困难，所以 需要治理服务之间依赖关系"></a>4.1.4.2 在传统的 rpc 远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理困难，所以 需要治理服务之间依赖关系</h4><h4 id="4-1-4-3-服务治理实现服务调用、负载均衡、容错等，实现服务发现与注册。"><a href="#4-1-4-3-服务治理实现服务调用、负载均衡、容错等，实现服务发现与注册。" class="headerlink" title="4.1.4.3 服务治理实现服务调用、负载均衡、容错等，实现服务发现与注册。"></a>4.1.4.3 服务治理实现服务调用、负载均衡、容错等，实现服务发现与注册。</h4><h4 id="4-1-4-4-二说分布式开发-https-jingyan-baidu-com-article-46650658def479f549e5f83e-html"><a href="#4-1-4-4-二说分布式开发-https-jingyan-baidu-com-article-46650658def479f549e5f83e-html" class="headerlink" title="4.1.4.4 二说分布式开发: https://jingyan.baidu.com/article/46650658def479f549e5f83e.html"></a>4.1.4.4 二说分布式开发: <a href="https://jingyan.baidu.com/article/46650658def479f549e5f83e.html">https://jingyan.baidu.com/article/46650658def479f549e5f83e.html</a></h4><h3 id="4-1-5-服务注册和发现"><a href="#4-1-5-服务注册和发现" class="headerlink" title="4.1.5 服务注册和发现"></a><strong>4.1.5</strong> 服务注册和发现</h3><p>Eureka采用了CS [client-server-java基础我们讲过一个多人聊天项目] 的设计架构，Eureka Server 作为服务注册功能的服务器，它是服务注册中心。</p><p>系统中的其他微服务，<strong>使用 Eureka的客户端连接到 Eureka Server</strong>并维持心跳连接，通过 Eureka Server 来监控系统中各个微服务是否正常运行。</p><p>在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息 比如 服务地址通讯地址等以别名方式注册到注册中心上。</p><p>服务消费者或者服务提供者，以服务别名的方式去注册中心上获取到实际的服务提供者通讯地址，然后通过RPC调用服务。</p><h2 id="4-2-创建单机-Eureka-Server-注册中心"><a href="#4-2-创建单机-Eureka-Server-注册中心" class="headerlink" title="4.2 创建单机 Eureka Server-注册中心"></a>4.2 创建单机 Eureka Server-注册中心</h2><h3 id="4-2-1-需求说明-x2F-图解"><a href="#4-2-1-需求说明-x2F-图解" class="headerlink" title="4.2.1 需求说明**&#x2F;**图解"></a><strong>4.2.1</strong> 需求说明**&#x2F;**图解</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230522104534270.png" alt="image-20230522104534270"></p><h3 id="4-2-2-实现步骤"><a href="#4-2-2-实现步骤" class="headerlink" title="4.2.2 实现步骤"></a><strong>4.2.2</strong> 实现步骤</h3><h4 id="4-2-2-1-创建-Moduel-amp-完成配置"><a href="#4-2-2-1-创建-Moduel-amp-完成配置" class="headerlink" title="4.2.2.1 创建 Moduel &amp; 完成配置"></a>4.2.2.1 创建 Moduel &amp; 完成配置</h4><h5 id="4-2-2-1-1-创建-e-commerce-eureka-server-9001-微服务模块-作为注册中心"><a href="#4-2-2-1-1-创建-e-commerce-eureka-server-9001-微服务模块-作为注册中心" class="headerlink" title="4.2.2.1.1 创建 e-commerce-eureka-server-9001 微服务模块**[**作为注册中心]"></a>4.2.2.1.1 创建 <strong>e-commerce-eureka-server-9001</strong> 微服务模块**[**作为注册中心]</h5><h6 id="创建-module"><a href="#创建-module" class="headerlink" title="创建 module"></a>创建 <strong>module</strong></h6><h6 id="4-2-2-1-2-修改-e-commerce-eureka-server-9001-的-pom-xml-加入依赖"><a href="#4-2-2-1-2-修改-e-commerce-eureka-server-9001-的-pom-xml-加入依赖" class="headerlink" title="4.2.2.1.2 修改 e-commerce-eureka-server-9001 的 pom.xml , 加入依赖"></a>4.2.2.1.2 修改 <strong>e-commerce-eureka-server-9001</strong> 的 <strong>pom.xml ,</strong> 加入依赖</h6><h6 id="4-2-2-1-3-创建-resources-x2F-application-yml"><a href="#4-2-2-1-3-创建-resources-x2F-application-yml" class="headerlink" title="4.2.2.1.3 创建 resources&#x2F;application.yml"></a><strong>4.2.2.1.3</strong> 创建 <strong>resources&#x2F;application.yml</strong></h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9001</span></span><br><span class="line"><span class="comment"># 配置eureka-server</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span> <span class="comment">#服务实例名</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">#表示自己就是注册中心，作用是维护注册服务实例，不需要去检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><h6 id="4-2-2-1-4-创建主启动类-com-x2F-hspedu-x2F-springcloud-x2F-EurekaApplication-java"><a href="#4-2-2-1-4-创建主启动类-com-x2F-hspedu-x2F-springcloud-x2F-EurekaApplication-java" class="headerlink" title="4.2.2.1.4 创建主启动类 com&#x2F;hspedu&#x2F;springcloud&#x2F;EurekaApplication.java"></a><strong>4.2.2.1.4</strong> 创建主启动类 <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;EurekaApplication.java</strong></h6><p>记得添加@EnableEurekaServer，表示该程序作为EurekaServer</p><h3 id="4-2-3-将-member-service-provider-10000-作-为-EurekaClient-注-册-到-e-commerce-eureka-server-9001-成为服务提供者"><a href="#4-2-3-将-member-service-provider-10000-作-为-EurekaClient-注-册-到-e-commerce-eureka-server-9001-成为服务提供者" class="headerlink" title="4.2.3 将 member-service-provider-10000 作 为 EurekaClient 注 册 到 e-commerce-eureka-server-9001 成为服务提供者"></a><strong>4.2.3</strong> 将 <strong>member-service-provider-10000</strong> 作 为 <strong>EurekaClient</strong> 注 册 到 <strong>e-commerce-eureka-server-9001</strong> 成为服务提供者</h3><h4 id="4-2-3-1-架构示意图"><a href="#4-2-3-1-架构示意图" class="headerlink" title="4.2.3.1 架构示意图"></a>4.2.3.1 架构示意图</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230522124755649.png" alt="image-20230522124755649" style="zoom:50%;" /><h4 id="4-2-3-2-修改-member-service-provider-10000-的-pom-xml"><a href="#4-2-3-2-修改-member-service-provider-10000-的-pom-xml" class="headerlink" title="4.2.3.2 修改 member-service-provider-10000 的 pom.xml"></a>4.2.3.2 修改 member-service-provider-10000 的 pom.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--       引入eureka-client场景启动器starter--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-2-3-3-修改-member-service-provider-10000-的-resources-x2F-application-yml"><a href="#4-2-3-3-修改-member-service-provider-10000-的-resources-x2F-application-yml" class="headerlink" title="4.2.3.3 修改 member-service-provider-10000 的 resources&#x2F;application.yml"></a>4.2.3.3 修改 member-service-provider-10000 的 resources&#x2F;application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">member-service-provider-10000</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/e_commerce_center_db?serverTimezone=GMT%2B8&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">QWEASDzxc123</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.study.springcloud.entity</span></span><br><span class="line"><span class="comment">#配置eureka-client</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span> <span class="comment">#将自己注册到Eureka-server</span></span><br><span class="line">    <span class="comment">#表示从Eureka-server抓取注册信息</span></span><br><span class="line">    <span class="comment">#如果是单节点，可以不配置；</span></span><br><span class="line">    <span class="comment">#但是provider是一个集群，则必须将此项配置为true，这样才能配合Ribbon使用负载均衡功能</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 表示将自己注册到哪个eureka-server</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:9001/eureka</span></span><br></pre></td></tr></table></figure><h4 id="4-2-3-4-修改-member-service-provider-10000-的-com-x2F-hspedu-x2F-springcloud-x2F-MemberApplication-java"><a href="#4-2-3-4-修改-member-service-provider-10000-的-com-x2F-hspedu-x2F-springcloud-x2F-MemberApplication-java" class="headerlink" title="4.2.3.4 修改 member-service-provider-10000 的 com&#x2F;hspedu&#x2F;springcloud&#x2F;MemberApplication.java"></a>4.2.3.4 修改 member-service-provider-10000 的 com&#x2F;hspedu&#x2F;springcloud&#x2F;MemberApplication.java</h4><p>添加注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@EnableEurekaClient,将该程序标识为Eureka-client</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br></pre></td></tr></table></figure><h4 id="4-2-3-5-完成测试"><a href="#4-2-3-5-完成测试" class="headerlink" title="4.2.3.5 完成测试"></a>4.2.3.5 完成测试</h4><h5 id="4-2-3-5-1-启动-e-commerce-eureka-server-9001"><a href="#4-2-3-5-1-启动-e-commerce-eureka-server-9001" class="headerlink" title="4.2.3.5.1 启动 **e-commerce-eureka-server-9001 **"></a><strong>4.2.3.5.1</strong> 启动 **e-commerce-eureka-server-9001 **</h5><h5 id="4-2-3-5-2-启动-member-service-provider-10000"><a href="#4-2-3-5-2-启动-member-service-provider-10000" class="headerlink" title="4.2.3.5.2 启动 **member-service-provider-10000 **"></a><strong>4.2.3.5.2</strong> 启动 **member-service-provider-10000 **</h5><h5 id="4-2-3-5-3-浏览器-http-localhost-9001"><a href="#4-2-3-5-3-浏览器-http-localhost-9001" class="headerlink" title="4.2.3.5.3 浏览器**: http://localhost:9001**"></a><strong>4.2.3.5.3</strong> 浏览器**: <a href="http://localhost:9001/">http://localhost:9001</a>**</h5><h5 id="4-2-3-5-4-微服务注册名配置说明"><a href="#4-2-3-5-4-微服务注册名配置说明" class="headerlink" title="4.2.3.5.4 微服务注册名配置说明"></a><strong>4.2.3.5.4</strong> 微服务注册名配置说明</h5><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230522130616526.png" alt="image-20230522130616526"></p><h3 id="4-2-4-配-置-member-service-consumer-80-作-为-EurekaClient，-可-以-拉取-x2F-获-取e-commerce-eureka-server-9001-提供的服务信息"><a href="#4-2-4-配-置-member-service-consumer-80-作-为-EurekaClient，-可-以-拉取-x2F-获-取e-commerce-eureka-server-9001-提供的服务信息" class="headerlink" title="4.2.4 配 置 member-service-consumer-80 作 为 EurekaClient， 可 以 拉取 &#x2F; 获 取e-commerce-eureka-server-9001 提供的服务信息"></a><strong>4.2.4</strong> 配 置 <strong>member-service-consumer-80</strong> 作 为 <strong>EurekaClient</strong>， 可 以 拉取 <strong>&#x2F;</strong> 获 取e-commerce-eureka-server-9001 提供的服务信息</h3><h4 id="4-2-4-1-架构示意图"><a href="#4-2-4-1-架构示意图" class="headerlink" title="4.2.4.1 架构示意图"></a>4.2.4.1 架构示意图</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230522202407897.png" alt="image-20230522202407897"></p><h4 id="4-2-4-2-修改-pom-xml"><a href="#4-2-4-2-修改-pom-xml" class="headerlink" title="4.2.4.2 修改 pom.xml"></a>4.2.4.2 修改 pom.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--       引入eureka-client场景启动器starter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-2-4-3-修改-application-yml"><a href="#4-2-4-3-修改-application-yml" class="headerlink" title="4.2.4.3 修改 application.yml"></a>4.2.4.3 修改 application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">在原本的配置在增加：</span></span><br><span class="line"><span class="comment">#配置eureka-client</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span> <span class="comment">#将自己注册到Eureka-server</span></span><br><span class="line">    <span class="comment">#表示从Eureka-server抓取注册信息</span></span><br><span class="line">    <span class="comment">#如果是单节点，可以不配置；</span></span><br><span class="line">    <span class="comment">#但是provider是一个集群，则必须将此项配置为true，这样才能配合Ribbon使用负载均衡功能</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 表示将自己注册到哪个eureka-server</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:9001/eureka</span></span><br></pre></td></tr></table></figure><h4 id="4-2-4-4-修改-MemberConsumerApplication-java"><a href="#4-2-4-4-修改-MemberConsumerApplication-java" class="headerlink" title="4.2.4.4 修改 MemberConsumerApplication.java"></a>4.2.4.4 修改 MemberConsumerApplication.java</h4><p>添加注解：@EnableEurekaClient             将该程序标识为Eureka-client</p><h4 id="4-2-4-5-完成测试"><a href="#4-2-4-5-完成测试" class="headerlink" title="4.2.4.5 完成测试"></a>4.2.4.5 完成测试</h4><h5 id="4-2-4-5-1-启动-e-commerce-eureka-server-9001"><a href="#4-2-4-5-1-启动-e-commerce-eureka-server-9001" class="headerlink" title="4.2.4.5.1 启动 **e-commerce-eureka-server-9001 **"></a><strong>4.2.4.5.1</strong> 启动 **e-commerce-eureka-server-9001 **</h5><h5 id="4-2-4-5-2-启动-member-service-consumer-80"><a href="#4-2-4-5-2-启动-member-service-consumer-80" class="headerlink" title="4.2.4.5.2 启动 **member-service-consumer-80 **"></a><strong>4.2.4.5.2</strong> 启动 **member-service-consumer-80 **</h5><h5 id="4-2-4-5-3-浏览器-http-localhost-9001"><a href="#4-2-4-5-3-浏览器-http-localhost-9001" class="headerlink" title="4.2.4.5.3 浏览器**: http://localhost:9001**"></a><strong>4.2.4.5.3</strong> 浏览器**: <a href="http://localhost:9001/">http://localhost:9001</a>**</h5><h3 id="4-2-5-Service-Consumer-、Service-Provider-、EurekaServer-的维护机制"><a href="#4-2-5-Service-Consumer-、Service-Provider-、EurekaServer-的维护机制" class="headerlink" title="4.2.5 Service Consumer 、Service Provider 、EurekaServer 的维护机制"></a><strong>4.2.5 Service Consumer</strong> 、<strong>Service Provider</strong> 、<strong>EurekaServer</strong> 的维护机制</h3><p>EurekaServer中维护了服务信息——一个键值对：key是<strong>服务名</strong>，value是 <strong>调用服务的地址</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230526170804321.png" alt="image-20230526170804321"></p><h3 id="4-2-6-Eureka自我保护模式"><a href="#4-2-6-Eureka自我保护模式" class="headerlink" title="4.2.6 Eureka自我保护模式"></a><strong>4.2.6 Eureka</strong>自我保护模式</h3><h4 id="4-2-6-1-自我保护模式理论"><a href="#4-2-6-1-自我保护模式理论" class="headerlink" title="4.2.6.1 自我保护模式理论"></a>4.2.6.1 自我保护模式理论</h4><ol><li><p>在默认情况下， <strong>Eureka 启动了自我保护模式</strong></p></li><li><p>自我保证机制&#x2F;模式说明</p><ul><li><p>默认情況下Eurekaclient定时向EurekaServer端发送心跳包。</p></li><li><p>如果Eureka在server端在一定时间内（默认90秒）没有收到Eurekaclient发送心跳包，便会直接从服务注册列表中剔除该服务。</p></li><li><p>如果Eureka 开启了自我保护模式&#x2F;机制，那么在短时间 (90秒中）内丢失了大量的服务实例心跳，这时候EurekaServer会开启自我保护机制，不会剔除该服务（该现象可能出现在如果网络不通或者阻鑫) 因为客户端还能正常发送心跳，只是网络延迟问题，而保护机制是为了解决此问题而产生的。</p></li></ul></li><li><p>自我保护是属于 <strong>CAP</strong> 里面的 AP 分支， 保证高可用和分区容错性。(cap解读：<a href="https://blog.csdn.net/wangliangluang/article/details/120626014">https://blog.csdn.net/wangliangluang/article/details/120626014</a>)</p></li><li><p>自我保护模式是—种<strong>应对网络异常的安全保护措施</strong>。它的架构哲学是宁可同时保留所有微服务(健康的微服务和不健康的微服务都会保留)也不盲目注销任何健康的微服 务。使用自我保护模式，可以让 Eureka 集群更加的健壮、稳定。</p></li><li><p>测试：</p><p>……</p></li></ol><h2 id="4-3-搭建-EurekaServer-集群-实现负载均衡-amp-故障容错"><a href="#4-3-搭建-EurekaServer-集群-实现负载均衡-amp-故障容错" class="headerlink" title="4.3 搭建 EurekaServer 集群- 实现负载均衡&amp;故障容错"></a>4.3 搭建 EurekaServer 集群- 实现负载均衡&amp;故障容错</h2><h3 id="4-3-1-为什么需要集群-Eureka-Server"><a href="#4-3-1-为什么需要集群-Eureka-Server" class="headerlink" title="4.3.1 为什么需要集群 Eureka Server"></a><strong>4.3.1</strong> 为什么需要集群 Eureka Server</h3><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230528115636389.png" alt="image-20230528115636389" style="zoom:50%;" /><ol><li><p>微服务 RPC 远程服务调用最核心的是实现高可用</p></li><li><p>如果注册中心只有1个，它出故障，会导致整个服务环境不可用</p></li><li><p>解决办法：搭建 <strong>Eureka 注册中心集群</strong>，<strong>实现负载均衡+故障容错</strong></p></li></ol><h3 id="4-3-2需求分析-x2F-图解"><a href="#4-3-2需求分析-x2F-图解" class="headerlink" title="4.3.2需求分析**&#x2F;**图解"></a>4.3.2需求分析**&#x2F;**图解</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230528120007909.png" alt="image-20230528120007909"></p><h3 id="4-3-3-搭建-Eureka-Server-集群"><a href="#4-3-3-搭建-Eureka-Server-集群" class="headerlink" title="4.3.3 搭建 Eureka Server 集群"></a><strong>4.3.3</strong> 搭建 <strong>Eureka Server</strong> 集群</h3><h4 id="4-3-3-1-创建-e-commerce-eureka-server-9002-微服务模块-作为注册中心"><a href="#4-3-3-1-创建-e-commerce-eureka-server-9002-微服务模块-作为注册中心" class="headerlink" title="4.3.3.1 创建 e-commerce-eureka-server-9002 微服务模块[作为注册中心]"></a>4.3.3.1 创建 e-commerce-eureka-server-9002 微服务模块[作为注册中心]</h4><h5 id="4-3-3-1-1-创建步骤参考-e-commerce-eureka-server-9001"><a href="#4-3-3-1-1-创建步骤参考-e-commerce-eureka-server-9001" class="headerlink" title="4.3.3.1.1 创建步骤参考 e-commerce-eureka-server-9001"></a><strong>4.3.3.1.1</strong> 创建步骤参考 <strong>e-commerce-eureka-server-9001</strong></h5><h5 id="4-3-3-1-2-修改-pom-xml-加入依赖"><a href="#4-3-3-1-2-修改-pom-xml-加入依赖" class="headerlink" title="4.3.3.1.2 修改 pom.xml , 加入依赖"></a><strong>4.3.3.1.2</strong> 修改 <strong>pom.xml ,</strong> 加入依赖</h5><h5 id="4-3-3-1-3-创建-resources-x2F-application-yml"><a href="#4-3-3-1-3-创建-resources-x2F-application-yml" class="headerlink" title="4.3.3.1.3 创建 resources&#x2F;application.yml"></a><strong>4.3.3.1.3</strong> 创建 <strong>resources&#x2F;application.yml</strong></h5><h5 id="4-3-3-1-4-创建主启动类-EurekaApplication9002-java"><a href="#4-3-3-1-4-创建主启动类-EurekaApplication9002-java" class="headerlink" title="4.3.3.1.4 创建主启动类 EurekaApplication9002.java"></a><strong>4.3.3.1.4</strong> 创建主启动类 <strong>EurekaApplication9002.java</strong></h5><h4 id="4-3-3-2-修改-e-commerce-eureka-server-9001-微服务模块"><a href="#4-3-3-2-修改-e-commerce-eureka-server-9001-微服务模块" class="headerlink" title="4.3.3.2 修改 e-commerce-eureka-server-9001 微服务模块"></a>4.3.3.2 修改 e-commerce-eureka-server-9001 微服务模块</h4><h5 id="4-3-3-2-1-修改-resources-x2F-application-yml"><a href="#4-3-3-2-1-修改-resources-x2F-application-yml" class="headerlink" title="4.3.3.2.1 修改 resources&#x2F;application.yml"></a><strong>4.3.3.2.1</strong> 修改 <strong>resources&#x2F;application.yml</strong></h5><h5 id="4-3-3-2-2-修改主启动类名为-EurekaApplication9001-java"><a href="#4-3-3-2-2-修改主启动类名为-EurekaApplication9001-java" class="headerlink" title="4.3.3.2.2 修改主启动类名为 EurekaApplication9001.java"></a><strong>4.3.3.2.2</strong> 修改主启动类名为 <strong>EurekaApplication9001.java</strong></h5><h4 id="4-3-3-3-修改-hosts-文件"><a href="#4-3-3-3-修改-hosts-文件" class="headerlink" title="4.3.3.3 修改 hosts 文件"></a>4.3.3.3 修改 hosts 文件</h4><p>​域名转ip地址：先找本机的host文件，hosts文件中没有才去DNS服务器寻找，</p><p>​现在我们需要访问eureka9001.com这样的形式，就需要自行在本机的hosts文件添加键值对实现域名-&gt;ip</p><p>&#x2F;private&#x2F;etc&#x2F;hosts复制出来，修改，覆盖原来的文件即可完成修改</p><p>​在hosts文件中添加内容：</p><p>​<strong>#eureka</strong> 主机名和 <strong>ip</strong> 映射 </p><p>​**127.0.0.1 eureka9001.com **</p><p>​<strong>127.0.0.1 eureka9002.com</strong></p><h4 id="4-3-3-4-完成测试"><a href="#4-3-3-4-完成测试" class="headerlink" title="4.3.3.4 完成测试"></a>4.3.3.4 完成测试</h4><h5 id="4-3-3-4-1-启动-e-commerce-eureka-server-9001"><a href="#4-3-3-4-1-启动-e-commerce-eureka-server-9001" class="headerlink" title="4.3.3.4.1 启动 **e-commerce-eureka-server-9001"></a><strong>4.3.3.4.1</strong> 启动 **e-commerce-eureka-server-9001</h5><h5 id="4-3-3-4-2-启动-e-commerce-eureka-server-9002"><a href="#4-3-3-4-2-启动-e-commerce-eureka-server-9002" class="headerlink" title="4.3.3.4.2** 启动 **e-commerce-eureka-server-9002"></a>4.3.3.4.2** 启动 **e-commerce-eureka-server-9002</h5><h5 id="4-3-3-4-3-浏览器-http-eureka9001-com-9001-浏览器-http-eureka9002-com-9002"><a href="#4-3-3-4-3-浏览器-http-eureka9001-com-9001-浏览器-http-eureka9002-com-9002" class="headerlink" title="4.3.3.4.3** 浏览器**: http://eureka9001.com:9001** 浏览器**: http://eureka9002.com:9002**"></a>4.3.3.4.3** 浏览器**: <a href="http://eureka9001.com:9001/">http://eureka9001.com:9001</a>** 浏览器**: <a href="http://eureka9002.com:9002/">http://eureka9002.com:9002</a>**</h5><h4 id="4-3-3-5-将-member-service-provider-10000-注册到-EurekaServer-集群-目前-2-台"><a href="#4-3-3-5-将-member-service-provider-10000-注册到-EurekaServer-集群-目前-2-台" class="headerlink" title="4.3.3.5 将 member-service-provider-10000 注册到 EurekaServer 集群(目前 2 台)"></a>4.3.3.5 将 member-service-provider-10000 注册到 EurekaServer 集群(目前 2 台)</h4><h5 id="4-3-3-5-1-修改-resources-x2F-application-yml"><a href="#4-3-3-5-1-修改-resources-x2F-application-yml" class="headerlink" title="4.3.3.5.1 修改 resources&#x2F;application.yml"></a><strong>4.3.3.5.1</strong> 修改 <strong>resources&#x2F;application.yml</strong></h5><p>‘’’</p><p>defaultZone: <a href="http://eureka9001.com:9001/eureka">http://eureka9001.com:9001/eureka</a>, <a href="http://eureka9002.com:9002/eureka">http://eureka9002.com:9002/eureka</a></p><p>*#*表示将自己注册到哪个 <em>eurekaServer</em></p><p>将本微服务注册到多个 <em>eurekaServer,</em> 使用逗号隔开</p><p>‘’’</p><h5 id="4-3-3-5-2-完成测试"><a href="#4-3-3-5-2-完成测试" class="headerlink" title="4.3.3.5.2 完成测试"></a><strong>4.3.3.5.2</strong> 完成测试</h5><p><strong>1.</strong> <strong>启动</strong> <strong>e-commerce-eureka-server-9001</strong> <strong>和</strong> <strong>e-commerce-eureka-server-9002</strong></p><p><strong>2. 启动</strong> <strong>member-service-provider-10000<br>3.</strong> <strong>观察</strong> <strong>member-service-provider-10000</strong> <strong>是否注册到</strong> <strong>Eureka</strong> <strong>集群</strong>前 <strong>2</strong> <strong>台</strong>)</p><h4 id="4-3-3-6-将-member-service-consumer-80-注册到-EurekaServer-集群-目前-2-台"><a href="#4-3-3-6-将-member-service-consumer-80-注册到-EurekaServer-集群-目前-2-台" class="headerlink" title="4.3.3.6 将 member-service-consumer-80 注册到 EurekaServer 集群(目前 2 台)"></a>4.3.3.6 将 member-service-consumer-80 注册到 EurekaServer 集群(目前 2 台)</h4><h5 id="4-3-3-6-1-修改-resources-x2F-application-yml"><a href="#4-3-3-6-1-修改-resources-x2F-application-yml" class="headerlink" title="4.3.3.6.1 修改 resources&#x2F;application.yml"></a><strong>4.3.3.6.1</strong> 修改 <strong>resources&#x2F;application.yml</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaultZone: http://eureka9001.com:9001/eureka,http://eureka9002.com:9002/eureka</span><br></pre></td></tr></table></figure><h5 id="4-3-3-6-2-完成测试"><a href="#4-3-3-6-2-完成测试" class="headerlink" title="4.3.3.6.2 完成测试"></a><strong>4.3.3.6.2</strong> 完成测试</h5><p><strong>1.</strong> <strong>启动</strong> <strong>e-commerce-eureka-server-9001</strong> <strong>和</strong> <strong>e-commerce-eureka-server-9002</strong><br><strong>2.</strong> <strong>启动</strong> <strong>member-service-consumer-80<br>3.</strong> <strong>观察</strong> <strong>member-service-consumer-80</strong> <strong>是否注册到</strong> <strong>Eureka</strong> <strong>集群</strong>(<strong>目前</strong> <strong>2</strong> <strong>台</strong>)</p><h3 id="4-3-4-搭建会员中心服务提供方-集群"><a href="#4-3-4-搭建会员中心服务提供方-集群" class="headerlink" title="4.3.4 搭建会员中心服务提供方**-**集群"></a><strong>4.3.4</strong> 搭建会员中心服务提供方**-**集群</h3><h4 id="4-3-4-1-架构示意图"><a href="#4-3-4-1-架构示意图" class="headerlink" title="4.3.4.1 架构示意图"></a>4.3.4.1 架构示意图</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230528140357541.png" alt="image-20230528140357541"></p><h4 id="4-3-4-2-创建member-service-provider-10002"><a href="#4-3-4-2-创建member-service-provider-10002" class="headerlink" title="4.3.4.2 创建member-service-provider-10002"></a>4.3.4.2 创建member-service-provider-10002</h4><p>1.参考member-service-provider-10000 来创建 member-service-provider-10002 即可</p><p>2.创建好后，使用memberservice-provider-10000 的源 码和配置替換member-service-provider-10002 生成的代码（不要到磁盘整体拷贝，会出现关联到 member-service-provider-10000 的问题，很麻烦，可以创建好新项目的包，然后再拷贝对应包下的文件，就不会出向题）</p><p>3.提醒，拷贝时不要忘记拷贝 resources&#x2F;mapper&#x2F;Mem berMapper:xml 这些xaos.xml 文件</p><h4 id="4-3-4-3-创建-resources-x2F-application-yml"><a href="#4-3-4-3-创建-resources-x2F-application-yml" class="headerlink" title="4.3.4.3 创建 resources&#x2F;application.yml"></a>4.3.4.3 创建 resources&#x2F;application.yml</h4><p><strong>1.</strong> 创建好 <strong>application.yml</strong></p><p><strong>2.</strong> 从 <strong>member-service-provider-10000</strong> 拷贝 <strong>application.yml</strong> 的内容</p><p><strong>3.</strong> 修改端口号即可</p><h4 id="4-3-4-4-修改主启动类名"><a href="#4-3-4-4-修改主启动类名" class="headerlink" title="4.3.4.4 修改主启动类名"></a>4.3.4.4 修改主启动类名</h4><p><strong>1.</strong> 修改 <strong>member-service-provider-10000</strong> 的主启动类为 <strong>MemberProviderApplication10000</strong></p><p><strong>2.</strong> <strong>修改</strong> <strong>member-service-provider-10002</strong> <strong>的主启动类为</strong> <strong>MemberProviderApplication10002</strong></p><h4 id="4-3-4-5-完成测试"><a href="#4-3-4-5-完成测试" class="headerlink" title="4.3.4.5 完成测试"></a>4.3.4.5 完成测试</h4><p>……</p><h4 id="4-3-4-6-注意事项和细节"><a href="#4-3-4-6-注意事项和细节" class="headerlink" title="4.3.4.6 注意事项和细节"></a>4.3.4.6 注意事项和细节</h4><ol><li>因为 member-service-provider-10000 和 mem ber-service-provider-10002 作为一个集群提供服务，因此需要將 spring.application.name 进行统一。</li><li>这样消费方通过统一的别名进行负载均衡调用。</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230528142117680.png" alt="image-20230528142117680" style="zoom:33%;" /><p>将相同服务的提供方对外暴露的名称设置为相同的，这样就方便管理了。</p><h3 id="4-3-5-配置服务消费端-member-service-consumer-80-使用会员中心服务集群"><a href="#4-3-5-配置服务消费端-member-service-consumer-80-使用会员中心服务集群" class="headerlink" title="4.3.5 配置服务消费端 member-service-consumer-80 使用会员中心服务集群"></a><strong>4.3.5</strong> 配置服务消费端 <strong>member-service-consumer-80</strong> 使用会员中心服务集群</h3><h4 id="4-3-5-1-架构图"><a href="#4-3-5-1-架构图" class="headerlink" title="4.3.5.1 架构图"></a>4.3.5.1 架构图</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230528143413873.png" alt="image-20230528143413873"></p><h4 id="4-3-5-2-修改-MemberConsumerController-java"><a href="#4-3-5-2-修改-MemberConsumerController-java" class="headerlink" title="4.3.5.2 修改 MemberConsumerController.java"></a>4.3.5.2 修改 MemberConsumerController.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MEMBER_SERVICE_PROVIDER_URL</span> <span class="operator">=</span> <span class="string">&quot;http://member-service-provider&quot;</span>;</span><br><span class="line"><span class="comment">//member-service-provider为服务提供集群对外暴露的统一名称</span></span><br></pre></td></tr></table></figure><h4 id="4-3-5-3-修改-CustomizationBean-java"><a href="#4-3-5-3-修改-CustomizationBean-java" class="headerlink" title="4.3.5.3 修改 CustomizationBean.java"></a>4.3.5.3 修改 CustomizationBean.java</h4><p>​给 RestTemplate添加注解：**@LoadBalanced**</p><p>​目的是：赋予 <em>RestTemplate</em> 负载均衡的能力</p><h4 id="4-3-5-5-完成测试"><a href="#4-3-5-5-完成测试" class="headerlink" title="4.3.5.5 完成测试"></a>4.3.5.5 完成测试</h4><h5 id="4-3-5-5-1-启动-eureka-server-集群-目前-2-台"><a href="#4-3-5-5-1-启动-eureka-server-集群-目前-2-台" class="headerlink" title="4.3.5.5.1 启动 eureka server 集群**(目前 2 台)**"></a>4.3.5.5.1 启动 <strong>eureka server</strong> 集群**(<strong>目前 <strong>2</strong> 台</strong>)**</h5><h5 id="4-3-5-5-2-启动-member-service-provider-10000"><a href="#4-3-5-5-2-启动-member-service-provider-10000" class="headerlink" title="4.3.5.5.2 启动 member-service-provider-10000"></a>4.3.5.5.2 启动 <strong>member-service-provider-10000</strong></h5><h5 id="4-3-5-5-3-启动-member-service-provider-10002"><a href="#4-3-5-5-3-启动-member-service-provider-10002" class="headerlink" title="4.3.5.5.3 启动 member-service-provider-10002"></a>4.3.5.5.3 启动 <strong>member-service-provider-10002</strong></h5><h5 id="4-3-5-5-4不急，先测试-http-localhost-10000-member-get-1-和-http-localhost-10002-member-get-1"><a href="#4-3-5-5-4不急，先测试-http-localhost-10000-member-get-1-和-http-localhost-10002-member-get-1" class="headerlink" title="4.3.5.5.4不急，先测试 : http://localhost:10000/member/get/1 和 http://localhost:10002/member/get/1"></a><strong>4.3.5.5.4</strong>不急，先测试 <strong>: <a href="http://localhost:10000/member/get/1">http://localhost:10000/member/get/1</a></strong> 和 <strong><a href="http://localhost:10002/member/get/1">http://localhost:10002/member/get/1</a></strong></h5><p>先看看直接使用服务提供方时有没有问题，没问题再进行下一步测试(方便排错！)</p><h5 id="4-3-5-5-5-启动-member-service-consumer-80"><a href="#4-3-5-5-5-启动-member-service-consumer-80" class="headerlink" title="4.3.5.5.5 启动 member-service-consumer-80"></a><strong>4.3.5.5.5</strong> 启动 <strong>member-service-consumer-80</strong></h5><h5 id="4-3-5-5-6-浏览器访问-http-localhost-member-consumer-get-1"><a href="#4-3-5-5-6-浏览器访问-http-localhost-member-consumer-get-1" class="headerlink" title="4.3.5.5.6 浏览器访问**: http://localhost/member/consumer/get/1**"></a><strong>4.3.5.5.6</strong> 浏览器访问**: <a href="http://localhost/member/consumer/get/1">http://localhost/member/consumer/get/1</a>**</h5><h4 id="4-3-5-6-交替访问member服务说明"><a href="#4-3-5-6-交替访问member服务说明" class="headerlink" title="4.3.5.6 交替访问member服务说明:"></a>4.3.5.6 交替访问member服务说明:</h4><ol><li>注解@LoadBalanced 底层是Ribbon支持算法</li><li>2.Ribbon和Eureka 整合后consumer 直接调用服务而不用再关心地址和端口号，且该服务还有负载功能</li></ol><h3 id="4-3-6-获取-Eureka-Server-服务注册信息-DiscoveryClient"><a href="#4-3-6-获取-Eureka-Server-服务注册信息-DiscoveryClient" class="headerlink" title="4.3.6 获取 Eureka Server 服务注册信息 -DiscoveryClient"></a><strong>4.3.6</strong> 获取 <strong>Eureka Server</strong> 服务注册信息 <strong>-DiscoveryClient</strong></h3><h4 id="4-3-6-1-需求分析-x2F-图解"><a href="#4-3-6-1-需求分析-x2F-图解" class="headerlink" title="4.3.6.1 需求分析&#x2F;图解"></a>4.3.6.1 需求分析&#x2F;图解</h4><p><strong>1.</strong> 需求分析示意图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230528150507261.png" alt="image-20230528150507261"></p><p><strong>2.</strong> <strong>这里我们以服务消费方</strong>， <strong>去获取</strong> <strong>Eureka Server</strong> <strong>的服务注册信息为例讲解</strong></p><p><strong>3.</strong> <strong>当然也可以在服务提供方获取</strong> <strong>Eureka Server</strong> <strong>的服务注册信息</strong></p><h4 id="4-3-6-2-代码实现"><a href="#4-3-6-2-代码实现" class="headerlink" title="4.3.6.2 代码实现"></a>4.3.6.2 代码实现</h4><ol><li><strong>所在模块  member-service-consumer-80</strong></li><li><strong>修改</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;MemberConsumerController.java</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//装配DiscoveryClient</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/member/consumer/discovery&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">discovery</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;String&gt; services = discoveryClient.getServices();</span><br><span class="line">    <span class="keyword">for</span> (String service : services)&#123;</span><br><span class="line">        log.info(<span class="string">&quot;服务名=&#123;&#125;&quot;</span>,service);</span><br><span class="line">        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(service);</span><br><span class="line">        <span class="keyword">for</span> (ServiceInstance instance : instances)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;id=&#123;&#125;,host=&#123;&#125;,port=&#123;&#125;,uri=&#123;&#125;&quot;</span>,instance.getServiceId(),instance.getHost(),instance.getPort(),instance.getUri());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> discoveryClient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.</strong> <strong>这里修改主启动类</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;MemberConsumerApplication.java</strong></p><p>添加注解：@EnableDiscoveryClient</p><h4 id="4-3-6-3-测试"><a href="#4-3-6-3-测试" class="headerlink" title="4.3.6.3 测试"></a>4.3.6.3 测试</h4><p><strong>1.</strong> <strong>重启</strong> <strong>member-service-consumer-80</strong></p><p><strong>2.</strong> <strong>浏览器输出</strong> <strong><a href="http://localhost/member/consumer/discovery">http://localhost/member/consumer/discovery</a></strong></p><h4 id="4-3-6-4-注意事项和细节说明"><a href="#4-3-6-4-注意事项和细节说明" class="headerlink" title="4.3.6.4 注意事项和细节说明"></a>4.3.6.4 注意事项和细节说明</h4><ol><li><p>在引入 <strong>DiscoveryClient</strong> 时，不要引入错误的包：</p><p>正确的包**:** <strong>import</strong> <strong>org.springframework.cloud.client.discovery.DiscoveryClient</strong>;</p><p>错误的包**:** <strong>import</strong> <strong>com.netflix.discovery.DiscoveryClient</strong>;</p></li></ol><h2 id="4-4-Eureka后续说明"><a href="#4-4-Eureka后续说明" class="headerlink" title="4.4 Eureka后续说明"></a>4.4 Eureka后续说明</h2><p><strong>1. Eureka</strong> 停更说明**: <a href="https://github.com/Netflix/eureka/wiki">https://github.com/Netflix/eureka/wiki</a>**</p><p><strong>2.</strong> <strong>对于一些早期使用</strong> <strong>Eureka</strong> <strong>项目，掌握老师讲解技术基本可以应付了</strong>(<strong>这也是老师为什么还 要讲</strong> <strong>Eureka</strong> <strong>的原因</strong>)</p><p><strong>3.目前替代 Eureka 做服务注册和发现，均衡负载的 最佳组件是 spring Cloud Alibaba Nacos，后面老师会重点讲解。</strong></p><p><strong>4.虽然Eureka 停更，目前用的不多，但是它的服务注册和发现，均衡负载的思想是优先的，有了Eureka 的基础，我们学习 Spring Cloud Alibaba Nacos 会轻松很多</strong></p><h1 id="5-SpringCloudRibbon服务负载均衡"><a href="#5-SpringCloudRibbon服务负载均衡" class="headerlink" title="5 SpringCloudRibbon服务负载均衡"></a><strong>5 SpringCloudRibbon</strong>服务负载均衡</h1><h2 id="5-1-Ribbon介绍"><a href="#5-1-Ribbon介绍" class="headerlink" title="5.1 Ribbon介绍"></a>5.1 Ribbon介绍</h2><h3 id="5-1-1-Ribbon是什么"><a href="#5-1-1-Ribbon是什么" class="headerlink" title="5.1.1 Ribbon是什么"></a><strong>5.1.1 Ribbon</strong>是什么</h3><ol><li><p>Spring Cloud Ribbon 是<strong>基于 Netflix Ribbon</strong> 实现的一套**<u>客户端负载均衡</u>**的工具。</p></li><li><p>Ribbon 主要功能是<strong>提供客户端负载均衡算法和服务调用</strong></p></li><li><p>Ribbon 客户端组件提供一系列完善的配置项如连接超时，重试等。</p></li><li><p>Ribbon 会基于某种规则（如简单轮询，随机连接等）去连接指定服务</p></li><li><p>程序员很容易使用 Ribbon 的负载均衡算法实现负载均衡</p></li><li><p>一句话：Ribbon： <strong>负载均衡+RestTemplate调用</strong></p></li></ol><h3 id="5-1-2-官网"><a href="#5-1-2-官网" class="headerlink" title="5.1.2 官网"></a><strong>5.1.2</strong> 官网</h3><h4 id="5-1-2-1-https-github-com-Netflix-ribbon"><a href="#5-1-2-1-https-github-com-Netflix-ribbon" class="headerlink" title="5.1.2.1 https://github.com/Netflix/ribbon"></a>5.1.2.1 <a href="https://github.com/Netflix/ribbon">https://github.com/Netflix/ribbon</a></h4><h3 id="5-1-3-Ribbon进入维护状态"><a href="#5-1-3-Ribbon进入维护状态" class="headerlink" title="5.1.3 Ribbon进入维护状态"></a><strong>5.1.3 Ribbon</strong>进入维护状态</h3><p><strong>Ribbon 目前进入维护模式, 未来替换方案 是 <u>Spring Cloud LoadBalancer</u></strong></p><h3 id="5-1-4-LB-Load-Balance"><a href="#5-1-4-LB-Load-Balance" class="headerlink" title="5.1.4 LB(Load Balance)"></a>5.1.4 LB(Load Balance)</h3><h4 id="5-1-4-1-LB分类"><a href="#5-1-4-1-LB分类" class="headerlink" title="5.1.4.1 LB分类"></a>5.1.4.1 LB分类</h4><h5 id="集中式-LB"><a href="#集中式-LB" class="headerlink" title="集中式 LB"></a>集中式 LB</h5><ul><li><p>即在服务的消费方和提供方之间使用独立的LB设施（可以是硬件，如F5，也可以是软件，如Nginx)，由该设施负责把访向请求通过某种策略转发至服务的提供方：</p></li><li><p>LB(Load Balance 负载均衡）</p></li></ul><h5 id="进程内-LB"><a href="#进程内-LB" class="headerlink" title="进程内 LB"></a>进程内 LB</h5><ul><li><p>将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些服务地址可用，然后再从这些地址中选择出一个合适的服务地址。</p></li><li><p>Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。</p></li></ul><h4 id="5-1-4-2-实例-前面-member-consumer-轮询负载访问-10000-x2F-10002-底层就是-Ribbon-默认的轮询负载算法"><a href="#5-1-4-2-实例-前面-member-consumer-轮询负载访问-10000-x2F-10002-底层就是-Ribbon-默认的轮询负载算法" class="headerlink" title="5.1.4.2 实例-前面 member-consumer 轮询负载访问 10000&#x2F;10002 底层就是 Ribbon 默认的轮询负载算法"></a>5.1.4.2 实例-前面 member-consumer 轮询负载访问 10000&#x2F;10002 底层就是 Ribbon 默认的轮询负载算法</h4><h2 id="5-2-Ribbon原理"><a href="#5-2-Ribbon原理" class="headerlink" title="5.2 Ribbon原理"></a>5.2 Ribbon原理</h2><h3 id="5-2-1-Ribbon架构图-amp-机制"><a href="#5-2-1-Ribbon架构图-amp-机制" class="headerlink" title="5.2.1 Ribbon架构图**&amp;**机制"></a><strong>5.2.1 Ribbon</strong>架构图**&amp;**机制</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230529203201726.png" alt="image-20230529203201726">Ribbon 机制</p><ol><li><strong>先选择 EurekaServer</strong>，它<u>优先选择在同一个区域内负载较少的 serve</u>r</li><li><strong>再根据用户指定的策略</strong>，在<u>从 server取到的服务注册列表中选择一个地址</u></li><li>Ribbon 提供了多种策略：比如轮询、随机和根据响应时间加权。</li></ol><h3 id="5-2-2-Ribbon常见负载算法"><a href="#5-2-2-Ribbon常见负载算法" class="headerlink" title="5.2.2 Ribbon常见负载算法"></a><strong>5.2.2 Ribbon</strong>常见负载算法</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230529203353777.png" alt="image-20230529203353777"></p><h2 id="5-3-替换负载均衡算法-应用实例"><a href="#5-3-替换负载均衡算法-应用实例" class="headerlink" title="5.3 替换负载均衡算法-应用实例"></a>5.3 替换负载均衡算法-应用实例</h2><h3 id="5-3-1-需求分析-x2F-图解"><a href="#5-3-1-需求分析-x2F-图解" class="headerlink" title="5.3.1 需求分析**&#x2F;**图解"></a><strong>5.3.1</strong> 需求分析**&#x2F;**图解</h3><ol><li>需求：将默认的轮询算法改成随机算法 RandomRule</li><li>浏览器输入：htp:&#x2F;&#x2F;ocalhost&#x2F;member&#x2F;consuimer&#x2F;get&#x2F;1</li><li>要求 彷问的 10000&#x2F;10002 端口的服务是随机的</li></ol><h3 id="5-3-2代码实现"><a href="#5-3-2代码实现" class="headerlink" title="5.3.2代码实现"></a>5.3.2代码实现</h3><ol><li>创建 member-service-consumer-80com&#x2F;hspedu&#x2F;springcloud&#x2F;config&#x2F;RibbonRule.java</li></ol><h3 id="5-3-3-测试"><a href="#5-3-3-测试" class="headerlink" title="5.3.3 测试"></a><strong>5.3.3</strong> 测试</h3><p><strong>1.</strong> 浏览器输入 **: <a href="http://localhost/member/consumer/get/1">http://localhost/member/consumer/get/1</a> **</p><p><strong>2.</strong> <strong>观察访问的</strong> <strong>10000&#x2F;10002</strong> <strong>端口的服务是随机的</strong></p><h1 id="6-SpringCloud-Open-Feign服务调用"><a href="#6-SpringCloud-Open-Feign服务调用" class="headerlink" title="6 SpringCloud Open Feign服务调用"></a>6 SpringCloud Open Feign服务调用</h1><h2 id="6-1-OpenFeign介绍"><a href="#6-1-OpenFeign介绍" class="headerlink" title="6.1 OpenFeign介绍"></a>6.1 OpenFeign介绍</h2><h3 id="6-1-1-OpenFeign是什么"><a href="#6-1-1-OpenFeign是什么" class="headerlink" title="6.1.1 OpenFeign是什么"></a><strong>6.1.1 OpenFeign</strong>是什么</h3><ol><li><p>0penFeign 是个声明式 Webservice 客户端，使用 OpenFeign 让编写 web Service 客户端更简单</p></li><li><p>它的使用方法是定义一个服务接口然后在上面添加注解</p></li><li><p>0penFeign 也支持可拔插式的编码器和解码器。</p></li><li><p>Spring cloud 对 OpenFeign 进行了封装使其支持了 Spring Mvc 标准注解和HttpMessageConverters</p></li><li><p>0penFeign 可以与Eureka 和 Ribbon 组合使用以支持负载均衡</p></li></ol><h3 id="6-1-2-官网"><a href="#6-1-2-官网" class="headerlink" title="6.1.2 官网"></a><strong>6.1.2</strong> 官网</h3><h4 id="6-1-2-1-https-github-com-spring-cloud-spring-cloud-openfeign"><a href="#6-1-2-1-https-github-com-spring-cloud-spring-cloud-openfeign" class="headerlink" title="6.1.2.1 https://github.com/spring-cloud/spring-cloud-openfeign"></a>6.1.2.1 <a href="https://github.com/spring-cloud/spring-cloud-openfeign">https://github.com/spring-cloud/spring-cloud-openfeign</a></h4><h3 id="6-1-3-Feign和OpenFeign区别"><a href="#6-1-3-Feign和OpenFeign区别" class="headerlink" title="6.1.3 Feign和OpenFeign区别"></a><strong>6.1.3 Feign</strong>和<strong>OpenFeign</strong>区别</h3><p>​Feign(不好用，没人用了)：</p><ul><li><p>Feign是Spring Cioud组件中的一个轻量级RESTful的HTTP服务客户端</p></li><li><p>Feign内置了Ribbon，用来做客户端免载均衡， 去调用服务注册中心的服务。</p></li><li><p>Feign的使用方式是：使用Feign的注解定义接口，调用服务注册中心的服务</p></li><li><p>Feign支持的注解和用法请参考官方文档：<a href="https://githulb.com/OpenFeign/feign">https://githulb.com/OpenFeign/feign</a></p></li><li><p>Feign本身不支持Spring MvC的注解，它有一套自己的注解</p></li></ul><p>​</p><p>​OpenFeign：</p><ul><li><p>openFeign是Spring Cloud **<u>在Feign的基础上支持了Spring MvC的注解</u>**，如@Requesapping等等。</p></li><li><p>OpenFeign的@FeignClient可以解析SpringvC的@RequestMapping注解下的接口</p></li><li><p>OpenFeign通过动态代理的方式产生实现类，实现<strong>类中做负载均衡并调用其他服务</strong></p></li></ul><p>精简一句话 : <strong>OpenFeign 就是在 Feign 基础上做了加强</strong> , 有些程序员为了方便，说 <u>Feign 就是指的 OpenFeign</u></p><h2 id="6-2-OpenFeign-应用实例"><a href="#6-2-OpenFeign-应用实例" class="headerlink" title="6.2 OpenFeign-应用实例"></a>6.2 OpenFeign-应用实例</h2><h3 id="6-2-1-需求分析-x2F-图解"><a href="#6-2-1-需求分析-x2F-图解" class="headerlink" title="6.2.1 需求分析**&#x2F;**图解"></a><strong>6.2.1</strong> 需求分析**&#x2F;**图解</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230529210545959.png" alt="image-20230529210545959"></p><p>(Eureka实现获取服务、Ribbon实现自定义负载均衡算法、RestTemplate实现远程调用)</p><p>(Eureka实现获取服务、OpenFeign实现负载均衡+远程调用)</p><h3 id="6-2-2-创建服务消费模块-通过-OpenFeigen-实现远程调用"><a href="#6-2-2-创建服务消费模块-通过-OpenFeigen-实现远程调用" class="headerlink" title="6.2.2 创建服务消费模块 **-**通过 OpenFeigen 实现远程调用"></a><strong>6.2.2</strong> 创建服务消费模块 **-**通过 <strong>OpenFeigen</strong> 实现远程调用</h3><p><strong>1.</strong> 参考 <strong>member-service-consumer-80</strong> 创建 **member-service-consumer-openfeign-80(**具体步骤参考以前)</p><p><strong>2.</strong> <strong>修改</strong> <strong>pom.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    引入openfeign-start，即场景启动器    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>**3.创建 application.yml 内容如下:**、</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">e-commerce-consumer-openfeign</span></span><br><span class="line"><span class="comment">#配置eureka-client</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span> <span class="comment">#将自己注册到Eureka-server</span></span><br><span class="line">    <span class="comment">#表示从Eureka-server抓取注册信息</span></span><br><span class="line">    <span class="comment">#如果是单节点，可以不配置；</span></span><br><span class="line">    <span class="comment">#但是provider是一个集群，则必须将此项配置为true，这样才能配合Ribbon使用负载均衡功能</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 表示将自己注册到哪个eureka-server</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka9001.com:9001/eureka,http://eureka9002.com:9002/eureka</span></span><br></pre></td></tr></table></figure><p>4.创建主启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span> <span class="comment">//启动openFeignClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberConsumerOpenfeignApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MemberConsumerOpenfeignApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>创建 com&#x2F;study&#x2F;springcloud&#x2F;service&#x2F;MemberFeignService.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;MEMBER-SERVICE-PROVIDER&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MemberFeignService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在这里定义方法——远程调用服务提供方给的接口</span></span><br><span class="line">    <span class="comment">//原来是使用RestController实现功能的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.远程调用的方式是get</span></span><br><span class="line">    <span class="comment">//2.远程调用的url http:MEMBER-SERVICE-PROVIDER/member/get/&#123;id&#125;</span></span><br><span class="line">    <span class="comment">//3.MEMBER-SERVICE-PROVIDER是服务提供方在Eureka Server注册的服务</span></span><br><span class="line">    <span class="comment">//4.openfeign会根据负载均衡来决定调用哪个服务-默认是轮询</span></span><br><span class="line">    <span class="comment">//5.优点：openfeign支持了springMVC注解 + 接口 --&gt;解耦</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/member/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getMemberById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Long id)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>创建 com&#x2F;study&#x2F;springcloud&#x2F;controller&#x2F;MemberConsumerFeignController.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span> <span class="comment">//结果以json格式返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberConsumerFeignController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//装配MemberFeignService</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MemberFeignService memberFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/member/consumer/openfeign/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getMemberById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memberFeignService.getMemberById(id);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-3-测试"><a href="#6-2-3-测试" class="headerlink" title="6.2.3 测试"></a><strong>6.2.3</strong> 测试</h3><p>​浏览器输入 <strong>: <a href="http://localhost/member/consumer/openfeign/get/1">http://localhost/member/consumer/openfeign/get/1</a></strong></p><h3 id="6-2-4-注意事项和细节"><a href="#6-2-4-注意事项和细节" class="headerlink" title="6.2.4 注意事项和细节"></a><strong>6.2.4</strong> 注意事项和细节</h3><ul><li><p>配Openfeign的使用特点是 微服务调用接口+@Feignclient，使用接口进行<strong>解耦</strong></p></li><li><p>@FeignClient(value &#x3D; “MEMBER-SERVICE-PROVIDER”)，这里MEMBER-SERVICE-PROVIDER就是Eureka Server服务提供方注册的名称，不要写错了</p></li><li><p>接口方法上： value是不能乱写，远程调用的url 为<a href="http://member-service-provider/member/get/%7Bid%7D">http://MEMBER-SERVICE-PROVIDER/member/get/{id}</a></p></li></ul><p>​@GetMapping(“&#x2F;member&#x2F;get&#x2F;{id}”)<br>​    public Result getMemberById(@PathVariable(“id”)Long id);</p><h2 id="6-3-日志配置"><a href="#6-3-日志配置" class="headerlink" title="6.3 日志配置"></a>6.3 日志配置</h2><h3 id="6-3-1-基本介绍"><a href="#6-3-1-基本介绍" class="headerlink" title="6.3.1 基本介绍"></a><strong>6.3.1</strong> 基本介绍</h3><p>1．说明：Feign 提供了日志打印功能，可以通过配罝来调整日志级别，从而对 Feign 接口的调用情况进行监控和输出</p><p>2.日志级别</p><ul><li><p><strong>NONE</strong> ：默认的，不显示任何日志</p></li><li><p><strong>BASIC</strong>：仅记录请求方法、URL、响应状态码及执行时间;</p></li><li><p><strong>HEADERS</strong> ： 除了 BASIC中定义的信息之外，还有请求和响应的头信息;</p></li><li><p><strong>FULL</strong>：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。</p></li></ul><h3 id="6-3-2-配置日志-应用实例"><a href="#6-3-2-配置日志-应用实例" class="headerlink" title="6.3.2 配置日志**-**应用实例"></a><strong>6.3.2</strong> 配置日志**-**应用实例</h3><p><strong>1.</strong> 在 <strong>member-service-consumer-openfeign-80</strong> 创 建</p><p><strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;config&#x2F;OpenFeignConfig.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenFeignConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">loggerLevel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 在 <strong>member-service-consumer-openfeign-80</strong> 修改 <strong>application.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对MemberFeignService接口调用过程打印信息-debug</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.study.springcloud.service.MemberFeignService:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230530125632781.png" alt="image-20230530125632781" style="zoom:50%;" /><h3 id="6-3-3-测试"><a href="#6-3-3-测试" class="headerlink" title="6.3.3 测试"></a><strong>6.3.3</strong> 测试</h3><p>……</p><h2 id="6-4-OpenFeign超时"><a href="#6-4-OpenFeign超时" class="headerlink" title="6.4 OpenFeign超时"></a>6.4 OpenFeign超时</h2><p>若服务提供方(可能由于各种原因，比如操作数据库时间过长)响应超过OpenFeign的等待时间(默认1秒)，会返回超时错误(time out)</p><p>……</p><h3 id="6-4-3-设置OpenFeign超时时间"><a href="#6-4-3-设置OpenFeign超时时间" class="headerlink" title="6.4.3 设置OpenFeign超时时间"></a><strong>6.4.3</strong> 设置OpenFeign超时时间</h3><p>在服务消费方的配置文件中进行响应配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置feign客户端超时时间</span></span><br><span class="line"><span class="comment"># read-timeout 建立连接：从服务提供方获取可用资源的全部时间</span></span><br><span class="line"><span class="comment"># connect-timeout 两端连接所用时间</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">connect-timeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">read-timeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><h3 id="6-4-4-测试"><a href="#6-4-4-测试" class="headerlink" title="6.4.4 测试"></a><strong>6.4.4</strong> 测试</h3><p>……</p><h1 id="7-🌟SpringCloudGateway-服务网关"><a href="#7-🌟SpringCloudGateway-服务网关" class="headerlink" title="7 🌟SpringCloudGateway 服务网关"></a>7 🌟SpringCloudGateway 服务网关</h1><h2 id="7-1-Gateway介绍"><a href="#7-1-Gateway介绍" class="headerlink" title="7.1 Gateway介绍"></a>7.1 Gateway介绍</h2><h3 id="7-1-1-看一个需求，引出网关服务"><a href="#7-1-1-看一个需求，引出网关服务" class="headerlink" title="7.1.1 看一个需求，引出网关服务"></a><strong>7.1.1</strong> 看一个需求，引出网关服务</h3><p><strong>1</strong>、有一个前后端分离项目**,** 分析如图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230530144204835.png" alt="image-20230530144204835"></p><p>2、使用网关服务, 重构项目架构</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230530144645171.png" alt="image-20230530144645171"></p><h3 id="7-1-2-🌟Gateway-网络拓扑图"><a href="#7-1-2-🌟Gateway-网络拓扑图" class="headerlink" title="7.1.2 🌟Gateway 网络拓扑图"></a><strong>7.1.2 🌟Gateway</strong> 网络拓扑图</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230530151559362.png" alt="image-20230530151559362"></p><h3 id="7-1-3-Gateway是什么"><a href="#7-1-3-Gateway是什么" class="headerlink" title="7.1.3 Gateway是什么"></a><strong>7.1.3 Gateway</strong>是什么</h3><ol><li><p>Gateway 是在 Spring 生态系统之上构建的 API 网关服务，基于 spring , Spring Boot 和 Project Reactor 等技术。</p></li><li><p>Gateway 旨在提供一种简单而有效的方式来对 API 进行路由，以及提供一些强大的过滤器功能，例如 ：熔断、限流、重试等。</p></li></ol><h3 id="7-1-4-官网"><a href="#7-1-4-官网" class="headerlink" title="7.1.4 官网"></a>7.1.4 官网</h3><h4 id="7-1-4-1-https-cloud-spring-io-spring-cloud-static-spring-cloud-gateway-2-2-1-RELEASE-reference-html"><a href="#7-1-4-1-https-cloud-spring-io-spring-cloud-static-spring-cloud-gateway-2-2-1-RELEASE-reference-html" class="headerlink" title="7.1.4.1 https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/"></a>7.1.4.1 <a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/</a></h4><h3 id="7-1-5-Gateway-核心功能"><a href="#7-1-5-Gateway-核心功能" class="headerlink" title="7.1.5 Gateway 核心功能"></a><strong>7.1.5 Gateway</strong> 核心功能</h3><h4 id="7-1-5-1-鉴权"><a href="#7-1-5-1-鉴权" class="headerlink" title="7.1.5.1 鉴权"></a>7.1.5.1 鉴权</h4><h4 id="7-1-5-2-流量控制"><a href="#7-1-5-2-流量控制" class="headerlink" title="7.1.5.2 流量控制"></a>7.1.5.2 流量控制</h4><h4 id="7-1-5-3-熔断"><a href="#7-1-5-3-熔断" class="headerlink" title="7.1.5.3 熔断"></a>7.1.5.3 熔断</h4><h4 id="7-1-5-4-日志监控"><a href="#7-1-5-4-日志监控" class="headerlink" title="7.1.5.4 日志监控"></a>7.1.5.4 日志监控</h4><h4 id="7-1-5-5-反向代理"><a href="#7-1-5-5-反向代理" class="headerlink" title="7.1.5.5 反向代理"></a>7.1.5.5 反向代理</h4><h3 id="7-1-6-Gateway-vs-Zuul"><a href="#7-1-6-Gateway-vs-Zuul" class="headerlink" title="7.1.6 Gateway vs Zuul"></a><strong>7.1.6 Gateway vs Zuul</strong></h3><h4 id="7-1-6-1-Gateway-和-Zuul-区别"><a href="#7-1-6-1-Gateway-和-Zuul-区别" class="headerlink" title="7.1.6.1 Gateway 和 Zuul 区别"></a>7.1.6.1 Gateway 和 Zuul 区别</h4><ol><li><p>SpringCloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Zuul</p></li><li><p>SpringCloud Gateway 是基于 Spring WebFlux框架实现的</p></li><li><p>Spring WebFlux 框架底层则使用了高性能的 Reactor 模式通信框架 Netty，提升了网关性能</p></li></ol><h4 id="7-1-6-2-Gateway-特性"><a href="#7-1-6-2-Gateway-特性" class="headerlink" title="7.1.6.2 Gateway 特性"></a>7.1.6.2 Gateway 特性</h4><p>​Spring Cloud Gateway 基 于 Spring Framework(支 特 Spring WebFlux)， project Reactor 和 spring Boot 进行构建，具有如下特性：</p><ul><li>动态路由</li><li>可以对路由指定 predicate(断言)和Filter(过滤器）</li><li>集成Hystrix的断路器功能</li><li>集成 Spring Cloud 服务发现功能</li><li>请求限流功能</li><li>支持路径重写</li></ul><h2 id="7-2-Gateway基本原理"><a href="#7-2-Gateway基本原理" class="headerlink" title="7.2 Gateway基本原理"></a>7.2 Gateway基本原理</h2><h3 id="7-2-1-Gateway核心组件"><a href="#7-2-1-Gateway核心组件" class="headerlink" title="7.2.1 Gateway核心组件"></a><strong>7.2.1 Gateway</strong>核心组件</h3><h4 id="7-2-1-1-一张图"><a href="#7-2-1-1-一张图" class="headerlink" title="7.2.1.1 一张图"></a>7.2.1.1 一张图</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230530152704594.png" alt="image-20230530152704594" style="zoom:50%;" /><ol><li><p>web 请求通过一些匹配条件，定位到真正的服务节点&#x2F;微服务模块，在这个转发过程的前后，进行一些精细化控制。</p></li><li><p>predicate：就是匹配条件(请求是否能被接受使用)</p></li><li><p>filter：可以理解为是网关的过滤机制。</p><p>有了predicate 和filter，再加上目标 URL,就可以实现一个具体的路由</p></li></ol><h4 id="7-2-1-2-Route-路由"><a href="#7-2-1-2-Route-路由" class="headerlink" title="7.2.1.2 Route(路由)"></a>7.2.1.2 Route(路由)</h4><p>一句话：路由是构建网关的基本模块，它由 <strong>ID</strong>，<strong>目标 URL</strong>，<strong>一系列的断言和过滤器</strong>组成，如果断言为 true 则匹配该路由。</p><h4 id="7-2-1-3-Predicate-断言"><a href="#7-2-1-3-Predicate-断言" class="headerlink" title="7.2.1.3 Predicate(断言)"></a>7.2.1.3 Predicate(断言)</h4><ol><li><p>一句话：对 HTTP 请求中的所有内容（例如请求头或请求参数）进行匹配，如果请求与断言相匹配则进行路由</p></li><li><p>简单举例，比如配置路径，- Path&#x3D;&#x2F;member&#x2F;get&#x2F;**             断言,路经相匹配的进行路由转发，如果Http 请求的路径不匹配，则不进行路由转发。</p></li></ol><h4 id="7-2-1-4-Filter-过滤"><a href="#7-2-1-4-Filter-过滤" class="headerlink" title="7.2.1.4 Filter(过滤)"></a>7.2.1.4 Filter(过滤)</h4><p>1、一句话：使用过滤器，可以在<strong>请求被路由前或者之后</strong>对请求进行处理</p><p>2、你可以理解成，在对 Http 请求断言匹配成功后，可以通过网关的过滤机制，对Http 请求处理</p><h3 id="7-2-2-HowItWorks工作机制"><a href="#7-2-2-HowItWorks工作机制" class="headerlink" title="7.2.2 HowItWorks工作机制"></a><strong>7.2.2 HowItWorks</strong>工作机制</h3><h4 id="7-2-2-1-一图胜千言"><a href="#7-2-2-1-一图胜千言" class="headerlink" title="7.2.2.1 一图胜千言"></a>7.2.2.1 一图胜千言</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230530163559159.png" alt="image-20230530163559159" style="zoom:50%;" /><ol><li><p>客户端向 Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，將其发送到 Gateway Web Handler。</p></li><li><p>Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。</p></li><li><p>过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（”pre”）或之后(“post”）执行业务逻辑。</p></li><li><p>Filter 在”pre”类型的过滤器可以做<strong>参数校验、权限校验、流量监控、日志输出、协议转换</strong>等，</p></li><li><p>在”post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。</p></li></ol><p>一句话说：路由转发＋执行过滤器链</p><h2 id="7-3-搭建-Gateway-微服务"><a href="#7-3-搭建-Gateway-微服务" class="headerlink" title="7.3 搭建 Gateway 微服务"></a>7.3 搭建 Gateway 微服务</h2><h3 id="7-3-1-搭建-Gateway-应用实例"><a href="#7-3-1-搭建-Gateway-应用实例" class="headerlink" title="7.3.1 搭建 **Gateway-**应用实例"></a><strong>7.3.1</strong> 搭建 **Gateway-**应用实例</h3><h4 id="7-3-1-1-需求分析-x2F-图解"><a href="#7-3-1-1-需求分析-x2F-图解" class="headerlink" title="7.3.1.1 需求分析&#x2F;图解"></a>7.3.1.1 需求分析&#x2F;图解</h4><p>– 引入 <strong>Gateway</strong> 项目架构</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230531095247037.png" alt="image-20230531095247037"></p><p><strong>1.</strong> <strong>通过网关暴露的接口，实现调用真正的服务</strong> </p><p><strong>2.</strong> <strong>网关本身也是一个微服务模块</strong></p><h4 id="7-3-1-2-代码实现"><a href="#7-3-1-2-代码实现" class="headerlink" title="7.3.1.2 代码实现"></a>7.3.1.2 代码实现</h4><p><strong>1.</strong> 参考 <strong>member-service-consumer-80</strong> 创建 **e-commerce-gateway-20000(**具体步骤参考以前)<br><strong>2.</strong> 修改 <strong>pom.xml,</strong> 部分内容可以从 <strong>member-service-consumer-80</strong> 的 <strong>pom.xml</strong> 拷贝</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.study.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>e-commerce-center<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>e-commerce-gateway-20000<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--       引入gateway start， 网关场景启动器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--       引入eureka-client场景启动器starter--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--老师特别说明：</span></span><br><span class="line"><span class="comment">    不要引入：spring-boot-starter-web、spring-boot-starter-actuator</span></span><br><span class="line"><span class="comment">    否则会出现冲突</span></span><br><span class="line"><span class="comment">    因为gateway是一个服务网关，不需要web</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引入 e_commerce_center-common-api --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.study.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>e_commerce_center-common-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3.<strong>创建 <strong>application.yml(<strong>重点核心</strong>)</strong> 内容如下</strong>:</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">20000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">e-commerce-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment">#配置路由，可以配置多个 List&lt;RouteDefinition&gt; routes</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">member_route01</span> <span class="comment">#路由的id，程序员自行配置</span></span><br><span class="line">          <span class="comment">#gateway 最终访问的url 是 uri + path</span></span><br><span class="line">          <span class="comment">#匹配后提供服务的路由地址：也可以是外网 如www.baidu.com</span></span><br><span class="line">          <span class="comment">#比如：客户端/浏览器请求url：http:localhost:20000/member/get/1</span></span><br><span class="line">          <span class="comment">#网关对请求url中的path进行匹配，如果匹配失败，返回404</span></span><br><span class="line">          <span class="comment">#如果匹配成功，最终访问的url=http://localhost:10000/member/get/1</span></span><br><span class="line">          <span class="comment">#                     即 uri + path</span></span><br><span class="line">          <span class="comment">#这里⬇️的uri是固定不变的，在当前这种情况下是可以不使用Eureka Server 的</span></span><br><span class="line">          <span class="comment">#后面会使用灵活uri配置，会用到Eureka Server</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:10000</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 断言，可以有多种形式</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/member/get/**</span></span><br><span class="line"><span class="comment"># 配置Eureka Client</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">e-commerce-service</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span> <span class="comment">#将自己注册到Eureka-server</span></span><br><span class="line">    <span class="comment">#表示从Eureka-server抓取注册信息</span></span><br><span class="line">    <span class="comment">#如果是单节点，可以不配置；</span></span><br><span class="line">    <span class="comment">#但是provider是一个集群，则必须将此项配置为true，这样才能配合Ribbon使用负载均衡功能</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 表示将自己注册到哪个eureka-server</span></span><br><span class="line">      <span class="comment">#这里为了方便，就使用9001端口一个server</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka9001.com:9001/eureka</span></span><br></pre></td></tr></table></figure><p>**4.**创建主启动类 <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;GateWayApplication20000.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GateWayApplication20000</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(GateWayApplication20000.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-1-3-测试"><a href="#7-3-1-3-测试" class="headerlink" title="7.3.1.3 测试"></a>7.3.1.3 测试</h4><p>……</p><h4 id="7-3-1-4-注意事项和细节"><a href="#7-3-1-4-注意事项和细节" class="headerlink" title="7.3.1.4 注意事项和细节"></a>7.3.1.4 注意事项和细节</h4><p>因为我们的 member 的 controller 的方法参数使用了@RequestBody ,所以在使用 postman时，需要使用 json 格式发送数据, 否则会报400错误。</p><h3 id="7-3-2-二说-Gateway-路由配置"><a href="#7-3-2-二说-Gateway-路由配置" class="headerlink" title="7.3.2 二说 Gateway 路由配置"></a><strong>7.3.2</strong> 二说 <strong>Gateway</strong> 路由配置</h3><h4 id="7-3-2-1-方式-1-application-yml-中配置-前面讲过"><a href="#7-3-2-1-方式-1-application-yml-中配置-前面讲过" class="headerlink" title="7.3.2.1 方式 1: application.yml 中配置-前面讲过"></a>7.3.2.1 方式 1: application.yml 中配置-前面讲过</h4><h4 id="7-3-2-2-方式-2-编写配置类注入【了解】"><a href="#7-3-2-2-方式-2-编写配置类注入【了解】" class="headerlink" title="7.3.2.2 方式 2: 编写配置类注入【了解】"></a>7.3.2.2 方式 2: 编写配置类注入【了解】</h4><p>​<strong>1.</strong> 先注销 <strong>application.yml</strong> 对网关路由部分注销</p><p>​<strong>2.</strong> <strong>重启</strong> <strong>e-commerce-gateway-20000,</strong> <strong>再次测试，网关路由失效</strong></p><p><strong>3.</strong> 参考官方文档:<a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#spring-cloud-circuitbreaker-filter-factory">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#spring-cloud-circuitbreaker-filter-factory</a> ， 创 建com&#x2F;hspedu&#x2F;springcloud&#x2F;config&#x2F;GateWayRoutesConfig.java</p><h4 id="7-3-2-3-测试"><a href="#7-3-2-3-测试" class="headerlink" title="7.3.2.3 测试"></a>7.3.2.3 测试</h4><p>……</p><h3 id="7-3-3-动态路由"><a href="#7-3-3-动态路由" class="headerlink" title="7.3.3 动态路由"></a><strong>7.3.3</strong> 动态路由</h3><h4 id="7-3-3-1-需求分析-x2F-图"><a href="#7-3-3-1-需求分析-x2F-图" class="headerlink" title="7.3.3.1 需求分析&#x2F;图"></a>7.3.3.1 需求分析&#x2F;图</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230531150741007.png" alt="image-20230531150741007"></p><h4 id="7-3-3-2-代码实现"><a href="#7-3-3-2-代码实现" class="headerlink" title="7.3.3.2 代码实现"></a>7.3.3.2 代码实现</h4><p><strong>1.</strong> 修改 <strong>e-commerce-gateway-20000</strong> 的 <strong>application.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">20000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">e-commerce-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="comment"># 启用 DiscoveryClient 服务发现</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment">#配置路由，可以配置多个 List&lt;RouteDefinition&gt; routes</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">member_route01</span> <span class="comment">#路由的id，程序员自行配置</span></span><br><span class="line">          <span class="comment"># 1. lb:负载均衡协议名称</span></span><br><span class="line">          <span class="comment">#    member-service-provider：注册到eureka server的服务名(小写)</span></span><br><span class="line">          <span class="comment"># 2. 默认情况下，负载均衡算法为轮询</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://member-service-provider</span></span><br><span class="line">          <span class="attr">predicates:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/member/get/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">member_route02</span> </span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://member-service-provider</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/member/save</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">member_route03</span> </span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://member-service-provider</span></span><br><span class="line">          <span class="attr">predicates:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/</span></span><br><span class="line"><span class="comment"># 配置Eureka Client</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">e-commerce-service</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span> <span class="comment">#将自己注册到Eureka-server</span></span><br><span class="line">    <span class="comment">#表示从Eureka-server抓取注册信息</span></span><br><span class="line">    <span class="comment">#如果是单节点，可以不配置；</span></span><br><span class="line">    <span class="comment">#但是provider是一个集群，则必须将此项配置为true，这样才能配合Ribbon使用负载均衡功能</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 表示将自己注册到哪个eureka-server</span></span><br><span class="line">      <span class="comment">#这里为了方便，就使用9001端口一个server</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka9001.com:9001/eureka</span></span><br></pre></td></tr></table></figure><h4 id="7-3-3-3-测试"><a href="#7-3-3-3-测试" class="headerlink" title="7.3.3.3 测试"></a>7.3.3.3 测试</h4><h5 id="7-3-3-3-1-启动-e-commerce-eureka-server-9001"><a href="#7-3-3-3-1-启动-e-commerce-eureka-server-9001" class="headerlink" title="7.3.3.3.1 启动 e-commerce-eureka-server-9001"></a>7.3.3.3.1 启动 e-commerce-eureka-server-9001</h5><h5 id="7-3-3-3-2-启动-member-service-provider-10000"><a href="#7-3-3-3-2-启动-member-service-provider-10000" class="headerlink" title="7.3.3.3.2 启动 member-service-provider-10000"></a>7.3.3.3.2 启动 member-service-provider-10000</h5><h5 id="7-3-3-3-3-启动-member-service-provider-10002"><a href="#7-3-3-3-3-启动-member-service-provider-10002" class="headerlink" title="7.3.3.3.3 启动 member-service-provider-10002"></a>7.3.3.3.3 启动 member-service-provider-10002</h5><h5 id="7-3-3-3-4-启动-e-commerce-gateway-20000"><a href="#7-3-3-3-4-启动-e-commerce-gateway-20000" class="headerlink" title="7.3.3.3.4 启动 e-commerce-gateway-20000"></a>7.3.3.3.4 启动 e-commerce-gateway-20000</h5><h5 id="7-3-3-3-5-浏览器-通过网关访问-http-localhost-20000-member-get-1"><a href="#7-3-3-3-5-浏览器-通过网关访问-http-localhost-20000-member-get-1" class="headerlink" title="7.3.3.3.5 浏览器**:(通过网关访问) http://localhost:20000/member/get/1**"></a>7.3.3.3.5 浏览器**:(<strong>通过网关访问</strong>) <a href="http://localhost:20000/member/get/1">http://localhost:20000/member/get/1</a>**</h5><p>​浏览器输入**: <a href="http://localhost:20000/member/get/1">http://localhost:20000/member/get/1</a>**</p><h4 id="7-3-3-4-注意事项和细节"><a href="#7-3-3-4-注意事项和细节" class="headerlink" title="7.3.3.4 注意事项和细节"></a>7.3.3.4 注意事项和细节</h4><h5 id="7-3-3-4-1-配置好动态路由后-Gateway-会根据注册中心上微服务名，为请求创建动态路由，实现-动态路由-功能"><a href="#7-3-3-4-1-配置好动态路由后-Gateway-会根据注册中心上微服务名，为请求创建动态路由，实现-动态路由-功能" class="headerlink" title="7.3.3.4.1 配置好动态路由后 Gateway 会根据注册中心上微服务名，为请求创建动态路由，实现 动态路由 功能"></a><strong>7.3.3.4.1</strong> 配置好动态路由后 <strong>Gateway</strong> 会根据注册中心上微服务名，为请求创建动态路由，实现 动态路由 功能</h5><h5 id="7-3-3-4-2-使用的-lb-协议支持负载均衡-轮询算法"><a href="#7-3-3-4-2-使用的-lb-协议支持负载均衡-轮询算法" class="headerlink" title="7.3.3.4.2 使用的 lb 协议支持负载均衡**-**轮询算法"></a><strong>7.3.3.4.2</strong> 使用的 <strong>lb</strong> 协议支持负载均衡**-**轮询算法</h5><h5 id="7-3-3-4-3-配置自己的负载均衡算法，-测试完毕恢复成原来的轮询算法"><a href="#7-3-3-4-3-配置自己的负载均衡算法，-测试完毕恢复成原来的轮询算法" class="headerlink" title="7.3.3.4.3 配置自己的负载均衡算法， 测试完毕恢复成原来的轮询算法"></a><strong>7.3.3.4.3</strong> 配置自己的负载均衡算法， 测试完毕恢复成原来的轮询算法</h5><h2 id="7-4-Predicate-x2F-断言"><a href="#7-4-Predicate-x2F-断言" class="headerlink" title="7.4 Predicate&#x2F;断言"></a>7.4 Predicate&#x2F;断言</h2><h3 id="7-4-1-基本介绍"><a href="#7-4-1-基本介绍" class="headerlink" title="7.4.1 基本介绍"></a><strong>7.4.1</strong> 基本介绍</h3><h4 id="7-4-1-1-一句话-Predicate-就是一组匹配规则，当请求匹配成功，就执行对应Route-匹配失败，放弃-处理-x2F-转发"><a href="#7-4-1-1-一句话-Predicate-就是一组匹配规则，当请求匹配成功，就执行对应Route-匹配失败，放弃-处理-x2F-转发" class="headerlink" title="7.4.1.1 一句话: Predicate 就是一组匹配规则，当请求匹配成功，就执行对应Route, 匹配失败，放弃 处理&#x2F;转发"></a>7.4.1.1 一句话: Predicate 就是一组匹配规则，当请求匹配成功，就执行对应Route, 匹配失败，放弃 处理&#x2F;转发</h4><h4 id="7-4-1-2-RoutePredicateFactories"><a href="#7-4-1-2-RoutePredicateFactories" class="headerlink" title="7.4.1.2 RoutePredicateFactories"></a>7.4.1.2 RoutePredicateFactories</h4><p><strong>文档地址</strong>: <a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories</a></p><ul><li>Spring Cloud Gateway包括许多内置的Route Predicate工厂，所有这些Predicate都与HTTP请求的不同属性匹配，可以组合使用．</li><li>Spring Cloud Gateway 创建 Route 对象时，使用RoutePredicateFactory 创建Predicate对象，Predicate 对象可以赋值给Route。</li><li>所有这些谓词都匹配HTTP请求的不同属性。多种谓词工厂可以组合</li></ul><p>其实就是利用工厂中的api进行断言</p><h3 id="7-4-2-RoutePredicate实例-根据上述文档进行操作演示"><a href="#7-4-2-RoutePredicate实例-根据上述文档进行操作演示" class="headerlink" title="7.4.2 RoutePredicate实例(根据上述文档进行操作演示)"></a>7.4.2 RoutePredicate实例(根据上述文档进行操作演示)</h3><h4 id="7-4-2-1-AfterRoutePredicate"><a href="#7-4-2-1-AfterRoutePredicate" class="headerlink" title="7.4.2.1 AfterRoutePredicate"></a>7.4.2.1 AfterRoutePredicate</h4><h5 id="7-4-2-1-1-需求分析-x2F-图解"><a href="#7-4-2-1-1-需求分析-x2F-图解" class="headerlink" title="7.4.2.1.1 需求分析**&#x2F;**图解"></a><strong>7.4.2.1.1</strong> 需求分析**&#x2F;**图解</h5><p><strong>1.</strong> 需求分析**&#x2F;**图解</p><p>​需求**:** 只有 2022-11-18 12:35:50 <u><strong>之后</strong></u>的请求才进行匹配**&#x2F;<strong>转发</strong>,** 不满足该条件的，不处理</p><h5 id="7-4-2-1-2-代码实现"><a href="#7-4-2-1-2-代码实现" class="headerlink" title="7.4.2.1.2 代码实现"></a><strong>7.4.2.1.2</strong> 代码实现</h5><h5 id="1-参考文档-https-cloud-spring-io-spring-cloud-static-spring-cloud-gateway-2-2-1-RELEASE-reference-html-gateway-request-predicates-factories"><a href="#1-参考文档-https-cloud-spring-io-spring-cloud-static-spring-cloud-gateway-2-2-1-RELEASE-reference-html-gateway-request-predicates-factories" class="headerlink" title="1. 参考文档 : https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories"></a><strong>1.</strong> 参考文档 <strong>: <a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories</a></strong></h5><p><strong>2.</strong> <strong>修改</strong> <strong>e-commerce-gateway-20000</strong> <strong>的</strong> <strong>application.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">after_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">After=2017-01-20T17:42:47.789-07:00[America/Denver]</span></span><br></pre></td></tr></table></figure><h4 id="7-4-2-2-BeforeRoutePredicate"><a href="#7-4-2-2-BeforeRoutePredicate" class="headerlink" title="7.4.2.2 BeforeRoutePredicate"></a>7.4.2.2 BeforeRoutePredicate</h4><p><strong>1.</strong> 需求分析**&#x2F;**图解</p><p>需求**:** 只有 2022-11-18 12:35:50 <u><strong>之前</strong></u>的请求才进行匹配**&#x2F;<strong>转发</strong>,** 不满足该条件的，不处理</p><h5 id="7-4-2-2-2-代码实现"><a href="#7-4-2-2-2-代码实现" class="headerlink" title="7.4.2.2.2 代码实现"></a><strong>7.4.2.2.2</strong> 代码实现</h5><p><strong>1.</strong> 参考文档 <strong>: <a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories</a></strong></p><p><strong>2.</strong> <strong>修改</strong> <strong>e-commerce-gateway-20000</strong> <strong>的</strong> <strong>application.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">before_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Before=2017-01-20T17:42:47.789-07:00[America/Denver]</span></span><br></pre></td></tr></table></figure><h4 id="7-4-2-3-BetweenRoutePredicate"><a href="#7-4-2-3-BetweenRoutePredicate" class="headerlink" title="7.4.2.3 BetweenRoutePredicate"></a>7.4.2.3 BetweenRoutePredicate</h4><p><strong>1.</strong> 需求分析**&#x2F;**图解</p><p>需求**:** 只有 <strong>2020-11-18 12:35:50</strong> 和 <strong>2022-11-18 12:35:50</strong> <u><em>之间</em></u> 的请求才进行匹配**&#x2F;<strong>转 发</strong>,** 不满足该条件的，不处理</p><h5 id="7-4-2-3-2-代码实现"><a href="#7-4-2-3-2-代码实现" class="headerlink" title="7.4.2.3.2 代码实现"></a><strong>7.4.2.3.2</strong> 代码实现</h5><p><strong>1.</strong> 参考文档 <strong>: <a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories</a></strong></p><p><strong>2.</strong> <strong>修改</strong> <strong>e-commerce-gateway-20000</strong> <strong>的</strong> <strong>application.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">between_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Between=2017-01-20T17:42:47.789-07:00[America/Denver],</span> <span class="number">2017-01-21T17:42:47.789-07:00</span>[<span class="string">America/Denver</span>]</span><br></pre></td></tr></table></figure><h4 id="7-4-2-4-CookieRoutePredicate"><a href="#7-4-2-4-CookieRoutePredicate" class="headerlink" title="7.4.2.4 CookieRoutePredicate"></a>7.4.2.4 CookieRoutePredicate</h4><h5 id="7-4-2-4-1-需求分析-x2F-图解"><a href="#7-4-2-4-1-需求分析-x2F-图解" class="headerlink" title="7.4.2.4.1 需求分析**&#x2F;**图解"></a><strong>7.4.2.4.1</strong> 需求分析**&#x2F;**图解</h5><p>​需求**:** 请求带有 <strong>cookie</strong> 键**: user** 值**: hsp** 才匹配**&#x2F;**断言成功</p><p><strong>1.4.2.4.2</strong> 代码实现</p><p><strong>1.</strong> 参考文档 <strong>: <a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories</a></strong></p><p><strong>2.</strong> <strong>修改</strong> <strong>e-commerce-gateway-20000</strong> <strong>的</strong> <strong>application.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">cookie_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Cookie=chocolate,</span> <span class="string">ch.p</span></span><br><span class="line">        <span class="comment"># chocolate 是 cookie 名字 ch.p 是 cookie 的值，是按照正则表达式来匹配的</span></span><br></pre></td></tr></table></figure><h4 id="7-4-2-5-HeaderRoutePredicate"><a href="#7-4-2-5-HeaderRoutePredicate" class="headerlink" title="7.4.2.5 HeaderRoutePredicate"></a>7.4.2.5 HeaderRoutePredicate</h4><h5 id="7-4-2-5-1-需求分析-x2F-图解"><a href="#7-4-2-5-1-需求分析-x2F-图解" class="headerlink" title="7.4.2.5.1 需求分析**&#x2F;**图解"></a><strong>7.4.2.5.1</strong> 需求分析**&#x2F;**图解</h5><p><strong>1.</strong> 需求分析**&#x2F;**图解</p><p><strong>需求</strong>: <strong>请求头</strong> <strong>Header</strong> <strong>有</strong> <strong>X-Request-Id</strong>， 并且值为xxxxx 才匹配&#x2F;断言成功</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">header_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br><span class="line">        <span class="comment"># X-Request-Id 是 header 的名称, \d+ 是一个正则表达式</span></span><br></pre></td></tr></table></figure><h4 id="7-4-2-6-HostRoutePredicate"><a href="#7-4-2-6-HostRoutePredicate" class="headerlink" title="7.4.2.6 HostRoutePredicate"></a>7.4.2.6 HostRoutePredicate</h4><h5 id="7-4-2-6-1-需求分析-x2F-图解"><a href="#7-4-2-6-1-需求分析-x2F-图解" class="headerlink" title="7.4.2.6.1 需求分析**&#x2F;**图解"></a><strong>7.4.2.6.1</strong> 需求分析**&#x2F;**图解</h5><p><strong>1.</strong> 需求分析**&#x2F;**图解</p><p>需求： <strong>请求</strong> <strong>Host</strong> <strong>是</strong><em><strong>*.hspedu.*</strong></em> 才匹配&#x2F;断言成功 <strong>,</strong> <strong>比如</strong> <strong>Host： <a href="http://www.hspedu.com/">www.hspedu.com</a></strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">host_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Host=**.somehost.org,**.anotherhost.org</span></span><br><span class="line">        <span class="comment">#Host 可以有多个, 使用逗号间隔</span></span><br></pre></td></tr></table></figure><h4 id="7-4-2-7-MethodRoutePredicate"><a href="#7-4-2-7-MethodRoutePredicate" class="headerlink" title="7.4.2.7 MethodRoutePredicate"></a>7.4.2.7 MethodRoutePredicate</h4><p><strong>1.4.2.7.1</strong> 需求分析**&#x2F;**图解</p><p><strong>需求</strong>: <strong>请求是</strong> <strong>XXXXXX</strong> <strong>方式才匹配</strong>&#x2F;<strong>断言成功</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Method=GET,POST</span></span><br><span class="line">        <span class="comment"># 请求方式可以有多个, 使用逗号间隔</span></span><br></pre></td></tr></table></figure><h4 id="7-4-2-8-PathRoutePredicate"><a href="#7-4-2-8-PathRoutePredicate" class="headerlink" title="7.4.2.8 PathRoutePredicate"></a>7.4.2.8 PathRoutePredicate</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">host_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/red/&#123;segment&#125;,/blue/&#123;segment&#125;</span></span><br><span class="line">        <span class="comment"># Path 可以有多个, 使用逗号间隔</span></span><br></pre></td></tr></table></figure><h4 id="7-4-2-9-QueryRoutePredicate"><a href="#7-4-2-9-QueryRoutePredicate" class="headerlink" title="7.4.2.9 QueryRoutePredicate"></a>7.4.2.9 QueryRoutePredicate</h4><h5 id="1-4-2-9-1-需求分析-x2F-图解"><a href="#1-4-2-9-1-需求分析-x2F-图解" class="headerlink" title="1.4.2.9.1 需求分析**&#x2F;**图解"></a><strong>1.4.2.9.1</strong> 需求分析**&#x2F;**图解</h5><p>需求**:** 请求有参数 <strong>email ,<strong>并且满足电子邮件的基本格式</strong>,</strong> 才能匹配**&#x2F;**断言成功</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">query_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Query=red,</span> <span class="string">gree.</span></span><br><span class="line">        <span class="comment">#red 是参数名 gree. 是值, 支持正则表达式.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#对应邮箱：</span></span><br><span class="line">      <span class="comment"># - Query=email, [\w-]+@([a-zA-Z]+\.)+[a-zA-Z]+</span></span><br></pre></td></tr></table></figure><h4 id="7-4-2-10-RemoteAddr-Route-Predicate"><a href="#7-4-2-10-RemoteAddr-Route-Predicate" class="headerlink" title="7.4.2.10 RemoteAddr Route Predicate"></a>7.4.2.10 RemoteAddr Route Predicate</h4><h5 id="7-4-2-10-1-需求分析-x2F-图解"><a href="#7-4-2-10-1-需求分析-x2F-图解" class="headerlink" title="7.4.2.10.1 需求分析**&#x2F;**图解"></a><strong>7.4.2.10.1</strong> 需求分析**&#x2F;**图解</h5><p><strong>需求</strong>: <strong>请求的</strong> <strong>IP</strong> <strong>是</strong> <strong>127.0.0.1,</strong> <strong>才能匹配</strong>&#x2F;断言成功</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">remoteaddr_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">RemoteAddr=192.168.1.1/24</span></span><br></pre></td></tr></table></figure><h2 id="7-5-Filter-x2F-过滤器"><a href="#7-5-Filter-x2F-过滤器" class="headerlink" title="7.5 Filter&#x2F;过滤器"></a>7.5 Filter&#x2F;过滤器</h2><h3 id="7-5-1-基本介绍"><a href="#7-5-1-基本介绍" class="headerlink" title="7.5.1 基本介绍"></a><strong>7.5.1</strong> 基本介绍</h3><p><strong>1.</strong> 文档地址 <strong>: <a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gatewayfilter-factories">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gatewayfilter-factories</a></strong></p><p> <strong>路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应</strong></p><p><strong>Spring Cloud Gateway 内置了多种路由过滤器，他们都由GatewayFilter的工厂类来产生</strong></p><h3 id="7-5-2-类型"><a href="#7-5-2-类型" class="headerlink" title="7.5.2 类型"></a><strong>7.5.2</strong> 类型</h3><h4 id="7-5-2-1-GatewayFilter"><a href="#7-5-2-1-GatewayFilter" class="headerlink" title="7.5.2.1 GatewayFilter"></a>7.5.2.1 GatewayFilter</h4><h4 id="7-5-2-2-GlobalFilter"><a href="#7-5-2-2-GlobalFilter" class="headerlink" title="7.5.2.2 GlobalFilter"></a>7.5.2.2 GlobalFilter</h4><p>一般很少使用官方的filter，都是自定义满足需求，因此只介绍一个官方filter</p><h3 id="7-5-3-GatewayFilter使用"><a href="#7-5-3-GatewayFilter使用" class="headerlink" title="7.5.3 GatewayFilter使用"></a><strong>7.5.3 GatewayFilter</strong>使用</h3><h4 id="7-5-3-1-开发直接使用-GatewayFilter-较少，一般是自定义过滤器"><a href="#7-5-3-1-开发直接使用-GatewayFilter-较少，一般是自定义过滤器" class="headerlink" title="7.5.3.1 开发直接使用 GatewayFilter 较少，一般是自定义过滤器"></a>7.5.3.1 开发直接使用 GatewayFilter 较少，一般是自定义过滤器</h4><p>​演示：The AddRequestParameter GatewayFilter Factory</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">add_request_parameter_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestParameter=color,</span> <span class="string">blue</span></span><br></pre></td></tr></table></figure><h3 id="7-5-4-自定义-GlobalFilter"><a href="#7-5-4-自定义-GlobalFilter" class="headerlink" title="7.5.4 自定义 GlobalFilter"></a><strong>7.5.4</strong> 自定义 <strong>GlobalFilter</strong></h3><h4 id="7-5-4-1-需求分析-x2F-图解"><a href="#7-5-4-1-需求分析-x2F-图解" class="headerlink" title="7.5.4.1 需求分析&#x2F;图解"></a>7.5.4.1 需求分析&#x2F;图解</h4><p><strong>1.</strong> 自定义全局 <strong>GlobalFilter</strong> 过滤器<br><strong>2.</strong> 如果请求参数 <strong>user&#x3D;hspedu , pwd&#x3D;123456</strong> 则放行**,** 否则不能通过验证</p><h4 id="7-5-4-2-代码实现"><a href="#7-5-4-2-代码实现" class="headerlink" title="7.5.4.2 代码实现"></a>7.5.4.2 代码实现</h4><p><strong>1.</strong> 在 <strong>e-commerce-gateway-20000</strong> 创建<strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;filter&#x2F;CustomGateWayFilter.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.springcloud.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/6/1</span></span><br><span class="line"><span class="comment"> * 11:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomGateWayFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//filter是核心的方法，将我们的过滤业务写在该方法中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">//先获取到对应的参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span></span><br><span class="line">                exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span></span><br><span class="line">                exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!(<span class="string">&quot;hspedu&quot;</span>.equals(user) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(pwd)))&#123;</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示过滤器执行的顺序，数字越小，优先级越高</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-5-4-3-测试"><a href="#7-5-4-3-测试" class="headerlink" title="7.5.4.3 测试"></a>7.5.4.3 测试</h4><h5 id="7-5-4-3-1-启动-e-commerce-eureka-server-9001"><a href="#7-5-4-3-1-启动-e-commerce-eureka-server-9001" class="headerlink" title="7.5.4.3.1 启动 e-commerce-eureka-server-9001"></a><strong>7.5.4.3.1</strong> 启动 e-commerce-eureka-server-9001</h5><h5 id="7-5-4-3-2-启动-member-service-provider-10000-x2F-10002"><a href="#7-5-4-3-2-启动-member-service-provider-10000-x2F-10002" class="headerlink" title="7.5.4.3.2 启动 member-service-provider-10000&#x2F;10002"></a>7.5.4.3.2 启动 member-service-provider-10000&#x2F;10002</h5><h5 id="7-5-4-3-3-启动-e-commerce-gateway-20000"><a href="#7-5-4-3-3-启动-e-commerce-gateway-20000" class="headerlink" title="7.5.4.3.3 启动 e-commerce-gateway-20000"></a>7.5.4.3.3 启动 e-commerce-gateway-20000</h5><h5 id="7-5-4-3-4-浏览器-通过网关访问-http-localhost-20000-member-get-1-user-hspedu-amp-pwd-123456-输入-http-localhost-20000-member-get-1-user-hspedu-amp-pwd-123456"><a href="#7-5-4-3-4-浏览器-通过网关访问-http-localhost-20000-member-get-1-user-hspedu-amp-pwd-123456-输入-http-localhost-20000-member-get-1-user-hspedu-amp-pwd-123456" class="headerlink" title="7.5.4.3.4 浏览器**:(通过网关访问) http://localhost:20000/member/get/1?user=hspedu&amp;pwd=123456** 输入**: http://localhost:20000/member/get/1?user=hspedu&amp;pwd=123456**"></a>7.5.4.3.4 浏览器**:(<strong>通过网关访问</strong>) <a href="http://localhost:20000/member/get/1?user=hspedu&pwd=123456">http://localhost:20000/member/get/1?user=hspedu&amp;pwd=123456</a>** 输入**: <a href="http://localhost:20000/member/get/1?user=hspedu&pwd=123456">http://localhost:20000/member/get/1?user=hspedu&amp;pwd=123456</a>**</h5><h4 id="7-5-4-4-测试完毕，记得代码恢复到测试前"><a href="#7-5-4-4-测试完毕，记得代码恢复到测试前" class="headerlink" title="7.5.4.4 测试完毕，记得代码恢复到测试前"></a>7.5.4.4 测试完毕，记得代码恢复到测试前</h4><h1 id="8-SpringCloud-Sleuth-Zipkin-服务跟踪"><a href="#8-SpringCloud-Sleuth-Zipkin-服务跟踪" class="headerlink" title="8 SpringCloud Sleuth+Zipkin 服务跟踪"></a>8 SpringCloud Sleuth+Zipkin 服务跟踪</h1><h2 id="8-1-Sleuth-x2F-ZipKin基础"><a href="#8-1-Sleuth-x2F-ZipKin基础" class="headerlink" title="8.1 Sleuth&#x2F;ZipKin基础"></a>8.1 Sleuth&#x2F;ZipKin基础</h2><h3 id="8-1-1-官网"><a href="#8-1-1-官网" class="headerlink" title="8.1.1 官网"></a><strong>8.1.1</strong> 官网</h3><h4 id="8-1-1-1-https-github-com-spring-cloud-spring-cloud-sleuth"><a href="#8-1-1-1-https-github-com-spring-cloud-spring-cloud-sleuth" class="headerlink" title="8.1.1.1 https://github.com/spring-cloud/spring-cloud-sleuth"></a>8.1.1.1 <a href="https://github.com/spring-cloud/spring-cloud-sleuth">https://github.com/spring-cloud/spring-cloud-sleuth</a></h4><h3 id="8-1-2-Sleuth-x2F-Zipkin是什么"><a href="#8-1-2-Sleuth-x2F-Zipkin是什么" class="headerlink" title="8.1.2 Sleuth&#x2F;Zipkin是什么?"></a><strong>8.1.2 Sleuth&#x2F;Zipkin</strong>是什么?</h3><h4 id="8-1-2-1-概述-两张图"><a href="#8-1-2-1-概述-两张图" class="headerlink" title="8.1.2.1 概述(两张图)"></a>8.1.2.1 概述(两张图)</h4><ol><li><p>在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的服务节点调用**,** 来协同产生最后的请求结果，每一个请求都会形成一条复杂的分布式服务调用链路</p></li><li><p>链路中的任何一环出现高延时或错误都会引起整个请求最后的失败,因此<u>对整个服务的调用进行链路追踪和分析</u>就非常的重要</p></li><li><p>Sleuth 和 Zipkin简单关系图</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230601125136474.png" alt="image-20230601125136474"></p><h4 id="8-1-2-2-一句话-Sleuth-提供了一套完整的服务跟踪的解决方案-并兼容-Zipkin"><a href="#8-1-2-2-一句话-Sleuth-提供了一套完整的服务跟踪的解决方案-并兼容-Zipkin" class="headerlink" title="8.1.2.2 一句话: Sleuth 提供了一套完整的服务跟踪的解决方案 并兼容 Zipkin"></a>8.1.2.2 一句话: Sleuth 提供了一套完整的服务跟踪的解决方案 并兼容 Zipkin</h4><h4 id="8-1-2-3-梳理-🌟Sleuth-做链路追踪-Zipkin-做数据搜集-x2F-存储-x2F-可视化"><a href="#8-1-2-3-梳理-🌟Sleuth-做链路追踪-Zipkin-做数据搜集-x2F-存储-x2F-可视化" class="headerlink" title="8.1.2.3 梳理: 🌟Sleuth 做链路追踪 , Zipkin 做数据搜集&#x2F;存储&#x2F;可视化"></a>8.1.2.3 梳理: 🌟<u>Sleuth 做链路追踪 , Zipkin 做数据搜集&#x2F;存储&#x2F;可视化</u></h4><h3 id="8-1-3-Sleuth工作原理"><a href="#8-1-3-Sleuth工作原理" class="headerlink" title="8.1.3 Sleuth工作原理"></a><strong>8.1.3 Sleuth</strong>工作原理</h3><p><strong>1. Span</strong> 和 <strong>Trace</strong> 在一个系统中使用 <strong>Zipkin</strong> 的过程**-**图形化</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230603152155135.png" alt="image-20230603152155135"></p><ul><li><p>表示一请求链路，一条链路通过Trace id唯一标识，span标识发起的请求信息，各span通过parent id关联起来</p></li><li><p>Trace：类似于树结构的Span集合，表示一条调用链路，存在唯一标识 (一条请求链路只有唯一一个Trace id)</p></li><li><p>Span：基本工作单元，表示调用链路来源，通俗的理解span就是一次请求信息</p></li></ul><p><strong>2. spans</strong> <strong>的</strong> <strong>parent&#x2F;child</strong> <strong>关系图形化</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230603152459615.png" alt="image-20230603152459615"></p><ul><li><p>小伙伴注意看老师标识的红线，后一个span节点的parentid 指向&#x2F;记录 了上一个Span结点</p></li><li><p>span就是一次请求信息</p></li><li><p>多个Span集合就构成<u>一条调用链路</u></p></li><li><p>在span&#x3D;C 这个节点存在分支</p></li></ul><h2 id="8-2-Sleuth-x2F-ZipKin-搭建链路监控实例"><a href="#8-2-Sleuth-x2F-ZipKin-搭建链路监控实例" class="headerlink" title="8.2 Sleuth&#x2F;ZipKin-搭建链路监控实例"></a>8.2 Sleuth&#x2F;ZipKin-搭建链路监控实例</h2><h3 id="8-2-1-需求说明-x2F-图解"><a href="#8-2-1-需求说明-x2F-图解" class="headerlink" title="8.2.1 需求说明**&#x2F;**图解"></a><strong>8.2.1</strong> 需求说明**&#x2F;**图解</h3><p><strong>要求</strong>: <strong>通过</strong> <strong>Sleuth</strong> <strong>和</strong> <strong>Zipkin</strong> <strong>可以对</strong>服务调用链路<strong>进行监控</strong>, <strong>并在</strong> <strong>Zipkin</strong> <strong>进行显示</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230603152942262.png" alt="image-20230603152942262"></p><h3 id="8-2-2-安装-x2F-使用-Zipkin"><a href="#8-2-2-安装-x2F-使用-Zipkin" class="headerlink" title="8.2.2 安装**&#x2F;**使用 Zipkin"></a><strong>8.2.2</strong> 安装**&#x2F;**使用 <strong>Zipkin</strong></h3><h4 id="8-2-2-1-下载"><a href="#8-2-2-1-下载" class="headerlink" title="8.2.2.1 下载"></a>8.2.2.1 下载</h4><ol><li><p>下载地址：<a href="https://repo1.maven.org/maven2/io/zipkin/zipkin-server/">https://repo1.maven.org/maven2/io/zipkin/zipkin-server/</a></p></li><li><p>得到 zipkin-server-2.14.1-exec.jar</p></li></ol><h4 id="8-2-2-2-运行"><a href="#8-2-2-2-运行" class="headerlink" title="8.2.2.2 运行"></a>8.2.2.2 运行</h4><ol><li>进入 zipkin-server-2.14.1-exec.jar 所在目录的终端</li><li>执行命令  java -jar zipkin-server-2.14.1-exec.jar    开启zipkin服务</li></ol><h4 id="8-2-2-3-访问"><a href="#8-2-2-3-访问" class="headerlink" title="8.2.2.3 访问"></a>8.2.2.3 访问</h4><p>​浏览器输入**:<a href="http://localhost:9411/zipkin/">http://localhost:9411/zipkin/</a>**</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230603225430611.png" alt="image-20230603225430611"></p><h3 id="8-2-3-服务提供方集成-Sleuth-x2F-Zipkin"><a href="#8-2-3-服务提供方集成-Sleuth-x2F-Zipkin" class="headerlink" title="8.2.3 服务提供方集成 Sleuth&#x2F;Zipkin"></a><strong>8.2.3</strong> 服务提供方集成 <strong>Sleuth&#x2F;Zipkin</strong></h3><p><strong>1.</strong> 修改 <strong>member-service-provider-10000</strong> 的 <strong>pom.xml ,</strong> 增加引入 <strong>sleuth+zipkin</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    引入sleuth与zipkin相关依赖    --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--包含了 sleuth+zipkin--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230603230040079.png" alt="image-20230603230040079" style="zoom:50%;" /><p><strong>2.</strong> <strong>修改</strong> <strong>member-service-provider-10000</strong> <strong>的</strong> <strong>appliaction.xml ,</strong> <strong>指定</strong> <strong>Zipkin</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">member-service-provider</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/e_commerce_center_db?serverTimezone=GMT%2B8&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">QWEASDzxc123</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="comment">#配置sleuth和zipkin</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://localhost:9411</span></span><br><span class="line">  <span class="attr">sleuth:</span></span><br><span class="line">    <span class="attr">sampler:</span></span><br><span class="line">      <span class="comment"># 采样率 在0～1之间，1表示全部采集</span></span><br><span class="line">      <span class="attr">probability:</span> <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.study.springcloud.entity</span></span><br><span class="line"><span class="comment">#配置eureka-client</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span> <span class="comment">#将自己注册到Eureka-server</span></span><br><span class="line">    <span class="comment">#表示从Eureka-server抓取注册信息</span></span><br><span class="line">    <span class="comment">#如果是单节点，可以不配置；</span></span><br><span class="line">    <span class="comment">#但是provider是一个集群，则必须将此项配置为true，这样才能配合Ribbon使用负载均衡功能</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 表示将自己注册到哪个eureka-</span></span><br><span class="line">      <span class="comment"># 将本服务注册到多个eureka-server，使用逗号间隔即可</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka9001.com:9001/eureka,http://eureka9002.com:9002/eureka</span></span><br><span class="line"><span class="comment">#  instance:</span></span><br><span class="line">    <span class="comment">#1秒发送一次心跳(默认是90秒</span></span><br><span class="line"><span class="comment">#    lease-renewal-interval-in-seconds: 1</span></span><br><span class="line">    <span class="comment">#服务端收到最后一次心跳后的等待时间上限</span></span><br><span class="line"><span class="comment">#    lease-expiration-duration-in-seconds: 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-2-4-服务消费方集成-Sleuth-x2F-Zipkin"><a href="#8-2-4-服务消费方集成-Sleuth-x2F-Zipkin" class="headerlink" title="8.2.4 服务消费方集成 Sleuth&#x2F;Zipkin"></a>8.2.4 服务消费方集成 Sleuth&#x2F;Zipkin</h3><p><strong>1.</strong> 修改 <strong>member-service-consumer-80</strong> 的 <strong>pom.xml ,</strong> 增加引入 <strong>sleuth+zipkin</strong></p><p><strong>2.</strong> 修改 <strong>member-service-consumer-80</strong> 的 <strong>appliaction.xml ,</strong> 指定 <strong>Zipkin</strong></p><h3 id="8-2-5-测试"><a href="#8-2-5-测试" class="headerlink" title="8.2.5 测试"></a><strong>8.2.5</strong> 测试</h3><h4 id="8-2-5-1-启动-e-commerce-eureka-server-9001"><a href="#8-2-5-1-启动-e-commerce-eureka-server-9001" class="headerlink" title="8.2.5.1 启动 e-commerce-eureka-server-9001"></a>8.2.5.1 启动 e-commerce-eureka-server-9001</h4><h4 id="8-2-5-2-启动-member-service-provider-10000"><a href="#8-2-5-2-启动-member-service-provider-10000" class="headerlink" title="8.2.5.2 启动 member-service-provider-10000"></a>8.2.5.2 启动 member-service-provider-10000</h4><h4 id="8-2-5-3-启动-member-service-consumer-80"><a href="#8-2-5-3-启动-member-service-consumer-80" class="headerlink" title="8.2.5.3 启动 member-service-consumer-80"></a>8.2.5.3 启动 member-service-consumer-80</h4><h4 id="8-2-5-4-浏览器-浏览器输入-http-localhost-member-consumer-get-1"><a href="#8-2-5-4-浏览器-浏览器输入-http-localhost-member-consumer-get-1" class="headerlink" title="8.2.5.4 浏览器: 浏览器输入: http://localhost/member/consumer/get/1"></a>8.2.5.4 浏览器: 浏览器输入: <a href="http://localhost/member/consumer/get/1">http://localhost/member/consumer/get/1</a></h4><h3 id="8-2-6-查看监控-amp-分析结果"><a href="#8-2-6-查看监控-amp-分析结果" class="headerlink" title="8.2.6 查看监控**&amp;**分析结果"></a>8.2.6 查看监控**&amp;**分析结果</h3><h4 id="8-2-6-1-查看监控-amp-分析结果"><a href="#8-2-6-1-查看监控-amp-分析结果" class="headerlink" title="8.2.6.1 查看监控&amp;分析结果"></a>8.2.6.1 查看监控&amp;分析结果</h4><p><strong>1.</strong> 查看 **Zipkin : <a href="http://localhost:9411/zipkin/">http://localhost:9411/zipkin/</a> **</p><p><strong>2.</strong> <strong>选择某个服务，看结果</strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230604102426067.png" alt="image-20230604102426067" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230604102442418.png" alt="image-20230604102442418" style="zoom:50%;" /><p><strong>3.</strong> 查看一次调用链路的深度，以及该链路包含请求,各个请求耗时，**<u><em>找到请求瓶颈，为优化提供依据</em></u>**(重要)</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230604102455803.png" alt="image-20230604102455803" style="zoom:50%;" /><p><strong>4.</strong> <strong>查看服务调用的依赖关系</strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230604102509066.png" alt="image-20230604102509066" style="zoom:50%;" /><h1 id="9-🌟SpringCloudAlibabaNacos-服务注册中心-服务配置"><a href="#9-🌟SpringCloudAlibabaNacos-服务注册中心-服务配置" class="headerlink" title="9 🌟SpringCloudAlibabaNacos 服务注册中心+服务配置"></a>9 🌟SpringCloudAlibabaNacos 服务注册中心+服务配置</h1><h2 id="9-1-Nacos基础"><a href="#9-1-Nacos基础" class="headerlink" title="9.1 Nacos基础"></a>9.1 Nacos基础</h2><h3 id="9-1-1-官网"><a href="#9-1-1-官网" class="headerlink" title="9.1.1 官网"></a>9.1.1 官网</h3><h4 id="9-1-1-1-https-github-com-alibaba-Nacos"><a href="#9-1-1-1-https-github-com-alibaba-Nacos" class="headerlink" title="9.1.1.1 https://github.com/alibaba/Nacos"></a>9.1.1.1 <a href="https://github.com/alibaba/Nacos">https://github.com/alibaba/Nacos</a></h4><h3 id="9-1-2-Nacos是什么"><a href="#9-1-2-Nacos是什么" class="headerlink" title="9.1.2 Nacos是什么?"></a>9.1.2 Nacos是什么?</h3><h4 id="9-1-2-1-一句话-Nacos-就是注册中心-替代-Eureka-配置中心-替代-Config"><a href="#9-1-2-1-一句话-Nacos-就是注册中心-替代-Eureka-配置中心-替代-Config" class="headerlink" title="9.1.2.1 一句话: Nacos 就是注册中心[替代 Eureka]+配置中心[替代 Config]"></a>9.1.2.1 一句话: <u>Nacos 就是注册中心[替代 Eureka]+配置中心[替代 Config]</u></h4><h4 id="9-1-2-2-Nacos-Dynamic-Naming-and-Configuration-Service"><a href="#9-1-2-2-Nacos-Dynamic-Naming-and-Configuration-Service" class="headerlink" title="9.1.2.2 Nacos:Dynamic Naming and Configuration Service"></a>9.1.2.2 Nacos:Dynamic Naming and Configuration Service</h4><h4 id="9-1-2-3-Nacos-架构理论基础-CAP-理论-支持-AP-和-CP-可以切换"><a href="#9-1-2-3-Nacos-架构理论基础-CAP-理论-支持-AP-和-CP-可以切换" class="headerlink" title="9.1.2.3 Nacos:架构理论基础: CAP 理论 (支持 AP 和 CP, 可以切换)"></a>9.1.2.3 Nacos:架构理论基础: CAP 理论 (支持 AP 和 CP, 可以切换)</h4><p>CAP理论：</p><p>​一个分布式系统最多只能同时满足<strong>一致性</strong>（Consistency）、<strong>可用性</strong>（Availability）和<strong>分区容错性</strong>（Partition tolerance）这三项中的两项。</p><ul><li><strong>一致性</strong>指 “all nodes see the same data at the same time”，即所有节点在同一时间的数据完全一致。即多副本（Replications）问题中的数据一致性</li><li><strong>可用性</strong>指“<code>Reads and writes always succeed</code>”，即服务在正常响应时间内一直可用。好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。</li><li><strong>分区容错性</strong>指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务。</li></ul><p>比如对于两个结点如果它们之间的网络断开了，我们假设需要满足分区容错性，那么一定要在一致性和可用性之间进行取舍(分区容错性满足的情况下，如果满足一致性那就必须等待网络恢复后数据进行同步后才能提供服务——放弃了可用性；反之，如果选择了可用性，那么两个结点提供的数据一定不能保证一致性——牺牲了一致性)</p><h3 id="9-1-3-Nacos下载-amp-运行"><a href="#9-1-3-Nacos下载-amp-运行" class="headerlink" title="9.1.3 Nacos下载&amp;运行"></a>9.1.3 Nacos下载&amp;运行</h3><h4 id="9-1-3-1-下载-https-github-com-alibaba-nacos-releases-tag-1-2-1"><a href="#9-1-3-1-下载-https-github-com-alibaba-nacos-releases-tag-1-2-1" class="headerlink" title="9.1.3.1 下载: https://github.com/alibaba/nacos/releases/tag/1.2.1"></a>9.1.3.1 下载: <a href="https://github.com/alibaba/nacos/releases/tag/1.2.1">https://github.com/alibaba/nacos/releases/tag/1.2.1</a></h4><h4 id="9-1-3-2-环境要求-Java8-x2F-Maven-3-2-x"><a href="#9-1-3-2-环境要求-Java8-x2F-Maven-3-2-x" class="headerlink" title="9.1.3.2 环境要求: Java8&#x2F;Maven 3.2.x+"></a>9.1.3.2 环境要求: Java8&#x2F;Maven 3.2.x+</h4><h4 id="9-1-3-3-解压"><a href="#9-1-3-3-解压" class="headerlink" title="9.1.3.3 解压"></a>9.1.3.3 解压</h4><p>在我的mac中执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /Applications/nacos/bin//因为我把nacos放在了/Applications目录下</span><br><span class="line">sh startup.sh -m standalone//在nacos/bin目录下执行该语句即可成功启动nacos服务</span><br><span class="line">sh shutdown.sh//关闭nacos</span><br></pre></td></tr></table></figure><h4 id="9-1-3-4-浏览器-http-localhost-8848-nacos"><a href="#9-1-3-4-浏览器-http-localhost-8848-nacos" class="headerlink" title="9.1.3.4 浏览器 http://localhost:8848/nacos"></a>9.1.3.4 浏览器 <a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a></h4><h4 id="9-1-3-5-用户名-x2F-密码-为-nacos"><a href="#9-1-3-5-用户名-x2F-密码-为-nacos" class="headerlink" title="9.1.3.5 用户名&#x2F;密码 为 nacos"></a>9.1.3.5 用户名&#x2F;密码 为 nacos</h4><h2 id="9-2-创建-Nacos-服务提供者"><a href="#9-2-创建-Nacos-服务提供者" class="headerlink" title="9.2 创建 Nacos 服务提供者"></a>9.2 创建 Nacos 服务提供者</h2><h3 id="9-2-1-需求说明-x2F-图解"><a href="#9-2-1-需求说明-x2F-图解" class="headerlink" title="9.2.1 需求说明&#x2F;图解"></a>9.2.1 需求说明&#x2F;图解</h3><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230604111207532.png" alt="image-20230604111207532" style="zoom:50%;" /><h3 id="9-2-2-创建-member-service-nacos-provider-10004-并注册到-NacosServer8848"><a href="#9-2-2-创建-member-service-nacos-provider-10004-并注册到-NacosServer8848" class="headerlink" title="9.2.2 创建 member-service-nacos-provider-10004 并注册到 NacosServer8848"></a><strong>9.2.2</strong> 创建 member-service-nacos-provider-10004 并注册到 NacosServer8848</h3><h4 id="9-2-2-1-创建-member-service-nacos-provider-10004"><a href="#9-2-2-1-创建-member-service-nacos-provider-10004" class="headerlink" title="9.2.2.1 创建 member-service-nacos-provider-10004"></a>9.2.2.1 创建 member-service-nacos-provider-10004</h4><ol><li><p>参考<strong>member-service-provider-10000</strong> 来创建 <strong>member-service-nacos-provider-10004</strong> 即可</p></li><li><p>创建好后，使用member-service-provider-10000 的源码和配置替换member-service-nacos-provider-10004 生成的代码</p></li><li><p>提醒，拷贝时不要忘记拷贝 resources&#x2F;mapper&#x2F;MernberrVapper.xml 这些xeox.xrl 文件</p></li></ol><h4 id="9-2-2-2-修改父项目-pom-xml"><a href="#9-2-2-2-修改父项目-pom-xml" class="headerlink" title="9.2.2.2 修改父项目 pom.xml"></a>9.2.2.2 修改父项目 pom.xml</h4><p><strong>1.</strong> 参考官方文档 <strong><a href="https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_nacos_discovery">https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_nacos_discovery</a></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="9-2-2-3-修改本模块-pom-xml"><a href="#9-2-2-3-修改本模块-pom-xml" class="headerlink" title="9.2.2.3 修改本模块 pom.xml"></a>9.2.2.3 修改本模块 pom.xml</h4><p><strong>1.</strong> 将 <strong>member-service-provider-10000</strong> 的 <strong>pom.xml</strong> 的<dependencies>…</dependencies></p><p>拷贝过来，修改即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.study.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>e-commerce-center<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>member-service-nacos-provider-10004<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入nacos-start nacos场景启动器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--        使用版本仲裁，从父项目中获取版本--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        springboot程序的监控系统，实现系统健康检测</span></span><br><span class="line"><span class="comment">                    可以通过 http://localhost:10000/actuator 看到相关连接</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 引入 e_commerce_center-common-api --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.study.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>e_commerce_center-common-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="9-2-2-4-创建-application-yml"><a href="#9-2-2-4-创建-application-yml" class="headerlink" title="9.2.2.4 创建 application.yml"></a>9.2.2.4 创建 application.yml</h4><p><strong>1.</strong> 将 <strong>member-service-provider-10000</strong> 的 <strong>application.xml</strong> 拷贝过来，修改即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10004</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">member-service-nacos-provider</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/e_commerce_center_db?serverTimezone=GMT%2B8&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">QWEASDzxc123</span></span><br><span class="line"><span class="comment">#  配置nacos</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#配置nacos server的地址</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.study.springcloud.entity</span></span><br><span class="line"><span class="comment">#配置暴露所有的监控点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="9-2-2-5-创建主启动类"><a href="#9-2-2-5-创建主启动类" class="headerlink" title="9.2.2.5 创建主启动类"></a>9.2.2.5 创建主启动类</h4><p><strong>1.</strong> 创建主启动类 MemberNacosProviderApplication10004</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.springcloud;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入nacos发现的注解</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberNacosProviderApplication10004</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MemberNacosProviderApplication10004.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-2-2-6-为看到更好提示，修改-Controller"><a href="#9-2-2-6-为看到更好提示，修改-Controller" class="headerlink" title="9.2.2.6 为看到更好提示，修改 Controller"></a>9.2.2.6 为看到更好提示，修改 Controller</h4><p>……</p><h4 id="9-2-2-7-测试"><a href="#9-2-2-7-测试" class="headerlink" title="9.2.2.7 测试"></a>9.2.2.7 测试</h4><h5 id="9-2-2-7-1-启动-Nacos-Server-8848"><a href="#9-2-2-7-1-启动-Nacos-Server-8848" class="headerlink" title="9.2.2.7.1 启动 Nacos Server 8848"></a><strong>9.2.2.7.1</strong> 启动 Nacos Server 8848</h5><h5 id="9-2-2-7-2-启动-member-service-nacos-provider-10004"><a href="#9-2-2-7-2-启动-member-service-nacos-provider-10004" class="headerlink" title="9.2.2.7.2 启动 member-service-nacos-provider-10004"></a>9.2.2.7.2 启动 <strong>member-service-nacos-provider-10004</strong></h5><h5 id="9-2-2-7-3-观察-nacos-服务是否注册成功"><a href="#9-2-2-7-3-观察-nacos-服务是否注册成功" class="headerlink" title="9.2.2.7.3 观察 nacos 服务是否注册成功"></a><strong>9.2.2.7.3</strong> 观察 <strong>nacos</strong> 服务是否注册成功</h5><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230604130757230.png" alt="image-20230604130757230"></p><h3 id="9-2-3-创建-member-service-nacos-provider-10006-并注册到-NacosServer8848"><a href="#9-2-3-创建-member-service-nacos-provider-10006-并注册到-NacosServer8848" class="headerlink" title="9.2.3 创建 member-service-nacos-provider-10006 并注册到 NacosServer8848"></a>9.2.3 创建 member-service-nacos-provider-10006 并注册到 NacosServer8848</h3><h4 id="9-2-3-1-创建-member-service-nacos-provider-10006"><a href="#9-2-3-1-创建-member-service-nacos-provider-10006" class="headerlink" title="9.2.3.1 创建 member-service-nacos-provider-10006"></a>9.2.3.1 创建 member-service-nacos-provider-10006</h4><ol><li><p>参考member-service-nacos-provider-10004 来创建 member-service-nacos-provider-10006 即可</p></li><li><p>创建好后，使用member-service-nacos-provider-10004 的源码和配罝替换member-service-nacos-provider-10006 生成的代码</p></li><li><p>提醒，拷贝时不要忘记拷贝 resources&#x2F;mapper&#x2F;MemberMapper.xml 这些xoxx.xml文件</p></li></ol><h4 id="9-2-3-2-修改本模块-pom-xml"><a href="#9-2-3-2-修改本模块-pom-xml" class="headerlink" title="9.2.3.2 修改本模块 pom.xml"></a>9.2.3.2 修改本模块 pom.xml</h4><p><strong>1.</strong> 将 <strong>member-service-provider-10000</strong> 的 <strong>pom.xml</strong> 的<dependencies>…</dependencies></p><p>拷贝过来，修改即可</p><h4 id="9-2-3-3-创建-application-yml"><a href="#9-2-3-3-创建-application-yml" class="headerlink" title="9.2.3.3 创建 application.yml"></a>9.2.3.3 创建 application.yml</h4><p><strong>1.</strong> 将 <strong>member-service-nacos-provider-10004</strong> 的 <strong>application.xml</strong> 拷贝过来，修改端口即可</p><h4 id="9-2-3-4-创建主启动类"><a href="#9-2-3-4-创建主启动类" class="headerlink" title="9.2.3.4 创建主启动类"></a>9.2.3.4 创建主启动类</h4><p><strong>1.</strong> 创建主启动类 MemberNacosProviderApplication10006 (也复制过来，改个名称即可)</p><h4 id="9-2-3-5-为看到更好提示，修改-Controller"><a href="#9-2-3-5-为看到更好提示，修改-Controller" class="headerlink" title="9.2.3.5 为看到更好提示，修改 Controller"></a>9.2.3.5 为看到更好提示，修改 Controller</h4><h4 id="9-2-3-6-测试"><a href="#9-2-3-6-测试" class="headerlink" title="9.2.3.6 测试"></a>9.2.3.6 测试</h4><h5 id="9-2-3-6-1-保证-Nacos-Server-8848-是启动的"><a href="#9-2-3-6-1-保证-Nacos-Server-8848-是启动的" class="headerlink" title="9.2.3.6.1 保证 Nacos Server 8848 是启动的"></a><strong>9.2.3.6.1</strong> 保证 <strong>Nacos Server 8848</strong> 是启动的</h5><h5 id="9-2-3-6-2-启动-member-service-nacos-provider-10006"><a href="#9-2-3-6-2-启动-member-service-nacos-provider-10006" class="headerlink" title="9.2.3.6.2 启动 **member-service-nacos-provider-10006 **"></a><strong>9.2.3.6.2</strong> 启动 **member-service-nacos-provider-10006 **</h5><h5 id="9-2-3-6-3-观察-nacos-服务是否注册成功"><a href="#9-2-3-6-3-观察-nacos-服务是否注册成功" class="headerlink" title="9.2.3.6.3 观察 nacos 服务是否注册成功"></a><strong>9.2.3.6.3</strong> 观察 <strong>nacos</strong> 服务是否注册成功</h5><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230605235515301.png" alt="image-20230605235515301"></p><h5 id="9-2-3-6-4-浏览器-http-localhost-10006-member-get-1"><a href="#9-2-3-6-4-浏览器-http-localhost-10006-member-get-1" class="headerlink" title="9.2.3.6.4 浏览器**: http://localhost:10006/member/get/1**"></a><strong>9.2.3.6.4</strong> 浏览器**: <a href="http://localhost:10006/member/get/1">http://localhost:10006/member/get/1</a>**</h5><h2 id="9-3-创建-Nacos-的服务消费者"><a href="#9-3-创建-Nacos-的服务消费者" class="headerlink" title="9.3 创建 Nacos 的服务消费者"></a>9.3 创建 Nacos 的服务消费者</h2><h3 id="9-3-1-需求说明-x2F-图解"><a href="#9-3-1-需求说明-x2F-图解" class="headerlink" title="9.3.1 需求说明**&#x2F;**图解"></a><strong>9.3.1</strong> 需求说明**&#x2F;**图解</h3><p><strong>–</strong> 示意图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230619155537025.png" alt="image-20230619155537025" style="zoom:50%;" /><h3 id="9-3-2-创建-member-service-nacos-consumer-80-并注册到-NacosServer8848"><a href="#9-3-2-创建-member-service-nacos-consumer-80-并注册到-NacosServer8848" class="headerlink" title="9.3.2 创建 member-service-nacos-consumer-80 并注册到 NacosServer8848"></a><strong>9.3.2</strong> 创建 <strong>member-service-nacos-consumer-80</strong> 并注册到 <strong>NacosServer8848</strong></h3><h4 id="9-3-2-1-创建-member-service-nacos-consumer-80"><a href="#9-3-2-1-创建-member-service-nacos-consumer-80" class="headerlink" title="9.3.2.1 创建 member-service-nacos-consumer-80"></a>9.3.2.1 创建 member-service-nacos-consumer-80</h4><ol><li>参考 member-service-consumer-80 来创建 member-service-nacos-consumer-80 即可</li></ol><h4 id="9-3-2-2-修改-pom-xml"><a href="#9-3-2-2-修改-pom-xml" class="headerlink" title="9.3.2.2 修改 pom.xml"></a>9.3.2.2 修改 pom.xml</h4><p>将 <strong>member-service-consumer-80</strong> 的 <strong>pom.xml</strong> 的<dependencies>…</dependencies> 拷 贝过来，修改即可</p><h4 id="9-3-2-3-创建-application-yml"><a href="#9-3-2-3-创建-application-yml" class="headerlink" title="9.3.2.3 创建 application.yml"></a>9.3.2.3 创建 application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">member-service-consumer-80</span></span><br><span class="line">    <span class="comment">#配置nacos</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment">#启动nacos服务的ip以及端口</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure><h4 id="9-3-2-4-创建主启动类"><a href="#9-3-2-4-创建主启动类" class="headerlink" title="9.3.2.4 创建主启动类"></a>9.3.2.4 创建主启动类</h4><p>……</p><h4 id="9-3-2-5-业务类"><a href="#9-3-2-5-业务类" class="headerlink" title="9.3.2.5 业务类"></a>9.3.2.5 业务类</h4><p><em>nacos</em> 本身就集成了 <em>Ribbon,</em> 直接支持 <em>Ribbon(负载均衡)+RestTemplate(远程调用)</em> 调用</p><p><strong>1.</strong> 创建配置类 <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;config&#x2F;CustomizationBean.java</strong></p><p><strong>2.</strong> 创建 <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;MemberNacosConsumerController.java</strong></p><h4 id="9-3-2-6-测试"><a href="#9-3-2-6-测试" class="headerlink" title="9.3.2.6 测试"></a>9.3.2.6 测试</h4><h5 id="9-3-2-6-1-启动-Nacos-Server-8848"><a href="#9-3-2-6-1-启动-Nacos-Server-8848" class="headerlink" title="9.3.2.6.1 启动 Nacos Server 8848"></a><strong>9.3.2.6.1</strong> 启动 Nacos Server 8848</h5><h5 id="9-3-2-6-2-启动-member-service-nacos-provider-10004-x2F-10006-9-3-2-6-3-启动-member-service-nacos-consumer-80"><a href="#9-3-2-6-2-启动-member-service-nacos-provider-10004-x2F-10006-9-3-2-6-3-启动-member-service-nacos-consumer-80" class="headerlink" title="9.3.2.6.2 启动 member-service-nacos-provider-10004&#x2F;10006 9.3.2.6.3 启动 member-service-nacos-consumer-80"></a>9.3.2.6.2 启动 <strong>member-service-nacos-provider-10004&#x2F;10006 9.3.2.6.3</strong> 启动 member-service-nacos-consumer-80</h5><h5 id="9-3-2-6-4-浏览器-http-localhost-member-nacos-consumer-get-1"><a href="#9-3-2-6-4-浏览器-http-localhost-member-nacos-consumer-get-1" class="headerlink" title="9.3.2.6.4 浏览器**: http://localhost/member/nacos/consumer/get/1**"></a>9.3.2.6.4 浏览器**: <a href="http://localhost/member/nacos/consumer/get/1">http://localhost/member/nacos/consumer/get/1</a>**</h5><h4 id="9-3-2-7-配置自己的负载均衡算法，-测试完毕恢复成原来的轮询算法"><a href="#9-3-2-7-配置自己的负载均衡算法，-测试完毕恢复成原来的轮询算法" class="headerlink" title="9.3.2.7 配置自己的负载均衡算法， 测试完毕恢复成原来的轮询算法"></a>9.3.2.7 配置自己的负载均衡算法， 测试完毕恢复成原来的轮询算法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.springcloud.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.IRule;</span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.RandomRule;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/6/19</span></span><br><span class="line"><span class="comment"> * 16:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * RibbonRule配置类，配置自己的负载均衡算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RibbonRule</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IRule <span class="title function_">myRibbonRule</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-4-NacosAP和CP切换-理论"><a href="#9-4-NacosAP和CP切换-理论" class="headerlink" title="9.4 NacosAP和CP切换-理论"></a>9.4 NacosAP和CP切换-理论</h2><h3 id="9-4-1-各种注册中心对比"><a href="#9-4-1-各种注册中心对比" class="headerlink" title="9.4.1 各种注册中心对比"></a><strong>9.4.1</strong> 各种注册中心对比</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230619224742402.png" alt="image-20230619224742402"></p><h3 id="9-4-2-选择-AP-还是-CP"><a href="#9-4-2-选择-AP-还是-CP" class="headerlink" title="9.4.2 选择 AP 还是 CP?"></a><strong>9.4.2</strong> 选择 <strong>AP</strong> 还是 <strong>CP?</strong></h3><p> <strong>1</strong>、<strong>CP:</strong> 服务可以不能用，但必须要保证数据的一致性。<br> <strong>2</strong>、<strong>AP:</strong> 数据可以短暂不一致，但最终是需要一致的，无论如何都要保证服务的可用。<br> <strong>3</strong>、取舍:只能在 <strong>CP</strong> 和 <strong>AP</strong> 选择一个平衡点**,** 大多数都是选择 <strong>AP</strong> 模式</p><h3 id="9-4-3-AP和CP切换"><a href="#9-4-3-AP和CP切换" class="headerlink" title="9.4.3 AP和CP切换"></a><strong>9.4.3 AP</strong>和<strong>CP</strong>切换</h3><p><strong>Nacos</strong> 集群默认支持的是<strong>CAP</strong>原则中的<strong>AP</strong>原则，但是也可切换为<strong>CP</strong>原则**(<strong>一般不切换</strong>)**</p><h4 id="9-4-3-2-参考-https-www-jianshu-com-p-c56e22c222bb"><a href="#9-4-3-2-参考-https-www-jianshu-com-p-c56e22c222bb" class="headerlink" title="9.4.3.2 参考: https://www.jianshu.com/p/c56e22c222bb"></a>9.4.3.2 参考: <a href="https://www.jianshu.com/p/c56e22c222bb">https://www.jianshu.com/p/c56e22c222bb</a></h4><h2 id="9-5-Nacos-配置中心实例"><a href="#9-5-Nacos-配置中心实例" class="headerlink" title="9.5 Nacos 配置中心实例"></a>9.5 Nacos 配置中心实例</h2><h3 id="9-5-1-需求分析-x2F-图解"><a href="#9-5-1-需求分析-x2F-图解" class="headerlink" title="9.5.1 需求分析**&#x2F;**图解"></a><strong>9.5.1</strong> 需求分析**&#x2F;**图解</h3><p>微服务各个模块中有许多配置是相同的，在配置中心进行统一的配置不仅配置更方便，也便于日后修改。</p><p><strong>–</strong> 示意图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230619225914409.png" alt="image-20230619225914409" style="zoom: 33%;" /><h3 id="9-5-2-在-Nacos-Server-加入配置"><a href="#9-5-2-在-Nacos-Server-加入配置" class="headerlink" title="9.5.2 在 Nacos Server 加入配置"></a><strong>9.5.2</strong> 在 <strong>Nacos Server</strong> 加入配置</h3><ol><li>进入到 Nacos Server</li><li>加入配置， 老韩特别提醒: 文件后缀.yaml 别忘了</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230619230758715.png" alt="image-20230619230758715" style="zoom:50%;" /><p><strong>Data ID: e-commerce-nacos-config-client-dev.yaml</strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230619230855754.png" alt="image-20230619230855754" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230619230930267.png" alt="image-20230619230930267" style="zoom:50%;" /><h3 id="9-5-3-创建-Nacos-配置客户端模块-e-commerce-nacos-config-client5000"><a href="#9-5-3-创建-Nacos-配置客户端模块-e-commerce-nacos-config-client5000" class="headerlink" title="9.5.3 创建 Nacos 配置客户端模块 e-commerce-nacos-config-client5000"></a><strong>9.5.3</strong> 创建 <strong>Nacos</strong> 配置客户端模块 <strong>e-commerce-nacos-config-client5000</strong></h3><h4 id="9-5-3-1-创建-Module"><a href="#9-5-3-1-创建-Module" class="headerlink" title="9.5.3.1 创建 Module"></a>9.5.3.1 创建 Module</h4><p>先创建 <strong>e-commerce-nacos-config-client5000</strong> 模块，参考以前的方法</p><h4 id="9-5-3-2-修改-pom-xml"><a href="#9-5-3-2-修改-pom-xml" class="headerlink" title="9.5.3.2 修改 pom.xml"></a>9.5.3.2 修改 pom.xml</h4><p><strong>1.</strong> 修改 <strong>pom.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在之前的消费方xml文件的基础上添加：</span><br><span class="line"><span class="comment">&lt;!--nacos-config--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="9-5-3-3-创建-application-xml"><a href="#9-5-3-3-创建-application-xml" class="headerlink" title="9.5.3.3 创建 application.xml"></a>9.5.3.3 创建 application.xml</h4><p>创建 <strong>application.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#指定环境，常见的环境有 dev/test/prod 开发，测试，生产</span></span><br></pre></td></tr></table></figure><p>参考*: <a href="https://blog.csdn.net/zsl131557/article/details/80886114">https://blog.csdn.net/zsl131557/article/details/80886114</a>*</p><h4 id="9-5-3-4-创建-bootstrap-yml"><a href="#9-5-3-4-创建-bootstrap-yml" class="headerlink" title="9.5.3.4 创建 bootstrap.yml"></a>9.5.3.4 创建 bootstrap.yml</h4><p>创建 <strong>bootstrap.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 这里的name 需要参考nacos配置中心的DataId</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">e-commerce-nacos-config-client</span></span><br><span class="line">  <span class="comment">#配置nacos</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#nacos配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定读取配置中心的yaml后缀的配置</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#老韩解读[重要]</span></span><br><span class="line"><span class="comment">#nacos 配置客户端，会根据配置，找到资源获取配置文件</span></span><br><span class="line"><span class="comment">#(1 config-server-addr)                       localhost:8848</span></span><br><span class="line"><span class="comment">#(2 spring.application.name/对应 DataId)       e-commerce-nacos-config-client </span></span><br><span class="line"><span class="comment">#(3 spring.profiles.active)                   dev</span></span><br><span class="line"><span class="comment">#(4 spring.cloud.nacos.config.file-extension 文件扩展名)    .yaml</span></span><br><span class="line"><span class="comment">#也就到 localhost:8848 下的 e-commerce-nacos-config-client-dev.yaml 获取配置信息</span></span><br><span class="line"><span class="comment">#规则总结: $&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span></span><br></pre></td></tr></table></figure><h4 id="9-5-3-5-主启动类"><a href="#9-5-3-5-主启动类" class="headerlink" title="9.5.3.5 主启动类"></a>9.5.3.5 主启动类</h4><p>……</p><h4 id="9-5-3-6-业务类"><a href="#9-5-3-6-业务类" class="headerlink" title="9.5.3.6 业务类"></a>9.5.3.6 业务类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.springcloud.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/6/20</span></span><br><span class="line"><span class="comment"> * 15:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NacosConfigClientController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解读 <span class="doctag">@Value</span>(&quot;$&#123;config.ip&#125;&quot;)</span></span><br><span class="line"><span class="comment">    * 1. client 会拉取 Nacos Server 的 e-commerce-nacos-config-client-dev.yaml * config:</span></span><br><span class="line"><span class="comment">    * ip: &quot;122.11.11.11&quot;</span></span><br><span class="line"><span class="comment">    * name: &quot;韩顺平教育&quot;</span></span><br><span class="line"><span class="comment">    * 2. <span class="doctag">@Value</span>(&quot;$&#123;config.ip&#125;&quot;) 会将 config.ip 赋给 configIp</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.ip&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configIp;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/nacos/config/ip&quot;)</span> <span class="keyword">public</span> String <span class="title function_">getConfigIp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> configIp; &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/nacos/config/name&quot;)</span> <span class="keyword">public</span> String <span class="title function_">getConfigName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> configName; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-5-3-7-测试"><a href="#9-5-3-7-测试" class="headerlink" title="9.5.3.7 测试"></a>9.5.3.7 测试</h4><h5 id="9-5-3-7-1-启动-Nacos-Server"><a href="#9-5-3-7-1-启动-Nacos-Server" class="headerlink" title="9.5.3.7.1 启动 **Nacos Server"></a><strong>9.5.3.7.1</strong> 启动 **Nacos Server</h5><h5 id="9-5-3-7-2-启动-e-commerce-nacos-config-client5000"><a href="#9-5-3-7-2-启动-e-commerce-nacos-config-client5000" class="headerlink" title="9.5.3.7.2 启动 **e-commerce-nacos-config-client5000 **"></a>9.5.3.7.2 启动 **e-commerce-nacos-config-client5000 **</h5><h5 id="9-5-3-7-3-浏览器-http-localhost-5000-nacos-config-ip"><a href="#9-5-3-7-3-浏览器-http-localhost-5000-nacos-config-ip" class="headerlink" title="9.5.3.7.3 浏览器**: http://localhost:5000/nacos/config/ip**"></a><strong>9.5.3.7.3</strong> 浏览器**: <a href="http://localhost:5000/nacos/config/ip">http://localhost:5000/nacos/config/ip</a>**</h5><p>​浏览器输入**: <a href="http://localhost:5000/nacos/config/ip">http://localhost:5000/nacos/config/ip</a>**</p><h4 id="9-5-3-8-注意事项和细节"><a href="#9-5-3-8-注意事项和细节" class="headerlink" title="9.5.3.8 注意事项和细节"></a>9.5.3.8 注意事项和细节</h4><p><strong>0. src\main\java\com\study\springcloud\controller\NacosConfigClientController.java</strong> 的 @Value(“${config.ip}”), 是 import org.springframework.beans.factory.annotation.Value; 而不是 lombok 包下的.</p><p><strong>1.</strong> <strong>配置文件</strong> <strong>application.yml</strong> <strong>和</strong> <strong>bootstrap.yml</strong> 结合会得到配置文件&#x2F;资源的地址</p><p> <strong>2.</strong> <strong>参考文档</strong>: <a href="https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html">https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html</a></p><p><strong>3.</strong> <strong>注意在</strong> <strong>Nacos Server</strong> <strong>的配置文件的后缀是</strong> <strong>.yaml ,</strong> <strong>而不是</strong> <strong>.yml</strong></p><p><strong>4.</strong> <strong>在项目初始化时，要保证先从配置中心进行配置拉取，拉取配置之后，才能保证项目的正常启动</strong>, <strong>也就是说如果项目不能正确的获取到</strong> <strong>Nacos Server</strong> <strong>的配置数据，项目是启动不了的</strong>.[<strong>演示</strong>]</p><p><strong>5. springboot</strong> <strong>中配置文件的加载是存在优先级顺序的，</strong>bootstrap.yml <strong>优先级高于</strong> <strong>application.yml</strong></p><p>🌟<strong>6.</strong> <strong>@RefreshScope</strong> <strong>是</strong> <strong>springcloud</strong> <strong>原生注解，实现配置信息自动刷新</strong>, <strong>如果在</strong> <strong>Nacos Server</strong> <strong>修改了配置数据，</strong>Client <strong>端就会得到最新配置</strong></p><h2 id="9-6-Nacos-分类配置-实现配置隔离"><a href="#9-6-Nacos-分类配置-实现配置隔离" class="headerlink" title="9.6 Nacos 分类配置 (实现配置隔离)"></a>9.6 Nacos 分类配置 (实现配置隔离)</h2><h3 id="9-6-1-DataID方案"><a href="#9-6-1-DataID方案" class="headerlink" title="9.6.1 DataID方案"></a><strong>9.6.1 DataID</strong>方案</h3><h4 id="9-6-1-1-需求分析-x2F-图解"><a href="#9-6-1-1-需求分析-x2F-图解" class="headerlink" title="9.6.1.1 需求分析&#x2F;图解"></a>9.6.1.1 需求分析&#x2F;图解</h4><p><strong>–</strong> 示意图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620155605713.png" alt="image-20230620155605713" style="zoom:50%;" /><h4 id="9-6-1-2-解决方案分析"><a href="#9-6-1-2-解决方案分析" class="headerlink" title="9.6.1.2 解决方案分析"></a>9.6.1.2 解决方案分析</h4><h5 id="9-6-1-2-1-使用-Data-ID-方案解决"><a href="#9-6-1-2-1-使用-Data-ID-方案解决" class="headerlink" title="9.6.1.2.1 使用 Data ID 方案解决"></a><strong>9.6.1.2.1</strong> 使用 <strong>Data ID</strong> 方案解决</h5><h4 id="9-6-1-3-配置实现"><a href="#9-6-1-3-配置实现" class="headerlink" title="9.6.1.3 配置实现"></a>9.6.1.3 配置实现</h4><p><strong>1.</strong> 在 <strong>nacos server</strong> 创建新的配置:<strong>e-commerce-nacos-config-client-test.yaml</strong></p><h4 id="9-6-1-4-修改-application-yml"><a href="#9-6-1-4-修改-application-yml" class="headerlink" title="9.6.1.4 修改 application.yml"></a>9.6.1.4 修改 application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">test</span> <span class="comment">#指定环境，常见的环境有 dev/test/prod 开发，测试，生产</span></span><br></pre></td></tr></table></figure><h4 id="9-6-1-5-测试"><a href="#9-6-1-5-测试" class="headerlink" title="9.6.1.5 测试"></a>9.6.1.5 测试</h4><h5 id="9-6-1-5-1-浏览器-http-localhost-5000-nacos-config-ip"><a href="#9-6-1-5-1-浏览器-http-localhost-5000-nacos-config-ip" class="headerlink" title="9.6.1.5.1 浏览器**: http://localhost:5000/nacos/config/ip**"></a><strong>9.6.1.5.1</strong> 浏览器**: <a href="http://localhost:5000/nacos/config/ip">http://localhost:5000/nacos/config/ip</a>**</h5><p>**1.**浏览器输入: <a href="http://localhost:5000/nacos/config/ip">http://localhost:5000/nacos/config/ip</a></p><h3 id="9-6-2-Group方案"><a href="#9-6-2-Group方案" class="headerlink" title="9.6.2 Group方案"></a><strong>9.6.2 Group</strong>方案</h3><h4 id="9-6-2-1-需求分析-x2F-图解"><a href="#9-6-2-1-需求分析-x2F-图解" class="headerlink" title="9.6.2.1 需求分析&#x2F;图解"></a>9.6.2.1 需求分析&#x2F;图解</h4><p><strong>–</strong> 示意图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620161153853.png" alt="image-20230620161153853" style="zoom:50%;" /><h4 id="9-6-2-2-解决方案分析"><a href="#9-6-2-2-解决方案分析" class="headerlink" title="9.6.2.2 解决方案分析"></a>9.6.2.2 解决方案分析</h4><h5 id="9-6-2-2-1-使用-Group-方案解决"><a href="#9-6-2-2-1-使用-Group-方案解决" class="headerlink" title="9.6.2.2.1 使用 Group 方案解决"></a><strong>9.6.2.2.1</strong> 使用 <strong>Group</strong> 方案解决</h5><h4 id="9-6-2-3-配置实现"><a href="#9-6-2-3-配置实现" class="headerlink" title="9.6.2.3 配置实现"></a>9.6.2.3 配置实现</h4><p><strong>1.</strong> 在 <strong>nacos server</strong> 创建新的配置:<strong>order&#x2F;e-commerce-nacos-config-client-dev.yaml</strong></p><p><strong>2.</strong> <strong>在</strong> <strong>nacos server</strong> **创建新的配置:**seckill&#x2F;e-commerce-nacos-config-client-dev.yaml</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230620161749751.png" alt="image-20230620161749751" style="zoom:50%;" /><h4 id="9-6-2-4-修改-application-yml"><a href="#9-6-2-4-修改-application-yml" class="headerlink" title="9.6.2.4 修改 application.yml"></a>9.6.2.4 修改 application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#指定环境，常见的环境有 dev/test/prod 开发，测试，生产</span></span><br></pre></td></tr></table></figure><h4 id="9-6-2-5-修改-bootstrap-yml"><a href="#9-6-2-5-修改-bootstrap-yml" class="headerlink" title="9.6.2.5 修改 bootstrap.yml"></a>9.6.2.5 修改 bootstrap.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">20000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 这里的name 需要参考nacos配置中心的DataId</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">e-commerce-nacos-config-client</span></span><br><span class="line">  <span class="comment">#配置nacos</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#nacos配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定读取配置中心的yaml后缀的配置</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">order</span> <span class="comment">#指定order组，默认为DEFAULT_GROUP</span></span><br></pre></td></tr></table></figure><h4 id="9-6-2-6-测试"><a href="#9-6-2-6-测试" class="headerlink" title="9.6.2.6 测试"></a>9.6.2.6 测试</h4><h5 id="9-6-2-6-1-浏览器-http-localhost-5000-nacos-config-ip"><a href="#9-6-2-6-1-浏览器-http-localhost-5000-nacos-config-ip" class="headerlink" title="9.6.2.6.1 浏览器**: http://localhost:5000/nacos/config/ip**"></a><strong>9.6.2.6.1</strong> 浏览器**: <a href="http://localhost:5000/nacos/config/ip">http://localhost:5000/nacos/config/ip</a>**</h5><p>**1.**浏览器输入: <a href="http://localhost:5000/nacos/config/ip">http://localhost:5000/nacos/config/ip</a></p><h3 id="9-6-3-Namespace方案"><a href="#9-6-3-Namespace方案" class="headerlink" title="9.6.3 Namespace方案"></a><strong>9.6.3 Namespace</strong>方案</h3><h4 id="9-6-3-1-需求分析-x2F-图解"><a href="#9-6-3-1-需求分析-x2F-图解" class="headerlink" title="9.6.3.1 需求分析&#x2F;图解"></a>9.6.3.1 需求分析&#x2F;图解</h4><p><strong>–</strong> 示意图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620162224978.png" alt="image-20230620162224978" style="zoom:50%;" /><h4 id="9-6-3-2-解决方案分析"><a href="#9-6-3-2-解决方案分析" class="headerlink" title="9.6.3.2 解决方案分析"></a>9.6.3.2 解决方案分析</h4><h5 id="9-6-3-2-1-使用-Namespace-方案解决"><a href="#9-6-3-2-1-使用-Namespace-方案解决" class="headerlink" title="9.6.3.2.1 使用 Namespace 方案解决"></a><strong>9.6.3.2.1</strong> 使用 <strong>Namespace</strong> 方案解决</h5><h4 id="9-6-3-3-配置实现"><a href="#9-6-3-3-配置实现" class="headerlink" title="9.6.3.3 配置实现"></a>9.6.3.3 配置实现</h4><p><strong>1.</strong> 在 <strong>nacos server</strong> 创建新的 <strong>namespace , baidu</strong> 和 <strong>alibaba</strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620162934242.png" alt="image-20230620162934242" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620163057931.png" alt="image-20230620163057931" style="zoom:50%;" /><p><strong>2.</strong> <strong>在</strong> <strong>nacos server</strong> <strong>创建新的</strong> <strong>group&#x2F;dataid</strong></p><h4 id="9-6-3-4-修改-application-yml"><a href="#9-6-3-4-修改-application-yml" class="headerlink" title="9.6.3.4 修改 application.yml"></a>9.6.3.4 修改 application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#指定环境，常见的环境有 dev/test/prod 开发，测试，生产</span></span><br></pre></td></tr></table></figure><h4 id="9-6-3-5-修改-bootstrap-yml"><a href="#9-6-3-5-修改-bootstrap-yml" class="headerlink" title="9.6.3.5 修改 bootstrap.yml"></a>9.6.3.5 修改 bootstrap.yml</h4><p><strong>1.</strong> 增加 <strong>Namespace</strong> 参数</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">20000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 这里的name 需要参考nacos配置中心的DataId</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">e-commerce-nacos-config-client</span></span><br><span class="line">  <span class="comment">#配置nacos</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#nacos配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定读取配置中心的yaml后缀的配置</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">seckill</span> <span class="comment">#指定order组，默认为DEFAULT_GROUP</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">8b005a7a-89b9-40ba-a5da-aac3e6c7a564</span></span><br></pre></td></tr></table></figure><h4 id="9-6-3-6-测试"><a href="#9-6-3-6-测试" class="headerlink" title="9.6.3.6 测试"></a>9.6.3.6 测试</h4><h5 id="9-6-3-6-1-浏览器-http-localhost-5000-nacos-config-ip"><a href="#9-6-3-6-1-浏览器-http-localhost-5000-nacos-config-ip" class="headerlink" title="9.6.3.6.1 浏览器**: http://localhost:5000/nacos/config/ip**"></a><strong>9.6.3.6.1</strong> 浏览器**: <a href="http://localhost:5000/nacos/config/ip">http://localhost:5000/nacos/config/ip</a>**</h5><p>**1.**浏览器输入: <a href="http://localhost:5000/nacos/config/ip">http://localhost:5000/nacos/config/ip</a></p><h3 id="9-6-4-Namespace-x2F-Group-x2F-Data-ID-关系"><a href="#9-6-4-Namespace-x2F-Group-x2F-Data-ID-关系" class="headerlink" title="9.6.4 Namespace&#x2F;Group&#x2F;Data ID 关系"></a><strong>9.6.4 Namespace&#x2F;Group&#x2F;Data ID</strong> 关系</h3><h4 id="9-6-4-1-一图胜千言"><a href="#9-6-4-1-一图胜千言" class="headerlink" title="9.6.4.1 一图胜千言"></a>9.6.4.1 一图胜千言</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620164046357.png" alt="image-20230620164046357" style="zoom:50%;" /><h4 id="9-6-4-2-详解介绍"><a href="#9-6-4-2-详解介绍" class="headerlink" title="9.6.4.2 详解介绍"></a>9.6.4.2 详解介绍</h4><p><strong>1. namespace &#x2F; group &#x2F; data id</strong> 的关系</p><p>2.梳理:</p><ul><li><p>Nacos默认的命名空间是public，Namespace主要用来实现配置隔离,隔离范围大</p></li><li><p>Group默认是DEFAULT GROUP, Group可以把不同的微服务划分到同一个分组里面去</p></li><li><p>Service就是微服务,相同的Service可以是一个Cluster(簇&#x2F;集群), Instance就是微服务的实例</p></li></ul><h1 id="10-SpringCloud-Alibaba-Sentinel——分布式系统的流量哨兵"><a href="#10-SpringCloud-Alibaba-Sentinel——分布式系统的流量哨兵" class="headerlink" title="10 SpringCloud Alibaba Sentinel——分布式系统的流量哨兵"></a>10 SpringCloud Alibaba Sentinel——分布式系统的流量哨兵</h1><h2 id="10-1-Sentinel基础"><a href="#10-1-Sentinel基础" class="headerlink" title="10.1 Sentinel基础"></a>10.1 Sentinel基础</h2><h3 id="10-1-1-官网"><a href="#10-1-1-官网" class="headerlink" title="10.1.1 官网"></a><strong>10.1.1</strong> 官网</h3><h4 id="10-1-1-1-Github-https-github-com-alibaba-Sentinel"><a href="#10-1-1-1-Github-https-github-com-alibaba-Sentinel" class="headerlink" title="10.1.1.1 Github: https://github.com/alibaba/Sentinel"></a>10.1.1.1 Github: <a href="https://github.com/alibaba/Sentinel">https://github.com/alibaba/Sentinel</a></h4><h4 id="10-1-1-2-快速开始-https-sentinelguard-io-zh-cn-docs-quick-start-html"><a href="#10-1-1-2-快速开始-https-sentinelguard-io-zh-cn-docs-quick-start-html" class="headerlink" title="10.1.1.2 快速开始: https://sentinelguard.io/zh-cn/docs/quick-start.html"></a>10.1.1.2 快速开始: <a href="https://sentinelguard.io/zh-cn/docs/quick-start.html">https://sentinelguard.io/zh-cn/docs/quick-start.html</a></h4><h4 id="10-1-1-3-中文-https-github-com-alibaba-Sentinel-wiki-E4-BB-8B-E7-BB-8D"><a href="#10-1-1-3-中文-https-github-com-alibaba-Sentinel-wiki-E4-BB-8B-E7-BB-8D" class="headerlink" title="10.1.1.3 中文: https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D"></a>10.1.1.3 中文: <a href="https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D">https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D</a></h4><h4 id="10-1-1-4-使-用-手-册-https-spring-cloud-alibaba-group-github-io-github-pages-greenwich-spring-cloud-alibaba-html-spring-cloud-alibaba-sentinel"><a href="#10-1-1-4-使-用-手-册-https-spring-cloud-alibaba-group-github-io-github-pages-greenwich-spring-cloud-alibaba-html-spring-cloud-alibaba-sentinel" class="headerlink" title="10.1.1.4 使 用 手 册 https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_sentinel"></a>10.1.1.4 使 用 手 册 <a href="https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_sentinel">https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_sentinel</a></h4><h3 id="10-1-2-Sentinel是什么"><a href="#10-1-2-Sentinel是什么" class="headerlink" title="10.1.2 Sentinel是什么?"></a><strong>10.1.2 Sentinel</strong>是什么?</h3><h4 id="10-1-2-1-Sentinel-概述"><a href="#10-1-2-1-Sentinel-概述" class="headerlink" title="10.1.2.1 Sentinel 概述"></a>10.1.2.1 Sentinel 概述</h4><ol><li>Sentinel 是什么?</li></ol><p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p><ol start="2"><li>Sentinel 的主要特性</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620201315601.png" alt="image-20230620201315601"></p><p><strong>梳理</strong>: sentinel **可以完成的功能 **: <strong>绿色方框</strong>列出的部分</p><ol start="3"><li>Sentinel 的开源生态</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620201431927.png" alt="image-20230620201431927"></p><h4 id="10-1-2-2-一句话-Sentinel-分布式系统的流量防卫兵-保护你的微服务"><a href="#10-1-2-2-一句话-Sentinel-分布式系统的流量防卫兵-保护你的微服务" class="headerlink" title="10.1.2.2 一句话: Sentinel: 分布式系统的流量防卫兵, 保护你的微服务"></a>10.1.2.2 一句话: Sentinel: 分布式系统的流量防卫兵, 保护你的微服务</h4><h3 id="10-1-3-Sentinel核心功能"><a href="#10-1-3-Sentinel核心功能" class="headerlink" title="10.1.3 Sentinel核心功能"></a><strong>10.1.3 Sentinel</strong>核心功能</h3><h4 id="10-1-3-1-流量控制"><a href="#10-1-3-1-流量控制" class="headerlink" title="10.1.3.1 流量控制"></a>10.1.3.1 流量控制</h4><h4 id="10-1-3-2-熔断降级"><a href="#10-1-3-2-熔断降级" class="headerlink" title="10.1.3.2 熔断降级"></a>10.1.3.2 熔断降级</h4><p><strong>-</strong> 在调用系统的时候，如果调用链路中的某个资源出现了不稳定，最终会导致请求发生堆积，如下图：</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620201814295.png" alt="image-20230620201814295" style="zoom:50%;" /><p><strong>解读</strong>：</p><p>​<u>熔断降级可以解决这个问题</u>，所谓的熔断降级就是当检测到调用链路中某个资源出现不稳定的表现，例如请求响应时间长或异常比例升高的时候，则<u>对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联故障</u>。</p><h4 id="10-1-3-3-系统负载保护"><a href="#10-1-3-3-系统负载保护" class="headerlink" title="10.1.3.3 系统负载保护"></a>10.1.3.3 系统负载保护</h4><p>​根据系统能够处理的请求，和允许进来的请求，来做平衡，追求的目标是在系统不被拖垮的情况下**,** 提高系统的吞吐率</p><h4 id="10-1-3-4-消息削峰填谷"><a href="#10-1-3-4-消息削峰填谷" class="headerlink" title="10.1.3.4 消息削峰填谷"></a>10.1.3.4 消息削峰填谷</h4><p>​某瞬时来了大流量的请求**,** 而如果此时要处理所有请求，很可能会导致系统负载过高，影响稳定性。</p><p>​但其实可能后面几秒之内都没有消息投递，若直接把多余的消息丢掉则没有充分利用系统处理消息的能力</p><p><strong>- Sentinel 的Rate Limiter模式能在某一段时间间隔内以匀速方式处理这样的请求, 充分利用系统的处理能力, 也就是削峰填谷, 保证资源的稳定性</strong></p><h3 id="10-1-4-Sentinel两个组成部分"><a href="#10-1-4-Sentinel两个组成部分" class="headerlink" title="10.1.4 Sentinel两个组成部分"></a><strong>10.1.4 Sentinel</strong>两个组成部分</h3><h4 id="10-1-4-1-核心库-Java-客户端-不依赖任何框架-x2F-库，能够运行在所有-Java运行时环境，对-Spring-Cloud有较好的支持"><a href="#10-1-4-1-核心库-Java-客户端-不依赖任何框架-x2F-库，能够运行在所有-Java运行时环境，对-Spring-Cloud有较好的支持" class="headerlink" title="10.1.4.1 核心库:(Java 客户端)不依赖任何框架&#x2F;库，能够运行在所有 Java运行时环境，对 Spring Cloud有较好的支持"></a>10.1.4.1 核心库:(Java 客户端)不依赖任何框架&#x2F;库，能够运行在所有 Java运行时环境，对 Spring Cloud有较好的支持</h4><h4 id="10-1-4-2-控制台-Dashboard-基于-Spring-Boot-开发，打包后可以直接运行，不需要额外的-Tomcat-等应用容器-就跟nacos、eureka那种控制台那样"><a href="#10-1-4-2-控制台-Dashboard-基于-Spring-Boot-开发，打包后可以直接运行，不需要额外的-Tomcat-等应用容器-就跟nacos、eureka那种控制台那样" class="headerlink" title="10.1.4.2 控制台:(Dashboard)基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器(就跟nacos、eureka那种控制台那样)"></a>10.1.4.2 控制台:(Dashboard)基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器(就跟nacos、eureka那种控制台那样)</h4><h2 id="10-2-Sentinel控制台"><a href="#10-2-Sentinel控制台" class="headerlink" title="10.2 Sentinel控制台"></a>10.2 Sentinel控制台</h2><h3 id="10-2-1-需求分析-x2F-图解"><a href="#10-2-1-需求分析-x2F-图解" class="headerlink" title="10.2.1 需求分析**&#x2F;**图解"></a><strong>10.2.1</strong> 需求分析**&#x2F;**图解</h3><p><strong>1.</strong> 需求**:** 搭建 <strong>Sentinel</strong> 控制台，用于显示各个微服务的使用情况</p><h3 id="10-2-2-下载"><a href="#10-2-2-下载" class="headerlink" title="10.2.2 下载"></a><strong>10.2.2</strong> 下载</h3><h4 id="10-2-2-1-https-github-com-alibaba-Sentinel-releases-tag-v1-8-0"><a href="#10-2-2-1-https-github-com-alibaba-Sentinel-releases-tag-v1-8-0" class="headerlink" title="10.2.2.1 https://github.com/alibaba/Sentinel/releases/tag/v1.8.0"></a>10.2.2.1 <a href="https://github.com/alibaba/Sentinel/releases/tag/v1.8.0">https://github.com/alibaba/Sentinel/releases/tag/v1.8.0</a></h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620203427041.png" alt="image-20230620203427041" style="zoom:50%;" /><h3 id="10-2-3-运行"><a href="#10-2-3-运行" class="headerlink" title="10.2.3 运行"></a><strong>10.2.3</strong> 运行</h3><h4 id="10-2-3-1-指令"><a href="#10-2-3-1-指令" class="headerlink" title="10.2.3.1 指令:"></a>10.2.3.1 指令:</h4><p>我把下载的jar包放在 &#x2F;Applications&#x2F;Java&#x2F;jar包资源 此处了</p><p>因此在终端运行以下指令即可启动 Sentinel</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /Applications/Java/jar包资源</span><br><span class="line">java -jar sentinel-dashboard-1.8.0.jar //启动</span><br><span class="line">java -jar sentinel-dashboard-1.8.0.jar --server.port=9999//也可以自定义端口运行该进程</span><br><span class="line">Ctrl+C即可关闭服务</span><br></pre></td></tr></table></figure><h4 id="10-2-3-2-注意-Sentinel-控制台-默认端口是-8080"><a href="#10-2-3-2-注意-Sentinel-控制台-默认端口是-8080" class="headerlink" title="10.2.3.2 注意: Sentinel 控制台 默认端口是 8080"></a>10.2.3.2 注意: Sentinel 控制台 默认端口是 8080</h4><h3 id="10-2-4-访问"><a href="#10-2-4-访问" class="headerlink" title="10.2.4 访问"></a><strong>10.2.4</strong> 访问</h3><h4 id="10-2-4-1-浏览器-http-localhost-8080"><a href="#10-2-4-1-浏览器-http-localhost-8080" class="headerlink" title="10.2.4.1 浏览器: http://localhost:8080"></a>10.2.4.1 浏览器: <a href="http://localhost:8080/">http://localhost:8080</a></h4><h4 id="10-2-4-2-控制台页面"><a href="#10-2-4-2-控制台页面" class="headerlink" title="10.2.4.2 控制台页面"></a>10.2.4.2 控制台页面</h4><p><strong>1.</strong> 浏览器输入**: <a href="http://localhost:8080/">http://localhost:8080</a> ,** 用户**&#x2F;**密码都是 <strong>sentinel</strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620203842208.png" alt="image-20230620203842208" style="zoom:25%;" /><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620204626829.png" alt="image-20230620204626829" style="zoom:50%;" /><p><strong>2.</strong> <strong>登录成功后的页面</strong>, <strong>目前是空的，因为</strong> <strong>sentinel</strong> <strong>还没有进行流量监控</strong></p><h2 id="10-3-Sentinel监控微服务"><a href="#10-3-Sentinel监控微服务" class="headerlink" title="10.3 Sentinel监控微服务"></a>10.3 Sentinel监控微服务</h2><h3 id="10-3-1-需求分析-x2F-图解"><a href="#10-3-1-需求分析-x2F-图解" class="headerlink" title="10.3.1 需求分析**&#x2F;**图解"></a><strong>10.3.1</strong> 需求分析**&#x2F;**图解</h3><ol><li>需求**:** 使用 <strong>Sentinel</strong> 控制台对 <strong>member-service-nacos-provider-10004</strong> 微服务 进行实时监控</li></ol><p><strong>–</strong> 示意图</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230620204744222.png" alt="image-20230620204744222" style="zoom: 50%;" /><ol start="2"><li>当调用了member-service-nacos-provider-10004微服务时,可以监控到请求的<strong>url&#x2F;QPS(每秒查询率)&#x2F;响应时间&#x2F;流量</strong></li></ol><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230620205650814.png" alt="image-20230620205650814" style="zoom:50%;" /><h3 id="10-3-2-代码-x2F-配置实现"><a href="#10-3-2-代码-x2F-配置实现" class="headerlink" title="10.3.2 代码**&#x2F;**配置实现"></a><strong>10.3.2</strong> 代码**&#x2F;**配置实现</h3><p><strong>1.</strong> 修改 <strong>member-service-nacos-provider-10004</strong> 的 <strong>pom.xml,</strong> 引入 <strong>alibaba-sentinel</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    引入alibaba-sentinel starter    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.</strong> <strong>修改</strong> <strong>member-service-nacos-provider-10004</strong> <strong>的</strong> <strong>application.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10004</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">member-service-nacos-provider</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/e_commerce_center_db?serverTimezone=GMT%2B8&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">QWEASDzxc123</span></span><br><span class="line"><span class="comment">#  配置nacos</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#配置nacos server的地址</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span> <span class="comment">#这个是 sentinel 控制台(sentinel dashboard)的地址 </span></span><br><span class="line">        <span class="comment">#解读 spring.cloud.sentinel.transport.port：</span></span><br><span class="line">        <span class="comment">#1. spring.cloud.sentinel.transport.port 端口配置会在被监控的微服务</span></span><br><span class="line">        <span class="comment"># 对应的机器上启动一个 Http Server</span></span><br><span class="line">        <span class="comment">#2. 该 Server 会与 Sentinel 控制台做交互</span></span><br><span class="line">        <span class="comment">#3. 比如 Sentinel 控制台添加了 1 个限流规则，会把规则数据 push 给这个</span></span><br><span class="line">        <span class="comment"># Http Server 接收，Http Server 再将规则注册到 微服务 中</span></span><br><span class="line">        <span class="comment">#4. 简单的说明: spring.cloud.sentinel.transport.port:指定被监控的微服务应用与</span></span><br><span class="line">        <span class="comment"># Sentinel 控制台交互的端口，微服务应用本地会起一个该端口占用的 Http Server</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span> <span class="comment">#默认 8719，假如被占用了, 会自动从 8719 开始依次+1 扫描。</span></span><br><span class="line">        <span class="comment">#直至找到未被占用的端口</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.study.springcloud.entity</span></span><br><span class="line"><span class="comment">#配置暴露所有的监控点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>3.</strong> <strong>成功启动后</strong>, netstat -anb <strong>可以查看到该端口</strong>.</p><h3 id="10-3-3-测试"><a href="#10-3-3-测试" class="headerlink" title="10.3.3 测试"></a><strong>10.3.3</strong> 测试</h3><h4 id="10-3-3-1-启动-Nacos-Server-8848"><a href="#10-3-3-1-启动-Nacos-Server-8848" class="headerlink" title="10.3.3.1 启动 Nacos Server 8848"></a>10.3.3.1 启动 Nacos Server 8848</h4><h4 id="10-3-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-3-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.3.3.2 启动 Sentinel8080 控制台 &#x2F; Sentinel dashboard"></a>10.3.3.2 启动 Sentinel8080 控制台 &#x2F; Sentinel dashboard</h4><h4 id="10-3-3-3-启动-member-service-nacos-provider-10004"><a href="#10-3-3-3-启动-member-service-nacos-provider-10004" class="headerlink" title="10.3.3.3 启动 member-service-nacos-provider-10004"></a>10.3.3.3 启动 member-service-nacos-provider-10004</h4><h4 id="10-3-3-4-浏览器-localhost-10004-x2F-member-x2F-get-x2F-1"><a href="#10-3-3-4-浏览器-localhost-10004-x2F-member-x2F-get-x2F-1" class="headerlink" title="10.3.3.4 浏览器: localhost:10004&#x2F;member&#x2F;get&#x2F;1"></a>10.3.3.4 浏览器: localhost:10004&#x2F;member&#x2F;get&#x2F;1</h4><h4 id="10-3-3-5-Sentinel-控制台监控页面"><a href="#10-3-3-5-Sentinel-控制台监控页面" class="headerlink" title="10.3.3.5 Sentinel 控制台监控页面"></a>10.3.3.5 Sentinel 控制台监控页面</h4><p><strong>1.</strong> 浏览器输入**: <a href="http://localhost:10004/member/get/1">http://localhost:10004/member/get/1</a>**</p><p><strong>2.</strong> <strong>进入到</strong> <strong>Sentinel</strong> <strong>查看实时监控效果</strong>, <a href="http://localhost:8080/#/dashboard">http://localhost:8080/#/dashboard</a></p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230620211122568.png" alt="image-20230620211122568" style="zoom:50%;" /><h3 id="10-3-4-注意事项和细节"><a href="#10-3-4-注意事项和细节" class="headerlink" title="10.3.4 注意事项和细节"></a><strong>10.3.4</strong> 注意事项和细节</h3><h4 id="10-3-4-1-QPS-Queries-Per-Second-每秒查询率-，是服务器每秒响应的查询次数"><a href="#10-3-4-1-QPS-Queries-Per-Second-每秒查询率-，是服务器每秒响应的查询次数" class="headerlink" title="10.3.4.1 QPS: Queries Per Second(每秒查询率)，是服务器每秒响应的查询次数"></a>10.3.4.1 QPS: Queries Per Second(每秒查询率)，是服务器每秒响应的查询次数</h4><h4 id="10-3-4-2-Sentinel采用的是懒加载，只有调用了某个接口-x2F-服务，才能看到监控数据"><a href="#10-3-4-2-Sentinel采用的是懒加载，只有调用了某个接口-x2F-服务，才能看到监控数据" class="headerlink" title="10.3.4.2 Sentinel采用的是懒加载，只有调用了某个接口&#x2F;服务，才能看到监控数据"></a>10.3.4.2 Sentinel采用的是懒加载，只有调用了某个接口&#x2F;服务，才能看到监控数据</h4><h2 id="10-4-Sentinel流量控制"><a href="#10-4-Sentinel流量控制" class="headerlink" title="10.4 Sentinel流量控制"></a>10.4 Sentinel流量控制</h2><h3 id="10-4-1-规则"><a href="#10-4-1-规则" class="headerlink" title="10.4.1 规则"></a><strong>10.4.1</strong> 规则</h3><p><strong>1.</strong> 先看一张图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620211426555.png" alt="image-20230620211426555" style="zoom:40%;" /><ol start="2"><li>对上图的解读</li></ol><ul><li><p>资源名：唯一名称，默认请求路径</p></li><li><p>针对来源：Sentine可以<u>针对调用者进行限流，填写微服务名</u>，默认default（不区分来源）</p></li><li><p>阈值类型&#x2F;单机阈值：</p><ul><li>QPS（每秒钟的请求数量）：当调用该 api 的 QPS 达到阈值的时候，进行限流</li><li>线程数：当调用该 api 的线程数达到阈值的时候，进行限流</li></ul></li></ul><p>解读： <strong>QPS和线程数的区别</strong>，注意听，比如 QPS和线程我们都设置阈值为1</p><p>（1）对QPS而言，如果在1秒内，客户端发出了2 次请求，就达到阈值，从而限流</p><p>（2）对线程数而言，如果在1秒内，客户端发出了2 次请求，不一定达到线程限制的國值，为什么呢？假设我们1 次请求后台会创建一个线程，但是这个请求完成时间是 0.1 秒（可以视为该请求对应的线程存活 0.1 秒)，所以当客户端第2 次请求时(比如客户端是在0.3秒发出的），这时第 1个请求的线程就己经结束了，因此就没有达到线程的闻值，也不会限流。</p><p>（3）小伙伴可以这样理解，如果1个请求对应的线程平均执行时间为 0.1 那么，就相当于 QPS 为 10</p><ul><li><p>是否集群：不需要集群</p></li><li><p>流控模式：</p><ul><li>直接：api 达到限流条件时，直接限流</li><li>关联：当关联的资源达到闻值时，就限流自己</li><li>链路：当从某个接口过来的资源达到限流条件时，开启限流</li></ul></li><li><p>流控效果：</p><ul><li>快速失败：直接失败，抛异常</li><li>Warm Up：根据 code Factor（冷加载因子，默认3）的值，从阈值&#x2F;codeFactor，经过预热时长，才达到设置的 QPS 阈值</li><li>排队等待：匀速排队，让请求以匀速的速度通过，阈值类型必须设置为 QPS， 否则无效</li></ul></li></ul><h3 id="10-4-2-流量控制实例-QPS"><a href="#10-4-2-流量控制实例-QPS" class="headerlink" title="10.4.2 流量控制实例**-QPS**"></a><strong>10.4.2</strong> 流量控制实例**-QPS**</h3><h4 id="10-4-2-1-需求分析-x2F-图解"><a href="#10-4-2-1-需求分析-x2F-图解" class="headerlink" title="10.4.2.1 需求分析&#x2F;图解"></a>10.4.2.1 需求分析&#x2F;图解</h4><p> <strong>1.</strong> 需求**:** 通过 <strong>Sentinel</strong> 实现 流量控制<br> <strong>2.</strong> <strong>当调用</strong> <strong>member-service-nacos-provider-10004</strong> <strong>的</strong> <strong>&#x2F;member&#x2F;get&#x2F;</strong>   **API **时，限制 <strong>1</strong>秒内最多访问 <strong>1</strong> <strong>次，否则直接失败，抛异常</strong></p><h4 id="10-4-2-2-配置实现步骤"><a href="#10-4-2-2-配置实现步骤" class="headerlink" title="10.4.2.2 配置实现步骤"></a>10.4.2.2 配置实现步骤</h4><p> <strong>1.</strong> 为**&#x2F;member&#x2F;get&#x2F;1** 增加流控规则</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230622221155249.png" alt="image-20230622221155249"></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230622221223336.png" alt="image-20230622221223336" style="zoom:40%;" /><p><strong>2.</strong> <strong>在流控规则菜单，可以看到新增的流控规则</strong></p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230622221447805.png" alt="image-20230622221447805" style="zoom: 33%;" /><h4 id="10-4-2-3-测试"><a href="#10-4-2-3-测试" class="headerlink" title="10.4.2.3 测试"></a>10.4.2.3 测试</h4><h5 id="10-4-2-3-1-启动-Nacos-Server-8848"><a href="#10-4-2-3-1-启动-Nacos-Server-8848" class="headerlink" title="10.4.2.3.1 启动 Nacos Server 8848"></a><strong>10.4.2.3.1</strong> 启动 Nacos Server 8848</h5><h5 id="10-4-2-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard-10-4-2-3-3-启动-member-service-nacos-provider-10004"><a href="#10-4-2-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard-10-4-2-3-3-启动-member-service-nacos-provider-10004" class="headerlink" title="10.4.2.3.2 启动 Sentinel8080 控制台**&#x2F;Sentinel dashboard 10.4.2.3.3** 启动 **member-service-nacos-provider-10004 **"></a>10.4.2.3.2 启动 <strong>Sentinel8080</strong> 控制台**&#x2F;Sentinel dashboard 10.4.2.3.3** 启动 **member-service-nacos-provider-10004 **</h5><h5 id="10-4-2-3-4-浏览器-localhost-10004-x2F-member-x2F-get-x2F-1"><a href="#10-4-2-3-4-浏览器-localhost-10004-x2F-member-x2F-get-x2F-1" class="headerlink" title="10.4.2.3.4 浏览器**: localhost:10004&#x2F;member&#x2F;get&#x2F;1 **"></a><strong>10.4.2.3.4</strong> 浏览器**: localhost:10004&#x2F;member&#x2F;get&#x2F;1 **</h5><h5 id="10-4-2-3-5-Sentinel-控制台监控页面"><a href="#10-4-2-3-5-Sentinel-控制台监控页面" class="headerlink" title="10.4.2.3.5 Sentinel 控制台监控页面"></a><strong>10.4.2.3.5 Sentinel</strong> 控制台监控页面</h5><p><strong>1.</strong> 浏览器输入**: <a href="http://localhost:10004/member/get/1">http://localhost:10004/member/get/1</a> , 1** 秒钟内访问次数不超过 <strong>1</strong> 次**,** 页 面显示正常</p><p><strong>2.</strong> <strong>浏览器输入</strong>:<a href="http://localhost:10004/member/get/1">http://localhost:10004/member/get/1</a> ,1秒钟内访问次数超过1次, <strong>页面出现错误提示</strong></p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230622221636917.png" alt="image-20230622221636917" style="zoom:33%;" /><h4 id="10-4-2-4-注意事项和细节"><a href="#10-4-2-4-注意事项和细节" class="headerlink" title="10.4.2.4 注意事项和细节"></a>10.4.2.4 注意事项和细节</h4><h5 id="1-流量规则改动，实时生效，不需重启微服务-Sentinel-控制台"><a href="#1-流量规则改动，实时生效，不需重启微服务-Sentinel-控制台" class="headerlink" title="1. 流量规则改动，实时生效，不需重启微服务 , Sentinel 控制台"></a><strong>1.</strong> 流量规则改动，实时生效，<u>不需重启微服务 <strong>, Sentinel</strong> 控制台</u></h5><p>​为什么？因为sentinel中规则一发生改动，就会将信息push到微服务主机监听sentinel服务的进程</p><h5 id="2-在-sentinel-配置流量规则时，如何配置通配符问题，-比如-x2F-member-x2F-get-x2F-1-x2F-member-x2F-get-x2F-2-统一使用一个规则"><a href="#2-在-sentinel-配置流量规则时，如何配置通配符问题，-比如-x2F-member-x2F-get-x2F-1-x2F-member-x2F-get-x2F-2-统一使用一个规则" class="headerlink" title="2. 在 sentinel 配置流量规则时，如何配置通配符问题， 比如 &#x2F;member&#x2F;get&#x2F;1 &#x2F;member&#x2F;get&#x2F;2 统一使用一个规则"></a><strong>2.</strong> 在 sentinel 配置流量规则时，如何配置通配符问题， 比如 &#x2F;member&#x2F;get&#x2F;1 &#x2F;member&#x2F;get&#x2F;2 统一使用一个规则</h5><ul><li>方案1: 在sentinel中 &#x2F;member&#x2F;get?id&#x3D;1 和 &#x2F;member&#x2F;get?id&#x3D;2 被统一认为是**&#x2F;member&#x2F;get** 所以只要对&#x2F;member&#x2F;get 限流就OK了.      (将要携带的参数放在载荷而不是路径中)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/member/get&quot;, params = &quot;id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">getgetMemberById</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">    <span class="type">Member</span> <span class="variable">member</span> <span class="operator">=</span> memberService.queryMemberById(id);</span><br><span class="line">    <span class="keyword">if</span>(member != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;查询成功 member-service-nacos-provider-10004&quot;</span>,member);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;402&quot;</span>,<span class="string">&quot;ID = &quot;</span>+ id + <span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230622223803411.png" alt="image-20230622223803411" style="zoom: 50%;" /><p>访问：<a href="http://localhost:10004/member/get?id=3">http://localhost:10004/member/get?id=3</a></p><ul><li>方案2: URL资源清洗<br>可以通过 UrlCleaner 接口来实现资源清洗，也就是对于&#x2F;member&#x2F;get&#x2F;{id}这个 URL，我们可以统一归集到&#x2F;member&#x2F;get&#x2F;*资源下，具体配置代码如下，实现 UrlCleaner 接口，并重写 clean 方法即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加代码：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.study.springcloud.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.adapter.servlet.callback.UrlCleaner;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/6/22</span></span><br><span class="line"><span class="comment"> * 22:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomUrlCleaner</span> <span class="keyword">implements</span> <span class="title class_">UrlCleaner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">clean</span><span class="params">(String originURL)</span> &#123;</span><br><span class="line">        <span class="comment">//资源清洗</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(originURL))&#123;</span><br><span class="line">            <span class="keyword">return</span> originURL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (originURL.startsWith(<span class="string">&quot;/member/get&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">// 1. 如果请求的是接口 /member/get 开头的, 比如/member/get/1</span></span><br><span class="line">            <span class="comment">// 2. 给 sentinel 的返回的资源名就是 /member/get/*</span></span><br><span class="line">            <span class="comment">// 3. 在 sentinel 对 /member/get/* 添加流控规则即可</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;/member/get/*&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则 返回收到的URL即可</span></span><br><span class="line">        <span class="keyword">return</span> originURL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-如果-sentinel-流控规则没有持久化，当我们重启调用-API-所在微服务模块后，规则会丢失，需要重新加入"><a href="#3-如果-sentinel-流控规则没有持久化，当我们重启调用-API-所在微服务模块后，规则会丢失，需要重新加入" class="headerlink" title="3. 如果 sentinel 流控规则没有持久化，当我们重启调用 API 所在微服务模块后，规则会丢失，需要重新加入"></a><strong>3.</strong> <strong>如果</strong> <strong>sentinel</strong> <strong>流控规则没有持久化，当我们重启调用</strong> <strong>API</strong> <strong>所在微服务模块后，规则会丢失，需要重新加入</strong></h5><h3 id="10-4-3-流量控制实例-线程数"><a href="#10-4-3-流量控制实例-线程数" class="headerlink" title="10.4.3 流量控制实例**-**线程数"></a><strong>10.4.3</strong> 流量控制实例**-**线程数</h3><h4 id="10-4-3-1-需求分析-x2F-图解"><a href="#10-4-3-1-需求分析-x2F-图解" class="headerlink" title="10.4.3.1 需求分析&#x2F;图解"></a>10.4.3.1 需求分析&#x2F;图解</h4><p> <strong>1.</strong> 需求**:** 通过 <strong>Sentinel</strong> 实现 流量控制<br> <strong>2.</strong> 当调用 <strong>member-service-nacos-provider-10004</strong> 的 <strong>&#x2F;member&#x2F;get&#x2F;*</strong>   <strong>API</strong> 时，<u>限制只有一个工作线程</u>，否则直接失败，抛异常**.**</p><h4 id="10-4-3-2-配置实现步骤"><a href="#10-4-3-2-配置实现步骤" class="headerlink" title="10.4.3.2 配置实现步骤"></a>10.4.3.2 配置实现步骤</h4><p><strong>1.</strong> 为**&#x2F;member&#x2F;get&#x2F;*** 增加流控规则</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623143357430.png" alt="image-20230623143357430"></p><p><strong>2.</strong> <strong>在流控规则菜单，可以看到新增的流控规则</strong></p><h4 id="10-4-3-3-测试"><a href="#10-4-3-3-测试" class="headerlink" title="10.4.3.3 测试"></a>10.4.3.3 测试</h4><h5 id="10-4-3-3-1-启动-Nacos-Server-8848"><a href="#10-4-3-3-1-启动-Nacos-Server-8848" class="headerlink" title="10.4.3.3.1 启动 Nacos Server 8848"></a><strong>10.4.3.3.1</strong> 启动 Nacos Server 8848</h5><h5 id="10-4-3-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-4-3-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.4.3.3.2 启动 Sentinel8080 控制台**&#x2F;Sentinel dashboard **"></a>10.4.3.3.2 启动 <strong>Sentinel8080</strong> 控制台**&#x2F;Sentinel dashboard **</h5><h5 id="10-4-3-3-3-启动-member-service-nacos-provider-10004"><a href="#10-4-3-3-3-启动-member-service-nacos-provider-10004" class="headerlink" title="10.4.3.3.3 启动 **member-service-nacos-provider-10004 **"></a><strong>10.4.3.3.3</strong> 启动 **member-service-nacos-provider-10004 **</h5><h5 id="10-4-3-3-4-浏览器-localhost-10004-x2F-member-x2F-get-x2F-1"><a href="#10-4-3-3-4-浏览器-localhost-10004-x2F-member-x2F-get-x2F-1" class="headerlink" title="10.4.3.3.4 浏览器**: localhost:10004&#x2F;member&#x2F;get&#x2F;1 **"></a><strong>10.4.3.3.4</strong> 浏览器**: localhost:10004&#x2F;member&#x2F;get&#x2F;1 **</h5><h5 id="10-4-3-3-5-结果页面"><a href="#10-4-3-3-5-结果页面" class="headerlink" title="10.4.3.3.5 结果页面"></a><strong>10.4.3.3.5</strong> 结果页面</h5><p><strong>1.</strong> 浏览器输入**: <a href="http://localhost:10004/member/get/1">http://localhost:10004/member/get/1</a> ,** 快速刷新**,** 页面显示正常**(<strong>原因是服务执行时间很短，刷新下一次的时候，启动的工作线程，已经完成</strong>)**</p><p><strong>2.</strong> <strong>为了看到效果，我们修改下</strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;MemberController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//让它睡眠一下</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.</strong> <strong>重启</strong> <strong>member-service-nacos-provider-10004 ,</strong> <strong>注意</strong>需要重新加入流控规则.</p><p><strong>4.</strong> <strong>浏览器输入</strong>: <a href="http://localhost:10004/member/get/1">http://localhost:10004/member/get/1</a> , <strong>快速刷新</strong>, <strong>页面出现异常</strong></p><h4 id="10-4-3-4-注意事项和细节"><a href="#10-4-3-4-注意事项和细节" class="headerlink" title="10.4.3.4 注意事项和细节"></a>10.4.3.4 注意事项和细节</h4><p> <strong>1.</strong> <u>当我们请求一次微服务的 <strong>API</strong> 接口时，后台会启动一个线程</u></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623144551449.png" alt="image-20230623144551449" style="zoom:50%;" /><p>2.阈值类型 QPS 和 线程数的区别讨论</p><ul><li>如果一个线程平均执行时间为0.05秒，就说明在1秒钟，可以执行20次(相当于 QPS为20)</li><li>如果一个线程平均执行时间为1秒，说明1秒钟，可以执行1次(相当于 QPS为1)</li><li>如果一个线程平均执行时间为2秒，说明2秒钟内，才能执行1次请求</li></ul><h3 id="10-4-4-流量控制实例-关联"><a href="#10-4-4-流量控制实例-关联" class="headerlink" title="10.4.4 流量控制实例**-**关联"></a><strong>10.4.4</strong> 流量控制实例**-**关联</h3><h4 id="10-4-4-1-关联的含义"><a href="#10-4-4-1-关联的含义" class="headerlink" title="10.4.4.1 关联的含义"></a>10.4.4.1 关联的含义</h4><h5 id="10-4-4-1-1-当关联的资源达到阈值时，就限流自己"><a href="#10-4-4-1-1-当关联的资源达到阈值时，就限流自己" class="headerlink" title="10.4.4.1.1 当关联的资源达到阈值时，就限流自己"></a><strong>10.4.4.1.1</strong> <u>当关联的资源达到阈值时，就限流自己</u></h5><h4 id="10-4-4-2-需求分析-x2F-图解"><a href="#10-4-4-2-需求分析-x2F-图解" class="headerlink" title="10.4.4.2 需求分析&#x2F;图解"></a>10.4.4.2 需求分析&#x2F;图解</h4><p><strong>1.</strong> 需求**:** 通过 <strong>Sentinel</strong> 实现 流量控制</p><p><strong>2.</strong> 当调用 <strong>member-service-nacos-provider-10004</strong> 的 <strong>&#x2F;t2 API</strong> 接口时，如果 <strong>QPS</strong> 超过 <strong>1</strong>，这时调用 <strong>&#x2F;t1 API</strong> 接口 直接失败，抛异常**.** </p><p>​梳理: <strong>&#x2F;t2</strong> 是关联的资源 <strong>,</strong> 限流的资源是**&#x2F;t1**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/t1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">t1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;t1执行...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/t2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">t2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;t2执行...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-4-4-3-配置实现步骤"><a href="#10-4-4-3-配置实现步骤" class="headerlink" title="10.4.4.3 配置实现步骤"></a>10.4.4.3 配置实现步骤</h4><p> <strong>1.</strong> 为**&#x2F;t1** 增加流控规则</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623150310128.png" alt="image-20230623150310128" style="zoom:50%;" /><p><strong>2.</strong> <strong>在流控规则菜单，可以看到新增的流控规则</strong></p><h4 id="10-4-4-4-测试"><a href="#10-4-4-4-测试" class="headerlink" title="10.4.4.4 测试"></a>10.4.4.4 测试</h4><h5 id="10-4-4-4-1-启动-Nacos-Server-8848"><a href="#10-4-4-4-1-启动-Nacos-Server-8848" class="headerlink" title="10.4.4.4.1 启动 Nacos Server 8848"></a><strong>10.4.4.4.1</strong> 启动 Nacos Server 8848</h5><h5 id="10-4-4-4-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-4-4-4-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.4.4.4.2 启动 Sentinel8080 控制台**&#x2F;Sentinel dashboard**"></a>10.4.4.4.2 启动 <strong>Sentinel8080</strong> 控制台**&#x2F;Sentinel dashboard**</h5><h5 id="10-4-4-4-3-启动-member-service-nacos-provider-10004"><a href="#10-4-4-4-3-启动-member-service-nacos-provider-10004" class="headerlink" title="10.4.4.4.3 启动 **member-service-nacos-provider-10004 **"></a>10.4.4.4.3 启动 **member-service-nacos-provider-10004 **</h5><h5 id="10-4-4-4-4-「Postman模拟高并发访问-x2F-t2-」"><a href="#10-4-4-4-4-「Postman模拟高并发访问-x2F-t2-」" class="headerlink" title="10.4.4.4.4 「Postman模拟高并发访问**&#x2F;t2**」"></a><strong>10.4.4.4.4 「Postman</strong>模拟高并发访问**&#x2F;t2**」</h5><p><strong>1.</strong> 创建新的 <strong>http request</strong></p><p><strong>2.</strong> <strong>保存</strong> <strong>request</strong> <strong>到 一个新的</strong> <strong>collection</strong> <strong>中</strong></p><p><strong>3.</strong> <strong>设置</strong> <strong>run collection</strong> <strong>参数</strong>, <strong>并运行</strong></p><p><strong>4.</strong> <strong>浏览器访问</strong>: <a href="http://localhost:10004/t1">http://localhost:10004/t1</a></p><h5 id="10-4-4-4-5-浏览器-localhost-10004-x2F-t1"><a href="#10-4-4-4-5-浏览器-localhost-10004-x2F-t1" class="headerlink" title="10.4.4.4.5 浏览器: localhost:10004&#x2F;t1"></a><strong>10.4.4.4.5</strong> 浏览器: localhost:10004&#x2F;t1</h5><p><strong>1.</strong> 浏览器访问 <strong><a href="http://localhost:10004/t1">http://localhost:10004/t1</a></strong> 的结果页面</p><h4 id="10-4-4-5-注意事项和细节"><a href="#10-4-4-5-注意事项和细节" class="headerlink" title="10.4.4.5 注意事项和细节"></a>10.4.4.5 注意事项和细节</h4><p> <strong>10.4.4.5.1</strong> 在 <strong>postman</strong> 执行 高并发访问 <strong>&#x2F;t2</strong> 没有结束时， 去访问 <strong>&#x2F;t1</strong> 才能看到流控异常出现</p><h3 id="10-4-5-流量控制实例-Warm-up"><a href="#10-4-5-流量控制实例-Warm-up" class="headerlink" title="10.4.5 流量控制实例**-Warm up**"></a>10.4.5 流量控制实例**-Warm up**</h3><h4 id="10-4-5-1-Warm-up-介绍"><a href="#10-4-5-1-Warm-up-介绍" class="headerlink" title="10.4.5.1 Warm up 介绍"></a>10.4.5.1 Warm up 介绍</h4><p><strong>1.</strong> 概述</p><ul><li><strong>当流量突然增大的时候，我们常常会希望系统从空闲状态到繁忙状态的切换的时间长 一些。即如果系统在此之前长期处于空闲的状态，我们希望处理请求的数量是缓步的 增多，经过预期的时间以后，到达系统处理请求个数的最大值。</strong>Warm Up(<strong>冷启动， 预热</strong>)<strong>模式就是为了实现这个目的的。</strong></li><li><strong>这个场景主要用于启动需要额外开销的场景，例如建立数据库连接等</strong></li></ul><p><strong>2.</strong> <strong>一张图</strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623215536876.png" alt="image-20230623215536876" style="zoom:50%;" /><ul><li><strong>通常冷启动的过程系统允许通过的</strong> <strong>QPS</strong> <strong>曲线图</strong>(上图)</li><li><strong>默认</strong> <strong>coldFactor</strong> <strong>为</strong> <strong>3</strong>，即请求 <strong>QPS</strong> <strong>从</strong> <strong>threshold &#x2F; 3</strong> <strong>开始，经预热时长逐渐升至设定的</strong> <strong>QPS</strong> <strong>阈值</strong></li><li><strong>这里的</strong>threshold <strong>就是最终要达到的</strong>QPS阈值.</li></ul><h5 id="10-4-5-1-1-文-档"><a href="#10-4-5-1-1-文-档" class="headerlink" title="10.4.5.1.1 文 档 :"></a><strong>10.4.5.1.1</strong> 文 档 <strong>:</strong></h5><p><strong><a href="https://github.com/alibaba/Sentinel/wiki/%E9%99%90%E6%B5%81---%E5%86%B7%E5%90%AF%E5%8A%A8">https://github.com/alibaba/Sentinel/wiki/%E9%99%90%E6%B5%81---%E5%86%B7%E5%90%AF%E5%8A%A8</a></strong></p><h5 id="10-4-5-1-2-默认-coldFactor-为-3，即请求-QPS-从-threshold-x2F-3-开始，经预热时长逐渐升至设定的-QPS-阈值"><a href="#10-4-5-1-2-默认-coldFactor-为-3，即请求-QPS-从-threshold-x2F-3-开始，经预热时长逐渐升至设定的-QPS-阈值" class="headerlink" title="10.4.5.1.2 默认 coldFactor 为 3，即请求 QPS 从 threshold &#x2F; 3 开始，经预热时长逐渐升至设定的 QPS 阈值"></a><strong>10.4.5.1.2</strong> 默认 <strong>coldFactor</strong> 为 <strong>3</strong>，即请求 <strong>QPS</strong> 从 <strong>threshold &#x2F; 3</strong> 开始，经预热时长逐渐升至设定的 <strong>QPS</strong> 阈值</h5><h5 id="10-4-5-1-3-Warm-up-称为-冷启动-x2F-预热"><a href="#10-4-5-1-3-Warm-up-称为-冷启动-x2F-预热" class="headerlink" title="10.4.5.1.3 Warm up 称为 冷启动**&#x2F;**预热"></a><strong>10.4.5.1.3 Warm up</strong> 称为 冷启动**&#x2F;**预热</h5><h5 id="10-4-5-1-4-应用场景-秒杀在开启瞬间，大流量很容易造成冲垮系统，Warmup-可慢慢的把流量放入，最终将阀值增长到设置阀值"><a href="#10-4-5-1-4-应用场景-秒杀在开启瞬间，大流量很容易造成冲垮系统，Warmup-可慢慢的把流量放入，最终将阀值增长到设置阀值" class="headerlink" title="10.4.5.1.4 应用场景**:** 秒杀在开启瞬间，大流量很容易造成冲垮系统，Warmup 可慢慢的把流量放入，最终将阀值增长到设置阀值"></a><strong>10.4.5.1.4</strong> 应用场景**:** 秒杀在开启瞬间，大流量很容易造成冲垮系统，<strong>Warmup</strong> 可慢慢的把流量放入，最终将阀值增长到设置阀值</h5><h4 id="10-4-5-2-需求分析-x2F-图解"><a href="#10-4-5-2-需求分析-x2F-图解" class="headerlink" title="10.4.5.2 需求分析&#x2F;图解"></a>10.4.5.2 需求分析&#x2F;图解</h4><p><strong>1.</strong> 需求**:** 通过 <strong>Sentinel</strong> 实现流量控制**,**演示 <strong>Warm up</strong></p><p><strong>2.</strong> 调用 <strong>member-service-nacos-provider-10004</strong> 的 <strong>&#x2F;t2 API</strong> 接口，将 <strong>QPS</strong> 设置为 <strong>9,</strong> 设置 <strong>Warm up</strong> 值为 <strong>3</strong></p><p><strong>4.</strong> 含义为 请求 <strong>&#x2F;t2</strong> 的 <strong>QPS</strong> 从 <strong>threshold &#x2F; 3( 9 &#x2F;3 &#x3D; 3)</strong> 开始，经预热时长**(3** 秒**)<strong>逐渐升至 设定的 <strong>QPS</strong> 阈值</strong>(9)**</p><p><strong>5.</strong> 为什么是 <strong>9 &#x2F; 3,</strong> 这个是 <strong>3</strong> 就是默认冷启动启动加载因子 <strong>coldFactor&#x3D;3</strong></p><p><strong>6.</strong> 测试预期效果**:** 在前 <strong>3</strong> 秒，如果访问 <strong>&#x2F;t2</strong> 的 <strong>QPS</strong> 超过 <strong>3,</strong> 会直接报错，在 <strong>3</strong> 秒后 访问 <strong>&#x2F;t2</strong> 的 <strong>QPS</strong> 超过 <strong>3,</strong> 小于等于 <strong>9,</strong> 是正常访问</p><h4 id="10-4-5-3-配置实现步骤"><a href="#10-4-5-3-配置实现步骤" class="headerlink" title="10.4.5.3 配置实现步骤"></a>10.4.5.3 配置实现步骤</h4><p><strong>1.</strong> 为**&#x2F;t2** 增加流控规则</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623220623200.png" alt="image-20230623220623200" style="zoom:50%;" /><p><strong>2.</strong> <strong>在流控规则菜单，可以看到新增的流控规则</strong></p><h4 id="10-4-5-4-测试"><a href="#10-4-5-4-测试" class="headerlink" title="10.4.5.4 测试"></a>10.4.5.4 测试</h4><h5 id="10-4-5-4-1-启动-Nacos-Server-8848"><a href="#10-4-5-4-1-启动-Nacos-Server-8848" class="headerlink" title="10.4.5.4.1 启动 Nacos Server 8848"></a><strong>10.4.5.4.1</strong> 启动 Nacos Server 8848</h5><h5 id="10-4-5-4-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-4-5-4-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.4.5.4.2 启动 Sentinel8080 控制台**&#x2F;Sentinel dashboard **"></a>10.4.5.4.2 启动 <strong>Sentinel8080</strong> 控制台**&#x2F;Sentinel dashboard **</h5><h5 id="10-4-5-4-3-启动-member-service-nacos-provider-10004"><a href="#10-4-5-4-3-启动-member-service-nacos-provider-10004" class="headerlink" title="10.4.5.4.3 启动 **member-service-nacos-provider-10004 **"></a><strong>10.4.5.4.3</strong> 启动 **member-service-nacos-provider-10004 **</h5><h5 id="10-4-5-4-4-浏览器-localhost-10004-x2F-t2"><a href="#10-4-5-4-4-浏览器-localhost-10004-x2F-t2" class="headerlink" title="10.4.5.4.4 浏览器**: localhost:10004&#x2F;t2**"></a><strong>10.4.5.4.4</strong> 浏览器**: localhost:10004&#x2F;t2**</h5><p><strong>1.</strong> 浏览器访问 <strong><a href="http://localhost:10004/t2">http://localhost:10004/t2</a></strong> 快速刷新页面，在前 <strong>3</strong> 秒，会出现流控异常， 后 <strong>3</strong> 秒就正常了**(<strong>如果你刷新非常快 <strong>QPS&gt;9</strong> <strong>,</strong> 仍然会出现流控异常</strong>)**</p><h4 id="10-4-5-5-注意事项和细节"><a href="#10-4-5-5-注意事项和细节" class="headerlink" title="10.4.5.5 注意事项和细节"></a>10.4.5.5 注意事项和细节</h4><p> <strong>10.4.5.5.1</strong> 测试 <strong>Warm up</strong> 效果不是很好测，如果出不来可以尝试，调整流控规则**:** 比如 <strong>QPS</strong> 为 **11, Warm up 预热时间 **6 秒</p><h5 id="10-4-5-5-2-如果请求停止-即-一段时间没有达到阈值-Warm-up-过程将重复-小伙伴可以理解是一个弹性过程"><a href="#10-4-5-5-2-如果请求停止-即-一段时间没有达到阈值-Warm-up-过程将重复-小伙伴可以理解是一个弹性过程" class="headerlink" title="10.4.5.5.2 如果请求停止**(即:** 一段时间没有达到阈值**), Warm up** 过程将重复**,** 小伙伴可以理解是一个弹性过程"></a><strong>10.4.5.5.2</strong> 如果请求停止**(<strong>即</strong>:** 一段时间没有达到阈值**), Warm up** 过程将重复**,** 小伙伴可以理解是一个弹性过程</h5><h3 id="10-4-6-流量控制实例-排队"><a href="#10-4-6-流量控制实例-排队" class="headerlink" title="10.4.6 流量控制实例**-**排队"></a>10.4.6 流量控制实例**-**排队</h3><h4 id="10-4-6-1-排队-介绍"><a href="#10-4-6-1-排队-介绍" class="headerlink" title="10.4.6.1 排队 介绍"></a>10.4.6.1 排队 介绍</h4><p><strong>1.</strong> 排队方式:这种方式严格控制了请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法</p><p><strong>2.</strong> <strong>一张图</strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623221119829.png" alt="image-20230623221119829" style="zoom:33%;" /><p><strong>3.</strong> <strong>这种方式主要用于处理间隔性突发的流量，例如消息队列。比如这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，<u>我们希望系统能够在接下来的空闲期间逐渐处理这些请求</u>，而不是在第一秒直接拒绝多余的请求。-类似前面说的削峰填谷</strong></p><p><strong>4.</strong> <strong>匀速排队，阈值必须设置为QPS</strong></p><h4 id="10-4-6-2-需求分析-x2F-图解"><a href="#10-4-6-2-需求分析-x2F-图解" class="headerlink" title="10.4.6.2 需求分析&#x2F;图解"></a>10.4.6.2 需求分析&#x2F;图解</h4><p><strong>1.</strong> 需求**:** 通过 <strong>Sentinel</strong> 实现 流量控制**-<strong>排队<br><strong>2.</strong> 调用 <strong>member-service-nacos-provider-10004</strong> 的 <strong>&#x2F;t2 API</strong> 接口，将 <strong>QPS</strong> 设置为 <strong>1 **<br><strong>3.</strong> 当调用 <strong>&#x2F;t2</strong> 的 <strong>QPS</strong> 超过 <strong>1</strong> 时，不拒绝请求，而是排队等待</strong>,</strong> 依次执行<br><strong>4.<strong>当等待时间超过 <strong>10</strong> 秒，则为等待超时——</strong>等待超时就不要了</strong></p><h4 id="10-4-6-3-修改业务类"><a href="#10-4-6-3-修改业务类" class="headerlink" title="10.4.6.3 修改业务类"></a>10.4.6.3 修改业务类</h4><p><strong>1.</strong> 为了测试看到效果，修改 <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;MemberController.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/t2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">t2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//模拟线程执行时间为1秒</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  log.info(<span class="string">&quot;执行 t2() 线程 id= &quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;t2执行...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-4-6-4-配置实现步骤"><a href="#10-4-6-4-配置实现步骤" class="headerlink" title="10.4.6.4 配置实现步骤"></a>10.4.6.4 配置实现步骤</h4><p><strong>1.</strong> 为**&#x2F;t2** 增加流控规则</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623222712777.png" alt="image-20230623222712777" style="zoom:50%;" /><p><strong>2.</strong> <strong>在流控规则菜单，可以看到新增的流控规则</strong></p><h4 id="10-4-6-5-测试"><a href="#10-4-6-5-测试" class="headerlink" title="10.4.6.5 测试"></a>10.4.6.5 测试</h4><h5 id="10-4-6-5-1-启动-Nacos-Server-8848"><a href="#10-4-6-5-1-启动-Nacos-Server-8848" class="headerlink" title="10.4.6.5.1 启动 Nacos Server 8848"></a><strong>10.4.6.5.1</strong> 启动 Nacos Server 8848</h5><h5 id="10-4-6-5-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-4-6-5-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.4.6.5.2 启动 Sentinel8080 控制台**&#x2F;Sentinel dashboard **"></a>10.4.6.5.2 启动 <strong>Sentinel8080</strong> 控制台**&#x2F;Sentinel dashboard **</h5><h5 id="10-4-6-5-3-启动-member-service-nacos-provider-10004"><a href="#10-4-6-5-3-启动-member-service-nacos-provider-10004" class="headerlink" title="10.4.6.5.3 启动 **member-service-nacos-provider-10004 **"></a><strong>10.4.6.5.3</strong> 启动 **member-service-nacos-provider-10004 **</h5><h5 id="10-4-6-5-4-浏览器-localhost-10004-x2F-t2"><a href="#10-4-6-5-4-浏览器-localhost-10004-x2F-t2" class="headerlink" title="10.4.6.5.4 浏览器**: localhost:10004&#x2F;t2**"></a><strong>10.4.6.5.4</strong> 浏览器**: localhost:10004&#x2F;t2**</h5><p><strong>1.</strong> 浏览器访问 <strong><a href="http://localhost:10004/t2">http://localhost:10004/t2</a></strong> 快速刷新页面 <strong>9</strong> 次，观察前台**&#x2F;**后台输出的情况</p><p>输出结果分析：没有报错误，后台请求排队执行，每隔1s匀速执行</p><p><strong>2.</strong> <strong>浏览器访问</strong> <strong><a href="http://localhost:10004/t2">http://localhost:10004/t2</a></strong> <strong>快速刷新页面</strong>20<strong>次，当请求等待时间超过</strong>10S, <strong>仍然出现流控异常</strong></p><h2 id="10-5-Sentinel熔断降级"><a href="#10-5-Sentinel熔断降级" class="headerlink" title="10.5 Sentinel熔断降级"></a>10.5 Sentinel熔断降级</h2><h3 id="10-5-1-线程堆积引出熔断降级"><a href="#10-5-1-线程堆积引出熔断降级" class="headerlink" title="10.5.1 线程堆积引出熔断降级"></a><strong>10.5.1</strong> 线程堆积引出熔断降级</h3><p><strong>1.</strong> 一个服务常常会调用别的模块，可能是另外的一个远程服务、数据库，或者第三方 API 等。</p><p><strong>2.</strong> 例如，支付的时候，可能需要远程调用银联提供的 API;查询某个商品的价格，可能需 要进行数据库查询。然而，这个被依赖服务的稳定性是不能保证的。如果依赖的服务出现 了不稳定的情况，请求的响应时间变长，那么调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身也变得不可用</p><p><strong>3.</strong> 这时，我们<u>对不稳定的服务进行熔断降级，让其快速返回结果，不要造成线程堆积</u></p><h3 id="10-5-2-文档地址-https-sentinelguard-io-zh-cn-docs-circuit-breaking-html"><a href="#10-5-2-文档地址-https-sentinelguard-io-zh-cn-docs-circuit-breaking-html" class="headerlink" title="10.5.2 文档地址**: https://sentinelguard.io/zh-cn/docs/circuit-breaking.html**"></a><strong>10.5.2</strong> 文档地址**: <a href="https://sentinelguard.io/zh-cn/docs/circuit-breaking.html">https://sentinelguard.io/zh-cn/docs/circuit-breaking.html</a>**</h3><h3 id="10-5-3-基本介绍"><a href="#10-5-3-基本介绍" class="headerlink" title="10.5.3 基本介绍"></a><strong>10.5.3</strong> 基本介绍</h3><p><strong>1.</strong> 一张图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623223928543.png" alt="image-20230623223928543" style="zoom:50%;" /><p><strong>2.</strong> <strong>解读上图</strong>:</p><ul><li><strong>现代微服务架构都是分布式的，由非常多的服务组成。不同服务之间相互调用，组成复杂的调用链路。</strong></li><li><strong>链路调用中会产生放大的效果。复杂链路上的某一环不稳定，就可能会层层级联，最终导致整个链路都不可用。</strong></li><li><strong>因此需要对不稳定的弱依赖服务调用进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩</strong></li></ul><p><strong>3.</strong> <strong>熔断,降级,限流三者的关系</strong></p><ul><li><p>熔断：强调的是服务之间的调用能实现自我恢复的状态 </p></li><li><p>限流：是从系统的流量入口考虑, 从进入的流量上进行限制**, **达到保护系统的作用</p></li><li><p>降级：是从系统业务的维度考虑，流量大了或者频繁异常, 可以牺牲一些非核心业务，保护核心流程正常使用</p></li></ul><p>-熔断是降级方式的一种</p><p>-降级又是限流的一种方式  </p><p>-三者都是为了通过一定的方式<strong>在流量过大或者出现异常时,保护系统的手段</strong></p><h3 id="10-5-4-熔断策略"><a href="#10-5-4-熔断策略" class="headerlink" title="10.5.4 熔断策略"></a><strong>10.5.4</strong> 熔断策略</h3><h4 id="10-5-4-1-慢调用比例"><a href="#10-5-4-1-慢调用比例" class="headerlink" title="10.5.4.1 慢调用比例"></a>10.5.4.1 慢调用比例</h4><p>1、慢调用比例 (SLOW_REQUEST_RATIO):选择以慢调用比例作为阈值，需要设置允许的慢调用 <strong>RT</strong>(即最大的响应时间)，<strong>请求的响应时间大于该值则统计为<u>慢调用</u></strong></p><p>2、当<strong>单位统计时长(statIntervalMs)内请求数目大于设置的最小请求数目</strong>，并且<strong>慢调用的<u>比例</u>大于阈值</strong>，则接下来的熔断时长内请求会自动被熔断</p><p>3、熔断时长后,熔断器会进入探测恢复状态(HALF-OPEN 状态)，若接下来的一个请求响应时间小于设置的慢调用RT则结束熔断，若大于设置的慢调用RT 则会再次被熔断</p><p>4、配置参考</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623225930567.png" alt="image-20230623225930567" style="zoom:33%;" /><h4 id="10-5-4-2-异常比例"><a href="#10-5-4-2-异常比例" class="headerlink" title="10.5.4.2 异常比例"></a>10.5.4.2 异常比例</h4><p>1、异常比例 (ERROR_RATIO):当单位统计时长(statIntervalMs)内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断</p><p>2、经过熔断时长后熔断器会进入探测恢复状态(HALF-OPEN状态) </p><p>3、若接下来的一个请求成功完成(没有错误)则结束熔断,否则会再次被熔断</p><p>4、异常比率的阈值范围是[0.0, 1.0]，代表0% - 100%</p><p>5、配置参考</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623230152696.png" alt="image-20230623230152696" style="zoom:33%;" /><p>6、工作示意图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623230238823.png" alt="image-20230623230238823" style="zoom:33%;" /><h4 id="10-5-4-3-异常数"><a href="#10-5-4-3-异常数" class="headerlink" title="10.5.4.3 异常数"></a>10.5.4.3 异常数</h4><p>1、异常数 (ERROR_COUNT):<u>当单位统计时长内的异常数目超过阈值之后会自动进行熔断</u></p><p>2、经过熔断时长后熔断器会进入探测恢复状态(HALF-OPEN 状态) </p><p>3、若接下来的一个请求成功完成(没有错误)则结束熔断，否则会再次被熔断</p><p>4、配置参考</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623230424805.png" alt="image-20230623230424805" style="zoom:33%;" /><h3 id="10-5-5-熔断降级实例-慢调用比例"><a href="#10-5-5-熔断降级实例-慢调用比例" class="headerlink" title="10.5.5 熔断降级实例**-**慢调用比例"></a><strong>10.5.5</strong> 熔断降级实例**-**慢调用比例</h3><h4 id="10-5-5-1-需求分析-x2F-图解"><a href="#10-5-5-1-需求分析-x2F-图解" class="headerlink" title="10.5.5.1 需求分析&#x2F;图解"></a>10.5.5.1 需求分析&#x2F;图解</h4><p><strong>1.</strong> 需求**:** 通过 <strong>Sentinel</strong> 实现 熔断降级控制**-**<u>慢调用比例</u></p><p><strong>2.</strong> <strong>当调用</strong> <strong>member-service-nacos-provider-10004</strong> <strong>的</strong> <strong>&#x2F;t3 API</strong> <strong>接口时，如果在</strong> <strong>1s</strong> <strong>内持续进入了</strong> <strong>5</strong> <strong>个请求，并且请求的平均响应时间超过</strong> <strong>200ms,</strong> <strong>那么就在未来</strong> <strong>10</strong> <strong>秒钟内，断路器打开</strong>, <strong>让</strong> <strong>&#x2F;t3 API</strong> <strong>接口微服务不可用</strong></p><p><strong>3.</strong> <strong>后面对</strong>&#x2F;t3 API <strong>接口访问降到</strong> <strong>1S</strong> <strong>内</strong> <strong>1</strong> <strong>个请求，降低访问量了，断路器关闭，微服务恢复</strong></p><h4 id="10-5-5-2-修改业务类"><a href="#10-5-5-2-修改业务类" class="headerlink" title="10.5.5.2 修改业务类"></a>10.5.5.2 修改业务类</h4><p><strong>1.</strong> 修改 <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;MemberController.java</strong> 增加方法 <strong>t3()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/t3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">t3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//模拟线程执行时间为1秒</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;熔断降级测试 执行 t3() 线程 id= &quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;t3执行...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-5-5-3-配置实现步骤"><a href="#10-5-5-3-配置实现步骤" class="headerlink" title="10.5.5.3 配置实现步骤"></a>10.5.5.3 配置实现步骤</h4><p><strong>1.</strong> 为**&#x2F;t3** 增加降级规则</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623231431243.png" alt="image-20230623231431243" style="zoom:50%;" /><p><strong>2.</strong> <strong>在流控规则菜单，可以看到新增的降级规则</strong></p><h4 id="10-5-5-4-测试"><a href="#10-5-5-4-测试" class="headerlink" title="10.5.5.4 测试"></a>10.5.5.4 测试</h4><h5 id="10-5-5-4-1-启动-Nacos-Server-8848"><a href="#10-5-5-4-1-启动-Nacos-Server-8848" class="headerlink" title="10.5.5.4.1 启动 Nacos Server 8848"></a><strong>10.5.5.4.1</strong> 启动 Nacos Server 8848</h5><h5 id="10-5-5-4-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-5-5-4-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.5.5.4.2 启动 Sentinel8080 控制台**&#x2F;Sentinel dashboard **"></a>10.5.5.4.2 启动 <strong>Sentinel8080</strong> 控制台**&#x2F;Sentinel dashboard **</h5><h5 id="10-5-5-4-3-启动-member-service-nacos-provider-10004"><a href="#10-5-5-4-3-启动-member-service-nacos-provider-10004" class="headerlink" title="10.5.5.4.3 启动 member-service-nacos-provider-10004"></a><strong>10.5.5.4.3</strong> 启动 <strong>member-service-nacos-provider-10004</strong></h5><h5 id="10-5-5-4-4-Postman测试"><a href="#10-5-5-4-4-Postman测试" class="headerlink" title="10.5.5.4.4 Postman测试"></a><strong>10.5.5.4.4 Postman</strong>测试</h5><p><strong>1.</strong> 先创建 <strong>collection ,</strong> 也可以在已经存在的 <strong>collection</strong> 进行修改</p><p>…………</p><h4 id="10-5-5-5-注意事项和细节"><a href="#10-5-5-5-注意事项和细节" class="headerlink" title="10.5.5.5 注意事项和细节"></a>10.5.5.5 注意事项和细节</h4><h5 id="10-5-5-5-1-平均响应时间超出阈值且在-1s-内通过的请求-gt-x3D-5-，-两个条件同时满足后触发降级"><a href="#10-5-5-5-1-平均响应时间超出阈值且在-1s-内通过的请求-gt-x3D-5-，-两个条件同时满足后触发降级" class="headerlink" title="10.5.5.5.1 平均响应时间超出阈值且在 1s 内通过的请求**&gt;&#x3D;5**， 两个条件同时满足后触发降级"></a>10.5.5.5.1 平均响应时间超出阈值且在 <strong>1s</strong> 内通过的请求**&gt;&#x3D;5**， 两个条件同时满足后触发降级</h5><h5 id="10-5-5-5-2-熔断时间过后，关闭断路器，访问恢复正常"><a href="#10-5-5-5-2-熔断时间过后，关闭断路器，访问恢复正常" class="headerlink" title="10.5.5.5.2 熔断时间过后，关闭断路器，访问恢复正常"></a>10.5.5.5.2 熔断时间过后，关闭断路器，访问恢复正常</h5><h3 id="10-5-6-熔断降级实例-异常比例"><a href="#10-5-6-熔断降级实例-异常比例" class="headerlink" title="10.5.6 熔断降级实例-异常比例"></a>10.5.6 熔断降级实例-异常比例</h3><h4 id="10-5-6-1-需求分析-x2F-图解"><a href="#10-5-6-1-需求分析-x2F-图解" class="headerlink" title="10.5.6.1 需求分析&#x2F;图解"></a>10.5.6.1 需求分析&#x2F;图解</h4><p><strong>1.</strong> 需求**:** 通过 <strong>Sentinel</strong> 实现 熔断降级控制</p><p><strong>2.</strong> 当调用 <strong>member-service-nacos-provider-10004</strong> 的 <strong>&#x2F;t4 API</strong> 接口时，当资源的每秒请求量**&gt;&#x3D;5<strong>，并且每秒异常总数占通过量的比值超过</strong>20%(<strong>即异常比例到</strong>20%),** 断路器打开**(<strong>即</strong>:** 进入降级状态**),** 让 <strong>&#x2F;t4 API</strong> 接口微服务不可用</p><p><strong>3.</strong> 当对**&#x2F;t4 API** 接口 访问降到 <strong>1S</strong> 内 <strong>1</strong> 个请求，降低访问量了，断路器关闭，<strong>5</strong> 秒后微服务恢复</p><h4 id="10-5-6-2-修改业务类"><a href="#10-5-6-2-修改业务类" class="headerlink" title="10.5.6.2 修改业务类"></a>10.5.6.2 修改业务类</h4><p><strong>1.</strong> 修改 <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;MemberController.java</strong> 增加方法 <strong>t4()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/t4&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">t4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((++num) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//异常比例 50% System.out.println(3 / 0);</span></span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;熔断降级测试【异常比例】 执行 t4() 线程 id= &quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;t4()执行&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-5-6-3-配置实现步骤"><a href="#10-5-6-3-配置实现步骤" class="headerlink" title="10.5.6.3 配置实现步骤"></a>10.5.6.3 配置实现步骤</h4><p><strong>1.</strong> 为**&#x2F;t4** 增加降级规则</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230624094738411.png" alt="image-20230624094738411" style="zoom:50%;" /><p><strong>2.</strong> <strong>在流控规则菜单，可以看到新增的降级规则</strong></p><h4 id="10-5-6-4-测试"><a href="#10-5-6-4-测试" class="headerlink" title="10.5.6.4 测试"></a>10.5.6.4 测试</h4><h5 id="10-5-6-4-1-启动-Nacos-Server-8848"><a href="#10-5-6-4-1-启动-Nacos-Server-8848" class="headerlink" title="10.5.6.4.1 启动 Nacos Server 8848"></a>10.5.6.4.1 启动 Nacos Server 8848</h5><h5 id="10-5-6-4-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-5-6-4-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.5.6.4.2 启动 Sentinel8080 控制台&#x2F;Sentinel dashboard"></a>10.5.6.4.2 启动 Sentinel8080 控制台&#x2F;Sentinel dashboard</h5><h5 id="10-5-6-4-3-启动-member-service-nacos-provider-10004"><a href="#10-5-6-4-3-启动-member-service-nacos-provider-10004" class="headerlink" title="10.5.6.4.3 启动 member-service-nacos-provider-10004"></a>10.5.6.4.3 启动 member-service-nacos-provider-10004</h5><h5 id="10-5-6-4-4-Postman测试"><a href="#10-5-6-4-4-Postman测试" class="headerlink" title="10.5.6.4.4 Postman测试"></a>10.5.6.4.4 Postman测试</h5><p><strong>1.</strong> 先创建给 <strong>collection ,</strong> 也可以在已经存在的 <strong>collection</strong> 进行修改**,** 一定确保更新成功**.**</p><p><strong>2.</strong> <strong>点击</strong> <strong>Run sentinel</strong></p><p><strong>3.</strong> 浏览器访问: <a href="http://localhost:10004/t4">http://localhost:10004/t4</a> 出现 Blocked by Sentinel (flow limiting)</p><p><strong>4.</strong> <strong>停止</strong> <strong>Postman</strong></p><p><strong>5.</strong> 浏览器访问: <a href="http://localhost:10004/t4">http://localhost:10004/t4</a> , 结果正常了(一次返回异常，一次返回正确结 果)</p><h4 id="10-5-7-5注意事项和细节"><a href="#10-5-7-5注意事项和细节" class="headerlink" title="10.5.7.5注意事项和细节"></a>10.5.7.5注意事项和细节</h4><h5 id="10-5-7-5-1-资源在-1-分钟的异常数目超过阈值之后会进行熔断降级"><a href="#10-5-7-5-1-资源在-1-分钟的异常数目超过阈值之后会进行熔断降级" class="headerlink" title="10.5.7.5.1 资源在 1 分钟的异常数目超过阈值之后会进行熔断降级"></a><strong>10.5.7.5.1</strong> 资源在 <strong>1</strong> 分钟的异常数目超过阈值之后会进行熔断降级</h5><p><strong>10.5.7.5.2</strong> 异常数统计是分钟级别的，若 设置的时间窗口 小于 <strong>60s</strong>，则结束熔断状态后仍可能再进入熔断状态**,** 测试时，最好将时间窗口设置超过 <strong>60S</strong></p><h2 id="10-6-Sentinel-热点规则"><a href="#10-6-Sentinel-热点规则" class="headerlink" title="10.6 Sentinel 热点规则"></a>10.6 Sentinel 热点规则</h2><h3 id="10-6-1-一个问题引出热点-key-限流"><a href="#10-6-1-一个问题引出热点-key-限流" class="headerlink" title="10.6.1 一个问题引出热点 key 限流"></a><strong>10.6.1</strong> 一个问题引出热点 <strong>key</strong> 限流</h3><p><strong>1.</strong> 热点**:** 热点即经常访问的数据。很多时候我们希望统计热点数据中**,** 访问频次最高的 <strong>Top K</strong> 数据，并对其访问进行限制。</p><p><strong>2.</strong> 比如某条新闻上热搜 ，在某段时间内高频访问， 为了防止系统雪崩**,** 可以对该条新闻进行热点限流</p><h3 id="10-6-2文档地址"><a href="#10-6-2文档地址" class="headerlink" title="10.6.2文档地址 :"></a>10.6.2文档地址 :</h3><p> <a href="https://github.com/alibaba/Sentinel/wiki/%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81">https://github.com/alibaba/Sentinel/wiki/%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81</a></p><h3 id="10-6-3-基本介绍"><a href="#10-6-3-基本介绍" class="headerlink" title="10.6.3 基本介绍"></a><strong>10.6.3</strong> 基本介绍</h3><p><strong>1.</strong> 一张图<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230624102921499.png" alt="image-20230624102921499"></p><p><strong>2.</strong> 解读上图:</p><ul><li><p>热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。</p></li><li><p>热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效</p></li><li><p>Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控 <strong><a href="https://blog.csdn.net/qq_34416331/article/details/106668747">https://blog.csdn.net/qq_34416331/article/details/106668747</a></strong></p></li><li><p>热点参数限流支持集群模式</p></li></ul><h3 id="10-6-4-热点-Key-限流-实例"><a href="#10-6-4-热点-Key-限流-实例" class="headerlink" title="10.6.4 热点 Key 限流**-**实例"></a><strong>10.6.4</strong> 热点 <strong>Key</strong> 限流**-**实例</h3><h4 id="10-6-4-1-需求分析-x2F-图解"><a href="#10-6-4-1-需求分析-x2F-图解" class="headerlink" title="10.6.4.1 需求分析&#x2F;图解"></a>10.6.4.1 需求分析&#x2F;图解</h4><p> <strong>1.</strong> 需求**:** 通过 <strong>Sentinel</strong> 实现热点 <strong>Key</strong> 限流<br> <strong>2.</strong> 对 <strong>member-service-nacos-provider-10004</strong> 的 <strong>&#x2F;news?id&#x3D;x&amp;type&#x3D;x API</strong> 接口进行热点限流<br> <strong>3.</strong> 假定 <strong>id&#x3D;10</strong> 这一条新闻是当前的热点新闻， 当查询新闻时，对通常的 <strong>id(<strong>非热点新闻</strong>)<strong>请求 <strong>QPS</strong> 限定为 <strong>2,</strong> 如果 <strong>id&#x3D;10 QPS</strong> 限定为 <strong>100<br> 4.</strong> 如果访问超出了规定的 <strong>QPS,</strong> 触发热点限流机制</strong>,</strong> 调用自定义的方法，给出提示信息**. **</p><p> <strong>5.</strong> 当对 <strong>&#x2F;news?id&#x3D;x&amp;type&#x3D;x API</strong> 接口降低访问量，<strong>QPS</strong> 达到规定范围**,** 服务恢复</p><h4 id="10-6-4-2-修改业务类"><a href="#10-6-4-2-修改业务类" class="headerlink" title="10.6.4.2 修改业务类"></a>10.6.4.2 修改业务类</h4><p><strong>1.</strong> 修 改 <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;MemberController.java</strong> 增 加 方 法 <strong>queryNews()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意 <span class="doctag">@GetMapping</span> 是 url 带有 / , <span class="doctag">@SentinelResource</span> 的 value 是没有 /的</span></span><br><span class="line"><span class="comment"> * * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/news&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;news&quot;,blockHandler = &quot;newsBlockHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryNews</span><span class="params">(<span class="meta">@RequestParam(value = &quot;id&quot;,required = false)</span> String id,</span></span><br><span class="line"><span class="params">                        <span class="meta">@RequestParam(value = &quot;type&quot;,required = false)</span> String type)</span></span><br><span class="line">&#123;</span><br><span class="line">    log.info(<span class="string">&quot;到 DB 查询数据库.... &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;返回 id= &quot;</span> + id + <span class="string">&quot; 新闻 fromDB&quot;</span>); &#125;</span><br><span class="line"><span class="comment">//热点 key 限制异常处理方法</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">newsBlockHandler</span><span class="params">(String id, String type, BlockException exception)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;查询 id= &quot;</span> + id</span><br><span class="line">            + <span class="string">&quot; 新闻 触发热点 key 限制保护.. sorry&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-6-4-3-测试"><a href="#10-6-4-3-测试" class="headerlink" title="10.6.4.3 测试"></a>10.6.4.3 测试</h4><h5 id="10-6-4-3-1-启动-Nacos-Server-8848"><a href="#10-6-4-3-1-启动-Nacos-Server-8848" class="headerlink" title="10.6.4.3.1 启动 Nacos Server 8848"></a><strong>10.6.4.3.1</strong> 启动 Nacos Server 8848</h5><h5 id="10-6-4-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-6-4-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.6.4.3.2 启动 Sentinel8080 控制台&#x2F;Sentinel dashboard"></a>10.6.4.3.2 启动 <strong>Sentinel8080</strong> 控制台&#x2F;Sentinel dashboard</h5><h5 id="10-6-4-3-3-启动-member-service-nacos-provider-10004"><a href="#10-6-4-3-3-启动-member-service-nacos-provider-10004" class="headerlink" title="10.6.4.3.3 启动 member-service-nacos-provider-10004"></a>10.6.4.3.3 启动 member-service-nacos-provider-10004</h5><h5 id="10-6-4-3-4-配置实现步骤"><a href="#10-6-4-3-4-配置实现步骤" class="headerlink" title="10.6.4.3.4 配置实现步骤"></a>10.6.4.3.4 配置实现步骤</h5><p><strong>1.</strong> 为资源 <strong>news</strong> 增加热点规则**,** 注意不是 <strong>&#x2F;news</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230624104344763.png" alt="image-20230624104344763"></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230624104402958.png" alt="image-20230624104402958" style="zoom: 33%;" /><p><strong>2.</strong> <strong>在热点参数限流规则菜单，可以看到新增规则</strong></p><h5 id="10-6-4-3-5-浏览器-http-localhost-10004-news-id-1-amp-type-E6-95-99-E8-82-B2"><a href="#10-6-4-3-5-浏览器-http-localhost-10004-news-id-1-amp-type-E6-95-99-E8-82-B2" class="headerlink" title="10.6.4.3.5 浏览器**: http://localhost:10004/news?id=1&amp;type=%E6%95%99%E8%82%B2**"></a>10.6.4.3.5 浏览器**: <a href="http://localhost:10004/news?id=1&type=%E6%95%99%E8%82%B2">http://localhost:10004/news?id=1&amp;type=%E6%95%99%E8%82%B2</a>**</h5><p>如果QPS没有超过2,则返回正确结果</p><p>如果QPS超过2,则返回热点key处理信息</p><h5 id="10-6-4-3-6-独立设置热点-id-x3D-10-的-QPS-阈值-即添加例外"><a href="#10-6-4-3-6-独立设置热点-id-x3D-10-的-QPS-阈值-即添加例外" class="headerlink" title="10.6.4.3.6 独立设置热点 id&#x3D;10 的 QPS 阈值(即添加例外)"></a>10.6.4.3.6 独立设置热点 id&#x3D;10 的 QPS 阈值(即添加例外)</h5><p><strong>1.</strong> 独立设置热点 <strong>id&#x3D;10</strong> 的 <strong>QPS</strong> 阈值**(<strong>即添加例外</strong>)**</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230624104744651.png" alt="image-20230624104744651" style="zoom: 50%;" /><h5 id="10-6-4-3-7-浏览器-http-localhost-10004-news-id-10-amp-type-E6-95-99-E8-82-B2"><a href="#10-6-4-3-7-浏览器-http-localhost-10004-news-id-10-amp-type-E6-95-99-E8-82-B2" class="headerlink" title="10.6.4.3.7 浏览器: http://localhost:10004/news?id=10&amp;type=%E6%95%99%E8%82%B2"></a>10.6.4.3.7 浏览器: <a href="http://localhost:10004/news?id=10&type=%E6%95%99%E8%82%B2">http://localhost:10004/news?id=10&amp;type=%E6%95%99%E8%82%B2</a></h5><p><strong>1.</strong> 浏览器输入: <a href="http://localhost:10004/news?id=10&type=%E6%95%99%E8%82%B2">http://localhost:10004/news?id=10&amp;type=%E6%95%99%E8%82%B2</a> , 如果QPS没有超过 100,则返回正确结果</p><p><strong>2.</strong> <strong>浏览器访问的</strong> <strong>id</strong> <strong>不是</strong>10 <strong>的，仍然遵守</strong> <strong>QPS</strong> <strong>不能超过</strong> <strong>2</strong> <strong>的热点限制</strong></p><h3 id="10-6-5-注意事项和细节"><a href="#10-6-5-注意事项和细节" class="headerlink" title="10.6.5 注意事项和细节"></a>10.6.5 注意事项和细节</h3><h4 id="10-6-5-1-热点参数类型是-byte-x2F-int-x2F-long-x2F-float-x2F-double-x2F-char-x2F-String"><a href="#10-6-5-1-热点参数类型是-byte-x2F-int-x2F-long-x2F-float-x2F-double-x2F-char-x2F-String" class="headerlink" title="10.6.5.1 热点参数类型是(byte&#x2F;int&#x2F;long&#x2F;float&#x2F;double&#x2F;char&#x2F;String)"></a>10.6.5.1 热点参数类型是(byte&#x2F;int&#x2F;long&#x2F;float&#x2F;double&#x2F;char&#x2F;String)</h4><h4 id="10-6-5-2-热点参数值，可以配置多个"><a href="#10-6-5-2-热点参数值，可以配置多个" class="headerlink" title="10.6.5.2 热点参数值，可以配置多个"></a>10.6.5.2 热点参数值，可以配置多个</h4><h4 id="10-6-5-3-热点规则只对指定的参数生效-比如本实例对-id-生效-对-type-不生效"><a href="#10-6-5-3-热点规则只对指定的参数生效-比如本实例对-id-生效-对-type-不生效" class="headerlink" title="10.6.5.3 热点规则只对指定的参数生效 (比如本实例对 id 生效, 对 type 不生效)"></a>10.6.5.3 热点规则只对指定的参数生效 (比如本实例对 id 生效, 对 type 不生效)</h4><h2 id="10-7-系统规则"><a href="#10-7-系统规则" class="headerlink" title="10.7 系统规则"></a>10.7 系统规则</h2><h3 id="10-7-1-一个问题引出系统规则"><a href="#10-7-1-一个问题引出系统规则" class="headerlink" title="10.7.1 一个问题引出系统规则"></a><strong>10.7.1</strong> 一个问题引出系统规则</h3><p>1.如我们系统最大性能能抗 100QPS，如何分配 &#x2F;t1 &#x2F;t2 的 QPS?</p><p><strong>方案1:</strong> &#x2F;t1 分配 QPS&#x3D;50；&#x2F;t2 分配 QPS&#x3D;50，问题，如果&#x2F;t1 当前 QPS 达到 50，而&#x2F;t2 的 QPS 才 10，会造成没有充分利用服务器性能</p><p><strong>方案2:</strong> &#x2F;t1 分配 QPS&#x3D;100 &#x2F;t2 分配 QPS&#x3D;100，问题，容易造成系统没有流量保护造成请求线程堆积，形成雪崩</p><p><u><strong>有没有对各个资源请求的QPS弹性设置，只要总数不超过系统最大QPS的流量保护规则?&#x3D;&gt; 系统规则</strong></u></p><h3 id="10-7-2文-档-地-址"><a href="#10-7-2文-档-地-址" class="headerlink" title="10.7.2文 档 地 址 :"></a><strong>10.7.2</strong>文 档 地 址 <strong>:</strong></h3><p><strong><a href="https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81">https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81</a></strong></p><h3 id="10-7-3-一句话-系统规则作用-在系统稳定的前提下，保持系统的吞吐量"><a href="#10-7-3-一句话-系统规则作用-在系统稳定的前提下，保持系统的吞吐量" class="headerlink" title="10.7.3 一句话**:** 系统规则作用**,** 在系统稳定的前提下，保持系统的吞吐量"></a><strong>10.7.3</strong> 一句话**:** 系统规则作用**,** 在系统稳定的前提下，保持系统的吞吐量</h3><h3 id="10-7-4-基本介绍"><a href="#10-7-4-基本介绍" class="headerlink" title="10.7.4 基本介绍"></a><strong>10.7.4</strong> 基本介绍</h3><p><strong>1.</strong> 一张图<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230624105741809.png" alt="image-20230624105741809" style="zoom:50%;" /></p><p>**2.**解读上图:</p><p>系统处理请求的过程想象为一个水管，到来的请求是往这个水管灌水，当系统处理顺畅的时候，请求不需要排队，直接从水管中穿过，这个请求的RT是最短的，反之，当请求堆积的时候，那么处理请求的时间则会变为:排队时间 + 最短处理时间</p><p>**3.**系统规则(参考以下五种数据来判断系统是否超负荷)</p><ul><li><p>Load 自适应(仅对 Linux&#x2F;Unix-like 机器生效): 系统的 load1 作为启发指标，进行自适应系统保护。当系统 <u>load1 超过设定的启发值</u>，且<u>系统当前的并发线程数超过估算的系统容量</u>时才会触发系统保护(BBR 阶段)。系统容量由系统的 maxQps * minRt 估算得出。设定参考值一般是 CPU cores *2.5</p></li><li><p>CPU usage (1.5.0+ 版本): 当系统 CPU 使用率超过阈值即触发系统保护 (取值范围0.0-1.0)，比较灵敏。</p></li><li><p>平均 RT: 当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</p></li><li><p>并发线程数:当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</p></li><li><p>入口 QPS:当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</p></li></ul><h3 id="10-7-5-实例"><a href="#10-7-5-实例" class="headerlink" title="10.7.5 实例"></a><strong>10.7.5</strong> 实例</h3><h4 id="10-7-5-1-需求分析-x2F-图解"><a href="#10-7-5-1-需求分析-x2F-图解" class="headerlink" title="10.7.5.1 需求分析&#x2F;图解"></a>10.7.5.1 需求分析&#x2F;图解</h4><p><strong>1.<strong>需求</strong>:</strong> 通过 <strong>Sentinel</strong> 实现 系统规则**-**入口 <strong>QPS</strong></p><p><strong>2.<strong>对 <strong>member-service-nacos-provider-10004</strong> 的 所有 <strong>API</strong> 接口进行流量保护，不管访问哪个 <strong>API</strong> 接口</strong>,</strong> 系统入口总的 <strong>QPS</strong> 不能大于 <strong>2,</strong> 大于 <strong>2</strong>，就进行限流控制 </p><p><strong>3.</strong> 提示**:** 上面的 <strong>QPS</strong> 是为了方便看效果**,** 设置的很小</p><h4 id="10-7-5-2-配置实现步骤"><a href="#10-7-5-2-配置实现步骤" class="headerlink" title="10.7.5.2 配置实现步骤"></a>10.7.5.2 配置实现步骤</h4><p><strong>1.</strong> 增加入口 <strong>QPS</strong> 系统规则</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230624110601568.png" alt="image-20230624110601568"></p><h4 id="10-7-5-3-测试"><a href="#10-7-5-3-测试" class="headerlink" title="10.7.5.3 测试"></a>10.7.5.3 测试</h4><h5 id="10-7-5-3-1-启动-Nacos-Server-8848"><a href="#10-7-5-3-1-启动-Nacos-Server-8848" class="headerlink" title="10.7.5.3.1 启动 Nacos Server 8848"></a>10.7.5.3.1 启动 Nacos Server 8848</h5><h5 id="10-7-5-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-7-5-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.7.5.3.2 启动 Sentinel8080 控制台&#x2F;Sentinel dashboard"></a>10.7.5.3.2 启动 Sentinel8080 控制台&#x2F;Sentinel dashboard</h5><h5 id="10-7-5-3-3-启动-member-service-nacos-provider-10004"><a href="#10-7-5-3-3-启动-member-service-nacos-provider-10004" class="headerlink" title="10.7.5.3.3 启动 member-service-nacos-provider-10004"></a>10.7.5.3.3 启动 member-service-nacos-provider-10004</h5><h5 id="10-7-5-3-4-浏览器-http-localhost-10004-t1"><a href="#10-7-5-3-4-浏览器-http-localhost-10004-t1" class="headerlink" title="10.7.5.3.4 浏览器: http://localhost:10004/t1"></a>10.7.5.3.4 浏览器: <a href="http://localhost:10004/t1">http://localhost:10004/t1</a></h5><p><strong>1.</strong> 浏览器输入**: <a href="http://localhost:10004/t1">http://localhost:10004/t1</a> ,** 如果 <strong>QPS</strong> 超过 <strong>2,</strong> 打开断路器，返回流控信息</p><p><strong>2.</strong> 浏览器输入: <a href="http://localhost:10004/news?id=1&type=%E6%95%99%E8%82%B2">http://localhost:10004/news?id=1&amp;type=%E6%95%99%E8%82%B2</a> , 如果QPS 超过2, 打开断路器，返回流控信息(说明: 项目的 &#x2F;t2 资源对应方法有休眠代码，所以使用 &#x2F;news?id&#x3D;x&amp;type&#x3D;x 测试)</p><h2 id="10-8-SentinelResource"><a href="#10-8-SentinelResource" class="headerlink" title="10.8 @SentinelResource"></a>10.8 @SentinelResource</h2><h3 id="10-8-1-自定义全局限流处理类"><a href="#10-8-1-自定义全局限流处理类" class="headerlink" title="10.8.1 自定义全局限流处理类"></a><strong>10.8.1</strong> 自定义全局限流处理类</h3><h4 id="10-8-1-1-需求分析-x2F-图解"><a href="#10-8-1-1-需求分析-x2F-图解" class="headerlink" title="10.8.1.1 需求分析&#x2F;图解"></a>10.8.1.1 需求分析&#x2F;图解</h4><p><strong>1.</strong> 先看前面的一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/news&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;news&quot;,blockHandler = &quot;newsBlockHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryNews</span><span class="params">(<span class="meta">@RequestParam(value = &quot;id&quot;,required = false)</span> String id,</span></span><br><span class="line"><span class="params">                        <span class="meta">@RequestParam(value = &quot;type&quot;,required = false)</span> String type)</span></span><br><span class="line">&#123;</span><br><span class="line">    log.info(<span class="string">&quot;到 DB 查询数据库.... &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;返回 id= &quot;</span> + id + <span class="string">&quot; 新闻 fromDB&quot;</span>); &#125;</span><br><span class="line"><span class="comment">//热点 key 限制异常处理方法</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">newsBlockHandler</span><span class="params">(String id, String type, BlockException exception)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;查询 id= &quot;</span> + id</span><br><span class="line">            + <span class="string">&quot; 新闻 触发热点 key 限制保护.. sorry&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>: <strong>当配置的资源名</strong> news <strong>触发限流机制时，会调用</strong> newsBlockHandler <strong>方法</strong></p><p><strong>2.</strong> <strong>上面的处理方案存在一些问题</strong></p><ul><li><p><strong>每个</strong>@SentinelResource <strong>对应一个异常处理方法，会造成方法很多</strong> </p></li><li><p>异常处理方法和资源请求方法在一起，不利于业务逻辑的分离</p></li></ul><ul><li><strong>解决方案</strong>-&gt; 自定义全局限流处理类</li></ul><p><strong>3.</strong> <strong>需求</strong>: <strong>请编写一个自定义全局限流处理类，完成对异常处理</strong>.</p><h4 id="10-8-1-2-代码实现"><a href="#10-8-1-2-代码实现" class="headerlink" title="10.8.1.2 代码实现"></a>10.8.1.2 代码实现</h4><p><strong>1.</strong> 修改 <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;MemberController.java</strong> 增加方法 <strong>t6()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解读：</span></span><br><span class="line"><span class="comment"> * value = &quot;t6&quot;: SentinelResource 资源名</span></span><br><span class="line"><span class="comment"> * blockHandlerClass = CustomGlobalBlockHandler.class: 全局限流处理类 * blockHandler = &quot;handlerMethod1&quot;: 全局限流处理类的哪个方法,可以指定. */</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/t6&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(</span></span><br><span class="line"><span class="meta">        value = &quot;t6&quot;,</span></span><br><span class="line"><span class="meta">        blockHandlerClass = CustomGlobalBlockHandler.class, blockHandler = &quot;handlerMethod1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">t6</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;执行 t6() 线程 id= &quot;</span> + Thread.currentThread().getId()); <span class="keyword">return</span> Result.success(<span class="string">&quot;200&quot;</span>, <span class="string">&quot;t6()执行成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> <strong>创建</strong> com&#x2F;hspedu&#x2F;springcloud&#x2F;handler&#x2F;CustomGlobalBlockHandler.java </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.springcloud.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;</span><br><span class="line"><span class="keyword">import</span> com.study.springcloud.entity.Result;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/6/24</span></span><br><span class="line"><span class="comment"> * 13:54</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 创建的异常处理方法需要是 static</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomGlobalBlockHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">handlerMethod1</span> <span class="params">(BlockException exception)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;400&quot;</span>, <span class="string">&quot;客户自定义异常处理 handlerm1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">handlerMethod2</span> <span class="params">(BlockException exception)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;401&quot;</span>, <span class="string">&quot;客户自定义异常处理 handlerm2()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-8-1-3-配置实现步骤"><a href="#10-8-1-3-配置实现步骤" class="headerlink" title="10.8.1.3 配置实现步骤"></a>10.8.1.3 配置实现步骤</h4><p><strong>1.</strong> 为资源 <strong>&#x2F;t6</strong> 增加流控规则**,**方便测试</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230624135913223.png" alt="image-20230624135913223" style="zoom:50%;" /><p><strong>2.</strong> <strong>在流控规则菜单，可以看到新增规则</strong></p><h4 id="10-8-1-4-测试"><a href="#10-8-1-4-测试" class="headerlink" title="10.8.1.4 测试"></a>10.8.1.4 测试</h4><h5 id="10-8-1-4-1-启动-Nacos-Server-8848"><a href="#10-8-1-4-1-启动-Nacos-Server-8848" class="headerlink" title="10.8.1.4.1 启动 Nacos Server 8848"></a><strong>10.8.1.4.1</strong> 启动 Nacos Server 8848</h5><h5 id="10-8-1-4-2-启动-Sentinel8080控制台-x2F-Sentinel-dashboard"><a href="#10-8-1-4-2-启动-Sentinel8080控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.8.1.4.2 启动 Sentinel8080控制台&#x2F;Sentinel dashboard"></a>10.8.1.4.2 启动 Sentinel8080控制台&#x2F;Sentinel dashboard</h5><h5 id="10-8-1-4-3-启动-member-service-nacos-provider-10004"><a href="#10-8-1-4-3-启动-member-service-nacos-provider-10004" class="headerlink" title="10.8.1.4.3 启动 member-service-nacos-provider-10004"></a>10.8.1.4.3 启动 member-service-nacos-provider-10004</h5><h5 id="10-8-1-4-4-浏览器-http-localhost-10004-t6"><a href="#10-8-1-4-4-浏览器-http-localhost-10004-t6" class="headerlink" title="10.8.1.4.4 浏览器: http://localhost:10004/t6"></a>10.8.1.4.4 浏览器: <a href="http://localhost:10004/t6">http://localhost:10004/t6</a></h5><p><strong>1.</strong> 浏览器输入**: <a href="http://localhost:10004/t6">http://localhost:10004/t6</a> ,** 如果 <strong>QPS</strong> 没有超过 <strong>1,</strong> 返回正常结果</p><p><strong>2.</strong> 浏览器输入: <a href="http://localhost:10004/t6">http://localhost:10004/t6</a> ,如果QPS 超过 1, 断路器打开，返回自定义限流处理方法信息</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230624140131429.png" alt="image-20230624140131429" style="zoom:50%;" /><h3 id="10-8-2-fallback自定义程序错误处理"><a href="#10-8-2-fallback自定义程序错误处理" class="headerlink" title="10.8.2 fallback自定义程序错误处理"></a>10.8.2 fallback自定义程序错误处理</h3><h4 id="10-8-2-1-看一段代码-引出-fallback"><a href="#10-8-2-1-看一段代码-引出-fallback" class="headerlink" title="10.8.2.1 看一段代码-引出 fallback"></a>10.8.2.1 看一段代码-引出 fallback</h4><p><strong>1.</strong> 修 改 <strong>member-service-nacos-provider-10004</strong> 的<strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;MemberController.java</strong> 增加一段代码**.**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/t6&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(</span></span><br><span class="line"><span class="meta">        value = &quot;t6&quot;,</span></span><br><span class="line"><span class="meta">        blockHandlerClass = CustomGlobalBlockHandler.class, blockHandler = &quot;handlerMethod1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">t6</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//假定: 当访问 t6 资源次数是 5 的倍数时，就出现了一个 java 的异常</span></span><br><span class="line">    <span class="keyword">if</span> (++num % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;num 的值异常 num= &quot;</span> + num); &#125;</span><br><span class="line">        log.info(<span class="string">&quot;执行 t6() 线程 id= &quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;200&quot;</span>, <span class="string">&quot;t6()执行成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 浏览器: <a href="http://localhost:10004/t6">http://localhost:10004/t6</a> , 看效果当num为 5的整数时，返回的是error页面，不友好.</p><p><strong>3.</strong> 怎么解决&#x3D;&gt; 使用 fallback</p><h4 id="10-8-2-2-基本介绍"><a href="#10-8-2-2-基本介绍" class="headerlink" title="10.8.2.2 基本介绍"></a>10.8.2.2 基本介绍</h4><h5 id="10-8-2-2-1-blockHandler只负责sentinel控制台配置违规"><a href="#10-8-2-2-1-blockHandler只负责sentinel控制台配置违规" class="headerlink" title="10.8.2.2.1 blockHandler只负责sentinel控制台配置违规"></a>10.8.2.2.1 blockHandler只负责sentinel控制台配置违规</h5><h5 id="10-8-2-2-2-fallback负责Java异常-x2F-业务异常"><a href="#10-8-2-2-2-fallback负责Java异常-x2F-业务异常" class="headerlink" title="10.8.2.2.2 fallback负责Java异常&#x2F;业务异常"></a>10.8.2.2.2 fallback<strong>负责</strong>Java<strong>异常</strong>&#x2F;业务异常</h5><h4 id="10-8-2-3-需求分析-x2F-图解"><a href="#10-8-2-3-需求分析-x2F-图解" class="headerlink" title="10.8.2.3 需求分析&#x2F;图解"></a>10.8.2.3 需求分析&#x2F;图解</h4><p><strong>1.</strong> 需求**:** 请编写一个自定义全局 <strong>fallback</strong> 处理类**,** 处理 <strong>java</strong> 异常**&#x2F;**业务异常 </p><p><strong>2.</strong> 也就是解决前面我们提出的问题</p><h4 id="10-8-2-4-代码实现"><a href="#10-8-2-4-代码实现" class="headerlink" title="10.8.2.4 代码实现"></a>10.8.2.4 代码实现</h4><p><strong>1.</strong> 在 <strong>member-service-nacos-provider-10004</strong> 创建<strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;handler&#x2F;CustomGlobalFallbackHandler.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomGlobalFallbackHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">fallBackHandlerMethod1</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;400&quot;</span>, <span class="string">&quot;java 异常信息= &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">fallBackHandlerMethod2</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;401&quot;</span>, <span class="string">&quot;java 异常信息= &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.<strong>在 member-service-nacos-provider-10004修改</strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;MemberController.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解读</span></span><br><span class="line"><span class="comment"> * value = &quot;t6&quot;: SentinelResource 资源名</span></span><br><span class="line"><span class="comment"> * blockHandlerClass = CustomGlobalBlockHandler.class: 全局限流处理类 * blockHandler = &quot;handlerMethod1&quot;: 全局限流处理类的哪个方法,可以指定. */</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/t6&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(</span></span><br><span class="line"><span class="meta">        value = &quot;t6&quot;,</span></span><br><span class="line"><span class="meta">        fallbackClass = CustomGlobalFallbackHandler.class,</span></span><br><span class="line"><span class="meta">        fallback = &quot;fallBackHandlerMethod1&quot;,</span></span><br><span class="line"><span class="meta">        blockHandlerClass = CustomGlobalBlockHandler.class,</span></span><br><span class="line"><span class="meta">        blockHandler = &quot;handlerMethod1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">t6</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//假定: 当访问 t6 资源次数是 5 的倍数时，就出现了一个 java 的异常</span></span><br><span class="line">    <span class="keyword">if</span> (++num % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;num 的值异常 num= &quot;</span> + num); &#125;</span><br><span class="line">        log.info(<span class="string">&quot;执行 t6() 线程 id= &quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;200&quot;</span>, <span class="string">&quot;t6()执行成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-8-2-5-测试"><a href="#10-8-2-5-测试" class="headerlink" title="10.8.2.5 测试"></a>10.8.2.5 测试</h4><h5 id="10-8-2-5-1-启动-Nacos-Server-8848"><a href="#10-8-2-5-1-启动-Nacos-Server-8848" class="headerlink" title="10.8.2.5.1 启动 Nacos Server 8848"></a>10.8.2.5.1 启动 Nacos Server 8848</h5><h5 id="10-8-2-5-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-8-2-5-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.8.2.5.2 启动 Sentinel8080 控制台&#x2F;Sentinel dashboard"></a>10.8.2.5.2 启动 <strong>Sentinel8080</strong> 控制台&#x2F;Sentinel dashboard</h5><h5 id="10-8-2-5-3-启动-member-service-nacos-provider-10004"><a href="#10-8-2-5-3-启动-member-service-nacos-provider-10004" class="headerlink" title="10.8.2.5.3 启动 member-service-nacos-provider-10004"></a>10.8.2.5.3 启动 member-service-nacos-provider-10004</h5><h5 id="10-8-2-5-4-浏览器-http-localhost-10004-t6"><a href="#10-8-2-5-4-浏览器-http-localhost-10004-t6" class="headerlink" title="10.8.2.5.4 浏览器: http://localhost:10004/t6"></a>10.8.2.5.4 浏览器: <a href="http://localhost:10004/t6">http://localhost:10004/t6</a></h5><p><strong>1.</strong> 浏览器输入**: <a href="http://localhost:10004/t6">http://localhost:10004/t6</a> ,** 访问次数不是 <strong>5</strong> 的倍数**,** 返回正常结果</p><p><strong>2.</strong> 浏览器输入: <a href="http://localhost:10004/t6">http://localhost:10004/t6</a> , 访问次数是 5 的倍数, 返回 fallback指定方法信息</p><p><strong>3.</strong> <strong>为资源</strong> <strong>&#x2F;t6</strong> <strong>增加流控规则</strong>,方便测试</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230624142029799.png" alt="image-20230624142029799" style="zoom:50%;" /><p><strong>4.</strong> <strong>在流控规则菜单，可以看到新增规则</strong></p><p><strong>5.</strong> 浏览器输入: <a href="http://localhost:10004/t6">http://localhost:10004/t6</a> , <strong>如果访问 QPS 大于1 , 由blockHandler指定的方法处理,访问次数是 5 的倍数, 由fallback指定方法处理,其它情况返回正常的结果.</strong></p><h3 id="10-8-3-exceptionsToIgnore-希望忽略某个异常"><a href="#10-8-3-exceptionsToIgnore-希望忽略某个异常" class="headerlink" title="10.8.3 exceptionsToIgnore  希望忽略某个异常"></a>10.8.3 exceptionsToIgnore  希望忽略某个异常</h3><h4 id="10-8-3-1-如果希望忽略某个异常，可以使用-exceptionsToIgnore"><a href="#10-8-3-1-如果希望忽略某个异常，可以使用-exceptionsToIgnore" class="headerlink" title="10.8.3.1 如果希望忽略某个异常，可以使用 exceptionsToIgnore"></a>10.8.3.1 如果希望忽略某个异常，可以使用 exceptionsToIgnore</h4><h4 id="10-8-3-2-应用实例"><a href="#10-8-3-2-应用实例" class="headerlink" title="10.8.3.2 应用实例"></a>10.8.3.2 应用实例</h4><p><strong>1.</strong> 如果希望忽略某个异常**(<strong>支持数组</strong>)**，可以使用 <strong>exceptionsToIgnore</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/t6&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(</span></span><br><span class="line"><span class="meta">        value = &quot;t6&quot;,</span></span><br><span class="line"><span class="meta">        fallbackClass = CustomGlobalFallbackHandler.class,</span></span><br><span class="line"><span class="meta">        fallback = &quot;fallBackHandlerMethod1&quot;,</span></span><br><span class="line"><span class="meta">        blockHandlerClass = CustomGlobalBlockHandler.class,</span></span><br><span class="line"><span class="meta">        blockHandler = &quot;handlerMethod1&quot;,</span></span><br><span class="line"><span class="meta">        exceptionsToIgnore = &#123;RuntimeException.class&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">t6</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//假定: 当访问 t6 资源次数是 5 的倍数时，就出现了一个 java 的异常</span></span><br><span class="line">    <span class="keyword">if</span> (++num % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;num 的值异常 num= &quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;执行 t6() 线程 id= &quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;200&quot;</span>, <span class="string">&quot;t6()执行成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 浏览器输入: <a href="http://localhost:10004/t6">http://localhost:10004/t6</a> , 你会发现访问次数为 5 的倍数时，不再调用 fallback 指定方法处理</p><p>​而是使用RuntimeException.class中的方式(即默认方式)处理</p><h3 id="10-8-4-接入-Sentinel-的方式"><a href="#10-8-4-接入-Sentinel-的方式" class="headerlink" title="10.8.4 接入 Sentinel 的方式"></a>10.8.4 接入 Sentinel 的方式</h3><p><u>即(不进入sentinel控制台网页而使用sentinel)</u></p><h4 id="10-8-4-1-代码方式-硬编码，侵入性强-不推荐"><a href="#10-8-4-1-代码方式-硬编码，侵入性强-不推荐" class="headerlink" title="10.8.4.1 代码方式(硬编码，侵入性强, 不推荐)"></a>10.8.4.1 代码方式(硬编码，侵入性强, 不推荐)</h4><p><strong>1.</strong> 文档地址**:** <strong><a href="https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D">https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D</a></strong></p><p><strong>2.</strong> 基本使用</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230629202935657.png" alt="image-20230629202935657" style="zoom:50%;" /><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230629203105770.png" alt="image-20230629203105770"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230629203336858.png" alt="image-20230629203336858"></p><h4 id="10-8-4-2-注解方式-低侵入性-前面用过-推荐"><a href="#10-8-4-2-注解方式-低侵入性-前面用过-推荐" class="headerlink" title="10.8.4.2 注解方式(低侵入性, 前面用过, 推荐)"></a>10.8.4.2 注解方式(低侵入性, 前面用过, 推荐)</h4><p><strong>1.</strong> 注解方式埋点不支持 <strong>private</strong> 方法</p><p><a href="https://xue.baidu.com/okam/pages/strategy-tp/index?strategyId=136707206360879&source=natural">https://xue.baidu.com/okam/pages/strategy-tp/index?strategyId=136707206360879&amp;source=natural</a></p><p><strong>2.</strong> @SentinelResource 用于定义资源，并提供可选的异常处理和fallback配置项。</p><p><strong>3. @SentinelResource</strong> <strong>注解包含以下属性</strong>(我们再梳理一下)</p><ul><li><p><strong>value</strong>:资源名称，必需项(不能为空)</p></li><li><p><strong>entryType</strong>:entry 类型，可选项(默认为EntryType.OUT)</p></li><li><p><strong>blockHandler &#x2F; blockHandlerClass</strong>: blockHandler <strong>对应处理</strong> <strong>BlockException</strong> 的函数名称，可选项blockHandler<u>函数访问范围需要是public</u>，返回类型需要与原方法相匹配，参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为BlockException。blockHandler 函数默认需要和原方法在同一个类中。若希望使用其 他类的函数，则可以指定blockHandlerClass为对应的类的Class对象，注意对应的函数必需为 static 函数，否则无法解析。</p></li><li><p><strong>fallback &#x2F; fallbackClass</strong>:fallback 函数名称，可选项，<u>用于在抛出异常的时候提供fallback处理逻辑</u>。fallback函数可以针对所有类型的异常(除了exceptionsToIgnore里面排除掉的异常类型)进行处理。fallback 函数签名和位置要求:</p></li></ul><ol><li>返回值类型必须与原函数返回值类型一致;</li><li>方法参数列表需要和原函数一致，或者可以额外多一个Throwable类型的参数用于接收对应的异常。</li><li>fallback函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定<u>fallbackClass</u>为对应的类的Class对象，注意对应的函数必需为static函数，否则无法解析。</li></ol><ul><li><strong>defaultFallback(since 1.6.0</strong>):默认的 fallback函数名称，可选项，通常用于通用的fallback逻辑(即可以用于很多服务或方法)。默认fallback函数可以针对所有类型 的异常(除了exceptionsToIgnore里面排除掉的异常类型)进行处理。若同时配置了fallback和defaultFallback，则只有fallback会生效。defaultFallback 函数签名要求:</li></ul><ol><li>返回值类型必须与原函数返回值类型一致;</li><li>方法参数列表需要为空，或者可以额外多一个Throwable类型的参数用于接收对应的异常。</li><li>defaultFallback函数默认需要和原方法在同一个类中。若希望使用其他类的函数， 则可以指定fallbackClass为对应的类的Class对象，注意对应的函数必需为static函数，否则无法解析。</li></ol><ul><li>exceptionsToIgnore(since 1.6.0)：用于指定哪些异常被排除掉，不会进入异常统计中，也不会进入fallback逻辑中，而是会原样抛出。</li></ul><h2 id="10-9-openFeign-sentinel-对远程调用熔断降级"><a href="#10-9-openFeign-sentinel-对远程调用熔断降级" class="headerlink" title="10.9 openFeign+sentinel 对远程调用熔断降级"></a>10.9 openFeign+sentinel 对远程调用熔断降级</h2><h3 id="10-9-1-当前微服务基础环境"><a href="#10-9-1-当前微服务基础环境" class="headerlink" title="10.9.1 当前微服务基础环境"></a><strong>10.9.1</strong> 当前微服务基础环境</h3><h4 id="10-9-1-1-当前微服务环境架构图"><a href="#10-9-1-1-当前微服务环境架构图" class="headerlink" title="10.9.1.1 当前微服务环境架构图"></a>10.9.1.1 当前微服务环境架构图</h4><p>– 示意图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230629205804092.png" alt="image-20230629205804092"></p><h4 id="10-9-1-2-测试"><a href="#10-9-1-2-测试" class="headerlink" title="10.9.1.2 测试"></a>10.9.1.2 测试</h4><h5 id="10-9-1-2-1-启动-Nacos-Server-8848"><a href="#10-9-1-2-1-启动-Nacos-Server-8848" class="headerlink" title="10.9.1.2.1 启动 Nacos Server 8848"></a>10.9.1.2.1 启动 Nacos Server 8848</h5><h5 id="10-9-1-2-2-启动-member-service-nacos-provider-10004-x2F-10006"><a href="#10-9-1-2-2-启动-member-service-nacos-provider-10004-x2F-10006" class="headerlink" title="10.9.1.2.2 启动 member-service-nacos-provider-10004&#x2F;10006"></a>10.9.1.2.2 启动 member-service-nacos-provider-10004&#x2F;10006</h5><h5 id="10-9-1-2-3-启动-member-service-nacos-consumer-80"><a href="#10-9-1-2-3-启动-member-service-nacos-consumer-80" class="headerlink" title="10.9.1.2.3 启动 member-service-nacos-consumer-80"></a>10.9.1.2.3 启动 member-service-nacos-consumer-80</h5><h5 id="10-9-1-2-4-浏览器-http-localhost-member-nacos-consumer-get-1"><a href="#10-9-1-2-4-浏览器-http-localhost-member-nacos-consumer-get-1" class="headerlink" title="10.9.1.2.4 浏览器**: http://localhost/member/nacos/consumer/get/1**"></a>10.9.1.2.4 浏览器**: <a href="http://localhost/member/nacos/consumer/get/1">http://localhost/member/nacos/consumer/get/1</a>**</h5><p><strong>1.</strong> 浏 览 器 输 入 <strong>: <a href="http://localhost/member/nacos/consumer/get/1">http://localhost/member/nacos/consumer/get/1</a> ,</strong> 目 前 是 <strong>Ribbon+RestTemplate</strong></p><h3 id="10-9-2-服务消费者整合-Openfeign"><a href="#10-9-2-服务消费者整合-Openfeign" class="headerlink" title="10.9.2 服务消费者整合 Openfeign"></a><strong>10.9.2</strong> 服务消费者整合 Openfeign</h3><p><strong>1.</strong> 需求:在 <strong>member-service-nacos-consumer-80</strong> 整合 <strong>Openfeign</strong> 实现远程调用</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230629210226986.png" alt="image-20230629210226986"></p><h4 id="10-9-2-2-代码-配置实现步骤"><a href="#10-9-2-2-代码-配置实现步骤" class="headerlink" title="10.9.2.2 代码+配置实现步骤"></a>10.9.2.2 代码+配置实现步骤</h4><p><strong>1.</strong> 修改 <strong>member-service-nacos-consumer-80</strong> 的 <strong>pom.xml</strong> 加入 <strong>openfeign</strong> 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    引入openfeign-start，即场景启动器    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.</strong> <strong>在</strong> <strong>member-service-nacos-consumer-80</strong> <strong>创 建</strong>com&#x2F;study&#x2F;springcloud&#x2F;service&#x2F;MemberOpenFeignService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.springcloud.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.study.springcloud.entity.Member;</span><br><span class="line"><span class="keyword">import</span> com.study.springcloud.entity.Result;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/6/29</span></span><br><span class="line"><span class="comment"> * 21:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;member-service-nacos-provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MemberOpenFeignService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 老韩解读</span></span><br><span class="line"><span class="comment">     * 1. 远程调用的方式为 get</span></span><br><span class="line"><span class="comment">     * 2. 远程调用的 url 为 http://member-service-nacos-provider/member/get/&#123;id&#125;</span></span><br><span class="line"><span class="comment">     * 3. member-service-nacos-provider 是 nacos 注册中心服务 member-service-nacos-provider:10004/10006 </span></span><br><span class="line"><span class="comment">     * 4. 会根据 OpenFeign 的均衡算法来决定是调用 10004 还是 10006</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/member/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Member&gt; <span class="title function_">getMembertById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.</strong> <strong>在</strong> <strong>member-service-nacos-consumer-80</strong> <strong>修改</strong> <strong>com&#x2F;study&#x2F;springcloud&#x2F;controller&#x2F;MemberNacosConsumerController.java</strong> 增加方法getMemberOpenfeignById()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/member/openfeign/consumer/get/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;Member&gt; <span class="title function_">getMemberOpenfeignById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//这里使用 Openfeign 接口方式远程调用服务</span></span><br><span class="line">    System.out.println(<span class="string">&quot;通过 openfeignd+负载均衡 调用服务&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> memberOpenFeignService.getMemberById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.</strong> <strong>再在</strong> <strong>member-service-nacos-consumer-80</strong> <strong>的主启动类加入注解</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;MemberNacosConsumerApplication80.java</strong></p><p>「@EnableFeignClients」</p><h4 id="10-9-2-3-测试"><a href="#10-9-2-3-测试" class="headerlink" title="10.9.2.3 测试"></a>10.9.2.3 测试</h4><h5 id="10-9-2-3-1-启动-Nacos-Server-8848"><a href="#10-9-2-3-1-启动-Nacos-Server-8848" class="headerlink" title="10.9.2.3.1 启动 Nacos Server 8848"></a>10.9.2.3.1 启动 Nacos Server 8848</h5><h5 id="10-9-2-3-2-启动-member-service-nacos-provider-10004-x2F-10006"><a href="#10-9-2-3-2-启动-member-service-nacos-provider-10004-x2F-10006" class="headerlink" title="10.9.2.3.2 启动 **member-service-nacos-provider-10004&#x2F;10006 **"></a>10.9.2.3.2 启动 **member-service-nacos-provider-10004&#x2F;10006 **</h5><h5 id="10-9-2-3-3-启动-member-service-nacos-consumer-80"><a href="#10-9-2-3-3-启动-member-service-nacos-consumer-80" class="headerlink" title="10.9.2.3.3 启动 member-service-nacos-consumer-80"></a><strong>10.9.2.3.3</strong> 启动 member-service-nacos-consumer-80</h5><h5 id="10-9-2-3-4-浏览器-http-localhost-member-openfeign-consumer-get-1"><a href="#10-9-2-3-4-浏览器-http-localhost-member-openfeign-consumer-get-1" class="headerlink" title="10.9.2.3.4 浏览器**: http://localhost/member/openfeign/consumer/get/1**"></a>10.9.2.3.4 浏览器**: <a href="http://localhost/member/openfeign/consumer/get/1">http://localhost/member/openfeign/consumer/get/1</a>**</h5><p><strong>1.</strong> 浏览器输入**: <a href="http://localhost/member/openfeign/consumer/get/1">http://localhost/member/openfeign/consumer/get/1</a> , 目前是 <strong>Openfeign 调用</strong>(<strong>负载均衡</strong>)**</p><h3 id="10-9-3-服务消费者整合-Sentinel"><a href="#10-9-3-服务消费者整合-Sentinel" class="headerlink" title="10.9.3 服务消费者整合 Sentinel"></a>10.9.3 服务消费者整合 Sentinel</h3><h4 id="10-9-3-1-需求分析-x2F-图解"><a href="#10-9-3-1-需求分析-x2F-图解" class="headerlink" title="10.9.3.1 需求分析&#x2F;图解"></a>10.9.3.1 需求分析&#x2F;图解</h4><p><strong>1.</strong> 需求:在 <strong>member-service-nacos-consumer-80</strong> 整合 <strong>Sentinel</strong> 能被 <strong>Sentinel</strong> 监控</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230630165412038.png" alt="image-20230630165412038" style="zoom:50%;" /><h4 id="10-9-3-2-代码-配置实现步骤"><a href="#10-9-3-2-代码-配置实现步骤" class="headerlink" title="10.9.3.2 代码+配置实现步骤"></a>10.9.3.2 代码+配置实现步骤</h4><p><strong>1.</strong> 修改 <strong>member-service-nacos-consumer-80</strong> 的 <strong>pom.xml</strong> 加入 <strong>sentinel</strong> 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入 alibaba-sentinel --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.</strong> 修改 <strong>member-service-nacos-consumer-80</strong> 的 <strong>application.yml</strong> 配置 <strong>sentinel</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">member-service-consumer-80</span></span><br><span class="line">    <span class="comment">#配置nacos</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment">#启动nacos服务的ip以及端口</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span> <span class="comment">#这个是 sentinel 控制台(sentinel dashboard)的地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span> <span class="comment">#默认 8719，假如被占用了, 会自动从 8719 开始依次+1 扫描。直至找到未被占用的端口</span></span><br><span class="line"><span class="attr">management:</span> <span class="comment">#暴露所有监控点</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="10-9-3-3-测试"><a href="#10-9-3-3-测试" class="headerlink" title="10.9.3.3 测试"></a>10.9.3.3 测试</h4><h5 id="10-9-3-3-1-启动-Nacos-Server-8848"><a href="#10-9-3-3-1-启动-Nacos-Server-8848" class="headerlink" title="10.9.3.3.1 启动 Nacos Server 8848"></a><strong>10.9.3.3.1</strong> 启动 Nacos Server 8848</h5><h5 id="10-9-3-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-9-3-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.9.3.3.2 启动 Sentinel8080 控制台&#x2F;Sentinel dashboard"></a>10.9.3.3.2 启动 <strong>Sentinel8080</strong> 控制台&#x2F;Sentinel dashboard</h5><h5 id="10-9-3-3-3-启动-member-service-nacos-provider-10004-x2F-10006"><a href="#10-9-3-3-3-启动-member-service-nacos-provider-10004-x2F-10006" class="headerlink" title="10.9.3.3.3 启动 **member-service-nacos-provider-10004&#x2F;10006 **"></a>10.9.3.3.3 启动 **member-service-nacos-provider-10004&#x2F;10006 **</h5><h5 id="10-9-3-3-4-启动-member-service-nacos-consumer-80"><a href="#10-9-3-3-4-启动-member-service-nacos-consumer-80" class="headerlink" title="10.9.3.3.4 启动 member-service-nacos-consumer-80"></a><strong>10.9.3.3.4</strong> 启动 member-service-nacos-consumer-80</h5><h5 id="10-9-3-3-5-浏览器-http-localhost-member-openfeign-consumer-get-1"><a href="#10-9-3-3-5-浏览器-http-localhost-member-openfeign-consumer-get-1" class="headerlink" title="10.9.3.3.5 浏览器**: http://localhost/member/openfeign/consumer/get/1**"></a>10.9.3.3.5 浏览器**: <a href="http://localhost/member/openfeign/consumer/get/1">http://localhost/member/openfeign/consumer/get/1</a>**</h5><p><strong>1.</strong> 浏览器输入**: <a href="http://localhost/member/openfeign/consumer/get/1">http://localhost/member/openfeign/consumer/get/1</a> ,** 目前是 <strong>Openfeign</strong> 调用**(<strong>负载均衡</strong>)**</p><p><strong>2.</strong> <strong>登录</strong> <strong>sentinel</strong> <strong>控制台</strong>: <strong>可以看到已经监控到</strong> <strong>member-service-nacos-consumer</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230630170804677.png" alt="image-20230630170804677"></p><h3 id="10-9-4-openFeign-sentinel-对远程调用熔断降级"><a href="#10-9-4-openFeign-sentinel-对远程调用熔断降级" class="headerlink" title="10.9.4 openFeign+sentinel 对远程调用熔断降级"></a>10.9.4 openFeign+sentinel 对远程调用熔断降级</h3><h4 id="10-9-4-1-需求分析-x2F-图解"><a href="#10-9-4-1-需求分析-x2F-图解" class="headerlink" title="10.9.4.1 需求分析&#x2F;图解"></a>10.9.4.1 需求分析&#x2F;图解</h4><p><strong>1.</strong> 需求**&#x2F;<strong>如图:在 <strong>member-service-nacos-consumer-80</strong> 调用某个无效服务时，启动 Sentinel 的熔断降级机制 <strong>,</strong> 能够快速返回响应，而不是使用默认的超时机制(因为超时机制容易线程堆积</strong>,** 从而导致雪崩)</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230630170956206.png" alt="image-20230630170956206"></p><p><strong>2.</strong> <strong>先测试一下，关闭</strong> <strong>10004&#x2F;10006,</strong> <strong>这时</strong> <strong>openfeign</strong> <strong>去调用会怎么样</strong>? (返回 <strong>time out)</strong></p><p><strong>3.</strong> <strong>还可以测试一下，让</strong> <strong>10004</strong> <strong>服务对应的</strong> <strong>API</strong> <strong>执行时间很长</strong>(比如休眠 <strong>2</strong> <strong>秒</strong>), <strong>这 时</strong> <strong>openfeign</strong> <strong>去调用会怎么样</strong>?</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230630171235813.png" alt="image-20230630171235813"></p><h4 id="10-9-4-2-代码-配置实现步骤"><a href="#10-9-4-2-代码-配置实现步骤" class="headerlink" title="10.9.4.2 代码+配置实现步骤"></a>10.9.4.2 代码+配置实现步骤</h4><p><strong>1.</strong> 修 改 <strong>member-service-nacos-consumer-80</strong> 的</p><p><strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;service&#x2F;MemberOpenFeignService.java,</strong> 加入 <strong>fallback</strong> 的处理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.springcloud.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.study.springcloud.entity.Member;</span><br><span class="line"><span class="keyword">import</span> com.study.springcloud.entity.Result;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/6/29</span></span><br><span class="line"><span class="comment"> * 21:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;member-service-nacos-provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MemberOpenFeignService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 老韩解读</span></span><br><span class="line"><span class="comment">     * 1. 远程调用的方式为 get</span></span><br><span class="line"><span class="comment">     * 2. 远程调用的 url 为 http://member-service-nacos-provider/member/get/&#123;id&#125;</span></span><br><span class="line"><span class="comment">     * 3. member-service-nacos-provider 是</span></span><br><span class="line"><span class="comment">     * nacos 注册中心服务 member-service-nacos-provider:10004/10006 </span></span><br><span class="line"><span class="comment">     * 4. 会根据 OpenFeign 的均衡算法来决定是调用 10004 还是 10006</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/member/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Member&gt; <span class="title function_">getMemberById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 创建 <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;service&#x2F;MemberFeignFallbackService.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.springcloud.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.study.springcloud.entity.Member;</span><br><span class="line"><span class="keyword">import</span> com.study.springcloud.entity.Result;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/6/30</span></span><br><span class="line"><span class="comment"> * 17:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberFeignFallbackService</span> <span class="keyword">implements</span> <span class="title class_">MemberOpenFeignService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Member&gt; <span class="title function_">getMemberById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;500&quot;</span>, <span class="string">&quot;被调用服务异常, 熔断降级，快速返回结果, 防止线程堆 积&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.</strong> 修改 <strong>member-service-nacos-consumer-80</strong> 的 <strong>application.yml ,</strong> 加入 <strong>openfeign</strong> 和 <strong>sentinel</strong> 整合配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">末尾添加以下：</span></span><br><span class="line"><span class="comment">#openfeign 和 sentinel 整合，必须配</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="10-9-4-3-测试"><a href="#10-9-4-3-测试" class="headerlink" title="10.9.4.3 测试"></a>10.9.4.3 测试</h4><h5 id="10-9-4-3-1-启动-Nacos-Server-8848"><a href="#10-9-4-3-1-启动-Nacos-Server-8848" class="headerlink" title="10.9.4.3.1 启动 Nacos Server 8848"></a><strong>10.9.4.3.1</strong> 启动 Nacos Server 8848</h5><h5 id="10-9-4-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-9-4-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.9.4.3.2 启动 Sentinel8080 控制台&#x2F;Sentinel dashboard"></a>10.9.4.3.2 启动 <strong>Sentinel8080</strong> 控制台&#x2F;Sentinel dashboard</h5><h5 id="10-9-4-3-3-关闭-member-service-nacos-provider-10004-x2F-10006"><a href="#10-9-4-3-3-关闭-member-service-nacos-provider-10004-x2F-10006" class="headerlink" title="10.9.4.3.3 关闭 **member-service-nacos-provider-10004&#x2F;10006 **"></a>10.9.4.3.3 关闭 **member-service-nacos-provider-10004&#x2F;10006 **</h5><h5 id="10-9-4-3-4-启动-member-service-nacos-consumer-80"><a href="#10-9-4-3-4-启动-member-service-nacos-consumer-80" class="headerlink" title="10.9.4.3.4 启动 member-service-nacos-consumer-80"></a><strong>10.9.4.3.4</strong> 启动 member-service-nacos-consumer-80</h5><h5 id="10-9-4-3-5-浏览器-http-localhost-member-openfeign-consumer-get-1"><a href="#10-9-4-3-5-浏览器-http-localhost-member-openfeign-consumer-get-1" class="headerlink" title="10.9.4.3.5 浏览器**: http://localhost/member/openfeign/consumer/get/1**"></a>10.9.4.3.5 浏览器**: <a href="http://localhost/member/openfeign/consumer/get/1">http://localhost/member/openfeign/consumer/get/1</a>**</h5><p><strong>1.</strong> 浏览器输入**: <a href="http://localhost/member/openfeign/consumer/get/1">http://localhost/member/openfeign/consumer/get/1</a> ,** 目前是 <strong>Openfeign</strong> 调用**(<strong>负载均衡</strong>)**</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230630172238879.png" alt="image-20230630172238879" style="zoom:50%;" /><h4 id="10-9-4-4-注意事项和细节说明"><a href="#10-9-4-4-注意事项和细节说明" class="headerlink" title="10.9.4.4 注意事项和细节说明"></a>10.9.4.4 注意事项和细节说明</h4><p><strong>1.</strong> 因为 <strong>member-service-nacos-consumer-80</strong> 已经被 <strong>sentinel</strong> 监控，所以我们可以加入相</p><p>关的流控规则**,** 比如为 <strong>&#x2F;member&#x2F;openfeign&#x2F;consumer&#x2F;get&#x2F;1</strong> 加入流控规则 <strong>qps &#x3D; 1</strong></p><p><strong>测试</strong>: <strong>如果</strong>&#x2F;member&#x2F;openfeign&#x2F;consumer&#x2F;get&#x2F;1 <strong>请求</strong> <strong>QPS</strong> <strong>超过</strong> <strong>1,</strong> <strong>会输出Blocked by Sentinel (flow limiting)</strong></p><p><strong>QPS</strong> <strong>没有超过</strong> <strong>1,</strong> <strong>会被</strong> <strong>fallback</strong> <strong>处理</strong></p><p><strong>2.</strong> <strong>如果远程服务恢复正常</strong>, <strong>又会正常调用</strong>.</p><h2 id="10-10-规则持久化"><a href="#10-10-规则持久化" class="headerlink" title="10.10 规则持久化"></a>10.10 规则持久化</h2><h3 id="10-10-1-规则没有持久化的问题"><a href="#10-10-1-规则没有持久化的问题" class="headerlink" title="10.10.1 规则没有持久化的问题"></a><strong>10.10.1</strong> 规则没有持久化的问题</h3><h4 id="10-10-1-1-如果-sentinel-流控规则没有持久化，当重启调用-API-x2F-接口-所在微服务后，规则就会丢失，需要-重新加入"><a href="#10-10-1-1-如果-sentinel-流控规则没有持久化，当重启调用-API-x2F-接口-所在微服务后，规则就会丢失，需要-重新加入" class="headerlink" title="10.10.1.1 如果 sentinel 流控规则没有持久化，当重启调用 API&#x2F;接口 所在微服务后，规则就会丢失，需要 重新加入"></a>10.10.1.1 如果 sentinel 流控规则没有持久化，当重启调用 API&#x2F;接口 所在微服务后，规则就会丢失，需要 重新加入</h4><h4 id="10-10-1-2-解决方案-通过-Nacos-进行持久化"><a href="#10-10-1-2-解决方案-通过-Nacos-进行持久化" class="headerlink" title="10.10.1.2 解决方案:通过 Nacos 进行持久化"></a>10.10.1.2 解决方案:通过 Nacos 进行持久化</h4><h3 id="10-10-2-规则持久化方案"><a href="#10-10-2-规则持久化方案" class="headerlink" title="10.10.2 规则持久化方案"></a><strong>10.10.2</strong> 规则持久化方案</h3><h4 id="10-10-2-1-阿里云-Ahas-最方便-x2F-付费"><a href="#10-10-2-1-阿里云-Ahas-最方便-x2F-付费" class="headerlink" title="10.10.2.1 阿里云 Ahas[最方便&#x2F;付费]"></a>10.10.2.1 阿里云 Ahas[最方便&#x2F;付费]</h4><p><strong>1.</strong> 官方文档 <strong>: <a href="https://help.aliyun.com/product/87450.html?spm=5176.cnahas.0.0.78034bb7ef0y86">https://help.aliyun.com/product/87450.html?spm=5176.cnahas.0.0.78034bb7ef0y86</a></strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230630190919413.png" alt="image-20230630190919413" style="zoom:50%;" /><h4 id="10-10-2-2-🌟在-Nacos-Server-配置规则-完成持久化-官方推荐"><a href="#10-10-2-2-🌟在-Nacos-Server-配置规则-完成持久化-官方推荐" class="headerlink" title="10.10.2.2 🌟在 Nacos Server 配置规则, 完成持久化 -官方推荐"></a>10.10.2.2 🌟在 Nacos Server 配置规则, 完成持久化 -官方推荐</h4><h4 id="10-10-2-3-将规则持久化到本地文件-定时同步"><a href="#10-10-2-3-将规则持久化到本地文件-定时同步" class="headerlink" title="10.10.2.3 将规则持久化到本地文件, 定时同步"></a>10.10.2.3 将规则持久化到本地文件, 定时同步</h4><h4 id="10-10-2-4-其它…"><a href="#10-10-2-4-其它…" class="headerlink" title="10.10.2.4 其它…"></a>10.10.2.4 其它…</h4><h3 id="10-10-3-Nacos-Server-配置中心-规则持久化实例"><a href="#10-10-3-Nacos-Server-配置中心-规则持久化实例" class="headerlink" title="10.10.3 Nacos Server 配置中心**-**规则持久化实例"></a><strong>10.10.3 Nacos Server</strong> 配置中心**-**规则持久化实例</h3><h4 id="10-10-3-1-工作原理示意图"><a href="#10-10-3-1-工作原理示意图" class="headerlink" title="10.10.3.1 工作原理示意图"></a>10.10.3.1 工作原理示意图</h4><p>其实就是靠把规则保存到nacos中，下次重启服务时再从nacos中获取先前设置的规则信息</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230630191350485.png" alt="image-20230630191350485"></p><h4 id="10-10-3-2-需求分析-x2F-图解"><a href="#10-10-3-2-需求分析-x2F-图解" class="headerlink" title="10.10.3.2 需求分析&#x2F;图解"></a>10.10.3.2 需求分析&#x2F;图解</h4><p><strong>1.</strong> 需 求 <strong>:</strong> 为 <strong>member-service-nacos-consumer-80</strong> 微服务的**&#x2F;member&#x2F;openfeign&#x2F;consumer&#x2F;get&#x2F;1 API** 接口添加流控规则 **QPS&#x3D;1&#x2F;**快速失败 <strong>.</strong></p><p><strong>2.</strong> <strong>要求将该流控规则加入到</strong> <strong>nacos server</strong> <strong>配置中心，实现持久化</strong></p><h4 id="10-10-3-3-代码-配置实现步骤"><a href="#10-10-3-3-代码-配置实现步骤" class="headerlink" title="10.10.3.3 代码+配置实现步骤"></a>10.10.3.3 代码+配置实现步骤</h4><p><strong>1.</strong> 在 <strong>Nacos Server</strong> 配置中心增加 <strong>Sentinel</strong> 客户端**&#x2F;**微服务模块的流控规则</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230630191715975.png" alt="image-20230630191715975" style="zoom:50%;" /><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span><span class="string">&quot;/member/openfeign/consumer/get/1&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;limitApp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;grade&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;strategy&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;controlBehavior&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;clusterMode&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230630192956899.png" alt="image-20230630192956899"></p><p><strong>2.</strong> <strong>在</strong> <strong>Nacos Server</strong> <strong>配置中心增加</strong> <strong>Sentinel</strong> <strong>客户端</strong>&#x2F;微服务模块的流控规则参数说明</p><ul><li><strong>resource</strong> ∶ 资源名称;</li><li><strong>limlitApp</strong> ∶  来源应用;</li><li>**grade **∶ 阈值类型，0 表示线程数，1 表示QPS;</li><li><strong>count</strong> ∶ 单机阈值;</li><li>**strategy **∶ 流控模式，0 表示直接，1 表示关联，2 表示链路;</li><li>**controlBehavior **∶ 流控效果，0 表示快速失败，1 表示Warm Up，2 表示排队等待;</li><li>**clusterMode **∶ 是否集群</li></ul><p><strong>3.</strong> <strong>修改</strong> <strong>member-service-nacos-consumer-80</strong> <strong>的</strong> <strong>pom.xml,</strong> <strong>加入</strong> <strong>sentinel</strong> <strong>和</strong> <strong>nacos</strong> <strong>持久化整合依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加入 sentinel 和 nacos 持久化整合依赖 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>4.</strong> <strong>修改</strong> <strong>member-service-nacos-consumer-80</strong>的application.yml , 配置该微服务从Nacos  Server获取流控规则</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在原本的基础上添加以下代码：</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">    <span class="comment"># 配置该微服务从 Nacos Server 获取流控规则</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">ds1:</span></span><br><span class="line">          <span class="attr">nacos:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">        <span class="attr">dataId:</span> <span class="string">member-service-nacos-consumer</span></span><br><span class="line">        <span class="attr">groupId:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">        <span class="attr">data-type:</span> <span class="string">json</span></span><br><span class="line">        <span class="attr">rule-type:</span> <span class="string">flow</span></span><br></pre></td></tr></table></figure><h4 id="10-10-3-4-测试"><a href="#10-10-3-4-测试" class="headerlink" title="10.10.3.4 测试"></a>10.10.3.4 测试</h4><h5 id="10-10-3-4-1-启动-Nacos-Server-8848"><a href="#10-10-3-4-1-启动-Nacos-Server-8848" class="headerlink" title="10.10.3.4.1 启动 Nacos Server 8848"></a><strong>10.10.3.4.1</strong> 启动 Nacos Server 8848</h5><h5 id="10-10-3-4-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-10-3-4-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.10.3.4.2 启动 Sentinel8080 控制台&#x2F;Sentinel dashboard"></a>10.10.3.4.2 启动 <strong>Sentinel8080</strong> 控制台&#x2F;Sentinel dashboard</h5><h5 id="10-10-3-4-3-启动-member-service-nacos-provider-10004-x2F-10006"><a href="#10-10-3-4-3-启动-member-service-nacos-provider-10004-x2F-10006" class="headerlink" title="10.10.3.4.3 启动 **member-service-nacos-provider-10004&#x2F;10006 **"></a>10.10.3.4.3 启动 **member-service-nacos-provider-10004&#x2F;10006 **</h5><h5 id="10-10-3-4-4-启动-member-service-nacos-consumer-80"><a href="#10-10-3-4-4-启动-member-service-nacos-consumer-80" class="headerlink" title="10.10.3.4.4 启动 member-service-nacos-consumer-80"></a><strong>10.10.3.4.4</strong> 启动 member-service-nacos-consumer-80</h5><h5 id="10-10-3-4-5-浏览器-http-localhost-member-openfeign-consumer-get-1"><a href="#10-10-3-4-5-浏览器-http-localhost-member-openfeign-consumer-get-1" class="headerlink" title="10.10.3.4.5 浏览器**: http://localhost/member/openfeign/consumer/get/1**"></a>10.10.3.4.5 浏览器**: <a href="http://localhost/member/openfeign/consumer/get/1">http://localhost/member/openfeign/consumer/get/1</a>**</h5><p><strong>1.</strong> 浏览器输入**: <a href="http://localhost/member/openfeign/consumer/get/1">http://localhost/member/openfeign/consumer/get/1</a> ,** 目前是 <strong>Openfeign</strong> 调用**(<strong>负载均衡</strong>),** <u><em><strong>而且流控规则已经生效了.</strong></em></u></p><p><strong>2.</strong> <strong>查看</strong> <strong>Sentinel</strong> <strong>控制台</strong>,<strong>发现已经同步了流控规则</strong></p><h4 id="10-10-3-5-注意事项和细节"><a href="#10-10-3-5-注意事项和细节" class="headerlink" title="10.10.3.5 注意事项和细节"></a>10.10.3.5 注意事项和细节</h4><p><strong>1.</strong> 在 <strong>nacos server</strong> 配置 <strong>sentinel</strong> 流控规则的 <strong>Data ID</strong> 也可以自己指定，比如写成 <strong>hsp-id,</strong> 只要在 **sentinel client&#x2F;**微服务 的 <strong>applicaion.yml</strong> 的 <strong>datasource.ds1.nacos.dataId</strong> 的值保持一致即可</p><p><strong>2.</strong> <strong>如图所示</strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230630194533516.png" alt="image-20230630194533516" style="zoom:50%;" /><h1 id="11-SpringCloud-Alibaba-Seata全局事务"><a href="#11-SpringCloud-Alibaba-Seata全局事务" class="headerlink" title="11 SpringCloud Alibaba Seata全局事务"></a>11 SpringCloud Alibaba Seata全局事务</h1><p><strong>全局事务</strong>——保证一个牵扯修改多个数据库的操作由于意外情况导致数据库中数据不一致的情况</p><h2 id="11-1-Seata基础"><a href="#11-1-Seata基础" class="headerlink" title="11.1 Seata基础"></a>11.1 Seata基础</h2><h3 id="11-1-1-先看一个问题，引出-Seata"><a href="#11-1-1-先看一个问题，引出-Seata" class="headerlink" title="11.1.1 先看一个问题，引出 Seata"></a><strong>11.1.1</strong> 先看一个问题，引出 <strong>Seata</strong></h3><p><strong>1.</strong> 单机单库**(<strong>多表</strong>)**处理事务示意图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230630203651434.png" alt="image-20230630203651434"></p><p><strong>2.</strong> <strong>分布式微服务架构下的数据库事务示意图</strong>（RPC，远程过程调用）</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230630204333902.png" alt="image-20230630204333902" style="zoom:50%;" /><p><strong>3.</strong> <strong>梳理上图</strong></p><p>用户购买商品的业务逻辑。整个业务逻辑由3个微服务提供支持∶</p><ul><li><strong>仓储服务∶对给定的商品扣除仓库&#x2F;商品数量</strong></li><li><strong>订单服务;根据采购需求创建订单</strong></li><li><strong>帐户服务∶从用户帐户中扣除余额</strong></li></ul><p><strong>4.</strong> <strong>问题分析</strong></p><ul><li><p><strong>单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用，分别使用三个独立的数据源</strong></p></li><li><p>业务操作需要调用三个服务来完成。此时<strong>每个服务内部的数据一致性由本地事务来保证</strong></p></li><li><p><strong>但是全局的数据—致性问题没法保证</strong></p></li><li><p>简单的说: <u>一次业务操作需要跨多个数据源或需要跨多个系统进行远程调用</u>，就会<strong>产生分布式事务问题</strong>—–</p><p>——-&gt;seata</p></li></ul><h3 id="11-1-2-分布式事务问题-amp-解决方案"><a href="#11-1-2-分布式事务问题-amp-解决方案" class="headerlink" title="11.1.2 分布式事务问题**&amp;**解决方案"></a><strong>11.1.2</strong> 分布式事务问题**&amp;**解决方案</h3><h4 id="11-1-2-1-分布式微服务架构下的全局数据一致性问题-即-分布式事务问题"><a href="#11-1-2-1-分布式微服务架构下的全局数据一致性问题-即-分布式事务问题" class="headerlink" title="11.1.2.1 分布式微服务架构下的全局数据一致性问题 [即: 分布式事务问题]"></a>11.1.2.1 分布式微服务架构下的全局数据一致性问题 [即: 分布式事务问题]</h4><h4 id="11-1-2-2-解决方案-Seata"><a href="#11-1-2-2-解决方案-Seata" class="headerlink" title="11.1.2.2 解决方案: Seata"></a>11.1.2.2 解决方案: Seata</h4><h3 id="11-1-3-官网"><a href="#11-1-3-官网" class="headerlink" title="11.1.3 官网"></a><strong>11.1.3</strong> 官网</h3><h4 id="11-1-3-1-http-seata-io-zh-cn"><a href="#11-1-3-1-http-seata-io-zh-cn" class="headerlink" title="11.1.3.1 http://seata.io/zh-cn/"></a>11.1.3.1 <a href="http://seata.io/zh-cn/">http://seata.io/zh-cn/</a></h4><h4 id="11-1-3-2-使用手册-https-seata-io-zh-cn-docs-overview-what-is-seata-html"><a href="#11-1-3-2-使用手册-https-seata-io-zh-cn-docs-overview-what-is-seata-html" class="headerlink" title="11.1.3.2 使用手册: https://seata.io/zh-cn/docs/overview/what-is-seata.html"></a>11.1.3.2 使用手册: <a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></h4><h3 id="11-1-4-Seata是什么"><a href="#11-1-4-Seata是什么" class="headerlink" title="11.1.4 Seata是什么?"></a>11.1.4 Seata是什么?</h3><p>Seata 是一款开源的分布式事务解决方案，致力于<strong>在微服务架构下提供<u>高性能和简单易用的分布式事务服务</u></strong></p><h2 id="11-2-🌟Seata-工作机制-x2F-返讲"><a href="#11-2-🌟Seata-工作机制-x2F-返讲" class="headerlink" title="11.2 🌟Seata 工作机制&#x2F;返讲"></a>11.2 🌟Seata 工作机制&#x2F;返讲</h2><h3 id="11-2-1-分布式事务过程分析"><a href="#11-2-1-分布式事务过程分析" class="headerlink" title="11.2.1 分布式事务过程分析"></a><strong>11.2.1</strong> 分布式事务过程分析</h3><p><strong>1. Seata</strong> 分布式事务处理过程-ID+三组件模型</p><p><strong>2.</strong> 一图胜千言</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703150121800.png" alt="image-20230703150121800"></p><p>上图展示了一个分布式事务在Seata的处理过程</p><ul><li>Transaction ID <strong>XID</strong>:全局唯一的事务ID</li><li>Transaction Coordinator(<strong>TC</strong>): 事务协调器，<u>维护全局事务的运行状态</u>，负责<u>协调并驱动全局事务的提交或回滚</u></li><li>Transaction Manager(<strong>TM</strong>): 控制<u>全局事务</u>的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议;</li><li>Resource Manager(<strong>RM</strong>):控制<u>分支事务</u>，负责分支注册，状态汇报，并接收事务协调器的指令，驱动分支 (本地)事务的<strong>提交和回滚</strong></li></ul><p>执行过程</p><ul><li>TM向 TC申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID</li><li>XID在微服务调用链路的上下文中传播</li><li>RM 向 TC注册分支事务，将其纳入 XID 对应全局事务的管辖</li><li>TM 向 TC 发起针对 XID 的全局提交或回滚决议。</li><li>TC 调度 XID下管辖的全部分支事务完成提交或回滚请求</li></ul><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703152243363.png" alt="image-20230703152243363" style="zoom:150%;" /><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703152337277.png" alt="image-20230703152337277"></p><h3 id="11-2-2-Seata-事务模式"><a href="#11-2-2-Seata-事务模式" class="headerlink" title="11.2.2 Seata 事务模式"></a>11.2.2 Seata 事务模式</h3><p><strong>1.</strong> <strong>地址</strong>: <a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></p><h4 id="11-2-2-1-AT-默认模式"><a href="#11-2-2-1-AT-默认模式" class="headerlink" title="11.2.2.1 AT(默认模式)"></a>11.2.2.1 AT(默认模式)</h4><h4 id="11-2-2-2-TCC"><a href="#11-2-2-2-TCC" class="headerlink" title="11.2.2.2 TCC"></a>11.2.2.2 TCC</h4><h4 id="11-2-2-3-SAGA"><a href="#11-2-2-3-SAGA" class="headerlink" title="11.2.2.3 SAGA"></a>11.2.2.3 SAGA</h4><h4 id="11-2-2-4-XA"><a href="#11-2-2-4-XA" class="headerlink" title="11.2.2.4 XA"></a>11.2.2.4 XA</h4><h3 id="11-2-3-AT无侵入模式"><a href="#11-2-3-AT无侵入模式" class="headerlink" title="11.2.3 AT无侵入模式"></a>11.2.3 AT无侵入模式</h3><h4 id="11-2-3-1-文档-https-seata-io-zh-cn-docs-overview-what-is-seata-html"><a href="#11-2-3-1-文档-https-seata-io-zh-cn-docs-overview-what-is-seata-html" class="headerlink" title="11.2.3.1 文档: https://seata.io/zh-cn/docs/overview/what-is-seata.html"></a>11.2.3.1 文档: <a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></h4><h4 id="11-2-3-2-一阶段加载"><a href="#11-2-3-2-一阶段加载" class="headerlink" title="11.2.3.2 一阶段加载"></a>11.2.3.2 一阶段加载</h4><p>在一阶段，<strong>Seata</strong> 会拦截**”**业务 <strong>SQL”</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703161643439.png" alt="image-20230703161643439"></p><ol><li><p>解析 SQL 语义，找到“业务SQL”要更新的业务数据，在业务数据被更新前，将其保存成”before image”(前罝镜像）</p></li><li><p>执行”业务 SQL”更新业务数据，在业务数据更新之后，其保存成”after image” &#x2F;后置镜像</p></li><li><p>最后生成行锁</p></li><li><p>以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性</p></li></ol><p>其中，<strong>前像与后像存于undo_log数据表中</strong></p><h4 id="11-2-3-3-二阶段提交"><a href="#11-2-3-3-二阶段提交" class="headerlink" title="11.2.3.3 二阶段提交"></a>11.2.3.3 二阶段提交</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703162629147.png" alt="image-20230703162629147" style="zoom: 40%;" /><p><strong>1.</strong> <strong>二阶段如果是顺利提交</strong></p><p><strong>2.</strong> <strong>因为”业务 SQL”在一阶段已经提交至数据库，所以 Seata 框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可</strong></p><h4 id="11-2-3-4-二阶段回滚"><a href="#11-2-3-4-二阶段回滚" class="headerlink" title="11.2.3.4 二阶段回滚"></a>11.2.3.4 二阶段回滚</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703162812449.png" alt="image-20230703162812449"></p><ol><li><p>二阶段如果是回滚的话，seata 就需要<strong>回滚一阶段己经执行的“业务 SQL”‘，还原业务数据</strong>。</p></li><li><p>回滚方式便是用”before image”还原业务数据;但在还原前要首先要校验脏号，对比”数据库当前业务数据”和”after image 如果两份数据完全一致就说明没有脏写，可以还原业务数据</p></li><li><p>如果不一致就说明有脏写，出现脏写就需要转人工处理</p></li></ol><h3 id="11-2-4-AT事务模式Debug验证"><a href="#11-2-4-AT事务模式Debug验证" class="headerlink" title="11.2.4 AT事务模式Debug验证"></a>11.2.4 AT<strong>事务模式</strong>Debug验证</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703163149523.png" alt="image-20230703163149523"></p><h3 id="11-2-5-SEATA的分布式交易解决方案"><a href="#11-2-5-SEATA的分布式交易解决方案" class="headerlink" title="11.2.5 SEATA的分布式交易解决方案"></a>11.2.5 SEATA的分布式交易解决方案</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703163341180.png" alt="image-20230703163341180"></p><h2 id="11-3-SeataServer安装"><a href="#11-3-SeataServer安装" class="headerlink" title="11.3 SeataServer安装"></a>11.3 SeataServer安装</h2><h3 id="11-3-1-下载"><a href="#11-3-1-下载" class="headerlink" title="11.3.1 下载"></a><strong>11.3.1</strong> 下载</h3><h4 id="11-3-1-1-https-github-com-seata-seata-releases-tag-v0-9-0"><a href="#11-3-1-1-https-github-com-seata-seata-releases-tag-v0-9-0" class="headerlink" title="11.3.1.1 https://github.com/seata/seata/releases/tag/v0.9.0"></a>11.3.1.1 <a href="https://github.com/seata/seata/releases/tag/v0.9.0">https://github.com/seata/seata/releases/tag/v0.9.0</a></h4><h3 id="11-3-2-安装和配置"><a href="#11-3-2-安装和配置" class="headerlink" title="11.3.2 安装和配置"></a><strong>11.3.2</strong> 安装和配置</h3><p><strong>1.</strong> 将 <strong>seata-server-0.9.0.zip</strong> 解压到 指定目录，比如 <strong>d:\program</strong></p><p><strong>2.</strong> <strong>修改</strong> <strong>conf\file.conf</strong> <strong>文件</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">transport &#123;</span><br><span class="line">  # tcp udt unix-domain-socket</span><br><span class="line">  type = <span class="string">&quot;TCP&quot;</span></span><br><span class="line">  #<span class="variable constant_">NIO</span> <span class="variable constant_">NATIVE</span></span><br><span class="line">  server = <span class="string">&quot;NIO&quot;</span></span><br><span class="line">  #enable heartbeat</span><br><span class="line">  heartbeat = <span class="literal">true</span></span><br><span class="line">  #thread factory <span class="keyword">for</span> netty</span><br><span class="line">  thread-factory &#123;</span><br><span class="line">    boss-thread-prefix = <span class="string">&quot;NettyBoss&quot;</span></span><br><span class="line">    worker-thread-prefix = <span class="string">&quot;NettyServerNIOWorker&quot;</span></span><br><span class="line">    server-executor-thread-prefix = <span class="string">&quot;NettyServerBizHandler&quot;</span></span><br><span class="line">    share-boss-worker = <span class="literal">false</span></span><br><span class="line">    client-selector-thread-prefix = <span class="string">&quot;NettyClientSelector&quot;</span></span><br><span class="line">    client-selector-thread-size = <span class="number">1</span></span><br><span class="line">    client-worker-thread-prefix = <span class="string">&quot;NettyClientWorkerThread&quot;</span></span><br><span class="line">    # netty boss thread size,will not be used <span class="keyword">for</span> <span class="variable constant_">UDT</span></span><br><span class="line">    boss-thread-size = <span class="number">1</span></span><br><span class="line">    #auto <span class="keyword">default</span> pin or <span class="number">8</span></span><br><span class="line">    worker-thread-size = <span class="number">8</span></span><br><span class="line">  &#125;</span><br><span class="line">  shutdown &#123;</span><br><span class="line">    # when destroy server, wait seconds</span><br><span class="line">    wait = <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  serialization = <span class="string">&quot;seata&quot;</span></span><br><span class="line">  compressor = <span class="string">&quot;none&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">service &#123;</span><br><span class="line">  #vgroup-&gt;rgroup</span><br><span class="line">  #vgroup_mapping.<span class="property">my_test_tx_group</span> = <span class="string">&quot;default&quot;</span></span><br><span class="line">  vgroup_mapping.<span class="property">my_test_tx_group</span> = <span class="string">&quot;hspedu_order_tx_group&quot;</span></span><br><span class="line">  #only support single node</span><br><span class="line">  <span class="keyword">default</span>.<span class="property">grouplist</span> = <span class="string">&quot;127.0.0.1:8091&quot;</span></span><br><span class="line">  #degrade current not support</span><br><span class="line">  enableDegrade = <span class="literal">false</span></span><br><span class="line">  #disable</span><br><span class="line">  disable = <span class="literal">false</span></span><br><span class="line">  #unit ms,s,m,h,d represents milliseconds, seconds, minutes, hours, days, <span class="keyword">default</span> permanent</span><br><span class="line">  max.<span class="property">commit</span>.<span class="property">retry</span>.<span class="property">timeout</span> = <span class="string">&quot;-1&quot;</span></span><br><span class="line">  max.<span class="property">rollback</span>.<span class="property">retry</span>.<span class="property">timeout</span> = <span class="string">&quot;-1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client &#123;</span><br><span class="line">  <span class="keyword">async</span>.<span class="property">commit</span>.<span class="property">buffer</span>.<span class="property">limit</span> = <span class="number">10000</span></span><br><span class="line">  lock &#123;</span><br><span class="line">    retry.<span class="property">internal</span> = <span class="number">10</span></span><br><span class="line">    retry.<span class="property">times</span> = <span class="number">30</span></span><br><span class="line">  &#125;</span><br><span class="line">  report.<span class="property">retry</span>.<span class="property">count</span> = <span class="number">5</span></span><br><span class="line">  tm.<span class="property">commit</span>.<span class="property">retry</span>.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line">  tm.<span class="property">rollback</span>.<span class="property">retry</span>.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## transaction log store</span><br><span class="line">store &#123;</span><br><span class="line">  ## store <span class="attr">mode</span>: file、db</span><br><span class="line">  ##mode = <span class="string">&quot;file&quot;</span></span><br><span class="line">  mode = <span class="string">&quot;db&quot;</span></span><br><span class="line"></span><br><span class="line">  ## file store</span><br><span class="line">  file &#123;</span><br><span class="line">    dir = <span class="string">&quot;sessionStore&quot;</span></span><br><span class="line"></span><br><span class="line">    # branch session size , <span class="keyword">if</span> exceeded first <span class="keyword">try</span> compress lockkey, still exceeded throws exceptions</span><br><span class="line">    max-branch-session-size = <span class="number">16384</span></span><br><span class="line">    # globe session size , <span class="keyword">if</span> exceeded throws exceptions</span><br><span class="line">    max-<span class="variable language_">global</span>-session-size = <span class="number">512</span></span><br><span class="line">    # file buffer size , <span class="keyword">if</span> exceeded allocate <span class="keyword">new</span> buffer</span><br><span class="line">    file-write-buffer-cache-size = <span class="number">16384</span></span><br><span class="line">    # when recover batch read size</span><br><span class="line">    session.<span class="property">reload</span>.<span class="property">read_size</span> = <span class="number">100</span></span><br><span class="line">    # <span class="keyword">async</span>, sync</span><br><span class="line">    flush-disk-mode = <span class="keyword">async</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ## database store</span><br><span class="line">  db &#123;</span><br><span class="line">    ## the implement <span class="keyword">of</span> javax.<span class="property">sql</span>.<span class="property">DataSource</span>, such <span class="keyword">as</span> <span class="title class_">DruidDataSource</span>(druid)/<span class="title class_">BasicDataSource</span>(dbcp) etc.</span><br><span class="line">    datasource = <span class="string">&quot;dbcp&quot;</span></span><br><span class="line">    ## mysql/oracle/h2/oceanbase etc.</span><br><span class="line">    db-type = <span class="string">&quot;mysql&quot;</span></span><br><span class="line">    driver-<span class="keyword">class</span>-name = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span><br><span class="line">    url = <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/seata&quot;</span></span><br><span class="line">    ##user = <span class="string">&quot;mysql&quot;</span></span><br><span class="line">    user = <span class="string">&quot;root&quot;</span></span><br><span class="line">    ##password = <span class="string">&quot;mysql&quot;</span></span><br><span class="line">    password = <span class="string">&quot;QWEASDzxc123&quot;</span></span><br><span class="line">    min-conn = <span class="number">1</span></span><br><span class="line">    max-conn = <span class="number">3</span></span><br><span class="line">    <span class="variable language_">global</span>.<span class="property">table</span> = <span class="string">&quot;global_table&quot;</span></span><br><span class="line">    branch.<span class="property">table</span> = <span class="string">&quot;branch_table&quot;</span></span><br><span class="line">    lock-table = <span class="string">&quot;lock_table&quot;</span></span><br><span class="line">    query-limit = <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">lock &#123;</span><br><span class="line">  ## the lock store <span class="attr">mode</span>: local、remote</span><br><span class="line">  mode = <span class="string">&quot;remote&quot;</span></span><br><span class="line"></span><br><span class="line">  local &#123;</span><br><span class="line">    ## store locks <span class="keyword">in</span> user<span class="string">&#x27;s database</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  remote &#123;</span></span><br><span class="line"><span class="string">    ## store locks in the seata&#x27;</span>s server</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">recovery &#123;</span><br><span class="line">  #schedule committing retry period <span class="keyword">in</span> milliseconds</span><br><span class="line">  committing-retry-period = <span class="number">1000</span></span><br><span class="line">  #schedule asyn committing retry period <span class="keyword">in</span> milliseconds</span><br><span class="line">  asyn-committing-retry-period = <span class="number">1000</span></span><br><span class="line">  #schedule rollbacking retry period <span class="keyword">in</span> milliseconds</span><br><span class="line">  rollbacking-retry-period = <span class="number">1000</span></span><br><span class="line">  #schedule timeout retry period <span class="keyword">in</span> milliseconds</span><br><span class="line">  timeout-retry-period = <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">transaction &#123;</span><br><span class="line">  undo.<span class="property">data</span>.<span class="property">validation</span> = <span class="literal">true</span></span><br><span class="line">  undo.<span class="property">log</span>.<span class="property">serialization</span> = <span class="string">&quot;jackson&quot;</span></span><br><span class="line">  undo.<span class="property">log</span>.<span class="property">save</span>.<span class="property">days</span> = <span class="number">7</span></span><br><span class="line">  #schedule <span class="keyword">delete</span> expired undo_log <span class="keyword">in</span> milliseconds</span><br><span class="line">  undo.<span class="property">log</span>.<span class="property">delete</span>.<span class="property">period</span> = <span class="number">86400000</span></span><br><span class="line">  undo.<span class="property">log</span>.<span class="property">table</span> = <span class="string">&quot;undo_log&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## metrics settings</span><br><span class="line">metrics &#123;</span><br><span class="line">  enabled = <span class="literal">false</span></span><br><span class="line">  registry-type = <span class="string">&quot;compact&quot;</span></span><br><span class="line">  # multi exporters use comma divided</span><br><span class="line">  exporter-list = <span class="string">&quot;prometheus&quot;</span></span><br><span class="line">  exporter-prometheus-port = <span class="number">9898</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">support &#123;</span><br><span class="line">  ## spring</span><br><span class="line">  spring &#123;</span><br><span class="line">    # auto proxy the <span class="title class_">DataSource</span> bean</span><br><span class="line">    datasource.<span class="property">autoproxy</span> = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.</strong> <strong>在</strong> <strong>mysql5.7</strong> <strong>创建</strong> <strong>seata</strong> <strong>数据库</strong></p><p><strong>4.</strong> <strong>修改</strong> <strong>seata</strong> <strong>的</strong> <strong>\conf\registry.conf ,</strong> <strong>配置注册中心</strong> <strong>nacos server</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span><br><span class="line">  # type = <span class="string">&quot;file&quot;</span></span><br><span class="line">  type = <span class="string">&quot;nacos&quot;</span></span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    # serverAddr = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">    serverAddr = <span class="string">&quot;localhost:8848&quot;</span></span><br><span class="line">    namespace = <span class="string">&quot;&quot;</span></span><br><span class="line">    cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  eureka &#123;</span><br><span class="line">    serviceUrl = <span class="string">&quot;http://localhost:8761/eureka&quot;</span></span><br><span class="line">    application = <span class="string">&quot;default&quot;</span></span><br><span class="line">    weight = <span class="string">&quot;1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  redis &#123;</span><br><span class="line">    serverAddr = <span class="string">&quot;localhost:6379&quot;</span></span><br><span class="line">    db = <span class="string">&quot;0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">    serverAddr = <span class="string">&quot;127.0.0.1:2181&quot;</span></span><br><span class="line">    session.<span class="property">timeout</span> = <span class="number">6000</span></span><br><span class="line">    connect.<span class="property">timeout</span> = <span class="number">2000</span></span><br><span class="line">  &#125;</span><br><span class="line">  consul &#123;</span><br><span class="line">    cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">    serverAddr = <span class="string">&quot;127.0.0.1:8500&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  etcd3 &#123;</span><br><span class="line">    cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">    serverAddr = <span class="string">&quot;http://localhost:2379&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  sofa &#123;</span><br><span class="line">    serverAddr = <span class="string">&quot;127.0.0.1:9603&quot;</span></span><br><span class="line">    application = <span class="string">&quot;default&quot;</span></span><br><span class="line">    region = <span class="string">&quot;DEFAULT_ZONE&quot;</span></span><br><span class="line">    datacenter = <span class="string">&quot;DefaultDataCenter&quot;</span></span><br><span class="line">    cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">    group = <span class="string">&quot;SEATA_GROUP&quot;</span></span><br><span class="line">    addressWaitTime = <span class="string">&quot;3000&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name = <span class="string">&quot;file.conf&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config &#123;</span><br><span class="line">  # file、nacos 、apollo、zk、consul、etcd3</span><br><span class="line">  type = <span class="string">&quot;file&quot;</span></span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">    namespace = <span class="string">&quot;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  consul &#123;</span><br><span class="line">    serverAddr = <span class="string">&quot;127.0.0.1:8500&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  apollo &#123;</span><br><span class="line">    app.<span class="property">id</span> = <span class="string">&quot;seata-server&quot;</span></span><br><span class="line">    apollo.<span class="property">meta</span> = <span class="string">&quot;http://192.168.1.204:8801&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    serverAddr = <span class="string">&quot;127.0.0.1:2181&quot;</span></span><br><span class="line">    session.<span class="property">timeout</span> = <span class="number">6000</span></span><br><span class="line">    connect.<span class="property">timeout</span> = <span class="number">2000</span></span><br><span class="line">  &#125;</span><br><span class="line">  etcd3 &#123;</span><br><span class="line">    serverAddr = <span class="string">&quot;http://localhost:2379&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name = <span class="string">&quot;file.conf&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="11-3-3-启动"><a href="#11-3-3-启动" class="headerlink" title="11.3.3 启动"></a><strong>11.3.3</strong> 启动</h3><h4 id="11-3-3-1-启动-Nacos-Server-8848"><a href="#11-3-3-1-启动-Nacos-Server-8848" class="headerlink" title="11.3.3.1 启动 Nacos Server 8848"></a>11.3.3.1 启动 Nacos Server 8848</h4><h4 id="11-3-3-2-双击-Seata-的-bin-seata-server-bat-启动-Seata-Server"><a href="#11-3-3-2-双击-Seata-的-bin-seata-server-bat-启动-Seata-Server" class="headerlink" title="11.3.3.2 双击 Seata 的\bin\seata-server.bat , 启动 Seata Server"></a>11.3.3.2 双击 Seata 的\bin\seata-server.bat , 启动 Seata Server</h4><p><strong>1.</strong> 启动 <strong>seata-server.bat ,</strong> 看到如下界面说明成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /Applications/seata/bin</span><br><span class="line">./seata-server.sh -h 127.0.0.1 -p 8848 -m db -n 1 </span><br></pre></td></tr></table></figure><h4 id="11-3-3-3-登录-Nacos-Server-查看-Seata-Server-是否注册成功"><a href="#11-3-3-3-登录-Nacos-Server-查看-Seata-Server-是否注册成功" class="headerlink" title="11.3.3.3 登录 Nacos Server , 查看 Seata Server 是否注册成功"></a>11.3.3.3 登录 Nacos Server , 查看 Seata Server 是否注册成功</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230702162714540.png" alt="image-20230702162714540"></p><h2 id="11-4-Seata-分布式事务-应用实例"><a href="#11-4-Seata-分布式事务-应用实例" class="headerlink" title="11.4 Seata 分布式事务-应用实例"></a>11.4 Seata 分布式事务-应用实例</h2><h3 id="11-4-1-需求分析-x2F-图解"><a href="#11-4-1-需求分析-x2F-图解" class="headerlink" title="11.4.1 需求分析**&#x2F;**图解"></a><strong>11.4.1</strong> 需求分析**&#x2F;**图解</h3><p><strong>1.</strong> 需求:完成下订单功能，由三个微服务模块协同完成**,** 涉及到多数据库**,** 多张表</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230702164527518.png" alt="image-20230702164527518" style="zoom:50%;" /><h3 id="11-4-2-创建数据库和表"><a href="#11-4-2-创建数据库和表" class="headerlink" title="11.4.2 创建数据库和表"></a>11.4.2 创建数据库和表</h3><p><strong>1.</strong> 创建业务数据库和表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 订单微服务的数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE order_micro_service </span><br><span class="line">USE order_micro_service</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">order</span>`(</span><br><span class="line">id <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">user_id <span class="type">BIGINT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">product_id <span class="type">BIGINT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">nums <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">money <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`status` <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;0:创建中; 1:已完结&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">order</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 库存微服务的数据库`storage``order` </span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE storage_micro_service </span><br><span class="line">USE storage_micro_service</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `storage`(</span><br><span class="line">id <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY, </span><br><span class="line">  product_id <span class="type">BIGINT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">amount <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;库存量&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 初始化库存表</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `storage` <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>, <span class="number">1</span>, <span class="number">10</span>); </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `storage`</span><br><span class="line"><span class="comment">-- 账号微服务的数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE account_micro_service </span><br><span class="line">USE account_micro_service</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `account`(</span><br><span class="line">id <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY , </span><br><span class="line">  user_id <span class="type">BIGINT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">money <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;账户金额&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 初始化账户表</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `account` <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>, <span class="number">666</span>, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 分别为 <strong>3</strong> 库创建对应的回滚日志表**,** 说明回滚日志表在 <strong>seata</strong> 的 <strong>\conf\db_undo_log.sql</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">use order_micro_service </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `undo_log` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT, </span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`log_created` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `log_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `ext` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line"><span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">use storage_micro_service </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `undo_log` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT, </span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`log_created` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `ext` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line"><span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">use account_micro_service </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `undo_log` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT, </span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`log_created` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `log_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `ext` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line"><span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="11-4-3-开发-seata-storage-micro-service-10010-微服务"><a href="#11-4-3-开发-seata-storage-micro-service-10010-微服务" class="headerlink" title="11.4.3 开发 seata_storage_micro_service-10010 微服务"></a>11.4.3 开发 seata_storage_micro_service-10010 微服务</h3><p><strong>1.</strong> 参考以前的方式，创建 <strong>seata_storage_micro_service-10010</strong> 微服务模块</p><p><strong>2.</strong> <strong>修改</strong> <strong>pom.xml,</strong> <strong>添加相关的</strong> <strong>jar</strong> <strong>依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 提示 application.yml --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入 openfeign，因为可能需要用到远程调用 --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 在微服务模块引入 nacos-discovery starter --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 排除自带的 seata-all --&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入指定版本的 io.seata --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入 e_commerce_center-common-api --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hspedu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>e_commerce_center-common-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 这里我们重新指定一下 version --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3.</strong> <strong>创建</strong> <strong>application.yml,</strong> <strong>进行相关的配置</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">seata_storage_micor_service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">alibaba:</span></span><br><span class="line">      <span class="attr">seata:</span></span><br><span class="line">        <span class="comment">#自定义事务组名称需要与 seata-server 中的对应,看 \conf\file.conf</span></span><br><span class="line">        <span class="attr">tx-service-group:</span> <span class="string">hspedu_order_tx_group</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#配置 Nacos Server</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/storage_micro_service</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">QWEASDzxc123</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">io:</span></span><br><span class="line">      <span class="attr">seata:</span> <span class="string">info</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapperLocations:</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure><p><strong>4.</strong> <strong>创建</strong> <strong>file.conf,</strong> <strong>进行相关的配置</strong>, <strong>说明:该文件从</strong> <strong>seata</strong> <strong>的</strong>\conf\file.conf <strong>拷贝，进行修改即可</strong></p><p><strong>5.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;entity&#x2F;Storage.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.springcloud.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/7/2</span></span><br><span class="line"><span class="comment"> * 20:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Long productId;</span><br><span class="line">    <span class="keyword">private</span> Integer amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6.</strong> <strong>创建</strong> com&#x2F;hspedu&#x2F;springcloud&#x2F;dao&#x2F;StorageDao.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StorageDao</span> &#123;</span><br><span class="line">    <span class="comment">//扣减库存信息</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(<span class="meta">@Param(&quot;productId&quot;)</span> Long productId, <span class="meta">@Param(&quot;nums&quot;)</span> Integer nums)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7.</strong> <strong>创建</strong> **resources&#x2F;**mapper&#x2F;StorageMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.hspedu.springcloud.dao.StorageDao&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.hspedu.springcloud.entity.Storage&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;product_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;productId&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">property</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 减少库存 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;reduce&quot;</span>&gt;</span></span><br><span class="line">        UPDATE</span><br><span class="line">            storage</span><br><span class="line">        SET</span><br><span class="line">            amount = amount - #&#123;nums&#125;</span><br><span class="line">        WHERE</span><br><span class="line">            product_id = #&#123;productId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>8.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;service&#x2F;StorageService.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line">    <span class="comment">// 扣减库存</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(Long productId, Integer nums)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>9.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;service&#x2F;impl&#x2F;StorageServiceImpl.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StorageServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private static final Logger LOGGER = LoggerFactory.getLogger(StorageServiceImpl.class);</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StorageDao storageDao;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(Long productId, Integer nums)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;==========seata_storage_micro_service-10010 扣 减 库 存 start==========&quot;</span>);</span><br><span class="line">        storageDao.reduce(productId, nums);</span><br><span class="line">        log.info(<span class="string">&quot;==========seata_storage_micro_service-10010 扣 减 库 存 end==========&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>10.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;StorageController.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StorageController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StorageService storageService;</span><br><span class="line">    <span class="comment">//扣减库存</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/storage/reduce&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">reduce</span><span class="params">(Long productId, Integer nums)</span> &#123;</span><br><span class="line">        storageService.reduce(productId, nums);</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;扣减库存成功 ok&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>11.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;config&#x2F;MyBatisConfig.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&#123;&quot;com.hspedu.springcloud.dao&quot;&#125;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>12.</strong> <strong>创建com&#x2F;hspedu&#x2F;springcloud&#x2F;config&#x2F;DataSourceProxyConfig.java ,常规配置(拿来使用即可)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.springcloud.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> io.seata.rm.datasource.DataSourceProxy;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.transaction.SpringManagedTransactionFactory; <span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/7/3</span></span><br><span class="line"><span class="comment"> * 11:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceProxyConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mybatis.mapperLocations&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String mapperLocations;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">druidDataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceProxy <span class="title function_">dataSourceProxy</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProxy</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSourceProxy dataSourceProxy)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>(); sqlSessionFactoryBean.setDataSource(dataSourceProxy);</span><br><span class="line">                sqlSessionFactoryBean.setMapperLocations(<span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>().getResources(mapperLocations));</span><br><span class="line">        sqlSessionFactoryBean.setTransactionFactory(<span class="keyword">new</span> <span class="title class_">SpringManagedTransactionFactory</span>()); <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>13.</strong> <strong>创 建 主 启 动 类</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;SeataStorageMicroServiceApplication10010.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.springcloud;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/7/3</span></span><br><span class="line"><span class="comment"> * 12:24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeataStorageMicroServiceApplication10010</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SeataStorageMicroServiceApplication10010.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-4-4-测试-seata-storage-micro-service-10010-微服务"><a href="#11-4-4-测试-seata-storage-micro-service-10010-微服务" class="headerlink" title="11.4.4 测试 seata_storage_micro_service-10010 微服务"></a><strong>11.4.4</strong> 测试 <strong>seata_storage_micro_service-10010</strong> 微服务</h3><h4 id="11-4-4-1-启动-Nacos-Server-8848"><a href="#11-4-4-1-启动-Nacos-Server-8848" class="headerlink" title="11.4.4.1 启动 Nacos Server 8848"></a>11.4.4.1 启动 Nacos Server 8848</h4><h4 id="11-4-4-2-双击-Seata-的-bin-seata-server-bat-启动-Seata-Server"><a href="#11-4-4-2-双击-Seata-的-bin-seata-server-bat-启动-Seata-Server" class="headerlink" title="11.4.4.2 双击 Seata 的\bin\seata-server.bat , 启动 Seata Server"></a>11.4.4.2 双击 Seata 的\bin\seata-server.bat , 启动 Seata Server</h4><h4 id="11-4-4-3-启动-seata-storage-micro-service-10010"><a href="#11-4-4-3-启动-seata-storage-micro-service-10010" class="headerlink" title="11.4.4.3 启动 seata_storage_micro_service-10010"></a>11.4.4.3 启动 seata_storage_micro_service-10010</h4><h4 id="11-4-4-4-登录-Nacos-Server-查看-10010-微服务是否注册成功"><a href="#11-4-4-4-登录-Nacos-Server-查看-10010-微服务是否注册成功" class="headerlink" title="11.4.4.4 登录 Nacos Server , 查看 10010 微服务是否注册成功"></a>11.4.4.4 登录 Nacos Server , 查看 10010 微服务是否注册成功</h4><p><strong>1.</strong> 登录 <strong>Nacos Server,</strong> 查看 <strong>10010</strong> 是否注册成功</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703125536604.png" alt="image-20230703125536604"></p><h3 id="11-4-5-开发-seata-account-micro-service-10012-微服务"><a href="#11-4-5-开发-seata-account-micro-service-10012-微服务" class="headerlink" title="11.4.5 开发 seata_account_micro_service-10012 微服务"></a><strong>11.4.5</strong> 开发 <strong>seata_account_micro_service-10012</strong> 微服务</h3><p>(account模块，参照上面storage模块的创建过程即可)</p><p><strong>1.</strong> 参考以前的方式，创建 <strong>seata_account_micro_service-10012</strong> 微服务模块</p><p><strong>2.</strong> <strong>修改</strong> <strong>pom.xml,</strong> <strong>添加相关的</strong> <strong>jar</strong> <strong>依赖</strong></p><p><strong>3.</strong> <strong>创建</strong> <strong>application.yml,</strong> <strong>进行相关的配置</strong></p><p><strong>4.1</strong> <strong>创建</strong> <strong>file.conf,</strong> <strong>进行相关的配置</strong>, <strong>说明:该文件从</strong> <strong>seata</strong> <strong>的</strong>\conf\file.conf <strong>拷贝，进行修 改即可</strong></p><p><strong>4.2</strong> <strong>创建</strong> <strong>registry.conf,</strong> <strong>进行相关的配置</strong>, <strong>说明:该文件从</strong> <strong>seata</strong> <strong>的</strong>\conf\registry.conf <strong>拷贝， 进行修改即可</strong></p><p><strong>5.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;entity&#x2F;Account.java</strong></p><p><strong>6.</strong> <strong>创建</strong> com&#x2F;hspedu&#x2F;springcloud&#x2F;dao&#x2F;AccountDao.java</p><p><strong>7.</strong> <strong>创建</strong> **resources&#x2F;**mapper&#x2F;AccountMapper.xml</p><p><strong>8.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;service&#x2F;AccountService.java</strong></p><p><strong>9.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;service&#x2F;impl&#x2F;AccountServiceImpl.java</strong></p><p><strong>10.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;AccountController.java</strong></p><p><strong>11.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;config&#x2F;MyBatisConfig.java</strong></p><p><strong>12.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;config&#x2F;DataSourceProxyConfig.java ,</strong> <strong>常规配置</strong>(拿来使用即可)</p><p><strong>13.</strong> <strong>创 建 主 启 动 类</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;SeataAccountMicroServiceApplication10012.java</strong></p><h3 id="11-4-6-测试-seata-account-micro-service-10012-微服务"><a href="#11-4-6-测试-seata-account-micro-service-10012-微服务" class="headerlink" title="11.4.6 测试 seata_account_micro_service-10012 微服务"></a><strong>11.4.6</strong> 测试 <strong>seata_account_micro_service-10012</strong> 微服务</h3><h4 id="11-4-6-1-启动-Nacos-Server-8848"><a href="#11-4-6-1-启动-Nacos-Server-8848" class="headerlink" title="11.4.6.1 启动 Nacos Server 8848"></a>11.4.6.1 启动 Nacos Server 8848</h4><h4 id="11-4-6-2-双击-Seata-的-bin-seata-server-bat-启动-Seata-Server"><a href="#11-4-6-2-双击-Seata-的-bin-seata-server-bat-启动-Seata-Server" class="headerlink" title="11.4.6.2 双击 Seata 的\bin\seata-server.bat , 启动 Seata Server"></a>11.4.6.2 双击 Seata 的\bin\seata-server.bat , 启动 Seata Server</h4><h4 id="11-4-6-3-启动-seata-account-micro-service-10012"><a href="#11-4-6-3-启动-seata-account-micro-service-10012" class="headerlink" title="11.4.6.3 启动 seata_account_micro_service-10012"></a>11.4.6.3 启动 seata_account_micro_service-10012</h4><h4 id="11-4-6-4-登录-Nacos-Server-查看-10012-微服务是否注册成功"><a href="#11-4-6-4-登录-Nacos-Server-查看-10012-微服务是否注册成功" class="headerlink" title="11.4.6.4 登录 Nacos Server , 查看 10012 微服务是否注册成功"></a>11.4.6.4 登录 Nacos Server , 查看 10012 微服务是否注册成功</h4><p><strong>1.</strong> 登录 <strong>Nacos Server,</strong> 查看 <strong>10012</strong> 是否注册成功</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703143135194.png" alt="image-20230703143135194"></p><p><strong>11.4.7</strong> 开发 <strong>seata-order-micro-service-10008</strong> 微服务</p><p>(Order模块，参照上面storage模块的创建过程即可)</p><p><strong>1.</strong> 参考以前的方式，创建 <strong>seata-order-micro-service-10008</strong> 微服务模块</p><p><strong>2.</strong> <strong>修改</strong> <strong>pom.xml,</strong> <strong>添加相关的</strong> <strong>jar</strong> <strong>依赖</strong></p><p><strong>3.</strong> <strong>创建</strong> <strong>application.yml,</strong> <strong>进行相关的配置</strong></p><p><strong>4.1</strong> <strong>创建</strong> <strong>file.conf,</strong> <strong>进行相关的配置</strong>, <strong>说明:该文件从</strong> <strong>seata</strong> <strong>的</strong>\conf\file.conf <strong>拷贝，进行修 改即可</strong></p><p><strong>4.2</strong> <strong>创建</strong> <strong>registry.conf,</strong> <strong>进行相关的配置</strong>, <strong>说明:该文件从</strong> <strong>seata</strong> <strong>的</strong>\conf\registry.conf <strong>拷贝， 进行修改即可</strong></p><p><strong>5.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;entity&#x2F;Order.java</strong></p><p><strong>6.</strong> <strong>创建</strong> com&#x2F;hspedu&#x2F;springcloud&#x2F;dao&#x2F;OrderDao.java</p><p><strong>7.</strong> <strong>创建</strong> **resources&#x2F;**mapper&#x2F;OrderMapper.xml</p><p><strong>8.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;service&#x2F;OrderService.java</strong></p><p><strong>9.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;service&#x2F;AccountService.java</strong></p><p><strong>10.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;service&#x2F;impl&#x2F;OrderServiceImpl.java</strong></p><p><strong>11.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;OrderController.java</strong></p><p><strong>12.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;config&#x2F;MyBatisConfig.java</strong></p><p><strong>13.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;config&#x2F;DataSourceProxyConfig.java ,</strong> <strong>常规配置</strong>(拿来使用即可)</p><p><strong>14.</strong> <strong>创 建 主 启 动 类</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;SeataOrderMicroServiceApplication10008.java</strong></p><h3 id="11-4-8-测试-seata-order-micro-service-10008-微服务"><a href="#11-4-8-测试-seata-order-micro-service-10008-微服务" class="headerlink" title="11.4.8 测试 seata-order-micro-service-10008 微服务"></a><strong>11.4.8</strong> 测试 <strong>seata-order-micro-service-10008</strong> 微服务</h3><p>……</p><h3 id="11-4-9-集成测试-1-三个微服务协同完成-正常下单"><a href="#11-4-9-集成测试-1-三个微服务协同完成-正常下单" class="headerlink" title="11.4.9 集成测试**(1)** 三个微服务协同完成**-**正常下单"></a><strong>11.4.9</strong> 集成测试**(1)** 三个微服务协同完成**-**正常下单</h3><h4 id="11-4-9-1-启动-Nacos-Server-8848"><a href="#11-4-9-1-启动-Nacos-Server-8848" class="headerlink" title="11.4.9.1 启动 Nacos Server 8848"></a>11.4.9.1 启动 Nacos Server 8848</h4><h4 id="11-4-9-2-双击-Seata-的-bin-seata-server-bat-启动-Seata-Server"><a href="#11-4-9-2-双击-Seata-的-bin-seata-server-bat-启动-Seata-Server" class="headerlink" title="11.4.9.2 双击 Seata 的\bin\seata-server.bat , 启动 Seata Server"></a>11.4.9.2 双击 Seata 的\bin\seata-server.bat , 启动 Seata Server</h4><h4 id="11-4-9-3-启动-seata-order-micro-service-10010-x2F-10012-x2F-10008-三个微服务"><a href="#11-4-9-3-启动-seata-order-micro-service-10010-x2F-10012-x2F-10008-三个微服务" class="headerlink" title="11.4.9.3 启动 seata-order-micro-service-10010 &#x2F;10012&#x2F;10008 三个微服务"></a>11.4.9.3 启动 seata-order-micro-service-10010 &#x2F;10012&#x2F;10008 三个微服务</h4><h4 id="11-4-9-4-浏览器-http-localhost-10008-order-save-userId-666-amp-productId-1-amp-nums-1-amp-money-100"><a href="#11-4-9-4-浏览器-http-localhost-10008-order-save-userId-666-amp-productId-1-amp-nums-1-amp-money-100" class="headerlink" title="11.4.9.4 浏览器 : http://localhost:10008/order/save?userId=666&amp;productId=1&amp;nums=1&amp;money=100"></a>11.4.9.4 浏览器 : <a href="http://localhost:10008/order/save?userId=666&productId=1&nums=1&money=100">http://localhost:10008/order/save?userId=666&amp;productId=1&amp;nums=1&amp;money=100</a></h4><p><strong>1.</strong> 浏 览 器 <strong>: <a href="http://localhost:10008/order/save?userId=666&productId=1&nums=1&money=100">http://localhost:10008/order/save?userId=666&amp;productId=1&amp;nums=1&amp;money=100</a></strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703143712667.png" alt="image-20230703143712667"></p><p><strong>2.</strong> <strong>查看数据库&#x2F;表的情况是否正常,结论:如果没有异常出现，正常下单，数据库三张表 数据一致性是OK的</strong></p><h4 id="11-4-9-5-注意事项和细节"><a href="#11-4-9-5-注意事项和细节" class="headerlink" title="11.4.9.5 注意事项和细节"></a>11.4.9.5 注意事项和细节</h4><p><strong>1. MySQL</strong> 出现 <strong>too many connections</strong>(<strong>1040</strong>)错误解决方法：</p><p>在 <strong>my.ini</strong> 设置 </p><p><strong>max_connections&#x3D;1000</strong></p><p><strong>2.</strong> 如果出现**: service id not legal hostname<br>** 报错 <strong>Service id not legal hostname</strong> 的原因是服务名称不能带有下划线，可以使用中划线**,**</p><p><strong>springcloud</strong> 无法识别下划线，把下划线改成中划线就好</p><h3 id="11-4-10-集成测试-2-三个微服务协同完成-模拟异常"><a href="#11-4-10-集成测试-2-三个微服务协同完成-模拟异常" class="headerlink" title="11.4.10 集成测试**(2)** 三个微服务协同完成**-**模拟异常"></a><strong>11.4.10</strong> 集成测试**(2)** 三个微服务协同完成**-**模拟异常</h3><h4 id="11-4-10-1-启动-Nacos-Server-8848"><a href="#11-4-10-1-启动-Nacos-Server-8848" class="headerlink" title="11.4.10.1 启动 Nacos Server 8848"></a>11.4.10.1 启动 Nacos Server 8848</h4><h4 id="11-4-10-2-双击-Seata-的-bin-seata-server-bat-启动-Seata-Server"><a href="#11-4-10-2-双击-Seata-的-bin-seata-server-bat-启动-Seata-Server" class="headerlink" title="11.4.10.2 双击 Seata 的\bin\seata-server.bat , 启动 Seata Server"></a>11.4.10.2 双击 Seata 的\bin\seata-server.bat , 启动 Seata Server</h4><h4 id="11-4-10-3-启动-seata-order-micro-service-100010-x2F-10012-x2F-10008-三个微服务"><a href="#11-4-10-3-启动-seata-order-micro-service-100010-x2F-10012-x2F-10008-三个微服务" class="headerlink" title="11.4.10.3 启动 seata-order-micro-service-100010 &#x2F;10012&#x2F;10008 三个微服务"></a>11.4.10.3 启动 seata-order-micro-service-100010 &#x2F;10012&#x2F;10008 三个微服务</h4><h4 id="11-4-10-4-浏览器-http-localhost-10008-order-save-userId-666-amp-productId-1-amp-nums-1-amp-money-100"><a href="#11-4-10-4-浏览器-http-localhost-10008-order-save-userId-666-amp-productId-1-amp-nums-1-amp-money-100" class="headerlink" title="11.4.10.4 浏览器 : http://localhost:10008/order/save?userId=666&amp;productId=1&amp;nums=1&amp;money=100"></a>11.4.10.4 浏览器 : <a href="http://localhost:10008/order/save?userId=666&productId=1&nums=1&money=100">http://localhost:10008/order/save?userId=666&amp;productId=1&amp;nums=1&amp;money=100</a></h4><p><strong>1.</strong> 修 改 <strong>seata_account_micro_service-10012</strong> 的<strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;AccountController.java</strong>， 模拟异常出现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/account/reduce&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">result</span><span class="params">(<span class="meta">@RequestParam(&quot;userId&quot;)</span> Long userId, <span class="meta">@RequestParam(&quot;money&quot;)</span> Integer money)</span>&#123;</span><br><span class="line"><span class="comment">//模拟异常, 超时</span></span><br><span class="line"><span class="comment">//openfeign 接口调用默认超时时间为 1s try &#123;</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">12</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace(); &#125;</span><br><span class="line">accountService.reduce(userId,money);</span><br><span class="line"><span class="keyword">return</span> Result.success(<span class="string">&quot;200&quot;</span>, <span class="string">&quot;扣减账户余额 OK&quot;</span>); &#125;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> <strong>浏 览 器</strong> <strong>: <a href="http://localhost:10008/order/save?userId=666&productId=1&nums=1&money=100">http://localhost:10008/order/save?userId=666&amp;productId=1&amp;nums=1&amp;money=100</a></strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703143951841.png" alt="image-20230703143951841"></p><p><strong>3.</strong> <strong>查看数据库&#x2F;表的情况是否正常</strong></p><p><strong>结论</strong>:这时数据库&#x2F;表，出现数据不一致现象, 订单是<u>未支付</u>，但是<u>库存减少了</u>，账号<u>钱也扣了</u>(提示:等休眠时间完成后，再查看account表，会看到数据不一致)</p><h3 id="11-4-11-集成测试-3-三个微服务协同完成-使用-GlobalTransactional-完成分布式事务控制-出现异常，也能保证数据一致性"><a href="#11-4-11-集成测试-3-三个微服务协同完成-使用-GlobalTransactional-完成分布式事务控制-出现异常，也能保证数据一致性" class="headerlink" title="11.4.11 集成测试**(3)** 三个微服务协同完成**-使用@GlobalTransactional** 完成分布式事务控制(出现异常，也能保证数据一致性)"></a><strong>11.4.11</strong> 集成测试**(3)** 三个微服务协同完成**-<strong>使用</strong>@GlobalTransactional** 完成分布式事务控制(出现异常，也能保证数据一致性)</h3><h4 id="11-4-11-1-启动-Nacos-Server-8848"><a href="#11-4-11-1-启动-Nacos-Server-8848" class="headerlink" title="11.4.11.1 启动 Nacos Server 8848"></a>11.4.11.1 启动 Nacos Server 8848</h4><h4 id="11-4-11-2-双击-Seata-的-bin-seata-server-bat-启动-Seata-Server"><a href="#11-4-11-2-双击-Seata-的-bin-seata-server-bat-启动-Seata-Server" class="headerlink" title="11.4.11.2 双击 Seata 的\bin\seata-server.bat , 启动 Seata Server"></a>11.4.11.2 双击 Seata 的\bin\seata-server.bat , 启动 Seata Server</h4><h4 id="11-4-11-3-启动-seata-order-micro-service-10008-x2F-10010-x2F-10012-三个微服务"><a href="#11-4-11-3-启动-seata-order-micro-service-10008-x2F-10010-x2F-10012-三个微服务" class="headerlink" title="11.4.11.3 启动 seata-order-micro-service-10008 &#x2F;10010&#x2F;10012 三个微服务"></a>11.4.11.3 启动 seata-order-micro-service-10008 &#x2F;10010&#x2F;10012 三个微服务</h4><h4 id="11-4-11-4-浏览器-http-localhost-10008-order-save-userId-666-amp-productId-1-amp-nums-1-amp-money-100"><a href="#11-4-11-4-浏览器-http-localhost-10008-order-save-userId-666-amp-productId-1-amp-nums-1-amp-money-100" class="headerlink" title="11.4.11.4 浏览器 : http://localhost:10008/order/save?userId=666&amp;productId=1&amp;nums=1&amp;money=100"></a>11.4.11.4 浏览器 : <a href="http://localhost:10008/order/save?userId=666&productId=1&nums=1&money=100">http://localhost:10008/order/save?userId=666&amp;productId=1&amp;nums=1&amp;money=100</a></h4><p><strong>1.</strong> 修 改 <strong>seata_account_micro_service-10012</strong> 的 <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;AccountController.java</strong>， 模拟异常出现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">AccountService accountService; </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 扣减账户余额</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/account/reduce&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">result</span><span class="params">(<span class="meta">@RequestParam(&quot;userId&quot;)</span> Long userId, <span class="meta">@RequestParam(&quot;money&quot;)</span> Integer money)</span>&#123;</span><br><span class="line"><span class="comment">//模拟异常, 超时，或者 int i = 9 / 0; </span></span><br><span class="line">  <span class="comment">//openfeign 接口调用默认超时时间为 1s</span></span><br><span class="line">  <span class="comment">//说明 1. 也可以使用其它方式模拟异常, 但在 Debug 看 Seata 分布式事务机制不方便, 不好看效果 , 所以这里我们使用超时异常</span></span><br><span class="line"><span class="comment">//说明 2. 因为是超时异常, 所以在 Debug 分析 Seata 机制时, 可能会发现某张表 被锁几条记录, 因为 seata 会做最终一致性操作(即尝试再提交上次超时的事务).</span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">12</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">accountService.reduce(userId,money);</span><br><span class="line"><span class="keyword">return</span> Result.success(<span class="string">&quot;200&quot;</span>, <span class="string">&quot;扣减账户余额 OK&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**2.**修 改 <strong>seata-order-micro-service-10008</strong> <strong>的</strong>com&#x2F;study&#x2F;springcloud&#x2F;service&#x2F;impl&#x2F;OrderServicelmpl.java</p><p><strong>使用<u>@GlobalTransactional</u>控制分布式事务，保证数据一致性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建订单-&gt;调用库存服务扣减库存-&gt;调用账户服务扣减账户余额-&gt;修改订单状态 </span></span><br><span class="line"><span class="comment">* 解读</span></span><br><span class="line"><span class="comment">* 1. <span class="doctag">@GlobalTransactional</span>: 分布式全局事务控制</span></span><br><span class="line"><span class="comment">* 2. name = &quot;hspedu-save-order&quot; 名称自己写，保证唯一即可</span></span><br><span class="line"><span class="comment">* 3. rollbackFor = Exception.class 指定发生什么异常就回滚，</span></span><br><span class="line"><span class="comment">* 这里指定只要发生异常就回滚</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">//下面这句话是做全局事务控制的, 如果没有，则没有分布式全局事务控制 </span></span><br><span class="line"><span class="meta">@GlobalTransactional(name = &quot;hspedu-save-order&quot;, rollbackFor = Exception.class)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">log.info(<span class="string">&quot;=========开始新建订单 start ==========&quot;</span>); </span><br><span class="line">  <span class="comment">//新建订单</span></span><br><span class="line">orderDao.save(order);</span><br><span class="line">System.out.println(<span class="string">&quot;order=&quot;</span> + order); </span><br><span class="line">  log.info(<span class="string">&quot;=========减库存 start ==========&quot;</span>); </span><br><span class="line">  storageService.reduce(order.getProductId(), order.getNums()); </span><br><span class="line">  log.info(<span class="string">&quot;=========减库存 end ==========&quot;</span>);</span><br><span class="line">log.info(<span class="string">&quot;=========减账户金额 start ==========&quot;</span>); </span><br><span class="line">  accountService.reduce(order.getUserId(), order.getMoney()); </span><br><span class="line">  log.info(<span class="string">&quot;=========减账户金额 end ==========&quot;</span>);</span><br><span class="line">log.info(<span class="string">&quot;=========修改订单状态 start ==========&quot;</span>); </span><br><span class="line">  orderDao.update(order.getUserId(), <span class="number">0</span>); </span><br><span class="line">  log.info(<span class="string">&quot;=========修改订单状态 end ==========&quot;</span>); </span><br><span class="line">  log.info(<span class="string">&quot;=========下订单 end==========&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3.</strong> <strong>重启</strong> <strong>seata-order-micro-service-10008</strong></p><p><strong>4.</strong> <strong>浏 览 器</strong> <strong>: <a href="http://localhost:10008/order/save?userId=666&productId=1&nums=1&money=100">http://localhost:10008/order/save?userId=666&amp;productId=1&amp;nums=1&amp;money=100</a></strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703143951841.png" alt="image-20230703143951841"></p><p><strong>5.</strong> 查看数据库&#x2F;表的情况是否正常, 结论:这时数据库&#x2F;表，数据不一致性得到保证.</p><h3 id="11-4-12-注意事项和细节"><a href="#11-4-12-注意事项和细节" class="headerlink" title="11.4.12 注意事项和细节"></a><strong>11.4.12</strong> 注意事项和细节</h3><h4 id="11-4-12-1-如果数据库-x2F-表使用到关键字，需要使用反引号"><a href="#11-4-12-1-如果数据库-x2F-表使用到关键字，需要使用反引号" class="headerlink" title="11.4.12.1 如果数据库&#x2F;表使用到关键字，需要使用反引号"></a>11.4.12.1 如果数据库&#x2F;表使用到关键字，需要使用反引号</h4><ul><li>举例说明**:** 比如<strong>mapper&#x2F;OrderMapper.xml ,</strong> 这里的 <strong>order</strong> 就要使用**&#96;&#96;,** 否则会报错</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;save&quot;</span>&gt;</span></span><br><span class="line">insert into `order` (id,user_id,product_id,nums,money,status) </span><br><span class="line">  values (null,#&#123;userId&#125;,#&#123;productId&#125;,#&#123;nums&#125;,#&#123;money&#125;,0);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">update `order` set status = 1</span><br><span class="line">where user_id=#&#123;userId&#125; and status = #&#123;status&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="11-4-12-2-openfeign在远程调用api接口时，默认超时时间为1s"><a href="#11-4-12-2-openfeign在远程调用api接口时，默认超时时间为1s" class="headerlink" title="11.4.12.2 openfeign在远程调用api接口时，默认超时时间为1s"></a>11.4.12.2 openfeign在远程调用api接口时，默认超时时间为1s</h4>]]></content>
      
      
      <categories>
          
          <category> Spring开发框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 写文章步骤</title>
      <link href="/2023/06/02/hexo-%E5%86%99%E6%96%87%E7%AB%A0%E6%AD%A5%E9%AA%A4/"/>
      <url>/2023/06/02/hexo-%E5%86%99%E6%96%87%E7%AB%A0%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo搭建博客配置注意事项："><a href="#hexo搭建博客配置注意事项：" class="headerlink" title="hexo搭建博客配置注意事项："></a>hexo搭建博客配置注意事项：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对文件夹进行配置</span></span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建新文章</span></span><br><span class="line">hexo <span class="keyword">new</span> <span class="string">&quot;文章名称&quot;</span></span><br><span class="line">hexo n <span class="string">&quot;文章名称&quot;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//清理hexo缓存</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新生成博客的静态文件</span></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line"><span class="comment">//本地运行博客若无法运行需要安装依赖：npm install hexo-server --save</span></span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line"><span class="comment">//部署博客到github仓库</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>在blog的package.json中修改：</p><p>“server”: “hexo server” 👉 “server”: “hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server”</p><p>此后 执行npm run server &#x3D; 同时执行以上三个命令</p><h2 id="博客配置注意事项："><a href="#博客配置注意事项：" class="headerlink" title="博客配置注意事项："></a>博客配置注意事项：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文章头部：</span><br><span class="line">title: 文章标题</span><br><span class="line">date: 2023-06-02 12:04:52</span><br><span class="line">tags: 博客创建</span><br><span class="line">categories: 博客创建</span><br><span class="line">cover: https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">title【必需】文章标题</span><br><span class="line">date【必需】文章创建日期</span><br><span class="line">updated【可选】文章更新日期</span><br><span class="line">tags【可选】文章标签</span><br><span class="line">categories【可选】文章分类</span><br><span class="line">keywords【可选】文章关键字</span><br><span class="line">description【可选】文章描述</span><br><span class="line">top_img【可选】文章顶部图片</span><br><span class="line">cover【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)</span><br><span class="line">comments【可选】显示文章评论模块(默认 true)</span><br><span class="line">toc【可选】显示文章TOC(默认为设置中toc的enable配置)</span><br><span class="line">toc_number【可选】显示toc_number(默认为设置中toc的number配置)</span><br><span class="line">toc_style_simple【可选】显示 toc 简洁模式</span><br><span class="line">copyright【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)</span><br><span class="line">copyright_author【可选】文章版权模块的文章作者</span><br><span class="line">copyright_author_href【可选】文章版权模块的文章作者链接</span><br><span class="line">copyright_url【可选】文章版权模块的文章连结链接</span><br><span class="line">copyright_info【可选】文章版权模块的版权声明文字</span><br><span class="line">mathjax【可选】显示mathjax(当设置 mathjax 的 per_page: false 时，才需要配置，默认 false )</span><br><span class="line">katex【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false )</span><br><span class="line">aplayer【可选】在需要的页面加载 aplayer 的 js 和 css,请参考文章下面的音乐 配置</span><br><span class="line">highlight_shrink【可选】配置代码框是否展开(true/false)(默认为设置中 highlight_shrink 的配置)</span><br><span class="line">aside【可选】显示侧边栏 (默认 true)</span><br><span class="line">abcjs【可选】加载 abcjs (当设置 abcjs 的 per_page: false 时，才需要配置，默认 false )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者: Jerry</span><br><span class="line">連結: https://butterfly.js.org/posts/dc584b87/#Post-Front-matter</span><br><span class="line">來源: Butterfly</span><br><span class="line">著作權歸作者所有。商業轉載請聯絡作者獲得授權，非商業轉載請註明出處。</span><br></pre></td></tr></table></figure><h2 id="对博客进行git版本控制："><a href="#对博客进行git版本控制：" class="headerlink" title="对博客进行git版本控制："></a>对博客进行git版本控制：</h2><p>将本地blog文件夹推送到仓库</p><p>当需要重新拉取blog文件夹时，只需要：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//进入想要放置blog的终端</span><br><span class="line">git clone 仓库链接</span><br><span class="line">//安装依赖</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>将本地代码更新到仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在blog目录下中端执行：</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;commit的名称(个人习惯：20230604commit01)&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h2 id="hexo-写文章步骤："><a href="#hexo-写文章步骤：" class="headerlink" title="hexo 写文章步骤："></a>hexo 写文章步骤：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">donn@Macc blog % hexo new &quot;算法小结&quot;</span><br><span class="line"></span><br><span class="line">INFO Validating config</span><br><span class="line"></span><br><span class="line">INFO Created: /opt/blog/source/_posts/算法小结.md</span><br></pre></td></tr></table></figure><ol><li><p>hexo new “文章名称”</p></li><li><p>在对应文件中写内容</p></li><li><p>完成部署：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g -c</span><br><span class="line">hexo s</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li></ol><p>🌟push到github仓库时出现超时报错的解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://github.com/Tangjiayang/Tangjiayang.github.io.git/&#x27;: Failed to connect to github.com port 443 after 75012 ms: Couldn&#x27;t connect to server</span><br><span class="line">FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: Spawn failed</span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (/opt/blog/node_modules/hexo-util/lib/spawn.js:51:21)</span><br><span class="line">    at ChildProcess.emit (node:events:511:28)</span><br><span class="line">    at ChildProcess._handle.onexit (node:internal/child_process:293:12)</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">取消全局代理：</span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果还不能解决：</span><br><span class="line">尝试刷新DNS缓存</span><br><span class="line">mac用户刷新DNS缓存指令：</span><br><span class="line">sudo killall -HUP mDNSResponder</span><br><span class="line">刷新后就可以啦～</span><br></pre></td></tr></table></figure><p>文章操作：</p><p>​文章置顶：</p><p>​添加配置      sticky: 1</p><h3 id="使用picgo-github搭建免费个人图床！"><a href="#使用picgo-github搭建免费个人图床！" class="headerlink" title="使用picgo+github搭建免费个人图床！"></a>使用picgo+github搭建免费个人图床！</h3><p>git使用：<a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></p><p><a href="https://blog.csdn.net/Jimmy_wei_2010/article/details/130268408">https://blog.csdn.net/Jimmy_wei_2010/article/details/130268408</a></p><p><a href="https://blog.csdn.net/qq_41982020/article/details/121437344">https://blog.csdn.net/qq_41982020/article/details/121437344</a></p><p>有关sshkey： <a href="https://blog.csdn.net/D_Ray_/article/details/120240909">https://blog.csdn.net/D_Ray_/article/details/120240909</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客创建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-Plus</title>
      <link href="/2023/06/02/MyBatis-Plus/"/>
      <url>/2023/06/02/MyBatis-Plus/</url>
      
        <content type="html"><![CDATA[<h1 id="一、MyBatis-Plus"><a href="#一、MyBatis-Plus" class="headerlink" title="一、MyBatis-Plus"></a>一、MyBatis-Plus</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus (opens new window)</a>（简称 MP）是一个 <a href="https://www.mybatis.org/mybatis-3/">MyBatis (opens new window)</a>的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><blockquote><p>我们的愿景是成为 MyBatis 最好的搭档，就像 <a href="https://baomidou.com/img/contra.jpg">魂斗罗</a> 中的 1P、2P，基友搭配，效率翻倍。</p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/relationship-with-mybatis.png" alt="img"></p><h2 id="2-特性"><a href="#2-特性" class="headerlink" title="2.特性"></a>2.特性</h2><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h2 id="3-支持数据库"><a href="#3-支持数据库" class="headerlink" title="3.支持数据库"></a>3.支持数据库</h2><blockquote><p>任何能使用 <code>MyBatis</code> 进行 CRUD, 并且支持标准 SQL 的数据库，具体支持情况如下，如果不在下列表查看分页部分教程 PR 您的支持。</p></blockquote><ul><li>MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb</li><li>达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库</li></ul><h2 id="4-框架结构"><a href="#4-框架结构" class="headerlink" title="4.框架结构"></a>4.框架结构</h2><p>![image-20230517103049072](&#x2F;Users&#x2F;donn&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230517103049072.png)</p><h2 id="5-官方地址"><a href="#5-官方地址" class="headerlink" title="5.官方地址"></a>5.官方地址</h2><blockquote><p><strong>官方网站：</strong><a href="https://baomidou.com/">https://baomidou.com/</a></p><p><strong>官方文档：</strong><a href="https://baomidou.com/pages/24112f/">https://baomidou.com/pages/24112f/</a></p></blockquote><h1 id="二、入门案例"><a href="#二、入门案例" class="headerlink" title="二、入门案例"></a>二、入门案例</h1><h2 id="1-开发环境"><a href="#1-开发环境" class="headerlink" title="1.开发环境"></a>1.开发环境</h2><ul><li><strong>IDE：IDEA 2019.3.5</strong></li><li><strong>JDK：JDK8+</strong></li><li><strong>构建工具：Maven 3.5.4</strong></li><li><strong>MySQL：MySQL 8.0.24</strong></li><li><strong>Navicat：Navicat Premium 15</strong></li><li><strong>Spring Boot：2.6.7</strong></li><li><strong>MyBatis-Plus：3.5.1</strong></li></ul><h2 id="2-建库建表"><a href="#2-建库建表" class="headerlink" title="2.建库建表"></a>2.建库建表</h2><ul><li><p><strong>打开Navicat运行以下SQL脚本进行建库建表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `mybatis_plus` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 */</span>; </span><br><span class="line">use `mybatis_plus`; </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` ( </span><br><span class="line">    `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>, </span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>, </span><br><span class="line">    `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>, </span><br><span class="line">    `email` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>, </span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`) </span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure></li><li><p><strong>插入几条测试数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (id, name, age, email) <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Jone&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;test1@baomidou.com&#x27;</span>), </span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;test2@baomidou.com&#x27;</span>), </span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;test3@baomidou.com&#x27;</span>), </span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;Sandy&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;test4@baomidou.com&#x27;</span>), </span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;Billie&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;test5@baomidou.com&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-创建工程"><a href="#3-创建工程" class="headerlink" title="3.创建工程"></a>3.创建工程</h2><ul><li><p><strong>使用<code>Spring Initializer</code>快速初始化一个 Spring Boot 工程</strong></p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519140839640.png" alt="image-20220519140839640" style="zoom:80%;" /><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519141335981.png" alt="image-20220519141335981" style="zoom:80%;" /><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519141737405.png" alt="image-20220519141737405" style="zoom:80%;" /><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519141849937.png" alt="image-20220519141849937" style="zoom:80%;" /></li><li><p><strong>引入<code>MyBatis-Plus</code>的依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">其他相关依赖：</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>安装<code>Lombok</code>插件</strong></p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519143257305.png" alt="image-20220519143257305" style="zoom:80%;" /></li></ul><h2 id="4-配置编码"><a href="#4-配置编码" class="headerlink" title="4.配置编码"></a>4.配置编码</h2><ul><li><p><strong>配置<code>application.yml</code>文件</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#配置数据源</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment">#配置数据源类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="comment">#配置连接数据库的信息</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> &#123;<span class="string">username</span>&#125;</span><br><span class="line">    <span class="attr">password:</span> &#123;<span class="string">password</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#MyBatis-Plus相关配置</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment">#配置日志</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure></li><li><p><strong>在 Spring Boot 启动类中添加 <code>@MapperScan</code> 注解，扫描 Mapper 文件夹</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;指定Mapper接口所在的包&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusDemoApplication</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(MybatisPlusDemoApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>编写实体类 <code>User.java</code>（此处使用了 Lombok 简化代码）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>编写 Mapper 包下的 <code>UserMapper</code>接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-测试查询"><a href="#5-测试查询" class="headerlink" title="5.测试查询"></a>5.测试查询</h2><ul><li><p><strong>编写一个测试类<code>MyBatisPlusTest.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusTest</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试查询所有数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSelectList</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//通过条件构造器查询一个list集合，若没有条件，则可以设置null为参数</span></span><br><span class="line">        List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>控制台打印查询结果</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519150454211.png" alt="image-20220519150454211"></p></li></ul><h1 id="三、增删改查"><a href="#三、增删改查" class="headerlink" title="三、增删改查"></a>三、增删改查</h1><h2 id="1-BaseMapper-lt-T-gt"><a href="#1-BaseMapper-lt-T-gt" class="headerlink" title="1.BaseMapper&lt;T&gt;"></a>1.BaseMapper&lt;T&gt;</h2><blockquote><p>说明:</p><ul><li>通用 CRUD 封装BaseMapper 接口，为 <code>Mybatis-Plus</code> 启动时自动解析实体表关系映射转换为 <code>Mybatis</code> 内部对象注入容器</li><li>泛型 <code>T</code> 为任意实体对象</li><li>参数 <code>Serializable</code> 为任意类型主键 <code>Mybatis-Plus</code> 不推荐使用复合主键约定每一张表都有自己的唯一 <code>id</code> 主键</li><li>对象 <code>Wrapper</code> 为条件构造器</li></ul></blockquote><p>MyBatis-Plus中的基本CRUD在内置的BaseMapper中都已得到了实现，因此我们继承该接口以后可以直接使用。</p><p>本次演示的CRUD操作不包含参数带有条件构造器的方法，关于条件构造器将单独在一个章节进行演示。</p><hr><blockquote><p><strong>BaseMapper中提供的CRUD方法：</strong></p></blockquote><ul><li><p><strong>增加：Insert</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入一条记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(T entity)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>删除：Delete</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; wrapper)</span>;</span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>修改：Update</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T updateEntity, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; whereWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 修改</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateById</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T entity)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>查询：Selete</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">selectById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 entity 条件，查询一条记录</span></span><br><span class="line">T <span class="title function_">selectOne</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMaps</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">selectObjs</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录（并翻页）</span></span><br><span class="line">IPage&lt;T&gt; <span class="title function_">selectPage</span><span class="params">(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录（并翻页）</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMapsPage</span><span class="params">(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line">Integer <span class="title function_">selectCount</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-调用Mapper层实现CRUD"><a href="#2-调用Mapper层实现CRUD" class="headerlink" title="2.调用Mapper层实现CRUD"></a>2.调用Mapper层实现CRUD</h2><h3 id="2-1插入"><a href="#2-1插入" class="headerlink" title="2.1插入"></a>2.1插入</h3><hr><blockquote><p><strong>最终执行的结果，所获取的id为1527206783590903810</strong></p><p><strong>这是因为MyBatis-Plus在实现插入数据时，会默认基于雪花算法的策略生成id</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试插入一条数据</span></span><br><span class="line"><span class="comment">  * MyBatis-Plus在实现插入数据时，会默认基于雪花算法的策略生成id</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;Vz&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">21</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;vz@oz6.cn&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insert(user);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;添加成功！&quot;</span> : <span class="string">&quot;添加失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">    <span class="comment">//1527206783590903810（当前 id 为雪花算法自动生成的id）</span></span><br><span class="line">    System.out.println(<span class="string">&quot;id自动获取&quot;</span> + user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2删除"><a href="#2-2删除" class="headerlink" title="2.2删除"></a>2.2删除</h3><hr><h4 id="a、根据ID删除数据"><a href="#a、根据ID删除数据" class="headerlink" title="a、根据ID删除数据"></a>a、根据ID删除数据</h4><blockquote><p><strong>调用方法：int deleteById(Serializable id);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试根据id删除一条数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteById</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteById(<span class="number">1527206783590903810L</span>);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;删除成功！&quot;</span> : <span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="b、根据ID批量删除数据"><a href="#b、根据ID批量删除数据" class="headerlink" title="b、根据ID批量删除数据"></a>b、根据ID批量删除数据</h4><blockquote><p><strong>调用方法：int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试通过id批量删除数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteBatchIds</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Long&gt; ids = Arrays.asList(<span class="number">6L</span>,<span class="number">7L</span>,<span class="number">8L</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteBatchIds(ids);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;删除成功！&quot;</span> : <span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="c、根据Map条件删除数据"><a href="#c、根据Map条件删除数据" class="headerlink" title="c、根据Map条件删除数据"></a>c、根据Map条件删除数据</h4><blockquote><p><strong>调用方法：int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 测试根据Map集合中所设置的条件删除数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteByMap</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//当前演示为根据name和age删除数据</span></span><br><span class="line">    <span class="comment">//执行SQL为：DELETE FROM user WHERE name = ? AND age = ?</span></span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Vz&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>,<span class="number">21</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteByMap(map);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;删除成功！&quot;</span> : <span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3修改"><a href="#2-3修改" class="headerlink" title="2.3修改"></a>2.3修改</h3><blockquote><p><strong>调用方法：int updateById(@Param(Constants.ENTITY) T entity);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试根据id修改用户信息</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateById</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//执行SQL为： UPDATE user SET name=?, age=?, email=? WHERE id=?</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setId(<span class="number">6L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;VzUpdate&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;Vz@sina.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.updateById(user);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;修改成功！&quot;</span> : <span class="string">&quot;修改失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4查询"><a href="#2-4查询" class="headerlink" title="2.4查询"></a>2.4查询</h3><hr><h4 id="a、根据ID查询用户信息"><a href="#a、根据ID查询用户信息" class="headerlink" title="a、根据ID查询用户信息"></a>a、根据ID查询用户信息</h4><blockquote><p><strong>调用方法：T selectById(Serializable id);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试根据id查询用户数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectById</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="b、根据多个ID查询多个用户信息"><a href="#b、根据多个ID查询多个用户信息" class="headerlink" title="b、根据多个ID查询多个用户信息"></a>b、根据多个ID查询多个用户信息</h4><blockquote><p><strong>调用方法：List<T> selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 根据多个id查询用户数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectBatchIds</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//执行SQL为：SELECT id,name,age,email FROM user WHERE id IN ( ? , ? , ? )</span></span><br><span class="line">    List&lt;Long&gt; ids = Arrays.asList(<span class="number">1L</span>,<span class="number">2L</span>,<span class="number">3L</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectBatchIds(ids);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="c、根据Map条件查询用户信息"><a href="#c、根据Map条件查询用户信息" class="headerlink" title="c、根据Map条件查询用户信息"></a>c、根据Map条件查询用户信息</h4><blockquote><p><strong>调用方法：List<T> selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 根据Map所设置的条件查询用户</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByMap</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//执行SQL为：SELECT id,name,age,email FROM user WHERE age = ?</span></span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectByMap(map);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="d、查询所有用户信息"><a href="#d、查询所有用户信息" class="headerlink" title="d、查询所有用户信息"></a>d、查询所有用户信息</h4><blockquote><p><strong>调用方法：List<T> selectList(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试查询所有数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSelectList</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-通用Service"><a href="#3-通用Service" class="headerlink" title="3.通用Service"></a>3.通用Service</h2><blockquote><p>说明:</p><ul><li>通用 Service CRUD 封装<code>IService</code>接口，进一步封装 CRUD 采用 <code>get 查询单行</code> <code>remove 删除</code> <code>list 查询集合</code> <code>page 分页</code> 前缀命名方式区分 <code>Mapper</code> 层避免混淆，</li><li>泛型 <code>T</code> 为任意实体对象</li><li>建议如果存在自定义通用 Service 方法的可能，请创建自己的 <code>IBaseService</code> 继承 <code>Mybatis-Plus</code> 提供的基类</li><li>对象 <code>Wrapper</code> 为 条件构造器</li></ul></blockquote><p>MyBatis-Plus中有一个接口 **<code>IService</code>**和其实现类 **<code>ServiceImpl</code>**，封装了常见的业务层逻辑，详情查看源码IService和ServiceImpl</p><p>因此我们在使用的时候仅需在自己定义的**<code>Service</code><strong>接口中继承</strong><code>IService</code><strong>接口，在自己的实现类中实现自己的Service并继承</strong><code>ServiceImpl</code>**即可</p><hr><blockquote><p><strong>IService中的CRUD方法</strong></p></blockquote><ul><li><p><strong>增加：Save、SaveOrUpdate</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入一条记录（选择字段，策略插入）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">save</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TableId 注解存在更新记录，否插入一条记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>删除：Remove</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>修改：Update</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 UpdateWrapper 条件，更新记录 需要设置sqlset</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(T updateEntity, Wrapper&lt;T&gt; whereWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 选择修改</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateById</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>查询：Get、List、Count</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">getById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, <span class="type">boolean</span> throwEx)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getMap</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">&lt;V&gt; V <span class="title function_">getObj</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">list</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line">Collection&lt;T&gt; <span class="title function_">listByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line">Collection&lt;T&gt; <span class="title function_">listByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 查询所有列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line">&lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">&lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询总记录数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>分页：Page</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">getById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, <span class="type">boolean</span> throwEx)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getMap</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">&lt;V&gt; V <span class="title function_">getObj</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-调用Service层操作数据"><a href="#4-调用Service层操作数据" class="headerlink" title="4.调用Service层操作数据"></a>4.调用Service层操作数据</h2><blockquote><p>我们在自己的Service接口中通过继承MyBatis-Plus提供的IService接口，不仅可以获得其提供的CRUD方法，而且还可以使用自身定义的方法。</p></blockquote><ul><li><p><strong>创建<code>UserService</code>并继承<code>IService</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * UserService继承IService模板提供的基础功能 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建<code>UserService</code>的实现类并继承<code>ServiceImpl</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * ServiceImpl实现了IService，提供了IService中基础功能的实现 </span></span><br><span class="line"><span class="comment">  * 若ServiceImpl无法满足业务需求，则可以使用自定的UserService定义方法，并在实现类中实现</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper,User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>测试查询记录数</strong></p><blockquote><p><strong>调用方法：int count();</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//查询总记录数</span></span><br><span class="line">    <span class="comment">//执行的SQL为：SELECT COUNT( * ) FROM user</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> userService.count();</span><br><span class="line">    System.out.println(<span class="string">&quot;总记录数：&quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>测试批量插入数据</strong></p><blockquote><p><strong>调用方法：boolean saveBatch(Collection<T> entityList);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;Vz&quot;</span>+i);</span><br><span class="line">        user.setAge(<span class="number">20</span>+i);</span><br><span class="line">        list.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> userService.saveBatch(list);</span><br><span class="line">    System.out.println(b ? <span class="string">&quot;添加成功！&quot;</span> : <span class="string">&quot;添加失败！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="四、常用注解"><a href="#四、常用注解" class="headerlink" title="四、常用注解"></a>四、常用注解</h1><blockquote><p>MyBatis-Plus提供的注解可以帮我们解决一些数据库与实体之间相互映射的问题。</p></blockquote><h2 id="1-TableName"><a href="#1-TableName" class="headerlink" title="1.@TableName"></a>1.@TableName</h2><blockquote><p>经过以上的测试，在使用MyBatis-Plus实现基本的CRUD时，我们并没有指定要操作的表，只是在Mapper接口继承BaseMapper时，设置了泛型User，而操作的表为user表，由此得出结论，MyBatis-Plus在确定操作的表时，由BaseMapper的泛型决定，即实体类型决定，且默认操作的表名和实体类型的类名一致。</p></blockquote><h3 id="1-1引出问题"><a href="#1-1引出问题" class="headerlink" title="1.1引出问题"></a>1.1引出问题</h3><hr><blockquote><p><strong>若实体类类型的类名和要操作的表的表名不一致，会出现什么问题？</strong></p></blockquote><ul><li><p>我们将表<code>user</code>更名为<code>t_user</code>，测试查询功能</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520093844842.png" alt="image-20220520093844842"></p></li><li><p>程序抛出异常，<strong>Table ‘mybatis_plus.user’ doesn’t exist</strong>，因为现在的表名为<code>t_user</code>，而默认操作的表名和实体类型的类名一致，即<code>user</code>表</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520094126411.png" alt="image-20220520094126411"></p></li></ul><h3 id="1-2解决问题"><a href="#1-2解决问题" class="headerlink" title="1.2解决问题"></a>1.2解决问题</h3><hr><h4 id="a、使用注解解决问题"><a href="#a、使用注解解决问题" class="headerlink" title="a、使用注解解决问题"></a>a、使用注解解决问题</h4><blockquote><p><strong>在实体类类型上添加<code>@TableName(&quot;t_user&quot;)</code>，标识实体类对应的表，即可成功执行SQL语句</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;t_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="b、使用全局配置解决问题"><a href="#b、使用全局配置解决问题" class="headerlink" title="b、使用全局配置解决问题"></a>b、使用全局配置解决问题</h4><blockquote><p><strong>在开发的过程中，我们经常遇到以上的问题，即实体类所对应的表都有固定的前缀，例如 <code>t_</code> 或 <code>tbl_</code> 此时，可以使用MyBatis-Plus提供的全局配置，为实体类所对应的表名设置默认的前缀，那么就不需要在每个实体类上通过@TableName标识实体类对应的表</strong></p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment"># 设置实体类所对应的表的统一前缀</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">t_</span></span><br></pre></td></tr></table></figure><h2 id="2-TableId"><a href="#2-TableId" class="headerlink" title="2.@TableId"></a>2.@TableId</h2><blockquote><p><strong>经过以上的测试，MyBatis-Plus在实现CRUD时，会默认将id作为主键列，并在插入数据时，默认基于雪花算法的策略生成id</strong></p></blockquote><h3 id="2-1引出问题"><a href="#2-1引出问题" class="headerlink" title="2.1引出问题"></a>2.1引出问题</h3><hr><blockquote><p><strong>若实体类和表中表示主键的不是id，而是其他字段，例如uid，MyBatis-Plus会自动识别uid为主键列吗？</strong></p></blockquote><ul><li><p>我们实体类中的属性<code>id</code>改为<code>uid</code>，将表中的字段<code>id</code>也改为<code>uid</code>，测试添加功能</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520100939157.png" alt="image-20220520100939157"></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520100715109.png" alt="image-20220520100715109"></p></li><li><p>程序抛出异常，<strong>Field ‘uid’ doesn’t have a default value</strong>，说明MyBatis-Plus没有将<code>uid</code>作为主键赋值</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520101317761.png" alt="image-20220520101317761"></p></li></ul><h3 id="2-2解决问题"><a href="#2-2解决问题" class="headerlink" title="2.2解决问题"></a>2.2解决问题</h3><hr><blockquote><p><strong>在实体类中uid属性上通过<code>@TableId</code>将其标识为主键，即可成功执行SQL语句</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Date</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long uid;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-TableId的value属性"><a href="#2-3-TableId的value属性" class="headerlink" title="2.3@TableId的value属性"></a>2.3@TableId的value属性</h3><hr><blockquote><p>若实体类中主键对应的属性为id，而表中表示主键的字段为uid，此时若只在属性id上添加注解@TableId，则抛出异常**Unknown column ‘id’ in ‘field list’**，即MyBatis-Plus仍然会将id作为表的主键操作，而表中表示主键的是字段uid此时需要通过@TableId注解的value属性，指定表中的主键字段，<code>@TableId(&quot;uid&quot;)</code>或<code>@TableId(value=&quot;uid&quot;)</code></p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520103030977.png" alt="image-20220520103030977"></p><h3 id="2-4-TableId的type属性"><a href="#2-4-TableId的type属性" class="headerlink" title="2.4@TableId的type属性"></a>2.4@TableId的type属性</h3><hr><blockquote><p><strong>type属性用来定义主键策略：默认雪花算法</strong></p></blockquote><p><strong>常用的主键策略：</strong></p><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">IdType.ASSIGN_ID（默认）</td><td align="center">基于雪花算法的策略生成数据id，与数据库id是否设置自增无关</td></tr><tr><td align="center">IdType.AUTO</td><td align="center">使用数据库的自增策略，注意，该类型请确保数据库设置了id自增，</td></tr></tbody></table><p><strong>配置全局主键策略：</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#MyBatis-Plus相关配置</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment">#配置日志</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment">#配置mp的主键策略为自增</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">      <span class="comment"># 设置实体类所对应的表的统一前缀</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">t_</span></span><br></pre></td></tr></table></figure><h2 id="3-TbaleField"><a href="#3-TbaleField" class="headerlink" title="3.@TbaleField"></a>3.@TbaleField</h2><blockquote><p>经过以上的测试，我们可以发现，MyBatis-Plus在执行SQL语句时，要保证实体类中的属性名和表中的字段名一致</p><p>如果实体类中的属性名和字段名不一致的情况，会出现什么问题呢？</p></blockquote><h3 id="3-1情况一"><a href="#3-1情况一" class="headerlink" title="3.1情况一"></a>3.1情况一</h3><hr><p>若实体类中的属性使用的是驼峰命名风格，而表中的字段使用的是下划线命名风格</p><p>例如实体类属性<code>userName</code>，表中字段<code>user_name</code></p><p>此时MyBatis-Plus会<strong>自动</strong>将下划线命名风格转化为驼峰命名风格</p><p>相当于在MyBatis中配置</p><h3 id="3-2情况二"><a href="#3-2情况二" class="headerlink" title="3.2情况二"></a>3.2情况二</h3><hr><blockquote><p>若实体类中的属性和表中的字段不满足情况1</p><p>例如实体类属性<code>name</code>，表中字段<code>username</code></p><p>此时需要在实体类属性上使用<code>@TableField(&quot;username&quot;)</code>设置属性所对应的字段名</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(&quot;uid&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@TableField(&quot;username&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-TableLogic"><a href="#4-TableLogic" class="headerlink" title="4.@TableLogic"></a>4.@TableLogic</h2><h3 id="4-1逻辑删除"><a href="#4-1逻辑删除" class="headerlink" title="4.1逻辑删除"></a>4.1逻辑删除</h3><hr><blockquote><p>物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据</p><p>逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录</p><p>使用场景：可以进行数据恢复</p></blockquote><h3 id="4-2实现逻辑删除"><a href="#4-2实现逻辑删除" class="headerlink" title="4.2实现逻辑删除"></a>4.2实现逻辑删除</h3><hr><ul><li><p><strong>数据库中创建逻辑删除状态列，设置默认值为0</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520134529809.png" alt="image-20220520134529809"></p></li><li><p><strong>实体类中添加逻辑删除属性</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520134636112.png" alt="image-20220520134636112"></p></li><li><p><strong>测试删除功能，真正执行的是修改</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteById</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteById(<span class="number">1527472864163348482L</span>);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;删除成功！&quot;</span> : <span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520135637388.png" alt="image-20220520135637388"></p></li><li><p><strong>此时执行查询方法，查询的结果为自动添加条件<code>is_deleted=0</code></strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520140036445.png" alt="image-20220520140036445"></p></li></ul><h1 id="五、条件构造器"><a href="#五、条件构造器" class="headerlink" title="五、条件构造器"></a>五、条件构造器</h1><h2 id="1-Wrapper介绍"><a href="#1-Wrapper介绍" class="headerlink" title="1.Wrapper介绍"></a>1.Wrapper介绍</h2><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220521092812125.png" alt="image-20220521092812125"></p><ul><li><p><code>Wrapper</code> ： 条件构造抽象类，最顶端父类</p><ul><li><p><code>AbstractWrapper </code>： 用于查询条件封装，生成 sql 的 where 条件</p><ul><li><p><code>QueryWrapper </code>： 查询条件封装</p></li><li><p><code>UpdateWrapper </code>： Update 条件封装</p></li><li><p><code>AbstractLambdaWrapper </code>： 使用Lambda 语法</p><ul><li><p><code>LambdaQueryWrapper </code>：用于Lambda语法使用的查询Wrapper</p></li><li><p><code>LambdaUpdateWrapper </code>： Lambda 更新封装Wrapper</p></li></ul></li></ul></li></ul></li></ul><h2 id="2-QueryWrapper"><a href="#2-QueryWrapper" class="headerlink" title="2.QueryWrapper"></a>2.QueryWrapper</h2><ul><li><p><strong>组装查询条件</strong></p><blockquote><p><strong>执行SQL：</strong>SELECT uid AS id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted&#x3D;0 AND (username LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//查询用户名包含a，年龄在20到30之间，邮箱信息不为null的用户信息</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.like(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;a&quot;</span>).between(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>,<span class="number">30</span>).isNotNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>组装排序条件</strong></p><blockquote><p><strong>执行SQL：</strong>SELECT uid AS id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted&#x3D;0 ORDER BY age DESC,id ASC</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//查询用户信息，按照年龄的降序排序，若年龄相同，则按照id升序排序</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.orderByDesc(<span class="string">&quot;age&quot;</span>).orderByAsc(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>组装删除条件</strong></p><blockquote><p><strong>执行SQL：</strong>UPDATE t_user SET is_deleted&#x3D;1 WHERE is_deleted&#x3D;0 AND (email IS NULL)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//删除邮箱地址为null的用户信息</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.delete(queryWrapper);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;删除成功！&quot;</span> : <span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>条件的优先级</strong></p><blockquote><p><strong>执行SQL：</strong>UPDATE t_user SET user_name&#x3D;?, email&#x3D;? WHERE is_deleted&#x3D;0 AND (age &gt; ? AND user_name LIKE ? OR email IS NULL)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//将（年龄大于20并且用户名中包含有a）或邮箱为null的用户信息修改</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    updateWrapper.gt(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>).like(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;a&quot;</span>).or().isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;Oz&quot;</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;test@oz6.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(user, updateWrapper);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;修改成功！&quot;</span> : <span class="string">&quot;修改失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>执行SQL：</strong>UPDATE t_user SET username&#x3D;?, email&#x3D;? WHERE is_deleted&#x3D;0 AND (username LIKE ? AND (age &gt; ? OR email IS NULL))</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    updateWrapper.like(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;a&quot;</span>).and(i-&gt;i.gt(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>).or().isNull(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;Vz7797&quot;</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;test@ss8o.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(user, updateWrapper);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;修改成功！&quot;</span> : <span class="string">&quot;修改失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>组装select子句</strong></p><blockquote><p><strong>执行SQL：</strong>SELECT username,age,email FROM t_user WHERE is_deleted&#x3D;0</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//查询用户的用户名、年龄、邮箱信息</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.select(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper);</span><br><span class="line">    maps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>实现子查询</strong></p><blockquote><p><strong>执行SQL：</strong>SELECT uid AS id,user_name AS name,age,email,is_deleted FROM t_user WHERE is_deleted&#x3D;0 AND (uid IN (select uid from t_user where uid &lt;&#x3D; 100))</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test07</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//查询id小于等于100的用户信息</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.inSql(<span class="string">&quot;uid&quot;</span>, <span class="string">&quot;select uid from t_user where uid &lt;= 100&quot;</span>);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-UpdateWrapper"><a href="#3-UpdateWrapper" class="headerlink" title="3.UpdateWrapper"></a>3.UpdateWrapper</h2><blockquote><p>UpdateWrapper不仅拥有QueryWrapper的组装条件功能，还提供了set方法进行修改对应条件的数据库信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test08</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    updateWrapper.like(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;a&quot;</span>).and( i -&gt; i.gt(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>).or().isNull(<span class="string">&quot;email&quot;</span>)).set(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;svip@qq.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(<span class="literal">null</span>, updateWrapper);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;修改成功！&quot;</span> : <span class="string">&quot;修改失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-condition"><a href="#4-condition" class="headerlink" title="4.condition"></a>4.condition</h2><blockquote><p>在真正开发的过程中，组装条件是常见的功能，而这些条件数据来源于用户输入，是可选的，因此我们在组装这些条件时，<strong>必须先判断用户是否选择了这些条件，若选择则需要组装该条件</strong>，若没有选择则一定不能组装，以免影响SQL执行的结果</p></blockquote><ul><li><p><strong>思路一</strong></p><blockquote><p><strong>执行SQL：</strong>SELECT uid AS id,user_name AS name,age,email,is_deleted FROM t_user WHERE is_deleted&#x3D;0 AND (user_name LIKE ? AND age &lt;&#x3D; ?)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test09</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageBegin</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageEnd</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotBlank(username))&#123;</span><br><span class="line">        <span class="comment">//isNotBlank判断某个字符创是否不为空字符串、不为null、不为空白符</span></span><br><span class="line">        queryWrapper.like(<span class="string">&quot;user_name&quot;</span>, username);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ageBegin != <span class="literal">null</span>)&#123;</span><br><span class="line">        queryWrapper.ge(<span class="string">&quot;age&quot;</span>, ageBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ageEnd != <span class="literal">null</span>)&#123;</span><br><span class="line">        queryWrapper.le(<span class="string">&quot;age&quot;</span>, ageEnd);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>思路二</strong></p><blockquote><p>上面的实现方案没有问题，但是代码比较复杂，我们可以使用带condition参数的重载方法构建查询条件，简化代码的编写</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test10</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageBegin</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageEnd</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.like(StringUtils.isNotBlank(username), <span class="string">&quot;user_name&quot;</span>, username)</span><br><span class="line">        .ge(ageBegin != <span class="literal">null</span>, <span class="string">&quot;age&quot;</span>, ageBegin)</span><br><span class="line">        .le(ageEnd != <span class="literal">null</span>, <span class="string">&quot;age&quot;</span>, ageEnd);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-LambdaQueryWrapper"><a href="#5-LambdaQueryWrapper" class="headerlink" title="5.LambdaQueryWrapper"></a>5.LambdaQueryWrapper</h2><blockquote><p>功能等同于QueryWrapper，提供了Lambda表达式的语法可以避免填错列名。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test11</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageBegin</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageEnd</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.like(StringUtils.isNotBlank(username), User::getName, username)</span><br><span class="line">        .ge(ageBegin != <span class="literal">null</span>, User::getAge, ageBegin)</span><br><span class="line">        .le(ageEnd != <span class="literal">null</span>, User::getAge, ageEnd);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-LambdaUpdateWrapper"><a href="#6-LambdaUpdateWrapper" class="headerlink" title="6.LambdaUpdateWrapper"></a>6.LambdaUpdateWrapper</h2><blockquote><p>功能等同于UpdateWrapper，提供了Lambda表达式的语法可以避免填错列名。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test12</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改</span></span><br><span class="line">    LambdaUpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    updateWrapper.like(User::getName, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">        .and(i -&gt; i.gt(User::getAge, <span class="number">20</span>).or().isNull(User::getEmail));</span><br><span class="line">    updateWrapper.set(User::getName, <span class="string">&quot;小黑&quot;</span>).set(User::getEmail,<span class="string">&quot;abc@atguigu.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(<span class="literal">null</span>, updateWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;result：&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、常用插件"><a href="#六、常用插件" class="headerlink" title="六、常用插件"></a>六、常用插件</h1><h2 id="1-分页插件"><a href="#1-分页插件" class="headerlink" title="1.分页插件"></a>1.分页插件</h2><blockquote><p>MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能</p></blockquote><ul><li><p><strong>添加配置类<code>MyBatisPlusConfig</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.atguigu.mybatisplus.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">//添加分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>编写测试方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//new Page()中的两个参数分别是当前页码，每页显示数量</span></span><br><span class="line">    Page&lt;User&gt; page = userMapper.selectPage(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">2</span>), <span class="literal">null</span>);</span><br><span class="line">    List&lt;User&gt; users = page.getRecords();</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-自定义分页"><a href="#2-自定义分页" class="headerlink" title="2.自定义分页"></a>2.自定义分页</h2><blockquote><p>上面调用的是MyBatis-Plus提供的带有分页的方法，那么我们自己定义的方法如何实现分页呢？</p></blockquote><ul><li><p><strong>在<code>UserMapper</code>接口中定义一个方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 根据年龄查询用户列表，分页显示 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> page 分页对象,xml中可以从里面进行取值,传递参数 Page 即自动分页,必须放在第一位 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> age 年龄 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">Page&lt;User&gt; <span class="title function_">selectPageVo</span><span class="params">(<span class="meta">@Param(&quot;page&quot;)</span> Page&lt;User&gt; page,<span class="meta">@Param(&quot;age&quot;)</span> Integer age)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>在<code>UserMapper.xml</code>中编写SQL实现该方法</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPageVo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select id,username as name,age,email from t_user where age &gt; #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>编写测试方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPageVo</span><span class="params">()</span>&#123;</span><br><span class="line">    Page&lt;User&gt; page = userMapper.selectPageVo(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;User&gt;(<span class="number">1</span>,<span class="number">2</span>), <span class="number">20</span>);</span><br><span class="line">    List&lt;User&gt; users = page.getRecords();</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-乐观锁"><a href="#3-乐观锁" class="headerlink" title="3.乐观锁"></a>3.乐观锁</h2><blockquote><p><strong>作用：当要更新一条记录的时候，希望这条记录没有被别人更新</strong></p></blockquote><p>乐观锁的实现方式：</p><ul><li>取出记录时，获取当前 version</li><li>更新时，带上这个 version</li><li>执行更新时， set version &#x3D; newVersion where version &#x3D; oldVersion</li><li>如果 version 不对，就更新失败</li></ul><h3 id="3-1场景"><a href="#3-1场景" class="headerlink" title="3.1场景"></a>3.1场景</h3><hr><ul><li>一件商品，成本价是80元，售价是100元。老板先是通知小李，说你去把商品价格增加50元。小李正在玩游戏，耽搁了一个小时。正好一个小时后，老板觉得商品价格增加到150元，价格太高，可能会影响销量。又通知小王，你把商品价格降低30元。</li><li>此时，小李和小王同时操作商品后台系统。小李操作的时候，系统先取出商品价格100元；小王也在操作，取出的商品价格也是100元。小李将价格加了50元，并将100+50&#x3D;150元存入了数据库；小王将商品减了30元，并将100-30&#x3D;70元存入了数据库。是的，如果没有锁，小李的操作就完全被小王的覆盖了。</li><li>现在商品价格是70元，比成本价低10元。几分钟后，这个商品很快出售了1千多件商品，老板亏1万多。</li></ul><h3 id="3-2乐观锁与悲观锁"><a href="#3-2乐观锁与悲观锁" class="headerlink" title="3.2乐观锁与悲观锁"></a>3.2乐观锁与悲观锁</h3><hr><ul><li>上面的故事，如果是乐观锁，小王保存价格前，会检查下价格是否被人修改过了。如果被修改过了，则重新取出的被修改后的价格，150元，这样他会将120元存入数据库。</li><li>如果是悲观锁，小李取出数据后，小王只能等小李操作完之后，才能对价格进行操作，也会保证最终的价格是120元。</li></ul><h3 id="3-3模拟修改冲突"><a href="#3-3模拟修改冲突" class="headerlink" title="3.3模拟修改冲突"></a>3.3模拟修改冲突</h3><hr><ul><li><p><strong>数据库中增加商品表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_product ( </span><br><span class="line">    id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>, </span><br><span class="line">    NAME <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品名称&#x27;</span>, </span><br><span class="line">    price <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;价格&#x27;</span>, </span><br><span class="line">    VERSION <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;乐观锁版本号&#x27;</span>, </span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id) </span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><strong>添加一条数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_product (id, NAME, price) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;外星人笔记本&#x27;</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>添加一个实体类<code>Product</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>添加一个Mapper接口<code>ProductMapper</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Product&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>测试方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProduct01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.小李获取商品价格</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productLi</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李获取的商品价格为：&quot;</span> + productLi.getPrice());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.小王获取商品价格</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productWang</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李获取的商品价格为：&quot;</span> + productWang.getPrice());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.小李修改商品价格+50</span></span><br><span class="line">    productLi.setPrice(productLi.getPrice()+<span class="number">50</span>);</span><br><span class="line">    productMapper.updateById(productLi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.小王修改商品价格-30</span></span><br><span class="line">    productWang.setPrice(productWang.getPrice()-<span class="number">30</span>);</span><br><span class="line">    productMapper.updateById(productWang);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.老板查询商品价格</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productBoss</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;老板获取的商品价格为：&quot;</span> + productBoss.getPrice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>执行结果</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220521225803162.png" alt="image-20220521225803162"></p></li></ul><h3 id="3-4乐观锁解决问题"><a href="#3-4乐观锁解决问题" class="headerlink" title="3.4乐观锁解决问题"></a>3.4乐观锁解决问题</h3><hr><ul><li><p><strong>实体类<code>version</code>字段添加注解<code>@Version</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="meta">@Version</span></span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>添加乐观锁插件配置</strong>(在配置类中添加)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    <span class="comment">//添加分页插件</span></span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">    <span class="comment">//添加乐观锁插件</span></span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>再次执行测试方法</strong></p><blockquote><p>小李查询商品信息：</p><p>​SELECT id,name,price,version FROM t_product WHERE id&#x3D;?</p><p>小王查询商品信息：</p><p>​SELECT id,name,price,version FROM t_product WHERE id&#x3D;?</p><p>小李修改商品价格，自动将version+1</p><p>​UPDATE t_product SET name&#x3D;?, price&#x3D;?, version&#x3D;? WHERE id&#x3D;? AND version&#x3D;?</p><p>​Parameters: 外星人笔记本(String), 150(Integer), 1(Integer), 1(Long), 0(Integer)</p><p>小王修改商品价格，此时version已更新，条件不成立，修改失败</p><p>​UPDATE t_product SET name&#x3D;?, price&#x3D;?, version&#x3D;? WHERE id&#x3D;? AND version&#x3D;?</p><p>​Parameters: 外星人笔记本(String), 70(Integer), 1(Integer), 1(Long), 0(Integer)</p><p>最终，小王修改失败，查询价格：150</p><p>​SELECT id,name,price,version FROM t_product WHERE id&#x3D;?</p></blockquote></li><li><p><strong>优化执行流程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProduct01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.小李获取商品价格</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productLi</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李获取的商品价格为：&quot;</span> + productLi.getPrice());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.小王获取商品价格</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productWang</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李获取的商品价格为：&quot;</span> + productWang.getPrice());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.小李修改商品价格+50</span></span><br><span class="line">    productLi.setPrice(productLi.getPrice()+<span class="number">50</span>);</span><br><span class="line">    productMapper.updateById(productLi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.小王修改商品价格-30</span></span><br><span class="line">    productWang.setPrice(productWang.getPrice()-<span class="number">30</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> productMapper.updateById(productWang);</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//操作失败，重试</span></span><br><span class="line">        <span class="type">Product</span> <span class="variable">productNew</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">        productNew.setPrice(productNew.getPrice()-<span class="number">30</span>);</span><br><span class="line">        productMapper.updateById(productNew);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.老板查询商品价格</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productBoss</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;老板获取的商品价格为：&quot;</span> + productBoss.getPrice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220521230448577.png" alt="image-20220521230448577"></p></li></ul><h1 id="七、通用枚举"><a href="#七、通用枚举" class="headerlink" title="七、通用枚举"></a>七、通用枚举</h1><blockquote><p>表中的有些字段值是固定的，例如性别（男或女），此时我们可以使用MyBatis-Plus的通用枚举来实现</p></blockquote><ul><li><p><strong>数据库表添加字段<code>sex</code></strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220521231317777.png" alt="image-20220521231317777"></p></li><li><p><strong>创建通用枚举类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SexEnum</span> &#123;</span><br><span class="line">    MALE(<span class="number">1</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">    FEMALE(<span class="number">2</span>, <span class="string">&quot;女&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EnumValue</span> <span class="comment">//将注解所标识的属性的值存储到数据库中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sex;</span><br><span class="line">    <span class="keyword">private</span> String sexName;</span><br><span class="line"></span><br><span class="line">    SexEnum(Integer sex, String sexName) &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.sexName = sexName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>User实体类中添加属性sex</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@TableField(&quot;username&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> isDeleted;  <span class="comment">//逻辑删除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SexEnum sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>配置扫描通用枚举</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#MyBatis-Plus相关配置</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="comment">#指定mapper文件所在的地址</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment">#配置日志</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">banner:</span> <span class="string">off</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment">#配置mp的主键策略为自增</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">      <span class="comment"># 设置实体类所对应的表的统一前缀</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">t_</span></span><br><span class="line">  <span class="comment">#配置类型别名所对应的包</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.atguigu.mybatisplus.pojo</span></span><br><span class="line">  <span class="comment"># 扫描通用枚举的包</span></span><br><span class="line">  <span class="attr">type-enums-package:</span> <span class="string">com.atguigu.mybatisplus.enums</span></span><br></pre></td></tr></table></figure></li><li><p><strong>执行测试方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">33</span>);</span><br><span class="line">    user.setSex(SexEnum.MALE);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insert(user);</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="八、多数据源"><a href="#八、多数据源" class="headerlink" title="八、多数据源"></a>八、多数据源</h1><blockquote><p>适用于多种场景：纯粹多库、 读写分离、 一主多从、 混合模式等</p></blockquote><p>场景说明：</p><p>我们创建两个库，分别为：<code>mybatis_plus</code>（以前的库不动）与<code>mybatis_plus_1</code>（新建），将mybatis_plus库的<code>product</code>表移动到mybatis_plus_1库，这样每个库一张表，通过一个测试用例分别获取用户数据与商品数据，如果获取到说明多库模拟成功</p><h2 id="1-创建数据库及表"><a href="#1-创建数据库及表" class="headerlink" title="1.创建数据库及表"></a>1.创建数据库及表</h2><ul><li><p><strong>创建数据库<code>mybatis_plus_1</code>和表&#96;product</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `mybatis_plus_1` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 */</span>;</span><br><span class="line">use `mybatis_plus_1`; </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> product ( </span><br><span class="line">    id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>, </span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品名称&#x27;</span>, </span><br><span class="line">    price <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;价格&#x27;</span>, </span><br><span class="line">    version <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;乐观锁版本号&#x27;</span>, </span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id) </span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><strong>添加测试数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product (id, NAME, price) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;外星人笔记本&#x27;</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>删除<code>mybatis_plus</code>库中的<code>product</code>表</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use mybatis_plus; </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> product;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-新建工程引入依赖"><a href="#2-新建工程引入依赖" class="headerlink" title="2.新建工程引入依赖"></a>2.新建工程引入依赖</h2><blockquote><p><strong>自行新建一个Spring Boot工程并选择MySQL驱动及Lombok依赖</strong></p></blockquote><p><strong>引入MyBaits-Plus的依赖及多数据源的依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dynamic-datasource-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-编写配置文件"><a href="#3-编写配置文件" class="headerlink" title="3.编写配置文件"></a>3.编写配置文件</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 配置数据源信息</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">dynamic:</span></span><br><span class="line">      <span class="comment"># 设置默认的数据源或者数据源组,默认值即为master</span></span><br><span class="line">      <span class="attr">primary:</span> <span class="string">master</span></span><br><span class="line">      <span class="comment"># 严格匹配数据源,默认false.true未匹配到指定数据源时抛异常,false使用默认数据源</span></span><br><span class="line">      <span class="attr">strict:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">master:</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="number">132537</span></span><br><span class="line">        <span class="attr">slave_1:</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus_1?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="number">132537</span></span><br></pre></td></tr></table></figure><h2 id="4-创建实体类"><a href="#4-创建实体类" class="headerlink" title="4.创建实体类"></a>4.创建实体类</h2><ul><li><p>新建一个<code>User</code>实体类（如果数据库表名有t_前缀记得配置）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建一个实体类<code>Product</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-创建Mapper及Service"><a href="#5-创建Mapper及Service" class="headerlink" title="5.创建Mapper及Service"></a>5.创建Mapper及Service</h2><ul><li><p>新建接口<code>UserMapper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建接口<code>ProductMapper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Product&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建Service接口<code>UserService</code>指定操作的数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DS(&quot;master&quot;)</span> <span class="comment">//指定操作的数据源，master为user表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建Service接口<code>ProductService</code>指定操作的数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DS(&quot;slave_1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Product&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>自行建立Service的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-编写测试方法"><a href="#6-编写测试方法" class="headerlink" title="6.编写测试方法"></a>6.编写测试方法</h2><blockquote><p><strong>记得在启动类中添加注解<code>@MapperScan()</code></strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestDatasourceApplicationTests</span> &#123;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line">UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line">ProductService productService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(<span class="number">1L</span>);</span><br><span class="line"><span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> productService.getById(<span class="number">1L</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;User = &quot;</span> + user);</span><br><span class="line">System.out.println(<span class="string">&quot;Product = &quot;</span> + product);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522113049945.png" alt="image-20220522113049945"></p><h1 id="九、MyBatisX插件"><a href="#九、MyBatisX插件" class="headerlink" title="九、MyBatisX插件"></a>九、MyBatisX插件</h1><blockquote><p>MyBatis-Plus为我们提供了强大的mapper和service模板，能够大大的提高开发效率。</p><p>但是在真正开发过程中，MyBatis-Plus并不能为我们解决所有问题，例如一些复杂的SQL，多表联查，我们就需要自己去编写代码和SQL语句，我们该如何快速的解决这个问题呢，这个时候可以使用MyBatisX插件。</p><p>MyBatisX一款基于 IDEA 的快速开发插件，为效率而生。</p></blockquote><h2 id="1-安装MyBatisX插件"><a href="#1-安装MyBatisX插件" class="headerlink" title="1.安装MyBatisX插件"></a>1.安装MyBatisX插件</h2><blockquote><p><strong>打开IDEA，File-&gt; Setteings-&gt;Plugins-&gt;MyBatisX，搜索栏搜索MyBatisX然后安装。</strong></p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522115718361.png" alt="image-20220522115718361"></p><h2 id="2-快速生成代码"><a href="#2-快速生成代码" class="headerlink" title="2.快速生成代码"></a>2.快速生成代码</h2><ul><li><p>新建一个Spring Boot项目引入依赖（创建工程时记得勾选lombok及mysql驱动）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dynamic-datasource-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置数据源信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">132537</span></span><br></pre></td></tr></table></figure></li><li><p>在IDEA中与数据库建立链接</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522120758740.png" alt="image-20220522120758740"></p></li><li><p>填写数据库信息并保存</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522121434468.png" alt="image-20220522121434468"></p></li><li><p>找到我们需要生成的表点击右键</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522121613909.png" alt="image-20220522121613909"></p></li><li><p>填写完信息以后下一步</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522122127649.png" alt="image-20220522122127649"></p></li><li><p>继续填写信息</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522122525598.png" alt="image-20220522122525598"></p></li><li><p><strong>大功告成（真特么好用yyds）</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522122612334.png" alt="image-20220522122612334"></p></li></ul><h2 id="3-快速生成CRUD"><a href="#3-快速生成CRUD" class="headerlink" title="3.快速生成CRUD"></a>3.快速生成CRUD</h2><blockquote><p>MyBaitsX可以根据我们在Mapper接口中输入的方法名快速帮我们生成对应的sql语句</p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522123143852.png" alt="image-20220522123143852"></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522123202310.png" alt="image-20220522123202310"></p><h1 id="十、致谢"><a href="#十、致谢" class="headerlink" title="十、致谢"></a>十、致谢</h1><p>感谢尚硅谷杨博超老师：<a href="https://www.bilibili.com/video/BV12R4y157Be?p=1">https://www.bilibili.com/video/BV12R4y157Be?p=1</a></p><p>感谢MyBatis-Plus作者苞米豆：<a href="https://baomidou.com/">https://baomidou.com/</a></p><p>感谢自己又坚持学习了一门课程：<a href="https://www.oz6.cn/">https://www.oz6.cn/</a></p><h1 id="代码生成器："><a href="#代码生成器：" class="headerlink" title="代码生成器："></a>代码生成器：</h1><h2 id="MyBatis-Plus-逆向程依赖："><a href="#MyBatis-Plus-逆向程依赖：" class="headerlink" title="MyBatis-Plus 逆向程依赖："></a>MyBatis-Plus 逆向程依赖：</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--MyBatis-Plus 逆向工程依赖代码生成器的核心依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 一个模板的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.freemarker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="生成代码："><a href="#生成代码：" class="headerlink" title="生成代码："></a>生成代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastAutoGeneratorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置我们需要创建在哪的路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/Users/luxiaogen/Documents/RoadTo2w/Java/尚硅谷/MyBatisPlus-2022/demo&quot;</span>;</span><br><span class="line">        <span class="comment">// 这里我是mysql8 5版本可以换成 jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">        FastAutoGenerator.create(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis_plus?serverTimezone=GMT%2B8&amp;characterEncoding=utf-8&amp;useSSL=false&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>)</span><br><span class="line">                .globalConfig(builder -&gt; &#123;</span><br><span class="line">                    builder.author(<span class="string">&quot;atguigu&quot;</span>) <span class="comment">// 设置作者</span></span><br><span class="line">                    <span class="comment">// .enableSwagger() // 开启 swagger 模式</span></span><br><span class="line">                    .fileOverride() <span class="comment">// 覆盖已生成文件</span></span><br><span class="line">                    .outputDir(path); <span class="comment">// 指定输出目录</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .packageConfig(builder -&gt; &#123;</span><br><span class="line">                    builder.parent(<span class="string">&quot;com.atguigu&quot;</span>) <span class="comment">// 设置父包名</span></span><br><span class="line">                            .moduleName(<span class="string">&quot;mybatisplus&quot;</span>) <span class="comment">// 设置父包模块名</span></span><br><span class="line">                            .pathInfo(Collections.singletonMap(OutputFile.mapperXml, path)); <span class="comment">// 设置mapperXml生成路径</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .strategyConfig(builder -&gt; &#123;</span><br><span class="line">                    builder.addInclude(<span class="string">&quot;t_user&quot;</span>) <span class="comment">// 设置需要生成的表名</span></span><br><span class="line">                            .addTablePrefix(<span class="string">&quot;t_&quot;</span>, <span class="string">&quot;c_&quot;</span>); <span class="comment">// 设置过滤表前缀</span></span><br><span class="line">                &#125;).templateEngine(<span class="keyword">new</span> <span class="title class_">FreemarkerTemplateEngine</span>()) <span class="comment">// 使用Freemarker 引擎模板，默认的是Velocity引擎模板</span></span><br><span class="line">                .execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h1><h4 id="MyBatisPlus-添加新的实体："><a href="#MyBatisPlus-添加新的实体：" class="headerlink" title="MyBatisPlus 添加新的实体："></a>MyBatisPlus 添加新的实体：</h4><p>​1.在entity包中编写实体类，添加@Date注解</p><p>​2.在mapper包中添加对应的mapper接口</p><p>​需要继承BaseMapper：extends BaseMapper&lt;实体类名&gt;</p><p>因为在需要对数据库进行实体类相应的表的查询时，我们需要用到xxMapper的实现类，</p><p>然而xxMapper是接口，没有实现类，因此我们在@Autowired定义的实现类后会报错，</p><p>因此我们需要<strong>在Mapper接口中添加@Repository注解</strong></p><p>​3.</p>]]></content>
      
      
      <categories>
          
          <category> 数据库相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis-Plus </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM探究</title>
      <link href="/2023/05/26/JVM%E6%8E%A2%E7%A9%B6/"/>
      <url>/2023/05/26/JVM%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM："><a href="#JVM：" class="headerlink" title="JVM："></a>JVM：</h1><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728164853677.png" alt="image-20230728164853677"></p><h3 id="运行过程："><a href="#运行过程：" class="headerlink" title="运行过程："></a>运行过程：</h3><p>​Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件，而字节码文件又通过 <strong>Java 虚拟机中的解释器</strong>，编译成特定机器上的机器码 。</p><p>① Java 源文件(.java)—-&gt;编译器(javac)—-&gt;字节码文件(.class)</p><p>② 字节码文件(.class)—-&gt;JVM—-&gt;机器码</p><h3 id="1-1线程"><a href="#1-1线程" class="headerlink" title="1.1线程"></a>1.1线程</h3><p>​这里所说的线程指程序执行过程中的一个线程实体。 JVM 允许一个应用并发执行多个线程。<u>Hotspot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系。</u> <strong>当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。Java 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。当线程结束时，会释放原生线程和 Java 线程的所有资源。</strong></p><h3 id="1-2JVM内存区域"><a href="#1-2JVM内存区域" class="headerlink" title="1.2JVM内存区域"></a>1.2JVM内存区域</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728184623227.png" alt="image-20230728184623227"></p><p>JVM内存区域分为：</p><ul><li>线程私有区域<ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法区</li></ul></li><li>线程共享区域（JAVA8之前）<ul><li>JAVA<strong>堆</strong></li><li>方法区<ul><li>常量池</li></ul></li></ul></li><li>直接内存</li></ul><ol><li><p><strong>线程私有数据区域生命周期与线程相同, 依赖用户线程的启动&#x2F;结束 而 创建&#x2F;销毁</strong>(在 HotspotVM 内, <u>每个线程都与操作系统的本地线程直接映射</u>, 因此这部分内存区域的存&#x2F;否跟随本地线程的生&#x2F;死对应)。</p></li><li><p><strong>线程共享区域</strong>随虚拟机的 启动&#x2F;关闭 而 创建&#x2F;销毁 </p></li><li><p><strong>直接内存</strong>并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728185217834.png" alt="image-20230728185217834"></p><h4 id="1-2-1程序计数器-线程私有"><a href="#1-2-1程序计数器-线程私有" class="headerlink" title="1.2.1程序计数器(线程私有)"></a>1.2.1程序计数器(线程私有)</h4><ul><li>一块较小的内存空间, 是<strong>当前线程所执行的字节码的行号指示器</strong>，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有” 的内存。</li><li>正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果还是 Native 方法，则为空。</li></ul><h4 id="1-2-2虚拟机栈-线程私有"><a href="#1-2-2虚拟机栈-线程私有" class="headerlink" title="1.2.2虚拟机栈(线程私有)"></a>1.2.2虚拟机栈(线程私有)</h4><p>​是<strong>描述java<u>方法</u>执行的内存模型</strong>，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于<u>存储局部变量表、操作数栈、动态链接、方法出口</u>等信息。 每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><h4 id="1-2-3本地方法区-线程私有"><a href="#1-2-3本地方法区-线程私有" class="headerlink" title="1.2.3本地方法区(线程私有)"></a>1.2.3本地方法区(线程私有)</h4><p>​本地方法区和 虚拟机栈 作用类似, 区别是<strong>虚拟机栈为执行 Java 方法服务, 而本地方法栈则为Native 方法服务</strong>, 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用, 那么该栈将会是一个C 栈，但 <u>HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一</u>。</p><h4 id="1-2-4-堆（Heap-线程共享）-运行时数据区"><a href="#1-2-4-堆（Heap-线程共享）-运行时数据区" class="headerlink" title="1.2.4. 堆（Heap-线程共享）-运行时数据区"></a>1.2.4. 堆（Heap-线程共享）-运行时数据区</h4><p>​是被线程共享的一块内存区域， <strong>创建的<u>对象和数组</u>都保存在 Java 堆内存中</strong>，也是<strong>垃圾收集器进行垃圾收集</strong>的最重要的内存区域。 由于现代 VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、 From Survivor 区和 To Survivor 区)和老年代。</p><h4 id="1-2-5-方法区-x2F-永久代（线程共享）"><a href="#1-2-5-方法区-x2F-永久代（线程共享）" class="headerlink" title="1.2.5. 方法区&#x2F;永久代（线程共享）"></a>1.2.5. 方法区&#x2F;永久代（线程共享）</h4><p>​即我们常说的永久代(Permanent Generation), 用于存储被 JVM 加载的<strong>类信息、 常量、 静态变量、 即时编译器编译后的代码</strong>等数据. </p><p>​HotSpot VM把GC分代收集扩展至方法区, 即使用Java堆的永久代来实现方法区, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存,而不必为方法区开发专门的内存管理器(永久代的内存回收的主要目标是针对<u><strong>常量池的回收和类型的卸载</strong></u>, 因此收益一般很小)。</p><p>​运行时**<u>常量池</u><strong>（Runtime Constant Pool）是方法区的一部分。 Class 文件中除了有</strong>类的版本、字段、方法、接口等描述等信息**外，还有一项信息是常量池（Constant Pool Table），用于<u>存放编译期生成的各种字面量和符号引用</u>，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java 虚拟机对 Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。</p><h3 id="1-3-JVM-运行时内存"><a href="#1-3-JVM-运行时内存" class="headerlink" title="1.3 JVM 运行时内存"></a>1.3 JVM 运行时内存</h3><p>java堆可以细分为</p><ul><li><p><em>新生代</em>——用于存放新生的对象，<strong>一般占据1&#x2F;3堆空间</strong>，由于频繁创建对象，所以<strong>新生代会频繁触发MinorGC 进行垃圾回收</strong>，新生代细分为以下三个区域：</p><ul><li><p><strong>Eden区</strong>：<strong>Java 新对象的出生地</strong>（如果新创建的对象占用内存很大，则直接分配到老年代）。<u>当 Eden 区内存不够的时候就会触发 MinorGC，对<strong>新生代区</strong>进行一次垃圾回收。</u></p></li><li><p><strong>ServivorFrom区</strong>：上一次 GC 的幸存者，作为这一次 GC 的被扫描者。</p></li><li><p><strong>ServivorTo区</strong>：<u>保留</u>了一次 MinorGC 过程中的<u>幸存者</u></p><ul><li><p>MinorGC 的过程（复制-&gt;清空-&gt;互换）MinorGC 采用<strong>复制算法</strong>。</p><ul><li><p>1： eden、 servicorFrom 复制到 ServicorTo，年龄+1。<br>首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（<u>如果有对象的年龄以及达到了老年的标准，则赋值到老年代区</u>），同时把这些对象的年龄+1（<u>如果 ServicorTo 不够位置了就放到老年区</u>）；</p></li><li><p>2： 清空 eden、 servicorFrom</p><p>​然后，清空 Eden 和 ServicorFrom 中的对象；</p></li><li><p>3： ServicorTo 和 ServicorFrom 互换</p><p>​最后， ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区。</p></li></ul></li></ul></li></ul></li><li><p><em>老年代</em></p></li></ul><p>​<strong>主要存放应用程序中生命周期长的内存对象。</strong></p><p>​老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。<strong>当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间</strong>。</p><p>​MajorGC 采用<strong>标记清除算法</strong>：首先扫描一次所有老年代，<u>标记出存活的对象，然后回收没有标记的对象</u>。 MajorGC 的耗时比较长，因为要扫描再回收。 MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。</p><ul><li>!!!<em>永久代</em></li></ul><p>​指内存的永久保存区域，主要存放 <strong>Class 和 Meta（元数据）</strong>的信息,<u>Class 在被加载的时候被放入永久区域， 它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理。</u>所以这也导致了<u>永久代的区域会随着加载的 Class 的增多而胀满，最</u>终抛出 OOM 异常。</p><p>！！！在JDK 1.8 的时候，<code>HotSpot</code>的永久代被彻底移除 ，被一个称为“元数据区”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于： <strong>元空间并不在虚拟机中，而是使用本地内存。</strong>因此，<u>默认情况下，元空间的大小仅受本地内存限制。 类的元数据放入 nativememory, 字符串池和类的静态变量放入 java 堆中， 这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制。</u></p><h3 id="面试题：说一下堆栈的区别？"><a href="#面试题：说一下堆栈的区别？" class="headerlink" title="面试题：说一下堆栈的区别？"></a>面试题：说一下堆栈的区别？</h3><ol><li>**<u>堆的物理地址分配是不连续的，性能较慢</u>**；栈的物理地址分配是连续的，性能相对较快。</li><li>堆存放的是对象的实例和数组；栈存放的是局部变量，操作数栈，返回结果等。</li><li>堆是线程共享的；栈是线程私有的。</li></ol><h3 id="🌟JAVA8及以后，JVM内存分布："><a href="#🌟JAVA8及以后，JVM内存分布：" class="headerlink" title="🌟JAVA8及以后，JVM内存分布："></a>🌟JAVA8及以后，JVM内存分布：</h3><p>![image-20230821101241186](&#x2F;Users&#x2F;donn&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230821101241186.png)</p><h3 id="面试题：Java-中-OutOfMemoryError和StackOverFlowError的区别？"><a href="#面试题：Java-中-OutOfMemoryError和StackOverFlowError的区别？" class="headerlink" title="面试题：Java 中 OutOfMemoryError和StackOverFlowError的区别？"></a>面试题：Java 中 OutOfMemoryError和StackOverFlowError的区别？</h3><ul><li><p>OutOfMemoryError（内存溢出错误）：当Java程序在运行过程中无法分配足够的内存空间时，就会抛出OutOfMemoryError。这种情况通常发生在创建过多的对象、持续大量的递归调用或者内存泄漏等情况下。如果系统中有大量的对象无法及时被垃圾回收器回收释放，就可能导致内存耗尽，从而触发OutOfMemoryError。</p></li><li><p>StackOverFlowError（栈溢出错误）：当一个线程的方法调用堆栈超出了栈的最大深度限制时，就会抛出StackOverFlowError。这种情况通常发生在方法递归调用过多或者死循环嵌套等情况下。当方法调用的层级过深，栈空间被耗尽，就会触发StackOverFlowError。</p></li></ul><p>总结起来，<strong>OutOfMemoryError指的是程序无法分配到足够的 <em>堆内存</em> 空间</strong>，而StackOverFlowError则是指方法调用链过于深入导致**<u>栈空间溢出</u>**。两者的触发条件和原因不同，但都提示了Java程序在内存管理或方法调用方面出现了问题，并且在处理上需要考虑相应的调整和优化。</p><h3 id="1-4垃圾回收与算法"><a href="#1-4垃圾回收与算法" class="headerlink" title="1.4垃圾回收与算法"></a>1.4垃圾回收与算法</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729200359311.png" alt="image-20230729200359311"></p><h4 id="1-4-1如何确定垃圾"><a href="#1-4-1如何确定垃圾" class="headerlink" title="1.4.1如何确定垃圾"></a>1.4.1如何确定垃圾</h4><h5 id="1-4-1-1引用计数法"><a href="#1-4-1-1引用计数法" class="headerlink" title="1.4.1.1引用计数法"></a>1.4.1.1引用计数法</h5><p>​一个对象如果没有任何与之关联的引用， 即他们的引用计数都为 0， 则说明对象不太可能再被用到，那么这个对象就是可回收对象。</p><h5 id="1-4-1-2-可达性分析"><a href="#1-4-1-2-可达性分析" class="headerlink" title="1.4.1.2. 可达性分析"></a>1.4.1.2. 可达性分析</h5><p>为了解决引用计数法的循环引用问题， Java 使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。</p><p><strong><u>GC Roots 是一组必须活跃的引用。用通俗的话来说，就是程序接下来通过直接引用或者间接引用，能够访问到的潜在被使用的对象。</u></strong></p><p>要注意的是，不可达对象不等价于可回收对象， 不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。</p><h4 id="1-4-2垃圾回收算法"><a href="#1-4-2垃圾回收算法" class="headerlink" title="1.4.2垃圾回收算法"></a>1.4.2垃圾回收算法</h4><h5 id="1-4-2-1-标记-清除算法（Mark-Sweep）"><a href="#1-4-2-1-标记-清除算法（Mark-Sweep）" class="headerlink" title="1.4.2.1 标记-清除算法（Mark-Sweep）"></a>1.4.2.1 标记-清除算法（Mark-Sweep）</h5><p>最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。如图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729204014222.png" alt="image-20230729204014222" style="zoom:55%;" /><p>从图中我们就可以发现，该算法最大的问题是<strong>内存碎片化严重</strong>，后续可能发生大对象不能找到可利用空间的问题。</p><h5 id="1-4-2-2-复制算法（copying）"><a href="#1-4-2-2-复制算法（copying）" class="headerlink" title="1.4.2.2 复制算法（copying）"></a>1.4.2.2 复制算法（copying）</h5><p>为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。<strong>按内存容量将内存划分为等大小的两块</strong>。每次只使用其中一块，<u><strong>当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉</strong></u>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729204457458.png" alt="image-20230729204457458"></p><p>这种算法虽然<u>实现简单，内存效率高，不易产生碎片</u>，但是最大的问题是**<u>可用内存被压缩到了原本的一半</u>**。且存活对象增多的话， Copying 算法的效率会大大降低。</p><h5 id="1-4-2-3-标记整理算法-Mark-Compact"><a href="#1-4-2-3-标记整理算法-Mark-Compact" class="headerlink" title="1.4.2.3 标记整理算法(Mark-Compact)"></a>1.4.2.3 标记整理算法(Mark-Compact)</h5><p>​结合了以上两个算法，为了避免缺陷而提出。<strong>标记阶段和 Mark-Sweep 算法相同， 标记后不是清理对象，而是将存活对象移向内存的一端。</strong>然后清除端边界外的对象。如图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729204701947.png" alt="image-20230729204701947"></p><h5 id="1-4-2-4-🌟分代收集算法"><a href="#1-4-2-4-🌟分代收集算法" class="headerlink" title="1.4.2.4 🌟分代收集算法"></a>1.4.2.4 🌟分代收集算法</h5><p>——根据对象销毁频率特点进行分区，各个分区采用合适的算法</p><p>分代收集法是目前大部分 JVM 所采用的方法，其核心思想是<strong>根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured&#x2F;Old Generation)和新生代(YoungGeneration)。</strong><u>老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。</u></p><h4 id="1-4-3如今广泛采用的回收方法："><a href="#1-4-3如今广泛采用的回收方法：" class="headerlink" title="1.4.3如今广泛采用的回收方法："></a>1.4.3如今广泛采用的回收方法：</h4><ul><li><strong>新生代与复制算法</strong></li></ul><p>​目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中<u>每次垃圾回收都要回收大部分对象</u>，即要复制的操作比较少，但通常并不是按照 1： 1 来划分新生代。一般将新生代划分为一块较大的 Eden空间(<strong>存放新创建的对象</strong>) 和两个较小的 Survivor 空间(From Space, To Space，存放存活对象)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。</p><ul><li><strong>老年代与标记复制算法</strong></li></ul><p>​而老年代因为每次只回收少量对象，因而采用 <strong>Mark-Compact(标记整理)</strong> 算法。</p><h4 id="1-4-4-🌟垃圾回收方法总结：！！！！！"><a href="#1-4-4-🌟垃圾回收方法总结：！！！！！" class="headerlink" title="1.4.4 🌟垃圾回收方法总结：！！！！！"></a>1.4.4 🌟垃圾回收方法总结：！！！！！</h4><ol><li>JAVA 虚拟机提到过的处于方法区的永生代(Permanet Generation)， 它用来存储 class 类，常量，方法描述等。<strong>对永生代的回收主要包括废弃常量和无用的类</strong>。</li><li>对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor 目前存放对象的那一块)，少数情况会直接分配到老生代(对象过大， To Space 区装不下)。</li><li><strong>当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC</strong>，进行 GC 后， EdenSpace 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 FromSpace 进行清理。</li><li>如果 To Space 无法足够存储某个对象(太大)，则将<u>这个对象存储到老生代</u>。</li><li>在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。</li><li>当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。 <strong>默认情况下<u>年龄到达 15 的对象会被移到老生代中</u>。</strong></li></ol><h3 id="1-5-JAVA中-四种引用类型"><a href="#1-5-JAVA中-四种引用类型" class="headerlink" title="1.5 JAVA中 四种引用类型"></a>1.5 JAVA中 四种引用类型</h3><h4 id="1-5-1-强引用"><a href="#1-5-1-强引用" class="headerlink" title="1.5.1. 强引用"></a>1.5.1. 强引用</h4><p>在 Java 中最常见的就是强引用， 把一个对象赋给一个引用变量，这个引用变量就是一个强引用。<u>当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收</u>的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。</p><h4 id="1-5-2-软引用"><a href="#1-5-2-软引用" class="headerlink" title="1.5.2. 软引用"></a>1.5.2. 软引用</h4><p>软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，<u>当系统内存空间不足时它会被回收</u>。软引用通常用在对内存敏感的程序中。</p><h4 id="1-5-3-弱引用"><a href="#1-5-3-弱引用" class="headerlink" title="1.5.3. 弱引用"></a>1.5.3. 弱引用</h4><p>弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，<u>只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。</u></p><h4 id="1-5-4-虚引用"><a href="#1-5-4-虚引用" class="headerlink" title="1.5.4. 虚引用"></a>1.5.4. 虚引用</h4><p>虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。 虚引用的主要作用是<u>跟踪对象被垃圾回收的状态</u>。</p><h3 id="1-6-GC-分代收集算法-VS-分区收集算法"><a href="#1-6-GC-分代收集算法-VS-分区收集算法" class="headerlink" title="1.6.GC 分代收集算法 VS 分区收集算法"></a>1.6.GC 分代收集算法 VS 分区收集算法</h3><h4 id="1-6-1-分代收集算法-1-4-2-4中提到过，只做介绍，分析请看前文"><a href="#1-6-1-分代收集算法-1-4-2-4中提到过，只做介绍，分析请看前文" class="headerlink" title="1.6.1. 分代收集算法(1.4.2.4中提到过，只做介绍，分析请看前文)"></a>1.6.1. 分代收集算法(1.4.2.4中提到过，只做介绍，分析请看前文)</h4><p>​当前主流 VM 垃圾收集都采用”分代收集” (Generational Collection)算法, 这种算法会根据对象存活周期的不同将内存划分为几块, 如 JVM 中的 新生代、老年代、永久代， 这样就可以根据各年代特点分别采用最适当的 GC 算法</p><h5 id="1-6-1-1-在新生代-复制算法"><a href="#1-6-1-1-在新生代-复制算法" class="headerlink" title="1.6.1.1. 在新生代-复制算法"></a>1.6.1.1. 在新生代-复制算法</h5><p>​每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集.</p><h5 id="1-6-1-2-在老年代-标记整理算法"><a href="#1-6-1-2-在老年代-标记整理算法" class="headerlink" title="1.6.1.2. 在老年代-标记整理算法"></a>1.6.1.2. 在老年代-标记整理算法</h5><p>​因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标记—整理” 算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存.</p><h4 id="1-6-2-分区收集算法"><a href="#1-6-2-分区收集算法" class="headerlink" title="1.6.2. 分区收集算法"></a>1.6.2. 分区收集算法</h4><h5 id="分区收集算法产生背景："><a href="#分区收集算法产生背景：" class="headerlink" title="分区收集算法产生背景："></a>分区收集算法产生背景：</h5><p>在垃圾回收过程中，应用软件将处于一种Stop the World 的状态。在Stop the Word 状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成，如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。</p><p>​分区算法则<u>将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收</u>.减少应用程序被挂起的时间 </p><p>​这样做的好处是可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是整个堆), 从而减少一次 GC 所产生的停顿。</p><p>由于分块进行垃圾回收，会导致额外的管理开销。</p><h3 id="1-7-GC-垃圾收集器"><a href="#1-7-GC-垃圾收集器" class="headerlink" title="1.7.GC 垃圾收集器"></a>1.7.GC 垃圾收集器</h3><p>java 虚拟中针对新生代和年老代分别提供了多种不同的垃圾收集器， JDK1.6 中 Sun HotSpot 虚拟机的垃圾收集器如下：</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730161121359.png" alt="image-20230730161121359" style="zoom: 40%;" /><h4 id="1-7-1-Serial-垃圾收集器（单线程、-复制算法）"><a href="#1-7-1-Serial-垃圾收集器（单线程、-复制算法）" class="headerlink" title="1.7.1. Serial 垃圾收集器（单线程、 复制算法）"></a>1.7.1. Serial 垃圾收集器（单线程、 复制算法）</h4><p>​Serial 是最基本垃圾收集器，使用复制算法，曾经是JDK1.3.1 之前新生代唯一的垃圾收集器。 Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，<u>对于限定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率</u>，因此 Serial垃圾收集器依然是 <u>java 虚拟机运行在 <strong>Client 模式</strong>下默认的新生代垃圾收集器。</u></p><h4 id="1-7-2-ParNew-垃圾收集器（Serial-多线程）"><a href="#1-7-2-ParNew-垃圾收集器（Serial-多线程）" class="headerlink" title="1.7.2. ParNew 垃圾收集器（Serial+多线程）"></a>1.7.2. ParNew 垃圾收集器（Serial+多线程）</h4><p>​ParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了<strong>使用多线程进行垃圾收集之外</strong>，其余的行为和 Serial 收集器完全一样， ParNew 垃圾收集器在垃圾收集过程中<u>同样也要暂停<strong>所有</strong>其他的工作线程。</u></p><p>​ParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过-XX:ParallelGCThreads 参数来限制垃圾收集器的线程数。ParNew 虽然是除了多线程外和Serial 收集器几乎完全一样，但是ParNew垃圾收集器是很多 java虚拟机运行在 <u><strong>Server 模式</strong>下新生代的默认垃圾收集器。</u></p><h4 id="1-7-3-Parallel-Scavenge-收集器（多线程复制算法、高效）"><a href="#1-7-3-Parallel-Scavenge-收集器（多线程复制算法、高效）" class="headerlink" title="1.7.3. Parallel Scavenge 收集器（多线程复制算法、高效）"></a>1.7.3. Parallel Scavenge 收集器（多线程复制算法、高效）</h4><p>​Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器， 它重点关注的是程序达到一个可控制的吞吐量（Thoughput， CPU 用于运行用户代码的时间&#x2F;CPU 总消耗时间，即吞吐量&#x3D;运行用户代码时间&#x2F;(运行用户代码时间+垃圾收集时间)），<strong>高吞吐量</strong>可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要<u>适用于在后台运算而不需要太多交互的任务</u>。 自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个重要区别。</p><h4 id="1-7-4-Serial-Old-收集器（单线程标记整理算法-）"><a href="#1-7-4-Serial-Old-收集器（单线程标记整理算法-）" class="headerlink" title="1.7.4. Serial Old 收集器（单线程标记整理算法 ）"></a>1.7.4. Serial Old 收集器（单线程标记整理算法 ）</h4><p>​Serial Old 是 <strong>Serial 垃圾收集器年老代版本</strong>，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在 <u>Client端</u> 默认的 java 虚拟机默认的年老代垃圾收集器。</p><h4 id="1-7-5-Parallel-Old-收集器（多线程标记整理算法）"><a href="#1-7-5-Parallel-Old-收集器（多线程标记整理算法）" class="headerlink" title="1.7.5. Parallel Old 收集器（多线程标记整理算法）"></a>1.7.5. Parallel Old 收集器（多线程标记整理算法）</h4><p>​Parallel Old 收集器是<strong>Parallel Scavenge的年老代版本</strong>，使用多线程的标记-整理算法，在 JDK1.6才开始提供。在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量， Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器， <u>如果系统对吞吐量要求比较高，可以优先考虑新生代 Parallel Scavenge和年老代 Parallel Old 收集器的搭配策略。</u></p><h4 id="1-7-6-CMS-收集器（多线程标记清除算法）"><a href="#1-7-6-CMS-收集器（多线程标记清除算法）" class="headerlink" title="1.7.6. CMS 收集器（多线程标记清除算法）"></a>1.7.6. CMS 收集器（多线程标记清除算法）</h4><p>Concurrent mark sweep(CMS)收集器是一种<strong>年老代垃圾收集器</strong>，其最主要目标是获取<u>最短垃圾回收停顿时间</u>， 和其他年老代使用标记-整理算法不同，它<u>使用多线程的标记-清除算法</u>。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段：</p><h5 id="1-7-6-1-初始标记"><a href="#1-7-6-1-初始标记" class="headerlink" title="1.7.6.1. 初始标记"></a>1.7.6.1. 初始标记</h5><p>​只是标记一下 GC Roots <u>能直接关联的对象</u>，速度很快，仍然<u>需要暂停所有的工作线程</u>。</p><h5 id="1-7-6-2-并发标记"><a href="#1-7-6-2-并发标记" class="headerlink" title="1.7.6.2. 并发标记"></a>1.7.6.2. 并发标记</h5><p>​进行 GC Roots 跟踪的过程，和用户线程一起工作，<u>不需要暂停工作线程</u>。</p><h5 id="1-7-6-3-重新标记"><a href="#1-7-6-3-重新标记" class="headerlink" title="1.7.6.3. 重新标记"></a>1.7.6.3. 重新标记</h5><p>​为了<u>修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录</u>，仍然<u>需要暂停所有的工作线程</u>。</p><h5 id="1-7-6-4-并发清除"><a href="#1-7-6-4-并发清除" class="headerlink" title="1.7.6.4. 并发清除"></a>1.7.6.4. 并发清除</h5><p>​清除 GC Roots 不可达对象，和用户线程一起工作，<u>不需要暂停工作线程</u>。**<u>由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作， 所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。</u>**</p><h4 id="1-7-7-G1-收集器"><a href="#1-7-7-G1-收集器" class="headerlink" title="1.7.7. G1 收集器"></a>1.7.7. G1 收集器</h4><p>—CMS收集器的升级版</p><p>Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器， G1 收集器两个最突出的改进是：</p><p>​<strong>基于标记-整理算法，不产生内存碎片。</strong></p><ol><li>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。G1 收集器避免全区域垃圾收集，它<u>把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间， 优先回收垃圾最多的区域。</u></li><li>区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率</li></ol><p>————————————</p><p>G1垃圾收集器的目标是在不同应用场景中追求高吞吐量和低停顿之间的最佳平衡。</p><p>G1将整个堆分成相同大小的分区（<code>Region</code>），有四种不同类型的分区：<code>Eden、Survivor、Old和Humongous</code>。分区的大小取值范围为 1M 到 32M，都是2的幂次方。分区大小可以通过<code>-XX:G1HeapRegionSize</code>参数指定。<code>Humongous</code>区域用于存储大对象。G1规定只要大小超过了一个分区容量一半的对象就认为是大对象。</p><p>G1 收集器对各个分区回收所获得的空间大小和回收所需时间的经验值进行排序，得到一个优先级列表，每次根据用户设置的最大回收停顿时间，优先回收价值最大的分区。</p><p>特点：可以由用户指定期望的垃圾收集停顿时间。</p><p>G1 收集器的回收过程分为以下几个步骤：</p><ul><li>初始标记。暂停所有其他线程，记录直接与 <code>GC Roots</code> 直接相连的对象，耗时较短 。</li><li>并发标记。从<code>GC Roots</code>开始对堆中对象进行可达性分析，找出要回收的对象，耗时较长，不过可以和用户程序并发执行。</li><li>最终标记。需对其他线程做短暂的暂停，用于处理并发标记阶段对象引用出现变动的区域。</li><li>筛选回收。对各个分区的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，然后把决定回收的分区的存活对象复制到空的分区中，再清理掉整个旧的分区的全部空间。这里的操作涉及存活对象的移动，会暂停用户线程，由多条收集器线程并行完成。</li></ul><h3 id="1-8-JAVA-IO-x2F-NIO"><a href="#1-8-JAVA-IO-x2F-NIO" class="headerlink" title="1.8. JAVA IO&#x2F;NIO"></a>1.8. JAVA IO&#x2F;NIO</h3><h4 id="1-8-1常见I-x2F-O模型"><a href="#1-8-1常见I-x2F-O模型" class="headerlink" title="1.8.1常见I&#x2F;O模型"></a>1.8.1常见I&#x2F;O模型</h4><h5 id="1-8-1-1-阻塞-IO-模型"><a href="#1-8-1-1-阻塞-IO-模型" class="headerlink" title="1.8.1.1 阻塞 IO 模型"></a>1.8.1.1 阻塞 IO 模型</h5><p>​最传统的一种 IO 模型，即<u>在读写数据过程中会发生阻塞现象</u>。当用户线程发出 IO 请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除 block 状态。典型的阻塞 IO 模型的例子为： data &#x3D; socket.read();如果数据没有就绪，就会一直阻塞在 read 方法。</p><p>——用户线程得不到数据就会阻塞(放弃CPU)，直到数据就绪</p><h5 id="1-8-1-2-非阻塞-IO-模型"><a href="#1-8-1-2-非阻塞-IO-模型" class="headerlink" title="1.8.1.2. 非阻塞 IO 模型"></a>1.8.1.2. 非阻塞 IO 模型</h5><p>​当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。 如果结果是一个error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。所以事实上，<u>在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO不会交出 CPU，而会一直占用 CPU</u>。 典型的非阻塞 IO 模型一般如下：</p><p>——用户线程得不到数据会一直询问(一直占用CPU)，直到获取数据</p><p>⚠️非阻塞IO在获取不到数据时会不断询问，导致CPU占用率很高</p><h5 id="1-8-1-3-多路复用-IO-模型"><a href="#1-8-1-3-多路复用-IO-模型" class="headerlink" title="1.8.1.3. 多路复用 IO 模型"></a>1.8.1.3. 多路复用 IO 模型</h5><p>​多路复用 IO 模型是目前使用得比较多的模型。 Java NIO 实际上就是多路复用 IO。<br>​在多路复用 IO模型中，<u>会有一个线程不断去轮询多个 socket 的状态</u>，只有当 socket 真正有读写事件时，才真正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。在 Java NIO 中，是通过 selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。<u>多路复用 IO 模式，通过一个线程就可以管理多个 socket，只有当socket 真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用 IO 比较适合连接数比较多的情况。</u></p><p>⚠️多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用 IO 模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</p><h5 id="1-8-1-4-信号驱动-IO-模型"><a href="#1-8-1-4-信号驱动-IO-模型" class="headerlink" title="1.8.1.4. 信号驱动 IO 模型"></a>1.8.1.4. 信号驱动 IO 模型</h5><p>​在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会<u>给对应的 socket 注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程</u>，用户线程接收到信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。</p><p>⚠️信号是告诉你数据已经好了，用户线程自己来调用</p><h5 id="1-8-1-5-异步-IO-模型"><a href="#1-8-1-5-异步-IO-模型" class="headerlink" title="1.8.1.5. 异步 IO 模型"></a>1.8.1.5. 异步 IO 模型</h5><p>​异步 IO 模型才是<u>最理想</u>的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后，它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它 read 操作完成了。也就说用户线程完全不需要实际的整个 IO 操作是如何进行的， 只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接去使用数据了。</p><p>​也就说在异步 IO 模型中， IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用 IO 函数进行实际的读写操作；而<u><strong>在异步 IO 模型中，收到信号表示 IO 操作已经完成，不需要再在用户线程中调用 IO 函数进行实际的读写操作。</strong></u></p><p>⚠️内核帮你读了数据并且复制给你了，你什么不被耽误就收到了数据！</p><h4 id="1-8-2-Java-NIO"><a href="#1-8-2-Java-NIO" class="headerlink" title="1.8.2.Java NIO"></a>1.8.2.Java NIO</h4><p>NIO 主要有三大核心部分： <strong>Channel(通道)， Buffer(缓冲区), Selector</strong>。*<u>传统 IO 基于字节流和字符流进行操作</u>*， 而 NIO 基于 Channel 和 Buffer(缓冲区)进行操作，<u>数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中</u>。 Selector(选择区)用于<u>监听多个通道的事件（比如：连接打开，数据到达）</u>。因此，单个线程可以监听多个数据通道。</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731140704880.png" alt="image-20230731140704880" style="zoom:50%;" /><p>🌟NIO 和传统 IO 之间第一个最大的区别是， IO 是面向流的， NIO 是面向缓冲区的。</p><h5 id="1-8-2-1-NIO-的缓冲区"><a href="#1-8-2-1-NIO-的缓冲区" class="headerlink" title="1.8.2.1. NIO 的缓冲区"></a>1.8.2.1. NIO 的缓冲区</h5><p>​Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，<u>它们没有被缓存在任何地方</u>。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据， 需要先将它缓存到一个缓冲区。 NIO 的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查该缓冲区中是否包含您需要处理的数据。而且需确保当更多的数据读入缓冲区时，不能覆盖缓冲区里尚未处理的数据。</p><h5 id="1-8-2-2-NIO-的非阻塞"><a href="#1-8-2-2-NIO-的非阻塞" class="headerlink" title="1.8.2.2. NIO 的非阻塞"></a>1.8.2.2. NIO 的非阻塞</h5><p>​IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是<u>它仅能得到目前可用的数据</u>，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，<u>所以直至数据变的可以读取之前，该线程可以继续做其他的事情</u>。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但<u>不需要等待它完全写入，这个线程同时可以去做别的事情</u>。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p><h5 id="1-8-2-3-Channel"><a href="#1-8-2-3-Channel" class="headerlink" title="1.8.2.3. Channel"></a>1.8.2.3. Channel</h5><p>首先说一下 Channel，国内大多翻译成“通道”。 Channel 和 IO 中的 Stream(流)是差不多一个等级的。 只不过 Stream 是单向的，譬如： InputStream, OutputStream， 而 <u>Channel 是双向的，既可以用来进行读操作，又可以用来进行写操作</u>。</p><p>NIO 中的 Channel 的主要实现有：</p><ol><li><p>FileChannel</p></li><li><p>DatagramChannel</p></li><li><p>SocketChannel</p></li><li><p>ServerSocketChannel</p></li></ol><p>这里看名字就可以猜出个所以然来：分别可以对应文件 IO、 UDP 和 TCP（Server 和 Client）。</p><h5 id="1-8-2-4-Buffer"><a href="#1-8-2-4-Buffer" class="headerlink" title="1.8.2.4. Buffer"></a>1.8.2.4. Buffer</h5><p>Buffer，故名思意， 缓冲区，实际上是一个容器，是一个连续数组。 Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731141618555.png" alt="image-20230731141618555" style="zoom:40%;" /><h5 id="1-8-2-5-Selector"><a href="#1-8-2-5-Selector" class="headerlink" title="1.8.2.5. Selector"></a>1.8.2.5. Selector</h5><p>​Selector 类是 NIO 的核心类， <u>Selector 能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理</u>。这样一来，只是用一个单线程就可以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。</p><h3 id="1-9-JVM-类加载机制"><a href="#1-9-JVM-类加载机制" class="headerlink" title="1.9.JVM 类加载机制"></a>1.9.JVM 类加载机制</h3><p>JVM 类<u>加载机制</u>分为五个部分：<strong>加载，验证，准备，解析，初始化</strong>，下面我们就分别来看一下这五个过程。</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731230933568.png" alt="image-20230731230933568"></p><h4 id="1-9-1-加载"><a href="#1-9-1-加载" class="headerlink" title="1.9.1. 加载"></a>1.9.1. 加载</h4><p>加载阶段会做3件事情：</p><ul><li><u>通过一个类的全限定名来获取定义此类的二进制字节流。</u></li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li><u><strong>在Java堆中生成一个代表这个类的java.lang.Class对象</strong></u>，作为对方法区中这些数据的访问入口。</li></ul><p>​注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。</p><h4 id="1-9-2-验证"><a href="#1-9-2-验证" class="headerlink" title="1.9.2. 验证"></a>1.9.2. 验证</h4><p>这一阶段的主要目的是为了<u>确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</u></p><h4 id="1-9-3-准备"><a href="#1-9-3-准备" class="headerlink" title="1.9.3. 准备"></a>1.9.3. 准备</h4><p><strong><u>–静态变量初始化为0、null等默认值，只有final修饰的变量在此阶段就能被赋予给定的值</u></strong></p><p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即**<u>在方法区中</u>**分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br></pre></td></tr></table></figure><p>实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080， 将 v 赋值为 8080 的 put static 指令是程序被编译后， 存放于类构造器<client>方法之中。</p><p>⚠️但是注意如果声明为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br></pre></td></tr></table></figure><p>在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v赋值为 8080。</p><h4 id="1-9-4-解析"><a href="#1-9-4-解析" class="headerlink" title="1.9.4. 解析"></a>1.9.4. 解析</h4><p>——在内存中实实在在地为变量分配内存空间</p><p>解析阶段是指虚拟机<u>将常量池中的<strong>符号引用</strong>替换为<strong>直接引用</strong></u>的过程。符号引用就是 class 文件中的：</p><ol><li><p>CONSTANT_Class_info</p></li><li><p>CONSTANT_Field_info</p></li><li><p>CONSTANT_Method_info     等类型的常量</p></li></ol><h5 id="1-9-4-1-符号引用"><a href="#1-9-4-1-符号引用" class="headerlink" title="1.9.4.1. 符号引用"></a>1.9.4.1. 符号引用</h5><ul><li>符号引用与虚拟机实现的布局无关， <strong>引用的目标并不一定要已经加载到内存中</strong>。 <u>各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的</u>，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。</li></ul><h5 id="1-9-4-2-直接引用"><a href="#1-9-4-2-直接引用" class="headerlink" title="1.9.4.2. 直接引用"></a>1.9.4.2. 直接引用</h5><ul><li>直接引用可以是<u>指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄</u>。如果有了直接引用，那<strong>引用的目标必定已经在内存中存在。</strong></li></ul><h4 id="1-9-5-初始化"><a href="#1-9-5-初始化" class="headerlink" title="1.9.5. 初始化"></a>1.9.5. 初始化</h4><p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。</p><h5 id="1-9-5-1-类构造器-lt-c-l-i-e-n-t-gt"><a href="#1-9-5-1-类构造器-lt-c-l-i-e-n-t-gt" class="headerlink" title="1.9.5.1 类构造器 &lt; c l i e n t &gt;"></a>1.9.5.1 类构造器 &lt; c l i e n t &gt;</h5><p>​🌟初始化阶段是<u>执行类构造器<client>方法</u>的过程。 <client>方法是由编译器自动<em><strong>收集类中的类变量的赋值操作</strong></em>和<em><strong>静态语句块中的语句</strong></em>合并而成的。虚拟机会保证子<client>方法执行之前，父类的<client>方法已经执行完毕， <u>如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<client>()方法。</u></p><h5 id="⚠️注意以下几种情况不会执行类初始化："><a href="#⚠️注意以下几种情况不会执行类初始化：" class="headerlink" title="⚠️注意以下几种情况不会执行类初始化："></a>⚠️注意以下几种情况<u>不会</u>执行类初始化：</h5><ol><li><u><em>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</em></u></li><li><u><em>定义对象数组，不会触发该类的初始化。</em></u></li><li><u><em>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。</em></u></li><li><u><em>通过类名获取 Class 对象，不会触发类的初始化。</em></u></li><li><u><em>通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。</em></u></li><li><u><em>通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。</em></u></li></ol><h5 id="1-9-5-2-类加载器"><a href="#1-9-5-2-类加载器" class="headerlink" title="1.9.5.2 类加载器"></a>1.9.5.2 类加载器</h5><h6 id="1-9-5-2-1-启动类加载器-Bootstrap-ClassLoader"><a href="#1-9-5-2-1-启动类加载器-Bootstrap-ClassLoader" class="headerlink" title="1.9.5.2.1. 启动类加载器(Bootstrap ClassLoader)"></a>1.9.5.2.1. 启动类加载器(Bootstrap ClassLoader)</h6><p>​负责加载 JAVA_HOME\lib 目录中的， 或通过-Xbootclasspath 参数指定路径中的， 且被虚拟机认可（按文件名识别， 如 rt.jar） 的类。</p><h6 id="1-9-5-2-2-扩展类加载器-Extension-ClassLoader"><a href="#1-9-5-2-2-扩展类加载器-Extension-ClassLoader" class="headerlink" title="1.9.5.2.2. 扩展类加载器(Extension ClassLoader)"></a>1.9.5.2.2. 扩展类加载器(Extension ClassLoader)</h6><p>​负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。</p><h6 id="1-9-5-2-3-应用程序类加载器-Application-ClassLoader-："><a href="#1-9-5-2-3-应用程序类加载器-Application-ClassLoader-：" class="headerlink" title="1.9.5.2.3. 应用程序类加载器(Application ClassLoader)："></a>1.9.5.2.3. 应用程序类加载器(Application ClassLoader)：</h6><p>​负责加载用户路径（classpath）上的类库。JVM 通过双亲委派模型进行类的加载， 当然我们也可以通过继承 java.lang.ClassLoader实现自定义的类加载器。</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731232552332.png" alt="image-20230731232552332" style="zoom: 33%;" /><h5 id="1-9-5-3-双亲委派"><a href="#1-9-5-3-双亲委派" class="headerlink" title="1.9.5.3 双亲委派"></a>1.9.5.3 双亲委派</h5><p>​当一个类收到了<strong>⚠️未知的</strong>类加载请求，他首先不会尝试自己去加载这个类，而是把<u>这个请求委派给父类去完成</u>，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有<u>当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class）， 子类加载器才会尝试自己去加载。</u></p><p>​采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，<u>这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。</u></p><h6 id="为什么需要双亲委派模型？"><a href="#为什么需要双亲委派模型？" class="headerlink" title="为什么需要双亲委派模型？"></a>为什么需要双亲委派模型？</h6><p>双亲委派模型的好处： 如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个<code>java.lang.Object</code>的同名类并放在<code>ClassPath</code>中，多个类加载器都去加载这个类到内存中，系统中将会出现多个不同的<code>Object</code>类，那么类之间的比较结果及类的唯一性将无法保证。</p><h6 id="🌟双亲委派流程图："><a href="#🌟双亲委派流程图：" class="headerlink" title="🌟双亲委派流程图："></a>🌟双亲委派流程图：</h6><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230911091721446.png" alt="image-20230911091721446" style="zoom:50%;" /><h3 id="💘探究：ClassLoader详解："><a href="#💘探究：ClassLoader详解：" class="headerlink" title="💘探究：ClassLoader详解："></a>💘探究：ClassLoader详解：</h3><p>​ClassLoader是用来查找Class的，负责将 **Class 的字节码(.class文件)**形式转换成内存形式的 Class 对象。</p><p>​每个 Class 对象的内部都有一个 <code>classLoader</code> 字段来标识自己是由哪个 ClassLoader 加载的。ClassLoader 就像一个容器，里面装了很多已经加载的 Class 对象。</p><p>​ClassLoader的内部结构如下，主要有三个关键方法：</p><ul><li>loadClass()</li><li>findClass()</li><li>defineClass()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载入口，定义了双亲委派规则</span></span><br><span class="line">  Class <span class="title function_">loadClass</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 先看看自己是否「已经」加载过了</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">t</span> <span class="operator">=</span> <span class="built_in">this</span>.findFromLoaded(name);</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 自己没加载过，则交给双亲</span></span><br><span class="line">      t = <span class="built_in">this</span>.parent.loadClass(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 双亲都不行，只能靠自己了</span></span><br><span class="line">      t = <span class="built_in">this</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 交给子类自己去实现</span></span><br><span class="line">  Class <span class="title function_">findClass</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> ClassNotFoundException();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 组装Class对象</span></span><br><span class="line">  Class <span class="title function_">defineClass</span><span class="params">(<span class="type">byte</span>[] code, String name)</span> &#123;</span><br><span class="line">    <span class="comment">//将类的字节码转换为Class对象并返回</span></span><br><span class="line">    <span class="keyword">return</span> buildClassFromCode(code, name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">  Class <span class="title function_">findClass</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 寻找字节码</span></span><br><span class="line">    <span class="type">byte</span>[] code = findCodeFromSomewhere(name);</span><br><span class="line">    <span class="comment">// 组装Class对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.defineClass(code, name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​</p><h3 id="1-10-对象创建过程"><a href="#1-10-对象创建过程" class="headerlink" title="1.10.对象创建过程"></a>1.10.对象创建过程</h3><ol><li><strong>类加载检查</strong>：JVM遇到一条new指令时，先检查能不能在常量池中定位到该类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化。如果没有就要先进行类加载。类已被加载就通过检查。</li><li><strong>分配内存</strong>：类加载检查通过后JVM为新对象分配内存，对象所需的内存大小在类加载完成后就确定了，JVM会在堆中按照指针碰撞或空闲列表的方式为对象划分出一块空间，选择哪种方式会根据垃圾收集器的算法而定。此外，内存分配还要保证线程安全，JVM采用<strong>CAS+失败重试或TLAB</strong>的方式保证线程安全。<ol><li>CAS+失败重试：乐观锁的一种实现，每次占用资源不加锁，而是不断尝试占用。</li><li>TLAB：线程创建时预先在堆中给线程分配一块内存，称为TLAB，专门用来存放该线程运行过程中创建的对象，而TLAB满了时，采用上述CAS在堆的其它内存中分配</li></ol></li><li><strong>初始化</strong>：分配到的内存空间都初始化为零值，通过这个操作保证了对象的字段可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li><li><strong>设置对象头</strong>：在对象头中设置这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄、是否启用偏向锁等信息。</li><li><strong>执行init方法：</strong>初始化对象，即按照程序员写的构造方法给对象进行初始化。</li></ol><h3 id="1-11-执行main方法的过程-例🌰"><a href="#1-11-执行main方法的过程-例🌰" class="headerlink" title="1.11.执行main方法的过程(例🌰)"></a>1.11.执行main方法的过程(例🌰)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;大B&quot;</span>);</span><br><span class="line">        p.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>编译<code>Application.java</code>后得到 <code>Application.class</code> 后，执行这个<code>class</code>文件，系统会启动一个 <code>JVM</code> 进程，从类路径中找到一个名为 <code>Application.class</code> 的二进制文件，将 <code>Application</code> 类信息加载到运行时数据区的方法区内，这个过程叫做类的加载。</li><li>JVM 找到 <code>Application</code> 的主程序入口，执行<code>main</code>方法。</li><li><code>main</code>方法的第一条语句为 <code>Person p = new Person(&quot;大B&quot;) </code>，就是让 JVM <u>创建一个<code>Person</code>对象(见1.10)</u>，但是这个时候方法区中是没有 <code>Person</code> 类的信息的，所以 JVM 马上加载 <code>Person</code> 类，把 <code>Person</code> 类的信息放到方法区中。</li><li>加载完 <code>Person</code> 类后，JVM 在堆中分配内存给 <code>Person</code> 对象，然后调用构造函数初始化 <code>Person</code> 对象，这个 <code>Person</code> 对象持有指向方法区中的 Person 类的类型信息的引用。</li><li>执行<code>p.getName()</code>时，JVM 根据 p 的引用找到 p 所指向的对象，然后根据此对象持有的引用定位到方法区中 <code>Person</code> 类的类型信息的方法表，获得 <code>getName()</code> 的字节码地址。</li><li>执行<code>getName()</code>方法。</li></ol><h3 id="🌟类的实例化顺序？"><a href="#🌟类的实例化顺序？" class="headerlink" title="🌟类的实例化顺序？"></a>🌟类的实例化顺序？</h3><ol><li>父类中的<code>static</code>代码块，当前类的<code>static</code>代码块</li><li>父类的普通代码块</li><li>父类的构造函数</li><li>当前类普通代码块</li><li>当前类的构造函数</li></ol><h3 id="🌟如何判断一个对象是否存活？"><a href="#🌟如何判断一个对象是否存活？" class="headerlink" title="🌟如何判断一个对象是否存活？"></a>🌟如何判断一个对象是否存活？</h3><ol><li><strong>引用计数法</strong></li></ol><p>​这种方法不能解决对象的循环引用问题</p><ol start="2"><li><strong>可达性分析：</strong></li></ol><p>​通过<u>GC Root对象</u>为起点，从这些节点向下搜索，搜索所走过的路径叫引用链，当一个对象到<code>GC Root</code>没有任何的引用链相连时，说明这个对象是不可用的。</p><p>​<u>什么是GC Roots的对象？</u></p><ul><li>虚拟机栈中引用的对象</li><li>本地方法栈中Native方法引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li></ul><h3 id="🌟什么情况下类会被卸载？"><a href="#🌟什么情况下类会被卸载？" class="headerlink" title="🌟什么情况下类会被卸载？"></a>🌟什么情况下类会被卸载？</h3><p>需要同时满足以下 3 个条件类才可能会被卸载 ：</p><ul><li>该类<u>所有的实例都已经被回收</u>。</li><li>加载该类的<u>类加载器</u>已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的类进行回收，但不一定会进行回收。</p><h3 id="🌟Minor-GC-和-Full-GC的区别？"><a href="#🌟Minor-GC-和-Full-GC的区别？" class="headerlink" title="🌟Minor GC 和 Full GC的区别？"></a>🌟Minor GC 和 Full GC的区别？</h3><ul><li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 <code>Minor GC</code>会频繁执行，执行的速度一般也会比较快。</li><li>Full GC：回收老年代和新生代，老年代的对象存活时间长，因此 <code>Full GC</code> 很少执行，执行速度会比 <code>Minor GC</code> 慢很多。</li></ul><h3 id="🌟内存的分配策略？"><a href="#🌟内存的分配策略？" class="headerlink" title="🌟内存的分配策略？"></a>🌟内存的分配策略？</h3><p><strong>对象优先在 Eden 分配</strong></p><ul><li>大多数情况下，对象在新生代 <code>Eden</code> 上分配，<u>当 <code>Eden</code> 空间不够时，触发 <code>Minor GC</code>。</u></li></ul><p><strong>大对象直接进入老年代</strong></p><ul><li>大对象是指需要连续内存空间的对象，最典型的大对象有长字符串和大数组。可以设置JVM参数 <code>-XX:PretenureSizeThreshold</code>，大于此值的对象直接在老年代分配。</li></ul><p><strong>长期存活的对象进入老年代</strong></p><ul><li>通过参数 <code>-XX:MaxTenuringThreshold</code> 可以设置对象进入老年代的年龄阈值。对象在<code>Survivor</code>区每经过一次 <code>Minor GC</code>，年龄就增加 1 岁，当它的年龄增加到一定程度，就会被晋升到老年代中。</li></ul><p><strong>动态对象年龄判定</strong></p><ul><li>并非对象的年龄必须达到 <code>MaxTenuringThreshold</code> 才能晋升老年代，<u>如果在 <code>Survivor</code> 中相同年龄所有对象大小的总和大于 <code>Survivor</code> 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需达到 <code>MaxTenuringThreshold</code> 年龄阈值。</u></li></ul><p><strong>空间分配担保</strong></p><ul><li>在发生 <code>Minor GC</code> 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 <code>Minor GC</code> 是安全的。如果不成立的话虚拟机会查看 <code>HandlePromotionFailure</code> 的值是否允许担保失败。如果允许，那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 <code>Minor GC</code>；如果小于，或者 <code>HandlePromotionFailure</code> 的值为不允许担保失败，那么就要进行一次 <code>Full GC</code>。</li></ul><h3 id="🌟对象头了解吗？"><a href="#🌟对象头了解吗？" class="headerlink" title="🌟对象头了解吗？"></a>🌟对象头了解吗？</h3><p>Java 内存中的对象由以下三部分组成：对象头、实例数据和对齐填充字节。</p><p>而对象头由以下三部分组成：<strong>mark word、指向类信息的指针和数组长度（数组才有）。</strong></p><p><code>mark word</code>包含：<u>对象的哈希码、分代年龄和锁标志位</u>。</p><p>对象的实例数据就是 Java 对象的属性和值。</p><p>对齐填充字节：因为JVM要求对象占的内存大小是 8bit 的倍数，因此后面有几个字节用于把对象的大小补齐至 8bit 的倍数。</p><p>内存对齐的主要作用是：</p><ol><li>平台原因：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</li><li>性能原因：经过内存对齐后，CPU的内存访问速度大大提升。</li></ol><p>本博客对以下文章有参考借鉴，十分感谢这些作者的文章🙏：</p><ul><li><a href="https://juejin.cn/post/7255137260881477688">java类加载机制详解</a></li><li><a href="https://juejin.cn/post/6844903729435508750?searchId=20230914153350006A2B436CFFA81FD42F">老大难的 Java ClassLoader 再不理解就老了</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 原理学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法小结</title>
      <link href="/2023/05/26/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93/"/>
      <url>/2023/05/26/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cyc2018.xyz/">优秀笔记</a></p><h1 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h1><h2 id="双指针："><a href="#双指针：" class="headerlink" title="双指针："></a>双指针：</h2><p>双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。</p><h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><p>满足单调性(指针在移动的过程中，待衡量的量总是朝一个方向变化)</p><h4 id="同向双指针："><a href="#同向双指针：" class="headerlink" title="同向双指针："></a>同向双指针：</h4><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></p><p><a href="https://leetcode.cn/problems/subarray-product-less-than-k/">713. 乘积小于 K 的子数组</a></p><h4 id="相向双指针："><a href="#相向双指针：" class="headerlink" title="相向双指针："></a>相向双指针：</h4><p><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></p><p><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></p><p><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></p><p><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></p><h1 id="前缀和技巧"><a href="#前缀和技巧" class="headerlink" title="前缀和技巧"></a>前缀和技巧</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维前缀和模板（&#x27;A&#x27; 的 ASCII 码最低位为 1，&#x27;.&#x27; 的 ASCII 码最低位为 0）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MatrixSum</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[][] sum;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MatrixSum</span><span class="params">(String[] matrix)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length();</span><br><span class="line">      sum = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">              sum[i + <span class="number">1</span>][j + <span class="number">1</span>] = sum[i + <span class="number">1</span>][j] + sum[i][j + <span class="number">1</span>] - sum[i][j] + (matrix[i].charAt(j) &amp; <span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回左上角在 (r1,c1) 右下角在 (r2-1,c2-1) 的子矩阵元素和（类似前缀和的左闭右开）</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> r1, <span class="type">int</span> c1, <span class="type">int</span> r2, <span class="type">int</span> c2)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> sum[r2][c2] - sum[r2][c1] - sum[r1][c2] + sum[r1][c1];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>有两种计算中值 m 的方式：</p><ul><li><p>m &#x3D; (l + h) &#x2F; 2</p></li><li><p>m &#x3D; l + (h - l) &#x2F; 2</p><p><strong>l + h 可能出现加法溢出</strong>，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，最好使用第二种计算法方法。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果while中是 l &lt;= h 的话，那么下面也要对应的 l = m + 1; r = m - 1</span></span><br><span class="line"><span class="comment">//如：</span></span><br><span class="line"><span class="keyword">while</span>(l &lt;= h)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (h - l)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt;= target)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;tag = <span class="literal">true</span>;&#125;</span><br><span class="line">        h = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是  l &lt; h 的话，那么下面只需要出现一个 &#123;l = m + 1  and  r = m&#125;  或者  &#123;l = m  and  r = m - 1&#125;!</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/">1011. 在 D 天内送达包裹的能力</a></p><p>&#x2F;&#x2F;这题好妙，本菜鸟根本想不到这题还能二分，长见识了！</p><p>我们对运载能力进行讨论：对于某运载能力，</p><ul><li><p>如果此运载能力下需要的天数大于系统所述的天数，那么需要提高运载能力；</p></li><li><p>如果    运载能力下需要的天数小于系统所述的天数，那么需要降低运载能力；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shipWithinDays</span><span class="params">(<span class="type">int</span>[] weights, <span class="type">int</span> days)</span> &#123;</span><br><span class="line">        <span class="comment">// 确定二分查找左右边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Arrays.stream(weights).max().getAsInt(), right = Arrays.stream(weights).sum();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// need 为需要运送的天数</span></span><br><span class="line">            <span class="comment">// cur 为当前这一天已经运送的包裹重量之和</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">need</span> <span class="operator">=</span> <span class="number">1</span>, cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> weight : weights) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur + weight &gt; mid) &#123;</span><br><span class="line">                    ++need;</span><br><span class="line">                    cur = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur += weight;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//因为要求最小的运载能力，所以我们在得到符合条件所述天数的运载能力时，要再往小的运载能力那边试试</span></span><br><span class="line">            <span class="keyword">if</span> (need &lt;= days) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p><a href="https://leetcode.cn/problems/minimize-the-maximum-difference-of-pairs/">2616. 最小化数对的最大差值</a></p><p>与上一题思路相同：</p><p>​🌟看到「<strong>最大化最小值</strong>」或者「<strong>最小化最大值</strong>」就要想到<u>二分答案</u>，这是一个固定的套路。</p><p>为什么？一般来说，二分的值越大，越能&#x2F;不能满足要求；二分的值越小，越不能&#x2F;能满足要求，有单调性，可以二分。</p><p>在这一题中，我们对 <strong>最大差值的最小值</strong> 进行二分(左边界为 两数相等的差值：0；右边界为最大值与最小值的差值)对于某一 最大差值的最小值 mid：如果满足<u>差值小于mid 的数对数量</u>大于p，则应当减小mid(满足的太多了，要让条件严格一些)，否则反之。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimizeMax</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> p)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, left = -<span class="number">1</span>, right = nums[n - <span class="number">1</span>] - nums[<span class="number">0</span>]; <span class="comment">// 开区间</span></span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123; <span class="comment">// 开区间</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt;&gt; <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">                <span class="keyword">if</span> (nums[i + <span class="number">1</span>] - nums[i] &lt;= mid) &#123; <span class="comment">// 都选</span></span><br><span class="line">                    ++cnt;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt;= p) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">作者：endlesscheng</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/minimize-the-maximum-difference-of-pairs/solution/er-fen-da-an-tan-xin-by-endlesscheng-dlxv/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h1 id="分治："><a href="#分治：" class="headerlink" title="分治："></a>分治：</h1><p><a href="https://leetcode.cn/problems/different-ways-to-add-parentheses/">241. 为运算表达式设计优先级</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">diffWaysToCompute</span><span class="params">(String input)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; ways = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> input.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            List&lt;Integer&gt; left = diffWaysToCompute(input.substring(<span class="number">0</span>, i));</span><br><span class="line">            List&lt;Integer&gt; right = diffWaysToCompute(input.substring(i + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> l : left) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> r : right) &#123;</span><br><span class="line">                    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                            ways.add(l + r);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                            ways.add(l - r);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                            ways.add(l * r);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ways.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        ways.add(Integer.valueOf(input));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真的太优美了！</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> generate(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            res.add(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i&lt;=end; i++)&#123;</span><br><span class="line">            List&lt;TreeNode&gt; left = generate(start, i - <span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; right = generate(i + <span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">for</span>(TreeNode l: left)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode r: right)&#123;</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(i);</span><br><span class="line">                    root.left = l;</span><br><span class="line">                    root.right = r;</span><br><span class="line">                    res.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>做完这两道，感觉已经摸清了分治的底细！ 遍历特征点，左边和右边的不同情况排列组合得到多种结果</p><h1 id="搜索："><a href="#搜索：" class="headerlink" title="搜索："></a>搜索：</h1><h2 id="BFS："><a href="#BFS：" class="headerlink" title="BFS："></a>BFS：</h2><p>​在程序实现 BFS 时需要考虑以下问题：</p><ul><li><strong>队列</strong>：用来存储每一轮遍历得到的节点；</li><li><strong>标记</strong>：对于遍历过的节点，应该将它标记，防止重复遍历。</li></ul><p>LinkedList&lt;&gt;() 的API：<strong>poll</strong>获取并删除队头元素；<strong>offer</strong>向队尾添加元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!wordList.contains(endWord))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (beginWord.equals(endWord))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//标记</span></span><br><span class="line">        HashSet&lt;String&gt; hashset = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//bfs</span></span><br><span class="line">        LinkedList&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        queue.offer(beginWord);</span><br><span class="line">        hashset.add(beginWord);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">while</span>(sz-- != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"><span class="comment">//                if(word.equals(endWord))return res;</span></span><br><span class="line"><span class="comment">//                res++;</span></span><br><span class="line"><span class="comment">//                if(hashset.contains(word))continue;</span></span><br><span class="line">                <span class="keyword">for</span>(String s:wordList)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(judge(word,s) &amp;&amp; !hashset.contains(s))&#123;</span><br><span class="line">                        queue.offer(s);</span><br><span class="line">                        <span class="keyword">if</span>(s.equals(endWord))<span class="keyword">return</span> res;</span><br><span class="line">                        <span class="comment">// System.out.println(word + &quot;-&gt;&quot; +s);</span></span><br><span class="line">                        hashset.add(s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需要写一个方法，来判断两个字符串的差异是否为一个字符</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">judge</span> <span class="params">(String s1, String s2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.length() != s2.length())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s1.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i) != s2.charAt(i))count++;</span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS:"></a>DFS:</h2><p>​从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS 常用来求解这种 <strong>可达性</strong> 问题。</p><p>在程序实现 DFS 时需要考虑以下问题：</p><ul><li><strong>栈</strong>：用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。</li><li><strong>标记</strong>：和 BFS 一样同样需要对已经遍历过的节点进行标记。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//套路格式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> [][] direction =  <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;<span class="comment">//方向，视题目而定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxAreaOfIsland</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                res = Math.max(res, dfs(grid, i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> [][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">      <span class="comment">//出界或者已经到达过</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= grid.length || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">addition</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        grid[i][j] = <span class="number">0</span>;<span class="comment">//到达过的地点全部进行标记(不能再次到达)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; direction.length; k++)&#123;</span><br><span class="line">            addition += dfs(grid, i + direction[k][<span class="number">0</span>], j + direction[k][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> addition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回溯："><a href="#回溯：" class="headerlink" title="回溯："></a>回溯：</h2><p>回溯做题三问：</p><ol><li>当前的操作是什么</li><li>当前操作对应的子问题是什么</li><li>下一个子问题是什么</li></ol><h3 id="子集形回溯："><a href="#子集形回溯：" class="headerlink" title="子集形回溯："></a>子集形回溯：</h3><p>​对每个点进行选择：选 or 不选</p><p>​或者从答案的角度：如果选这个会满足条件再依此继续</p><h3 id="组合型回溯："><a href="#组合型回溯：" class="headerlink" title="组合型回溯："></a>组合型回溯：</h3><p>​有顺序要求可以进行剪枝</p><h3 id="排列型回溯："><a href="#排列型回溯：" class="headerlink" title="排列型回溯："></a>排列型回溯：</h3><p>​</p><p>​Backtracking（回溯）属于 DFS。</p><ul><li>普通 DFS 主要用在 <strong>可达性问题</strong> ，这种问题只需要执行到特点的位置然后返回即可。</li><li>而 Backtracking 主要用于求解 <strong>排列组合</strong> 问题，例如有 { ‘a’,’b’,’c’ } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。</li></ul><p>因为 Backtracking 不是立即返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：</p><ul><li>在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；</li><li>但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对于一定规则下的排列组合问题，我们使用回溯法进行求解</span><br><span class="line">回溯法 = dfs+回溯操作</span><br><span class="line">一般而言void dfs的参数如下(int n, &lt;T&gt;存储当前步骤生成的中间结果的变量,用于存储最终各种情况的变量[一般为一个ArrayList], 待进行操作的元素)；</span><br><span class="line">如：dfs(0,new StringBuilder(),res,s);</span><br><span class="line">dfs中刚开始写上终止条件：n到达指定轮数或不满足其他限制条件，直接return</span><br><span class="line">接下来根据当前存储的中间结果，再·给中间结果添加这轮得到的产物 ··对其进行下一轮dfs ···将这轮的产物删去，并换成这一轮产物的下一种情况！</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回溯模版：</span></span><br><span class="line"><span class="comment">//在回溯时，如果使用ArrayList等引用对象存放你产生的结果，在将其添加至结果集中时需要重新创建一个与其相同的副本，将副本加入结果集，如果不这样做，回溯后删除了元素会导致结果集中元素的改变。。</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   ArrayList&lt;Integer&gt; curNum = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">boolean</span>[] tag = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        dfs(curNum, tag, res, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(ArrayList&lt;Integer&gt; curNum,<span class="type">boolean</span>[] tag, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curNum.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(curNum));<span class="comment">//##############################就说的是这里！！！！</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!tag[i])&#123;</span><br><span class="line">                curNum.add(nums[i]);</span><br><span class="line">                tag[i] = <span class="literal">true</span>;</span><br><span class="line">                dfs(curNum, tag, res, nums);</span><br><span class="line">                curNum.remove(curNum.size() - <span class="number">1</span>);</span><br><span class="line">                tag[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于排列问题：我们只需要遍历并回溯所有的情况并记录即可，</p><p><strong>组合问题</strong>，相对于排列问题而言，不计较一个组合内元素的顺序性（即 [1, 2, 3] 与 [1, 3, 2] 认为是同一个组合），因此很多时候<strong>需要按某种顺序展开搜索</strong>，这样才能做到不重不漏。</p><p>我们需要按照某种顺序(比如大小顺序)进行搜索，也就是“剪枝”</p><p><u>笔记的回溯第11、12、13、14、15题未做！</u></p><h1 id="贪心："><a href="#贪心：" class="headerlink" title="贪心："></a>贪心：</h1><h3 id="适用范围："><a href="#适用范围：" class="headerlink" title="适用范围："></a>适用范围：</h3><p>贪心算法在<strong>有最优子结构</strong>的问题中尤为有效。最优子结构的意思是问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。</p><h2 id="两种常见思路："><a href="#两种常见思路：" class="headerlink" title="两种常见思路："></a>两种常见思路：</h2><h3 id="排序解法"><a href="#排序解法" class="headerlink" title="排序解法"></a>排序解法</h3><p>用排序法常见的情况是输入一个包含几个（一般一到两个）权值的数组，通过排序然后遍历模拟计算的方法求出最优值。</p><h3 id="后悔解法"><a href="#后悔解法" class="headerlink" title="后悔解法"></a>后悔解法</h3><p>思路是无论当前的选项是否最优都接受，然后进行比较，如果选择之后不是最优了，则反悔，舍弃掉这个选项；否则，正式接受。如此往复。</p><h1 id="动态规划！"><a href="#动态规划！" class="headerlink" title="动态规划！"></a>动态规划！</h1><p>​写到0-1背包第三题</p><h1 id="链表："><a href="#链表：" class="headerlink" title="链表："></a>链表：</h1><h3 id="纯链表操作的题目有很多都可以使用-递归-解决！"><a href="#纯链表操作的题目有很多都可以使用-递归-解决！" class="headerlink" title="纯链表操作的题目有很多都可以使用 递归 解决！"></a>纯链表操作的题目有很多都可以使用 <em>递归</em> 解决！</h3><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要求两两交换链表中的节点</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">    head.next = swapPairs(next.next);</span><br><span class="line">    next.next = head;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="除了递归很常见以外，快慢指针的方法-也很常见"><a href="#除了递归很常见以外，快慢指针的方法-也很常见" class="headerlink" title="除了递归很常见以外，快慢指针的方法 也很常见"></a>除了递归很常见以外，<u><em>快慢指针的方法</em></u> 也很常见</h3><p>如判断链表是否回文，可以使用快慢指针找到链表的中间(具体奇偶位再考虑)，再将链表分割位两个子链表，反转其一，如果两个子链表相等则回文！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast != <span class="literal">null</span>) slow = slow.next;  <span class="comment">// 偶数节点，让 slow 指向下一个节点</span></span><br><span class="line">    cut(head, slow);                     <span class="comment">// 切成两个链表</span></span><br><span class="line">    <span class="keyword">return</span> isEqual(head, reverse(slow));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cut</span><span class="params">(ListNode head, ListNode cutNode)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (head.next != cutNode) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nextNode</span> <span class="operator">=</span> head.next;</span><br><span class="line">        head.next = newHead;</span><br><span class="line">        newHead = head;</span><br><span class="line">        head = nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isEqual</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val != l2.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树："><a href="#树：" class="headerlink" title="树："></a>树：</h1><h2 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h2><p>一棵树要么是空树，要么有两个指针，每个指针指向一棵树。树是一种递归结构，很多树的问题可以使用<strong>递归</strong>来处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">对树的操作，一般可以用递归解决：</span><br><span class="line"><span class="comment">//通用格式：</span></span><br><span class="line">functionname ( TreeNode root )&#123;</span><br><span class="line"><span class="keyword">if</span>(root  == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">  &#125;  </span><br><span class="line">  root.left = functionname(xxx);</span><br><span class="line">  root.right = functionname(xxx);</span><br><span class="line">  <span class="keyword">return</span> xxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//例1:</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    depth(root);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">depth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> depth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> depth(root.right);</span><br><span class="line">    max = Math.max(max, leftDepth + rightDepth);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例2:</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;<span class="keyword">return</span> root;&#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = invertTree(root.right);</span><br><span class="line">        root.right = invertTree(temp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//例3:</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root1.val + root2.val);</span><br><span class="line">        res.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">        res.right = mergeTrees(root1.right, root2.right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例4:一种有点妙的格式：</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSubtreeWithRoot(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSubtreeWithRoot</span><span class="params">(TreeNode s, TreeNode t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span> &amp;&amp; s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span> || s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t.val != s.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSubtreeWithRoot(s.left, t.left) &amp;&amp; isSubtreeWithRoot(s.right, t.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续做前中后序遍历!</p><h2 id="层次遍历："><a href="#层次遍历：" class="headerlink" title="层次遍历："></a>层次遍历：</h2><p>广度优先即可</p><h2 id="前中后序遍历："><a href="#前中后序遍历：" class="headerlink" title="前中后序遍历："></a>前中后序遍历：</h2><h2 id="BST："><a href="#BST：" class="headerlink" title="BST："></a>BST：</h2><h2 id="Trie："><a href="#Trie：" class="headerlink" title="Trie："></a>Trie：</h2><h1 id="数组与矩阵："><a href="#数组与矩阵：" class="headerlink" title="数组与矩阵："></a>数组与矩阵：</h1><p>看到：5. 有序矩阵的 Kth Element</p><h1 id="图："><a href="#图：" class="headerlink" title="图："></a>图：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java建图模板</span></span><br><span class="line">g = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[n];</span><br><span class="line">Arrays.setAll(g, e -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;() );</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> e : edges)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> e[<span class="number">0</span>], y = e[<span class="number">1</span>];</span><br><span class="line">    g[x].add(y);</span><br><span class="line">    g[y].add(x);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="二分图："><a href="#二分图：" class="headerlink" title="二分图："></a>二分图：</h2><p>​如果可以用两种颜色对图中的节点进行着色，并且保证相邻的节点颜色不同，那么这个图就是二分图。</p><p>​&#x2F;&#x2F;判断是否是二分图⬇️</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">judge</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBipartite</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">       <span class="comment">//color记录每个节点的颜色，0为还没被染色，1、2分别为两种颜色</span></span><br><span class="line">       <span class="type">int</span> color[] = <span class="keyword">new</span> <span class="title class_">int</span>[graph.length];</span><br><span class="line">       <span class="comment">//我认为应该深度遍历这个图，给遍历过的结点染色，</span></span><br><span class="line">       <span class="comment">//如果遇到已经染色的，看看如果和自己颜色相同，则不是二分图！</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; graph.length; i++)&#123;</span><br><span class="line">           <span class="comment">//对于每棵子树，如果有一个节点被dfs过，那么如果可以构成二分子图的话，这颗子树上的所有节点都不必再进行dfs了，故此处只找还未被涂色的节点进行dfs！</span></span><br><span class="line">           <span class="keyword">if</span>(color[i] == <span class="number">0</span>) &#123;</span><br><span class="line">               dfs(graph, i, <span class="number">1</span>, color);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> judge;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span> i, <span class="type">int</span> thisColor, <span class="type">int</span>[] color)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!judge)<span class="keyword">return</span>;</span><br><span class="line">       color[i] = thisColor;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; graph[i].length; j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(color[graph[i][j]] == <span class="number">0</span>)&#123;</span><br><span class="line">               dfs(graph, graph[i][j], thisColor==<span class="number">1</span>?<span class="number">2</span>:<span class="number">1</span>, color);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(color[i] == color[graph[i][j]])&#123;</span><br><span class="line">                   judge = <span class="literal">false</span>;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="拓扑排序："><a href="#拓扑排序：" class="headerlink" title="拓扑排序："></a>拓扑排序：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将邻接矩阵转换为邻接表：</span></span><br><span class="line"><span class="type">int</span>[][] prerequisites <span class="comment">//邻接矩阵</span></span><br><span class="line">List&lt;Integer&gt;[] graphic = <span class="keyword">new</span> <span class="title class_">List</span>[numCourses];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">    graphic[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] pre : prerequisites) &#123;</span><br><span class="line">    graphic[pre[<span class="number">0</span>]].add(pre[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1: 深度优先</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*定义三种状态：0-&gt;未搜索；1-&gt;搜索中；2-&gt;已完成</span></span><br><span class="line"><span class="comment">*遍历所有结点，对未搜索的结点进行dfs，</span></span><br><span class="line"><span class="comment">*对于dfs：先将该结点置为1状态，遍历所有该结点需要的结点，如果没有依赖的结点或者依赖的结点的状态都为2，则该结点也</span></span><br><span class="line"><span class="comment">*可以标记成2；如果该结点依赖的结点状态为0，则dfs依赖的结点；如果依赖的结点的状态为1，则说明存在环，不满足拓扑排</span></span><br><span class="line"><span class="comment">*序！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//深度优先判断拓扑排序⬇️</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrderByDFS(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="comment">//1.构建图</span></span><br><span class="line">        List&lt;Integer&gt;[] relation = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            relation[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] arr: prerequisites)&#123;</span><br><span class="line">            relation[arr[<span class="number">0</span>]].add(arr[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建数组，存放每门课程的状态0，1，2</span></span><br><span class="line">        <span class="type">int</span>[] status = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//用于存放课程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(status[i] == <span class="number">0</span>)&#123; <span class="comment">//未搜索过，于是对其进行dfs搜索！</span></span><br><span class="line">                dfs(i, relation, status,stack);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(loop)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> numCourses - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            res[i] = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> curCourse, List&lt;Integer&gt;[] relation, <span class="type">int</span>[] status, LinkedList&lt;Integer&gt; stack)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(loop)<span class="keyword">return</span>;</span><br><span class="line">        status[curCourse] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> next: relation[curCourse])&#123;</span><br><span class="line">            <span class="keyword">if</span>(status[next] == <span class="number">0</span>)&#123;</span><br><span class="line">                dfs(next, relation, status,stack);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(status[next] == <span class="number">1</span>)&#123;</span><br><span class="line">                loop = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(curCourse);</span><br><span class="line">        status[curCourse] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2: 广度优先</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*将邻接矩阵转化为邻接表 其中：A需要B == B-&gt;A 因此 任务K入度为0表示K可以直接完成！</span></span><br><span class="line"><span class="comment">  *使用队列，将入度为0的任务添加至队列，遍历这些任务，将它们指向的队列的入度--；将操作后入度为0的再添加进队列</span></span><br><span class="line"><span class="comment">  *直到队列为空(如果从队列弹出的任务总数 &lt; 总任务数，则说明图中有环，不能构成拓扑排序)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">//广度优先判断拓扑排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrderByBFS(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="comment">//1.构建图</span></span><br><span class="line">        <span class="comment">//广度优先，a需要b 则 b-&gt;a</span></span><br><span class="line">        <span class="comment">//每次记录入度为0的课程,因此需要创建数组记录每个课程的入度</span></span><br><span class="line">        List&lt;Integer&gt;[] relation = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[numCourses];</span><br><span class="line">        <span class="type">int</span> []inDegree = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            relation[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] arr: prerequisites)&#123;</span><br><span class="line">            relation[arr[<span class="number">1</span>]].add(arr[<span class="number">0</span>]);</span><br><span class="line">            inDegree[arr[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//队列初始化：将所有入度为0的课程都加入queue</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化完毕，开始常规bfs</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(sz-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">curCourse</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i: relation[curCourse])&#123;</span><br><span class="line">                    inDegree[i]--;</span><br><span class="line">                    <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                        queue.offer(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res[index++] = curCourse;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index == numCourses? res: <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="并查集："><a href="#并查集：" class="headerlink" title="并查集："></a>并查集：</h2><p>并查集可以动态地连通两个点，并且可以非常快速地判断两个点是否连通。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *===============================并查集模板，可直接使用！！！=====================================</span></span><br><span class="line"><span class="comment"> * 数组模拟树，实现并查集。数组内的元素表示父亲的下角表，相当于指针。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> element)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (element != parent[element]) &#123;</span><br><span class="line">            element = parent[element];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> firstElement, <span class="type">int</span> secondElement)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(firstElement) == find(secondElement);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unionElements</span><span class="params">(<span class="type">int</span> firstElement, <span class="type">int</span> secondElement)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">firstRoot</span> <span class="operator">=</span> find(firstElement);</span><br><span class="line">        <span class="type">int</span> <span class="variable">secondRoot</span> <span class="operator">=</span> find(secondElement);</span><br><span class="line">        <span class="keyword">if</span> (firstRoot == secondRoot) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parent[firstRoot] = secondRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//并查集的应用：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findRedundantConnection(<span class="type">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">unionfind</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">UnionFind</span>(edges.length + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge:edges)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!unionfind.isConnected(edge[<span class="number">0</span>],edge[<span class="number">1</span>]))&#123;</span><br><span class="line">                unionfind.unionElements(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="寻找图中的最大环："><a href="#寻找图中的最大环：" class="headerlink" title="寻找图中的最大环："></a>寻找图中的最大环：</h2><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>用于<u><strong>值域较小的大量数字的排序</strong></u>，将各个<strong>数字的值</strong>与<strong>个数</strong>作为一个<strong>数组的下标</strong>和<strong>值</strong>通过遍历数组，累加arr[]的值 &#x3D; k<strong>得到第k小的数字</strong></p><h1 id="桶排序："><a href="#桶排序：" class="headerlink" title="桶排序："></a>桶排序：</h1><p>​设置若干个桶 bucket[i] 存储出现次数为i的数， bucket定义为 ArrayList[ ] 类型</p><h1 id="快速选择："><a href="#快速选择：" class="headerlink" title="快速选择："></a>快速选择：</h1><p>平常人们<strong>选择数据中某个第几大</strong>的数据，往往使用先排序在选择的方法，这种方法的时间复杂度最快为Onlogn（快排时间复杂度），但在数据较大时往往会超出时间限制，故本次介绍时间复杂度为On的快速选择方法</p><p>快速选择算法：算法核心为递归和分治，和快速排序算法有一定的相似度，算法大概过程为<br>1.先判断区间的端点l,r和比较数pivot,pivot可取为arr[l],arr[r],arr[(l + r) &#x2F; 2)]。</p><p>2.进行排序交换，使区间分为两部分，左边部分小于等于pivot，右边部分大于等于pivot。</p><p>3.递归排序左右边，当要求的第K个数,k &gt;&#x3D; sl，则递归排序右边，否则递归排序左边，如果区间只有一个数则返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">quickChoose</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> [] arr,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//如果当前只有一个数存在</span></span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">           <span class="keyword">return</span> arr[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则进行排序和查找</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l - <span class="number">1</span>,j = r + <span class="number">1</span>,pivot = arr[l];</span><br><span class="line">        <span class="comment">//本次返回j,j + 1</span></span><br><span class="line">        <span class="comment">//当前元素区间不止为一个数时</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(arr[++i] &lt; pivot);</span><br><span class="line">            <span class="keyword">while</span>(arr[--j] &gt; pivot);</span><br><span class="line">            <span class="comment">//如果满足区间元素不为1</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[i];</span><br><span class="line">                arr[i] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果在左半部分，直接排序左边求解</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s1</span> <span class="operator">=</span> j - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1 &gt;= k)&#123;</span><br><span class="line">            <span class="keyword">return</span> quickChoose(l,i - <span class="number">1</span>,arr,k);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//否则排序右边数组</span></span><br><span class="line">            k = k - s1;</span><br><span class="line">            <span class="keyword">return</span> quickChoose( i,r,arr,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="匈牙利算法："><a href="#匈牙利算法：" class="headerlink" title="匈牙利算法："></a>匈牙利算法：</h1><ul><li><p><strong>匈牙利算法主要用来解决两个问题：求二分图的最大匹配数和最小点覆盖数</strong>。</p><p>求二分图最大连通数 模版⬇️</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意类名必须为 Main, 不要有任何 package xxx 信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 注意 hasNext 和 hasNextLine 的区别</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        List&lt;Integer&gt; odd = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; even = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(temp % <span class="number">2</span> == <span class="number">0</span>)&#123;even.add(temp);&#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;odd.add(temp);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> [] match = <span class="keyword">new</span> <span class="title class_">int</span> [even.size()];</span><br><span class="line">        <span class="keyword">if</span>(odd.size() == <span class="number">0</span> || even.size() == <span class="number">0</span>)&#123; <span class="comment">//缺少奇数或者偶数无法构成素数</span></span><br><span class="line">            System.out.println(count);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i: odd)&#123;</span><br><span class="line">            <span class="type">boolean</span> [] used = <span class="keyword">new</span> <span class="title class_">boolean</span> [even.size()];</span><br><span class="line">            <span class="keyword">if</span>(find(i,even, match, used))count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i, List&lt;Integer&gt; even, <span class="type">int</span>[] match,<span class="type">boolean</span> [] used)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; even.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrime(i + even.get(j)) &amp;&amp; !used[j])&#123;</span><br><span class="line">                used[j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(match[j] == <span class="number">0</span> || find(match[j], even, match,used))&#123;</span><br><span class="line">                    match[j] = i;  </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n % i == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="多路归并："><a href="#多路归并：" class="headerlink" title="多路归并："></a>多路归并：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lfool.github.io/LFool-Notes/algorithm/多路归并技巧总结.html</span><br></pre></td></tr></table></figure><ul><li><p>21.合并两个有序链表(简单)</p></li><li><p>23.合并K个升序链表(<strong>困难</strong>)</p><p>每次从所有链表头中选择数值最小的值加入结果链表中即可。自己做时只使用了遍历的方法，但是发现大神们<strong>使用小根堆</strong>来获取最小的链表头部！</p><ul><li>还可以使用归并的方法，(合并n个链表—–分半分半再分半—–&gt;合并2个链表)，针对合并2个链表编写代码</li><li>还可以使用PriorityQueue<ListNode>优先队列，它自动将队列内的元素按照提供的重写的compare方法来排序，每次poll出最小的，再把它的next(如果有)放入队列</li></ul></li></ul><h1 id="单调栈："><a href="#单调栈：" class="headerlink" title="单调栈："></a>单调栈：</h1><p>​<strong>用于处理 获取递增子序列之类的题目</strong></p><p>​遍历所给的数据，并维护一个栈，</p><p>​比如现在需要找出长度为n的最小字典序子字符串</p><p>​如果获得的数据比栈顶的小，则弹出栈顶，直到栈为空 或 栈顶元素小于所持元素， (这里还注意：因为我们需要的是长度为n的子序列，所以在我们每次想要pop的时候都需要判断：栈中元素以及未遍历的元素总数是否达到了了n，若&gt;n，则允许pop)</p><p>最后将栈中的数据依次pop，再reverse一下即可</p><h1 id="🌟TreeSet的使用："><a href="#🌟TreeSet的使用：" class="headerlink" title="🌟TreeSet的使用："></a>🌟TreeSet的使用：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        in.next();</span><br><span class="line">        <span class="keyword">while</span> (in.hasNextInt()) &#123; <span class="comment">// 注意 while 处理多个 case</span></span><br><span class="line">            treeSet.add(in.nextInt());           </span><br><span class="line">        &#125;</span><br><span class="line">        Iterator&lt;Integer&gt; tree = treeSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (tree.hasNext())&#123;</span><br><span class="line">            System.out.println(tree.next());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ceiling(E e)：返回大于等于给定元素的最小元素，如果不存在则返回 null。 </span></span><br><span class="line"><span class="comment">//  floor(E e)：返回小于等于给定元素的最大元素，如果不存在则返回 null。</span></span><br></pre></td></tr></table></figure><h1 id="System-arraycopy-的使用"><a href="#System-arraycopy-的使用" class="headerlink" title="System.arraycopy()的使用"></a>System.arraycopy()的使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>      src      the source array. 源数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>      srcPos   starting position in the source array. 源数组的起始位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>      dest     the destination array. 目标数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>      destPos  starting position in the destination data. 目标数组的起始位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>      length   the number of array elements to be copied. 复制的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">arraycopy(Object src,<span class="type">int</span> srcPos,Object dest, <span class="type">int</span> destPos, <span class="type">int</span> length)；</span><br></pre></td></tr></table></figure><h1 id="动态规划："><a href="#动态规划：" class="headerlink" title="动态规划："></a>动态规划：</h1><h4 id="1031-两个非重叠子数组的最大和"><a href="#1031-两个非重叠子数组的最大和" class="headerlink" title="1031. 两个非重叠子数组的最大和"></a><a href="https://leetcode.cn/problems/maximum-sum-of-two-non-overlapping-subarrays/">1031. 两个非重叠子数组的最大和</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums 和两个整数 firstLen 和 secondLen，请你找出并返回两个非重叠 子数组 中元素的最大和，长度分别为 firstLen 和 secondLen 。</span><br><span class="line">长度为 firstLen 的子数组可以出现在长为 secondLen 的子数组之前或之后，但二者必须是不重叠的。</span><br><span class="line">子数组是数组的一个 连续 部分。</span><br></pre></td></tr></table></figure><p>使用动态规划 ：</p><ul><li><p>dp1[ i ]表示前i个数中长度为firstLen的子数组的最大值 (若 i &lt; firstLen)则dp1[ i ] &#x3D; 前i个数之和</p></li><li><p>dp2[ i ]表示前i个数中长度为secondLen的子数组的最大值</p><p>我们得到dp1[ ]与dp2[ ]数组后，对于每个i，我们可以让res &#x3D; Max{res, 数组1(firstLen)包含了最新的第i位，数组2(secondLen)包含了最新的第i位}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumTwoNoOverlap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> firstLen, <span class="type">int</span> secondLen)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] += nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        arr1[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        arr2[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            arr1[i] = firstLen&gt;i?nums[i]: Math.max(nums[i] - nums[i - firstLen],arr1[i - <span class="number">1</span>]);</span><br><span class="line">            arr2[i] = secondLen&gt;i?nums[i]: Math.max(nums[i] - nums[i - secondLen],arr2[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (firstLen + secondLen &gt; i)&#123;</span><br><span class="line">                res = nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res = Math.max(res, nums[i] - nums[i - firstLen] + arr2[i - firstLen]);</span><br><span class="line">                res = Math.max(res, nums[i] - nums[i - secondLen] + arr1[i - secondLen]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>**1606自己做的超时了，答案的数据结构有点复杂，不知道什么时候有空再看看～</p><p>**2151 二进制枚举，有空来复盘！</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
