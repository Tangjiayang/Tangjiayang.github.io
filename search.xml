<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络</title>
      <link href="/2023/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL原理学习</title>
      <link href="/2023/07/27/MySQL%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/07/27/MySQL%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><strong><u>MySQL原理——知识架构</u></strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728105935995.png" alt="image-20230728105935995"></p><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h3 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h3><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728111959688.png" alt="image-20230728111959688" style="zoom: 67%;" /><h4 id="MySQL服务器逻辑架构："><a href="#MySQL服务器逻辑架构：" class="headerlink" title="MySQL服务器逻辑架构："></a>MySQL服务器逻辑架构：</h4><ul><li>最上层的服务并不是 MySQL 所独有的，大多数基于网络的客户端&#x2F;服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。</li><li>第二层架构是 MysQL 比较有意思的部分。大多数 MysQL 的核心服务功能都在这一层，包括<strong>查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数）</strong>，所有跨存储引擎的功能都在这一层实现：<strong>存储过程、触发器、视图</strong>等。</li><li>第三层包含了存储引擎。存储引擎负责 MySQL 中数据的存储和提取。和 GNU&#x2F;Linux 下的各种文件系统一样，每个存储引l擎都有它的优势和劣势。<strong>服务器通过 API 与存储引擎进行通信。这些接口屏蔽了不同存储引擎之问的差异，使得这些差异对上层的查询过程透明</strong>。存储引擎API包合几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行记录” 等操作。但存储引擎不会去解析 SQL，不同存储引擎之间也不会相互通信，而只是简单地响应上层服务器的请求。</li></ul><h4 id="连接管理与安全性"><a href="#连接管理与安全性" class="headerlink" title="连接管理与安全性"></a>连接管理与安全性</h4><ul><li><u>每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行</u>，该线程只能轮流在服务器的CPU中运行。</li><li>客户端连接到服务器时，服务器对其进行认证(用户名、主机信息、密码)，认证成功后进一步验证该客户端是否具有执行某个查询的权限</li></ul><h4 id="优化与执行"><a href="#优化与执行" class="headerlink" title="优化与执行"></a>优化与执行</h4><ul><li>MysQL会<strong>解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适索引等</strong>。用户可以通过特殊的关键宇提示(hint） 优化器，影响它的决策过程。也可以请求优化器解释 (explain）优化过程的各个因素，使用户可以知道服务器是如何进行优化决策的，并提供一个参考基准，便于用戶重构查询和 schetna、修改相关配置，使应用尽可能高效运行。</li><li>优化器并不关心表使用的是什么存储引擎，但存储引擎对于优化查询是有影响的。优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等。例如，某些存储引擎的某种索引，可能对一些特定的查询有优化。</li><li>对于 SELECT 语向，在解析查询之前，服务器会先检查查询缓存 (Query Cache)，<strong>如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集</strong>。</li></ul><h3 id="一条SQL的执行过程"><a href="#一条SQL的执行过程" class="headerlink" title="一条SQL的执行过程"></a>一条SQL的执行过程</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728122544760.png" alt="image-20230728122544760"></p><p>MySQL执行SQL查询的流程图⬆️：</p><p>可以看到， MySQL 的架构共分为两层：<strong>Server 层和存储引擎层</strong>，</p><ul><li>**Server 层负责<u>建立连接、分析和执行 SQL</u>**。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。</li><li><strong>存储引擎层负责数据的存储和提取</strong>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。</li></ul><p>好了，现在我们对 Server 层和存储引擎层有了一个简单认识，接下来，就详细说一条 SQL 查询语句的执行流程，依次看看每一个功能模块的作用。</p><h4 id="Step1-连接器"><a href="#Step1-连接器" class="headerlink" title="Step1: 连接器"></a>Step1: 连接器</h4><p>服务器(通常，我们的日常学习中，使用本机提供mysql服务，所以也需要在本机启动mysql)启动MySQL后，用户端连接MySQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># -h 指定 MySQL 服务得 IP 地址，如果是连接本地的 MySQL服务，可以不用这个参数；</span><br><span class="line"># -u 指定用户名，管理员角色名为 root；</span><br><span class="line"># -p 指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里面输入密码</span><br><span class="line">mysql -h$ip -u$user -p</span><br></pre></td></tr></table></figure><ol><li><p><strong>服务器未启动mysql</strong>：连接的过程需要先经过 TCP 三次握手，因为 **<u>MySQL 是基于 TCP 协议进行传输的</u>**，如果 <strong>MySQL 服务并没有启动</strong>，则会收到报错</p></li><li><p><strong>客户端用户名&#x2F;密码错误</strong>：如果 MySQL 服务正常运行，完成 TCP 连接的建立后，连接器就要开始验证你的用户名和密码，如果用户名或密码不对，就收到一个”Access denied for user”的错误，然后客户端程序结束执行。</p></li></ol><p>🌟<strong>如果用户密码都没有问题，连接器就会获取该用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断。所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</strong>——用户信息修改后，本次连接不生效，需重新连接</p><h5 id="如何查看-MySQL-服务被多少个客户端连接了？"><a href="#如何查看-MySQL-服务被多少个客户端连接了？" class="headerlink" title="如何查看 MySQL 服务被多少个客户端连接了？"></a>如何查看 MySQL 服务被多少个客户端连接了？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show processlist;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728123837566.png" alt="image-20230728123837566" style="zoom:50%;" /><h5 id="空闲连接会一直占用着吗？"><a href="#空闲连接会一直占用着吗？" class="headerlink" title="空闲连接会一直占用着吗？"></a>空闲连接会一直占用着吗？</h5><p>不会，MySQL 定义了空闲连接的最大空闲时长，由 <strong>wait_timeout 参数控制</strong>的，默认值是 8 小时（28880秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。</p><p>我们自己也可以手动断开空闲的连接，使用的是 kill connection + id 的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; kill connection +6;</span><br></pre></td></tr></table></figure><p>一个处于空闲状态的连接被服务端主动断开后，<strong>这个客户端并不会马上知道</strong>，等到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”</p><h5 id="MySQL-的连接数有限制吗？"><a href="#MySQL-的连接数有限制吗？" class="headerlink" title="MySQL 的连接数有限制吗？"></a>MySQL 的连接数有限制吗？</h5><p><u>MySQL 服务支持的最大连接数由 max_connections 参数控制</u>，比如我的 MySQL 服务默认是 151 个,超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。</p><h5 id="MySQL-短连接和长连接："><a href="#MySQL-短连接和长连接：" class="headerlink" title="MySQL 短连接和长连接："></a>MySQL 短连接和长连接：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 短连接</span><br><span class="line">连接 mysql 服务（TCP 三次握手）</span><br><span class="line">执行sql</span><br><span class="line">断开 mysql 服务（TCP 四次挥手）</span><br><span class="line"></span><br><span class="line">// 长连接</span><br><span class="line">连接 mysql 服务（TCP 三次握手）</span><br><span class="line">执行sql</span><br><span class="line">执行sql</span><br><span class="line">执行sql</span><br><span class="line">....</span><br><span class="line">断开 mysql 服务（TCP 四次挥手）</span><br></pre></td></tr></table></figure><p>可以看到，使用<strong>长连接</strong>的好处就是可以<strong>减少建立连接和断开连接的过程</strong>，所以一般是推荐使用长连接。</p><p>但是，<u>使用长连接后可能会占用内存增多</u>，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，<u>这些连接对象资源只有在连接断开时才会释放</u>。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象。</p><h5 id="怎么解决长连接占用内存的问题？"><a href="#怎么解决长连接占用内存的问题？" class="headerlink" title="怎么解决长连接占用内存的问题？"></a>怎么解决长连接占用内存的问题？</h5><p>第一种，<strong>定期断开长连接</strong>。既然断开连接后就会释放连接占用的内存资源，那么我们可以定期断开长连接。</p><p>第二种，<strong>客户端主动重置连接</strong>。MySQL 5.7 版本实现了 mysql_reset_connection() 函数的接口，注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。👍</p><h5 id="连接器工作总结："><a href="#连接器工作总结：" class="headerlink" title="连接器工作总结："></a>连接器工作总结：</h5><ul><li>与客户端进行 TCP 三次握手建立<strong>连接</strong>；</li><li><strong>校验客户端的用户名和密码</strong>，如果用户名或密码不对，则会报错；</li><li>如果用户名和密码都对了，会<strong>读取该用户的权限</strong>，然后后面的权限逻辑判断都基于此时读取到的权限；</li></ul><h4 id="Step2-查询缓存"><a href="#Step2-查询缓存" class="headerlink" title="Step2: 查询缓存"></a>Step2: 查询缓存</h4><p>MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段，看看是什么类型的语句。</p><p>如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，<strong>这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。</strong></p><p>但是查询缓存被命中的几率很低，基本不会命中，因此 MySQL 8.0 开始(被移除了)，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了。</p><p>对于 MySQL 8.0 之前的版本，如果想关闭查询缓存，我们可以通过将参数 query_cache_type 设置成 DEMAND。</p><h4 id="Step3-解析SQL"><a href="#Step3-解析SQL" class="headerlink" title="Step3: 解析SQL"></a>Step3: 解析SQL</h4><p>在正式执行 SQL 查询语句之前， MySQL 会先<strong>对 SQL 语句做解析</strong>，这个工作交由「解析器」来完成。</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="解析器："><a href="#解析器：" class="headerlink" title="解析器："></a>解析器：</h5><ul><li><p><strong>词法分析</strong>。MySQL 会根据你输入的字符串<strong>识别出关键字</strong>出来，构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。</p></li><li><p><strong>语法分析</strong>。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p></li></ul><p><u>如果我们输入的 SQL 语句语法不对，就会在解析器这个阶段报错</u>。比如，我下面这条查询语句，把 from 写成了 form，这时 MySQL 解析器就会给报错。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF.png" alt="img"></p><p>⚠️但是注意，<strong>表不存在或者字段不存在，并不是在解析器里做的</strong></p><h4 id="Step4-执行SQL"><a href="#Step4-执行SQL" class="headerlink" title="Step4: 执行SQL"></a>Step4: 执行SQL</h4><p>​经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条<strong>SELECT 查询语句</strong>流程主要可以分为下面这三个阶段：</p><ul><li>prepare 阶段，也就是<strong>预处理阶段；</strong></li><li>optimize 阶段，也就是<strong>优化阶段；</strong></li><li>execute 阶段，也就是<strong>执行阶段；</strong></li></ul><h5 id="🌟预处理阶段："><a href="#🌟预处理阶段：" class="headerlink" title="🌟预处理阶段："></a>🌟预处理阶段：</h5><p>预处理器主要进行如下操作：</p><ol><li><p><strong>检查 SQL 查询语句中的表或者字段是否存在；</strong></p></li><li><p>将 select * 中的 * 符号，扩展为表上的所有列；</p></li></ol><h5 id="🌟优化阶段："><a href="#🌟优化阶段：" class="headerlink" title="🌟优化阶段："></a>🌟优化阶段：</h5><p>优化器主要进行如下操作：</p><p>​<strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</p><p>*要想知道优化器选择了哪个索引，我们可以在查询语句最前面加个 explain 命令，这样就会输出这条 SQL 语句的执行计划，然后执行计划中的 key 就表示执行过程中使用了哪个索引</p><h5 id="🌟执行阶段："><a href="#🌟执行阶段：" class="headerlink" title="🌟执行阶段："></a>🌟执行阶段：</h5><p>执行器主要进行如下操作：</p><p><strong>执行前要对操作用户的权限进行判断！</strong></p><p><strong>执行器将与存储引擎交互，执行SQL语句(交互是以记录为单位的)</strong></p><p>​共有三种执行方式：</p><ol><li><strong>主键索引查询</strong></li></ol><p>​根据主键字段的值来查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>​这条查询语句的查询条件用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用访问类型为 const 进行查询，也就是使用主键索引查询一条记录，那么执行器与存储引擎的执行流程是这样的：</p><ul><li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 id &#x3D; 1 交给存储引擎，<strong>让存储引擎定位符合条件的第一条记录</strong>。</li><li>存储引擎通过主键索引的 B+ 树结构定位到 id &#x3D; 1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；</li><li>执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。</li><li>执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。</li></ul><p>至此，这个语句就执行完成了。</p><ol start="2"><li><strong>全表扫描</strong></li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from product where name = &#x27;iphone&#x27;;</span><br></pre></td></tr></table></figure><p>这条查询语句的查询条件没有用到索引，所以优化器决定选用访问类型为 ALL 进行查询，也就是全表扫描的方式查询，那么这时执行器与存储引擎的执行流程是这样的：</p><ul><li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，<strong>让存储引擎读取表中的第一条记录</strong>；</li><li>执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；<strong>如果是则将记录发给客户</strong>（是的没错，S<u>erver 层每从存储引擎读到一条记录就会发送给客户端</u>，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）。</li><li>执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 all，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；</li><li>一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息；</li><li>执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。</li></ul><p>至此，这个语句就执行完成了</p><ol start="3"><li><strong>索引下推</strong></li></ol><p>索引下推能够减少<strong>二级索引</strong>在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。</p><p>「<strong>索引下推暂时不必了解</strong>」</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>​执行一条 SQL 查询语句，期间发生了什么？</p><ul><li>连接器：建立连接，管理连接、校验用户身份；</li><li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li><li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li><li>执行 SQL：执行 SQL 共有三个阶段：<ul><li>预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。</li><li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li><li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li></ul></li></ul><h3 id="引擎分类："><a href="#引擎分类：" class="headerlink" title="引擎分类："></a>引擎分类：</h3><h4 id="MySQL存储引擎有哪些？"><a href="#MySQL存储引擎有哪些？" class="headerlink" title="MySQL存储引擎有哪些？"></a>MySQL存储引擎有哪些？</h4><ul><li>InnoDB</li><li>MyISAM</li><li>……(上面两款最常用)</li></ul><h4 id="Innodb-和-MyISAM-存储引擎有什么区别？"><a href="#Innodb-和-MyISAM-存储引擎有什么区别？" class="headerlink" title="Innodb 和 MyISAM 存储引擎有什么区别？"></a>Innodb 和 MyISAM 存储引擎有什么区别？</h4><h5 id="1-磁盘文件的对比"><a href="#1-磁盘文件的对比" class="headerlink" title="1. 磁盘文件的对比"></a>1. 磁盘文件的对比</h5><p>创建两张表：zz_myisam_index、zz_innodb_index，分别使用了不同的引擎</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728163011906.png" alt="image-20230728163011906"></p><h6 id="1-1-使用MyISAM引擎的表"><a href="#1-1-使用MyISAM引擎的表" class="headerlink" title="1.1 使用MyISAM引擎的表"></a>1.1 使用MyISAM引擎的表</h6><p>zz_myisam_index这张表是使用MyISAM引擎的表，在磁盘中有三个文件：</p><ul><li>zz_myisam_index.frm：该文件中<strong>存储表的结构信息</strong>。</li><li>zz_myisam_index.MYD：该文件中<strong>存储表的行数据</strong>。</li><li>zz_myisam_index.MYI：该文件中<strong>存储表的索引数据</strong>。</li></ul><h6 id="1-2-使用InnoDB引擎的表"><a href="#1-2-使用InnoDB引擎的表" class="headerlink" title="1.2 使用InnoDB引擎的表"></a>1.2 使用InnoDB引擎的表</h6><p>zz_innodb_index这张表是使用InnoDB引擎的表，在磁盘中仅有两个文件：</p><ul><li>zz_innodb_index.frm：该文件中存储表的<strong>结构信息</strong>。</li><li>zz_innodb_index.ibd：该文件中存储表的<strong>行数据和索引数据</strong>。</li></ul><h5 id="2-索引支持的对比"><a href="#2-索引支持的对比" class="headerlink" title="2.索引支持的对比"></a>2.索引支持的对比</h5><ul><li>因为MyISAM引擎在设计之初，会将表分为.frm、.MYD、.MYI三个文件放在磁盘存储，<strong>表数据和索引数据是分别放在.MYD、.MYI文件中</strong>，所以注定了<u>MyISAM引擎只支持非聚簇索引</u>。</li><li>而InnoDB引擎的<strong>表数据、索引数据都放在.ibd文件中存储</strong>，因此<u>InnoDB是支持聚簇索引</u>的。</li></ul><p><strong>聚簇索引的要求</strong>是：索引键和行数据必须在物理空间上也是连续的，而MyISAM表数据和索引数据，分别位于两个磁盘文件中，这也就注定了它无法满足聚簇索引的要求。</p><p>但<strong>不支持聚簇索引也有好处</strong>，也就是<u>无论走任何索引，都只需要一遍查询即可获得数据</u>，而InnoDB引擎的表中，<u>如果不走聚簇（主键）索引查询数据，走其他索引的情况下，都需要经过两遍（回表）查询才能获得数据。</u></p><h5 id="3-事务机制的对比"><a href="#3-事务机制的对比" class="headerlink" title="3.事务机制的对比"></a>3.事务机制的对比</h5><ul><li><strong>InnoDB引擎中有两个自己专享的日志，即 undo-log、redo-log</strong>，使用InnoDB存储引擎的表，可以借助undo-log日志实现事务机制，支持多条SQL组成一个事务，可以保证发生异常的情况下，组成这个事务的SQL到底回滚还是提交。</li><li>而MyISAM并未设计类似的技术，在启动时不会在内存中构建undo_log_buffer缓冲区，磁盘中也没有相应的日志文件，因此MyISAM并<strong>不支持事务机制</strong></li></ul><p>&#x3D;&#x3D;&#x3D;&#x3D;&gt; 一个引擎是否支持事务，这点尤为重要</p><h5 id="4-故障恢复的对比"><a href="#4-故障恢复的对比" class="headerlink" title="4.故障恢复的对比"></a>4.故障恢复的对比</h5><ul><li>InnoDB在启动时，同样会在内存中构建一个redo_log_buffer缓冲区，在磁盘中也会有相应的redo-log日志文件，所以当一条或多条SQL语句执行成功后，不论MySQL在何时宕机，<strong>只要这个事务提交了，InnoDB引擎都能确保该事务的数据不会丢失，也就以此保障了事务的持久性。</strong></li><li>但MyISAM引擎同样<strong>没有redo-log日志，所以并不支持数据的故障恢复</strong>，如果表是使用MyISAM引擎创建的，当一条SQL将数据写入到了缓冲区后，SQL还未被写到bin-log日志，此时机器断电、DB宕机了，重启之后由于数据在宕机前还未落盘，所以丢了也就无法找回。</li></ul><h5 id="5-锁粒度的对比"><a href="#5-锁粒度的对比" class="headerlink" title="5.锁粒度的对比"></a>5.锁粒度的对比</h5><p>MyISAM仅支持表锁，而InnoDB同时支持表锁、行锁，但为啥MyISAM引擎不支持行锁呢？不是不想，而是做不到!</p><p>—-由于MyISAM每个索引都会对应一棵B+树，那么对可能导致基于不同索引查询数据时，可能会导致一行数据上加多个锁，导致锁失效。</p><h5 id="6-并发性能的对比"><a href="#6-并发性能的对比" class="headerlink" title="6.并发性能的对比"></a>6.并发性能的对比</h5><p>​MyISAM仅支持表锁，InnoDB同时支持表锁、行锁，由于这点原因，其实<strong>InnoDB引擎的并发支持性早已远超MyISAM了，毕竟锁的粒度越小，并发冲突的概率也就越低，因此并发支撑就越高。</strong></p><h5 id="7-内存利用度的对比"><a href="#7-内存利用度的对比" class="headerlink" title="7.内存利用度的对比"></a>7.内存利用度的对比</h5><p>InnoDB引擎的创始人Heikki Tuuri早早想到了这点，通过缓冲池结合异步IO技术，活生生将一款基于磁盘的引擎，演变成了半内存式的引擎。反观MyISAM引擎，内部虽然也有缓冲池以及异步IO技术，但对内存的开发度远不足于InnoDB引擎，运行期间大量操作依旧会走磁盘完成。</p><p>—-InnoDB引擎的内存利用率很高</p><h4 id="🌟为什么InnoDB代替了MyISAM？"><a href="#🌟为什么InnoDB代替了MyISAM？" class="headerlink" title="🌟为什么InnoDB代替了MyISAM？"></a>🌟为什么InnoDB代替了MyISAM？</h4><p>①存储方式：<code>MyISAM</code>引擎会将表数据和索引数据分成两个文件存储。</p><p>②索引支持：因为<code>MyISAM</code>引擎的表数据和索引数据是分开的，因此不支持聚簇索引。</p><p>③事务支持：由于<code>MyISAM</code>引擎没有<code>undo-log</code>日志，所以不支持多条<code>SQL</code>组成事务并回滚。</p><p>④故障恢复：<code>MyISAM</code>引擎依靠<code>bin-log</code>日志实现，<code>bin-log</code>中未写入的数据会永久丢失。</p><p>⑤锁粒度支持：因为<code>MyISAM</code>不支持聚簇索引，因此无法实现行锁，所有并发操作只能加表锁。</p><p>⑥并发性能：<code>MyISAM</code>引擎仅支持表锁，所以多条线程出现读-写并发场景时会阻塞。</p><p>⑦内存利用度：<code>MyISAM</code>引擎过于依赖<code>MySQL Server</code>，对缓冲池、异步<code>IO</code>技术开发度不够。</p><h4 id="MyISAM引擎的可取之处："><a href="#MyISAM引擎的可取之处：" class="headerlink" title="MyISAM引擎的可取之处："></a>MyISAM引擎的可取之处：</h4><ol><li><p>统计总数的优化：</p><p>仅仅是对于<code>select count(*) from table_name;</code>这条语句，MyISAM引擎有更好的表现——因为其维护了一个变量——其存储了表中的记录总数，仅此而已，上述语句添加任何条件都会原形毕露。</p></li><li><p>删除数据&#x2F;表的优化：</p></li></ol><p>​当使用<code>delete</code>命令清空表数据时，<code>MyISAM</code>会直接<strong>重新创建表数据文件</strong>，而<code>InnoDB</code>则是一行行删除数据，因此对于清空表数据的操作，<code>MyISAM</code>比<code>InnoDB</code>快上无数倍。</p><p>​同时<code>MyISAM</code>引擎的表，对于<code>delete</code>过的数据不会立即删除，而且先隐藏起来，后续定时删除或手动删除，</p><ol start="3"><li>CRUD速度更快</li></ol><p>​<code>InnoDB</code>的聚簇索引，会影响读写数据的性能：基于非聚簇索引查找数据，就算查到了也需要经过一次回表才能得到数据，同时插入数据、修改数据时，都需要维护聚簇索引和非聚簇索引之间的关系</p><p>​而<code>MyISAM</code>引擎中，所有已创建的索引都是非聚簇索引，每个索引之间都是独立的，在索引中存储的是直接指向行数据的地址，而并非聚簇索引的索引键，因此无论走任何索引，都仅需一次即可获得数据，无需做回表查询。</p><p><strong>but</strong>：以单连接的方式测试，确实<code>MyISAM</code>会远超<code>InnoDB</code>，毕竟单个连接意味着只有一条线程，一条线程就不会出现锁竞争，表锁会一直由这条线程持有。但是在多连接的情况下，由于MyISAM只支持表锁，因此性能会大大降低，远低于InnoDB！</p><h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h1><h3 id="一行记录的存储格式"><a href="#一行记录的存储格式" class="headerlink" title="一行记录的存储格式"></a>一行记录的存储格式</h3><h4 id="MySQL-的数据存放在哪个文件？"><a href="#MySQL-的数据存放在哪个文件？" class="headerlink" title="MySQL 的数据存放在哪个文件？"></a>MySQL 的数据存放在哪个文件？</h4><p>—-MySQL 存储的行为是由存储引擎实现的，MySQL 支持多种存储引擎，<strong>不同的存储引擎保存的文件自然也不同</strong></p><p>本小节针对InnoDB展开讨论：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 我们可以在MySQL中使用下面的指令来获取mysql存储表信息的路径，所有的表结构和表数据都会在这个文件中</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;datadir&#x27;</span>;</span><br></pre></td></tr></table></figure><p>进入该目录，mysql中的每个数据库都会在该目录中对应一个子目录，进入数据库对应的子目录，我们发现其中结构为：</p><ul><li><strong>db.opt</strong> : 存放当前数据库的默认字符集和字idb符校验规则</li><li><strong>表名.frm</strong> : <strong>表结构</strong>会保存在这个文件。在 <u>MySQL 中建立一张表都会生成一个.frm 文件</u>，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。 </li><li><strong>表名.ibd</strong> : <strong>表数据</strong>会保存在这个文件，InnoDB引擎默认将每个表的<u>数据</u>分开存放， <strong>表名.ibd 文件也称为独占表空间文件</strong></li></ul><h5 id="表空间文件-存放表中数据的文件-的结构是怎么样的？"><a href="#表空间文件-存放表中数据的文件-的结构是怎么样的？" class="headerlink" title="表空间文件(存放表中数据的文件)的结构是怎么样的？"></a>表空间文件(存放表中数据的文件)的结构是怎么样的？</h5><p>​<strong>表空间由段（segment）、区（extent）、页（page）、行（row）组成</strong>，InnoDB存储引擎的逻辑存储结构大致如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730144124140.png" alt="image-20230730144124140"></p><h6 id="1、行（row）"><a href="#1、行（row）" class="headerlink" title="1、行（row）"></a>1、行（row）</h6><p>数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。</p><h6 id="2、页（page）"><a href="#2、页（page）" class="headerlink" title="2、页（page）"></a>2、页（page）</h6><p>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I&#x2F;O 操作）只能处理一行数据，效率会非常低。</p><p>因此，<strong>InnoDB 的数据是按「页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。</p><p><strong>默认每个页的大小为 16KB</strong>，也就是最多能保证 16KB 的连续存储空间。</p><p>页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p><h6 id="3、区（extent）"><a href="#3、区（extent）" class="headerlink" title="3、区（extent）"></a>3、区（extent）</h6><p>我们知道 InnoDB 存储引擎是用 B+ 树来组织数据的。</p><p>B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I&#x2F;O，随机 I&#x2F;O 是非常慢的。</p><p>解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I&#x2F;O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。</p><p>那具体怎么解决呢？</p><p><strong>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I&#x2F;O 了</strong>。</p><h6 id="4、段（segment）"><a href="#4、段（segment）" class="headerlink" title="4、段（segment）"></a>4、段（segment）</h6><p>表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。</p><ul><li><strong>索引段</strong>：存放 B + 树的非叶子节点的区的集合；</li><li><strong>数据段</strong>：存放 B + 树的叶子节点的区的集合；</li><li><strong>回滚段</strong>：存放的是回滚数据的区的集合；</li></ul><h4 id="InnoDB-行格式学习："><a href="#InnoDB-行格式学习：" class="headerlink" title="InnoDB 行格式学习："></a>InnoDB 行格式学习：</h4><p><u>行格式（row_format），就是一条记录的存储结构。</u></p><p><strong>COMPACT行格式</strong>——是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。</p><p>其他行格式要么就是太落后已经被淘汰、要么就是在COMPACT格式上进行增强，所以选择了解<strong>COMPACT</strong>行格式。</p><h5 id="COMPACT行格式："><a href="#COMPACT行格式：" class="headerlink" title="COMPACT行格式："></a>COMPACT行格式：</h5><p>​<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730145223318.png" alt="image-20230730145223318"></p><h6 id="1-变长字段长度列表"><a href="#1-变长字段长度列表" class="headerlink" title="1. 变长字段长度列表"></a>1. 变长字段长度列表</h6><ul><li><p>「变长字段长度列表」只出现在<strong>数据表有变长字段的时候</strong></p></li><li><p>根据列的顺序，<strong>逆序</strong>存放每条记录中各个变长字段的真实长度</p></li></ul><p>— 🌟为什么要逆序？</p><ol><li><p>「记录头信息」中指向下一个记录的指针，指向的是下一条记录的<strong>「记录头信息」和「真实数据」之间的位置</strong>，这样向左读就是记录头信息，向右读就是真实数据，比较方便。</p></li><li><p>「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以<strong>使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率</strong>。</p></li><li><p>🧠<u><em>通俗易懂，但不准确的说明</em></u>： 你初始指向的是中间的位置，往左一格更容易读到字段长度信息，往右一格能够读到该字段的真实数据信息(从中间向两边扩张地读取，更容易实现现在同义词指针移动，读到同一字段的数据 &amp; 长度信息)</p></li></ol><p>同样的道理， NULL 值列表的信息也需要逆序存放。</p><h6 id="2-NULL-值列表"><a href="#2-NULL-值列表" class="headerlink" title="2. NULL 值列表"></a>2. NULL 值列表</h6><p>NULL 值列表也不是必须的。</p><p><strong>当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了</strong>。</p><p>所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）。</p><p>表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中。</p><p><u>如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit）</u>，二进制位<strong>按照列的顺序<u>逆序</u>排列</strong>。</p><ul><li>二进制位的值为<code>1</code>时，代表该列的值为NULL</li><li>二进制位的值为<code>0</code>时，代表该列的值不为NULL</li></ul><p>NULL 值列表必须用整数个字节的位表示（1字节8位），<strong>如果使用的二进制位个数不足整数个字节，则在字节的高位补 0</strong>——–&gt;意思就是，如果你的允许为null的字段数量不足8的倍数，也会开辟 8 的倍数的空间来存储(高位补0)，即InnoDB的基本存储单元为1B</p><h6 id="3-记录头信息"><a href="#3-记录头信息" class="headerlink" title="3. 记录头信息"></a>3. 记录头信息</h6><p>记录头信息中包含的内容很多，举例几个比较重要的：</p><ul><li><strong>delete_mask</strong> ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。</li><li><strong>next_record</strong>：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</li><li><strong>record_type</strong>：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</li></ul><h6 id="4-记录的真实数据"><a href="#4-记录的真实数据" class="headerlink" title="4. 记录的真实数据"></a>4. 记录的真实数据</h6><p>​记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别为：<strong>row_id、trx_id、roll_pointer</strong>，我们来看下这三个字段是什么。</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730152307044.png" alt="image-20230730152307044"></p><ul><li>row_id</li></ul><p>​如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id<strong>不是必需的</strong>，占用 6 个字节。</p><p>​没有主键或唯一约束列时，会自动帮你生成一个隐藏主键(疑问🤔️：用于聚簇索引？)</p><ul><li>trx_id</li></ul><p>​事务id，表示<strong>这个数据是由哪个事务生成的</strong>。 trx_id是<strong>必需的</strong>，占用 6 个字节。</p><ul><li>roll_pointer</li></ul><p>​<strong>这条记录上一个版本的指针</strong>。roll_pointer 是<strong>必需的</strong>，占用 7 个字节。</p><h4 id="varchar-n-中-n-最大取值为多少？"><a href="#varchar-n-中-n-最大取值为多少？" class="headerlink" title="varchar(n) 中 n 最大取值为多少？"></a>varchar(n) 中 n 最大取值为多少？</h4><p>我们要清楚一点，<strong>MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度<u>加起来</u>不能超过 65535 个字节</strong>。</p><p>也就是说，一行记录除了 TEXT、BLOBs 类型的列，限制最大为 65535 字节，<u>注意是一行的总长度</u>，不是一列。</p><p>知道了这个前提之后，我们再来看看这个问题：「varchar(n) 中 n 最大取值为多少？」</p><p>varchar(n) 字段类型的 n 代表的是最多存储的字符数量，并不是字节大小哦。</p><p>要算 varchar(n) 最大能允许存储的字节数，还要看数据库表的字符集，因为字符集代表着，1个字符要占用多少字节，比如 ascii 字符集， 1 个字符占用 1 字节，那么 varchar(100) 意味着最大能允许存储 100 字节的数据。</p><p>答：一条记录所有字段的「真实数据 + 变长字段长度列表 + NULL值列表」长度和 &lt;&#x3D; 65535 B</p><h4 id="行溢出后，MySQL-是怎么处理的？"><a href="#行溢出后，MySQL-是怎么处理的？" class="headerlink" title="行溢出后，MySQL 是怎么处理的？"></a>行溢出后，MySQL 是怎么处理的？</h4><p>MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 <code>16KB</code>，也就是 <code>16384字节</code>，而一个 varchar(n) 类型的列最多可以存储 <code>65532字节</code>，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会<strong>发生行溢出，多的数据就会存到另外的「溢出页」中</strong>。</p><p>🌟当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。大致如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730153621037.png" alt="image-20230730153621037"></p><p>注意：Compressed 和 Dynamic 这两种行格式(COMPACT的改进版)，它们对于行溢出的处理为：</p><ul><li>采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，<strong>只存储 20 个字节的指针来指向溢出页！而实际的数据都存储在溢出页中；</strong></li></ul><h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><h5 id="MySQL-的-NULL-值是怎么存放的？"><a href="#MySQL-的-NULL-值是怎么存放的？" class="headerlink" title="MySQL 的 NULL 值是怎么存放的？"></a>MySQL 的 NULL 值是怎么存放的？</h5><p>​MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。</p><p>​NULL值列表会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。</p><h5 id="MySQL-怎么知道-varchar-n-实际占用数据的大小？"><a href="#MySQL-怎么知道-varchar-n-实际占用数据的大小？" class="headerlink" title="MySQL 怎么知道 varchar(n) 实际占用数据的大小？"></a>MySQL 怎么知道 varchar(n) 实际占用数据的大小？</h5><p>​MySQL 的 Compact 行格式中会用「变长字段长度列表」存储变长字段实际占用的数据大小。</p><h5 id="varchar-n-中-n-最大取值为多少？-1"><a href="#varchar-n-中-n-最大取值为多少？-1" class="headerlink" title="varchar(n) 中 n 最大取值为多少？"></a>varchar(n) 中 n 最大取值为多少？</h5><p>​所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;&#x3D; 65535。</p><h5 id="行溢出后，MySQL-是怎么处理的？-1"><a href="#行溢出后，MySQL-是怎么处理的？-1" class="headerlink" title="行溢出后，MySQL 是怎么处理的？"></a>行溢出后，MySQL 是怎么处理的？</h5><p>​存到溢出页中，真实数据区存放溢出页地址(非完全行溢出方式、完全行溢出方式)</p><h3 id="char和varchar"><a href="#char和varchar" class="headerlink" title="char和varchar"></a>char和varchar</h3><h4 id="存储机制区别："><a href="#存储机制区别：" class="headerlink" title="存储机制区别："></a>存储机制区别：</h4><ul><li><strong>最大长度</strong>：char是255，varchar是65535，单位是字符（而不是字节）。</li><li><strong>尾随空格</strong>：char会将尾随空格去掉，而varchar不会。<br>因为存储时，char会用空格填充至指定长度，所以取出时需要去除空格。如果char字段有唯一索引，<code>a</code> 和 <code>a空格</code> 会提示唯一索引冲突。</li><li><strong>存储空间占用</strong>：<u>varchar会占用额外的1~2字节来<strong>存储字符串长度</strong></u>。如果最大长度超过255，就需要2字节，否则1字节。</li></ul><h4 id="性能差异："><a href="#性能差异：" class="headerlink" title="性能差异："></a>性能差异：</h4><p>从char和varchar的存储结构对比，可以得出一个结论：<strong>char填充空格可能导致浪费存储空间，进而导致性能下降</strong>。因为char多存储一些空格，意味着需要<u>从磁盘读写更多的数据、耗费更多内存、查找数据时删除空格可能也会耗费一些CPU性能</u>。</p><p><strong>大部分情况下，varchar的性能优于char，最好使用varchar。</strong></p><p>不过考虑一个极端的场景：某个字段的最大长度是100字节，但是会频繁修改。如果使用<code>char(100)</code>，则插入记录后就分配了100个字节，后续修改不会造成页分裂、页空隙等问题，而<code>varchar(100)</code>由于没有提前分配存储空间，后续修改时可能出现页分裂，进而导致性能下降。</p><h3 id="数据页"><a href="#数据页" class="headerlink" title="数据页"></a>数据页</h3><h4 id="InnoDB-是如何存储数据的？"><a href="#InnoDB-是如何存储数据的？" class="headerlink" title="InnoDB 是如何存储数据的？"></a>InnoDB 是如何存储数据的？</h4><p>——按行存储数据，但是读取数据时，一次会读取目标行所在的整列</p><p>数据库的 I&#x2F;O 操作的最小单位是页，<strong>InnoDB 数据页的默认大小是 16KB</strong>，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p><p>数据页包括七个部分，结构如下图：</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731110101701.png" alt="image-20230731110101701" style="zoom: 33%;" /><p><strong>说明：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731110642767.png" alt="image-20230731110642767"></p><h5 id="File-Header："><a href="#File-Header：" class="headerlink" title="File Header："></a>File Header：</h5><p>在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731110737757.png" alt="image-20230731110737757"></p><p>采用链表的结构是让数据页之间不需要是物理上的连续的，而是逻辑上的连续。</p><h5 id="User-Records："><a href="#User-Records：" class="headerlink" title="User Records："></a>User Records：</h5><p><strong>数据页中的记录按照「主键」顺序组成单向链表</strong>，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。</p><p>因此，数据页中有一个<strong>页目录</strong>，起到记录的索引作用，就像我们书那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。</p><h5 id="Page-Directory："><a href="#Page-Directory：" class="headerlink" title="Page Directory："></a>Page Directory：</h5><p>页目录创建的过程如下：</p><ol><li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；</li><li><u>每个记录组的最后一条记录就是组内最大的那条记录</u>，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段</li><li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），<strong>每个槽相当于指针指向了不同组的最后一个记录</strong>。</li></ol><p><strong>页目录就是由多个槽组成的，槽相当于分组记录的索引</strong>。然后，因为记录是按照「主键值」从小到大排序的，所以<strong>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个页中的记录链表。</p><p>举个例子，5 个槽的编号分别为 0，1，2，3，4，我想查找主键为 11 的用户记录：</p><ul><li>先二分得出槽中间位是 (0+4)&#x2F;2&#x3D;2 ，2号槽里最大的记录为 8。因为 11 &gt; 8，所以需要从 2 号槽后继续搜索记录；</li><li>再使用二分搜索出 2 号和 4 槽的中间位是 (2+4)&#x2F;2&#x3D; 3，3 号槽里最大的记录为 12。因为 11 &lt; 12，所以主键为 11 的记录在 3 号槽里；</li><li>这里有个问题，<strong>「槽对应的值都是这个组的主键最大的记录，如何找到组里最小的记录」</strong>？<ul><li>找前一个槽最大记录+1即可</li></ul></li></ul><p>看到第三步的时候，可能有的同学会疑问，如果某个槽内的记录很多，然后因为记录都是单向链表串起来的，那这样在槽内查找某个记录的时间复杂度不就是 O(n) 了吗？</p><p>这点不用担心，InnoDB 对每个分组中的记录条数都是有规定的，槽内的记录就只有几条：</p><ul><li>第一个分组中的记录只能有 1 条记录；</li><li>最后一个分组中的记录条数范围只能在 1-8 条之间；</li><li>剩下的分组中记录条数范围只能在 4-8 条之间。</li></ul><h5 id="总结——单数据页内的查询步骤："><a href="#总结——单数据页内的查询步骤：" class="headerlink" title="总结——单数据页内的查询步骤："></a>总结——单数据页内的查询步骤：</h5><p>上面我们都是在说一个数据页中的记录检索，因为一个数据页中的记录是有限的，且主键值是有序的，所以通过对所有记录进行分组，然后将组号（槽号）存储到页目录，使其起到索引作用，通过二分查找的方法快速检索到记录在哪个分组，来降低检索的时间复杂度。</p><h4 id="B-树是如何进行查询的？"><a href="#B-树是如何进行查询的？" class="headerlink" title="B+ 树是如何进行查询的？"></a>B+ 树是如何进行查询的？</h4><p>当我们需要存储大量的记录时，就需要多个数据页。<strong>InnoDB 采用了 B+ 树作为索引</strong>。磁盘的 I&#x2F;O 操作次数对索引的使用效率至关重要，因此在构造索引的时候，我们更倾向于采用“矮胖”的 B+ 树数据结构，这样所需要进行的磁盘 I&#x2F;O 次数更少，而且 B+ 树 更适合进行关键字的范围查询。</p><p>InnoDB 里的 B+ 树中的<strong>每个节点都是一个数据页</strong>，结构示意图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731111828591.png" alt="image-20230731111828591"></p><p>通过上图，我们看出 B+ 树的特点：</p><ul><li><u>只有叶子节点（最底层的节点）才存放了数据</u>，非叶子节点（其他上层节）仅用来存放目录项作为索引。</li><li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li><li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</li></ul><p>🌰我们再看看 B+ 树如何实现快速查找主键为 6 的记录，以上图为例子：</p><ul><li>从根节点开始，通过二分法快速定位到符合页内范围包含查询值的页，因为查询的主键值为 6，在[1, 7)范围之间，所以到页 30 中查找更详细的目录项；</li><li>在非叶子节点（页30）中，继续通过二分法快速定位到符合页内范围包含查询值的页，主键值大于 5，所以就到叶子节点（页16）查找记录；</li><li>接着，在叶子节点（页16）中，通过槽查找记录时，使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到主键为 6 的记录。</li></ul><p>🌟<strong>可以看到，在定位记录所在哪一个页时，也是通过二分法快速定位到包含该记录的页。定位到该页后，又会在该页内进行二分法快速定位记录所在的分组（槽号），最后在分组内进行遍历查找。</strong></p><h5 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h5><ol><li><p>构建数据页的B+树</p><ol start="2"><li>将要查询的主键值与B+树节点的最大、最小记录比较，进行二分查找，找到记录所在的数据页</li><li>在数据页中，再使用二分查找找到记录在哪个槽，在槽中顺序遍历找到结果</li></ol></li></ol><h4 id="聚簇索引和二级索引"><a href="#聚簇索引和二级索引" class="headerlink" title="聚簇索引和二级索引"></a>聚簇索引和二级索引</h4><p>另外，索引又可以分成聚簇索引和非聚簇索引（二级索引），它们<strong>区别就在于叶子节点存放的是什么数据</strong>：</p><ul><li><u>聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点</u>；(InnoDB,索引与数据都存在.idb文件中)</li><li>二级索引的叶子节点存放的是主键值，而不是实际数据。</li></ul><p>因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。</p><p>InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用<strong>主键</strong>作为聚簇索引的索引键；</li><li>如果没有主键，就选择第一个<strong>不包含 NULL 值的唯一列</strong>作为聚簇索引的索引键；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个<strong>隐式自增 id 列</strong>作为聚簇索引的索引键；</li></ul><p>一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了<u>二级索引（非聚簇索引&#x2F;辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。</u></p><p>二级索引的 B+ 树如下图，数据部分为主键值：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731112821532.png" alt="image-20230731112821532"></p><p>因此，<strong>如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。</strong></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>InnoDB 的数据是按「数据页」为单位来读写的，默认数据页大小为 16 KB。每个数据页之间通过双向链表的形式组织起来，物理上不连续，但是逻辑上连续。</li><li>数据页内包含用户记录，每个记录之间用单向链表的方式组织起来，为了加快在数据页内高效查询记录，设计了一个页目录，页目录存储各个槽（分组），且主键值是有序的，于是可以通过二分查找法的方式进行检索从而提高效率。</li><li>为了高效查询记录所在的数据页，InnoDB 采用 b+ 树作为索引，每个节点都是一个数据页。</li><li>如果叶子节点存储的是实际数据的就是聚簇索引，一个表只能有一个聚簇索引；如果叶子节点存储的不是实际数据，而是主键值则就是二级索引，一个表中可以有多个二级索引。</li><li>在使用二级索引进行查找数据时，如果查询的数据能在二级索引找到，那么就是「索引覆盖」操作，如果查询的数据不在二级索引里，就需要先在二级索引找到主键值，需要去聚簇索引中获得数据行，这个过程就叫作「回表」。</li></ul><p>本博客对以下文章有参考借鉴，十分感谢这些作者的文章🙏：</p><ul><li>执行一条 select 语句，期间发生了什么？<a href="https://xiaolincoding.com/mysql/base/how_select.html)https://xiaolincoding.com/mysql/base/how_select.html">https://xiaolincoding.com/mysql/base/how_select.html)https://xiaolincoding.com/mysql/base/how_select.html</a></li><li>MySQL引擎篇：<a href="https://juejin.cn/post/7151275584218202143">https://juejin.cn/post/7151275584218202143</a></li><li>MySQL 一行记录是怎么存储的？<a href="https://xiaolincoding.com/mysql/base/row_format.html">https://xiaolincoding.com/mysql/base/row_format.html</a></li><li>MySQL中char与varchar的区别：存储机制、性能差异<a href="https://www.maoyingdong.com/mysql-char-vs-varchar/">https://www.maoyingdong.com/mysql-char-vs-varchar/</a></li><li>从数据页的角度看 B+ 树<a href="https://xiaolincoding.com/mysql/index/page.html">https://xiaolincoding.com/mysql/index/page.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2023/07/27/SpringMVC/"/>
      <url>/2023/07/27/SpringMVC/</url>
      
        <content type="html"><![CDATA[<p>本博客是根据韩顺平老师的SpingMVC课程进行的知识总结！</p>]]></content>
      
      
      <categories>
          
          <category> Spring开发框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实操中遇到的后端开发相关问题与解决方案</title>
      <link href="/2023/07/24/%E5%AE%9E%E6%93%8D%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2023/07/24/%E5%AE%9E%E6%93%8D%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="java："><a href="#java：" class="headerlink" title="java："></a>java：</h1><h3 id="流的使用："><a href="#流的使用：" class="headerlink" title="流的使用："></a>流的使用：</h3><ol><li>需求：将得到的对象List 根据某一属性进行分组(例如你需要根据分别对产品id的每种情况进行讨论)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 用于存储从每条记录中得到的有效信息</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InfoDTO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long equipmentId;</span><br><span class="line">    <span class="keyword">private</span> Boolean isSuccess;</span><br><span class="line">    <span class="keyword">private</span> Date actingTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InfoDTO</span><span class="params">(Long equipmentId, Date actingTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.equipmentId = equipmentId;</span><br><span class="line">        <span class="built_in">this</span>.actingTime = actingTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InfoDTO</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ArrayList&lt;InfoDTO&gt; successInfo = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//填充successInfo，此处省略       </span></span><br><span class="line">Map&lt;Long,List&lt;InfoDTO&gt;&gt; groupedList = successInfo.stream().collect(Collectors.groupingBy(InfoDTO::getEquipmentId));</span><br></pre></td></tr></table></figure><h1 id="数据库："><a href="#数据库：" class="headerlink" title="数据库："></a>数据库：</h1><h3 id="动态查询："><a href="#动态查询：" class="headerlink" title="动态查询："></a>动态查询：</h3><h5 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h5><p>​有许多同类型的表(表名前缀相同，都是类似于xxxx202209 –&gt; 公共前缀+年月信息)，由于数据量庞大按月份分成了多张表，我们需要根据前端请求中携带的年月信息去查询不同的表</p><h5 id="实现方案："><a href="#实现方案：" class="headerlink" title="实现方案："></a>实现方案：</h5><p>​使用拦截器，(按照我目前的理解。。)对数据库查询语句进行拦截，当查询表名为公共前缀时，就获取请求头传来的日期信息，凭借成完整的表名，去对应的表中查询！</p><h5 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.springbootinit.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.DynamicTableNameInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> miemie</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018-08-10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.nrec.springbootinit.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="type">DynamicTableNameInnerInterceptor</span> <span class="variable">dynamicTableNameInnerInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicTableNameInnerInterceptor</span>();</span><br><span class="line">        dynamicTableNameInnerInterceptor.setTableNameHandler((sql, tableName) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;这里填哪些相同结构表名的公共前缀&quot;</span>.equals(tableName)) &#123;</span><br><span class="line">              <span class="comment">//这里，我在controller中，用户请求时，就将date信息存放在请求参数传递辅助类的 map 中，因此在这里可以获取</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">dateSuf</span> <span class="operator">=</span> RequestDataHelper.getRequestData(<span class="string">&quot;date&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;公共前缀&quot;</span> + dateSuf;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//如果不是我要查询的表，那么就还是按原来的表名查询</span></span><br><span class="line">                <span class="keyword">return</span> tableName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        interceptor.addInnerInterceptor(dynamicTableNameInnerInterceptor);</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.xxx.springbootinit.config;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.toolkit.CollectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求参数传递辅助类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDataHelper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求参数存取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; REQUEST_DATA = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置请求参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestData 请求参数 MAP 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setRequestData</span><span class="params">(Map&lt;String, Object&gt; requestData)</span> &#123;</span><br><span class="line">        REQUEST_DATA.set(requestData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取请求参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param 请求参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 请求参数 MAP 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getRequestData</span><span class="params">(String param)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; dataMap = getRequestData();</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(dataMap)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) dataMap.get(param);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取请求参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 请求参数 MAP 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title function_">getRequestData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> REQUEST_DATA.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//controller层示例接口：</span></span><br><span class="line"> <span class="meta">@GetMapping(&quot;/query&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResultDTO <span class="title function_">query</span><span class="params">(<span class="meta">@RequestParam(&quot;date&quot;)</span>String date)</span>&#123;</span><br><span class="line">        RequestDataHelper.setRequestData(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&quot;date&quot;</span>, date);&#125;&#125;);</span><br><span class="line">      <span class="comment">//继续写业务。。。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目开发 </tag>
            
            <tag> 经验总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2023/07/16/Spring/"/>
      <url>/2023/07/16/Spring/</url>
      
        <content type="html"><![CDATA[<p> 本博客参照了韩顺平老师的 Spring 课程讲义！</p><h1 id="1-Spring-基本介绍"><a href="#1-Spring-基本介绍" class="headerlink" title="1 Spring 基本介绍"></a>1 Spring 基本介绍</h1><h2 id="1-1-官方资料"><a href="#1-1-官方资料" class="headerlink" title="1.1 官方资料"></a>1.1 官方资料</h2><h3 id="1-1-1-官网-https-spring-io"><a href="#1-1-1-官网-https-spring-io" class="headerlink" title="1.1.1 官网 https://spring.io/"></a>1.1.1 官网 <a href="https://spring.io/">https://spring.io/</a></h3><h3 id="1-1-2-Spring5-下载"><a href="#1-1-2-Spring5-下载" class="headerlink" title="1.1.2 Spring5 下载"></a>1.1.2 Spring5 下载</h3><p>……</p><h3 id="1-1-3-在线文档-https-docs-spring-io-spring-framework-docs-current-reference-html"><a href="#1-1-3-在线文档-https-docs-spring-io-spring-framework-docs-current-reference-html" class="headerlink" title="1.1.3 在线文档: https://docs.spring.io/spring-framework/docs/current/reference/html/"></a>1.1.3 在线文档: <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/">https://docs.spring.io/spring-framework/docs/current/reference/html/</a></h3><h3 id="1-1-4-离线文档-解压-spring-5-3-8-dist-zipspring-framework-5-3-8-docs-reference-html-index-html"><a href="#1-1-4-离线文档-解压-spring-5-3-8-dist-zipspring-framework-5-3-8-docs-reference-html-index-html" class="headerlink" title="1.1.4 离线文档 : 解压 spring-5.3.8-dist.zipspring-framework-5.3.8\docs\reference\html\index.html"></a>1.1.4 离线文档 : 解压 spring-5.3.8-dist.zipspring-framework-5.3.8\docs\reference\html\index.html</h3><h3 id="1-1-5-离线API-解压-spring-5-3-8-dist-zipspring-framework-5-3-8-docs-javadoc-api-index-html"><a href="#1-1-5-离线API-解压-spring-5-3-8-dist-zipspring-framework-5-3-8-docs-javadoc-api-index-html" class="headerlink" title="1.1.5 离线API: 解压 spring-5.3.8-dist.zipspring-framework-5.3.8\docs\javadoc-api\index.html"></a>1.1.5 离线API: 解压 spring-5.3.8-dist.zipspring-framework-5.3.8\docs\javadoc-api\index.html</h3><h2 id="1-2-Spring-学习的核心内容"><a href="#1-2-Spring-学习的核心内容" class="headerlink" title="1.2 Spring 学习的核心内容"></a>1.2 Spring 学习的核心内容</h2><p>一图胜千言</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230716213809556.png" alt="image-20230716213809556"></p><p>老韩解读上图:</p><p>1、Spring 核心学习内容 IOC、AOP, jdbcTemplate, 声明式事务</p><p>2、IOC: 控制反转 , 可以管理 java 对象</p><p>3、AOP : 切面编程</p><p>4、 JDBCTemplate : 是 spring 提供一套访问数据库的技术, 应用性强，相对好理解</p><p>5、声明式事务: 基于 ioc&#x2F;aop 实现事务管理, 理解需要小伙伴花时间</p><p>6、IOC, AOP 是重点同时难点</p><h2 id="1-3-Spring-几个重要概念"><a href="#1-3-Spring-几个重要概念" class="headerlink" title="1.3 Spring 几个重要概念"></a>1.3 Spring 几个重要概念</h2><ol><li>Spring 可以整合其他的框架(老韩解读: Spring 是管理框架的框架)</li><li>Spring 有两个核心的概念: <strong>IOC</strong> 和 <strong>AOP</strong></li><li>IOC [Inversion Of Control 反转控制]</li></ol><h3 id="●-传统的开发模式-JdbcUtils-x2F-反射"><a href="#●-传统的开发模式-JdbcUtils-x2F-反射" class="headerlink" title="● 传统的开发模式[JdbcUtils &#x2F; 反射]"></a>● 传统的开发模式[JdbcUtils &#x2F; 反射]</h3><p>程序——&gt;环境 &#x2F;&#x2F;程序读取环境配置，然后自己创建对象.</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230716214351358.png" alt="image-20230716214351358"></p><p>老韩解读上图(以连接到数据库为例说明)</p><p>1、<strong>程序员编写程序, 在程序中读取配置信息</strong></p><p>2、**(程序员)创建对象**, new Object???() || 反射方式</p><p>3、使用对象完成任务</p><h3 id="●-IOC-的开发模式-EmpAction-EmpService-EmpDao-Emp"><a href="#●-IOC-的开发模式-EmpAction-EmpService-EmpDao-Emp" class="headerlink" title="● IOC 的开发模式 [EmpAction EmpService EmpDao Emp]"></a>● IOC 的开发模式 [EmpAction EmpService EmpDao Emp]</h3><p>程序&lt;—–容器 &#x2F;&#x2F;<strong>容器创建好对象，程序直接使用</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230716214640935.png" alt="image-20230716214640935"></p><p>老韩解读上图</p><p>1、<u>Spring 根据配置文件 xml || 注解, 创建对象</u>， 并放入到容器(如：ConcurrentHashMap)中,并且可以完成对象之间的依赖</p><p>2、**<u>当需要使用某个对象实例的时候, 就直接从容器中获取即可</u>**</p><p>3、程序员可以更加关注如何使用对象完成相应的业务  (以前是 new … &#x3D;&#x3D;&gt; 注解&#x2F;配置方式)</p><p>4、<strong>DI—Dependency Injection 依赖注入</strong>，可以理解成是 IOC 的另外叫法.</p><p>5、Spring最大的价值，通过配置，<strong>给程序提供需要使用的web 层</strong>[Servlet(Action&#x2F;Controller)]&#x2F;Service&#x2F;Dao&#x2F;[JavaBean&#x2F;entity]<strong>对象</strong>,这个是核心价值所在，也是 ioc 的具体体现, 实现了解耦</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230716220144385.png" alt="image-20230716220144385" style="zoom:50%;" /><h2 id="1-4-Spring-快速入门"><a href="#1-4-Spring-快速入门" class="headerlink" title="1.4 Spring 快速入门"></a>1.4 Spring 快速入门</h2><h3 id="1-4-1-需求说明"><a href="#1-4-1-需求说明" class="headerlink" title="1.4.1 需求说明"></a>1.4.1 需求说明</h3><ol><li>通过 Spring 的方式[配置文件]， 获取 JavaBean: Monster 的对象， 并给该的对象属性赋值， 输出该对象信息</li></ol><h3 id="1-4-2-完成步骤"><a href="#1-4-2-完成步骤" class="headerlink" title="1.4.2 完成步骤"></a>1.4.2 完成步骤</h3><p>……</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      1. 配置monster对象/javabean</span></span><br><span class="line"><span class="comment">      2. 在beans中可以配置多个bean</span></span><br><span class="line"><span class="comment">      3. bean表示就是一个java对象</span></span><br><span class="line"><span class="comment">      4. class属性是用于指定类的全路径-&gt;spring底层使用反射创建</span></span><br><span class="line"><span class="comment">      5. 🌟id属性表示该java对象在spring容器中的id, 通过id可以获取到对象</span></span><br><span class="line"><span class="comment">      6. &lt;property name=&quot;monsterId&quot; value=&quot;100&quot;&gt; 用于给该对象的属性赋值</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Monster&quot;</span> <span class="attr">id</span>=<span class="string">&quot;monster01&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monsterId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;牛魔王&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;skill&quot;</span> <span class="attr">value</span>=<span class="string">&quot;芭蕉扇&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Monster&quot;</span> <span class="attr">id</span>=<span class="string">&quot;monster02&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monsterId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1001&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;牛魔王~&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;skill&quot;</span> <span class="attr">value</span>=<span class="string">&quot;芭蕉扇~&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-3-注意事项和细节"><a href="#1-4-3-注意事项和细节" class="headerlink" title="1.4.3 注意事项和细节"></a>1.4.3 注意事项和细节</h3><h4 id="1、-说明"><a href="#1、-说明" class="headerlink" title="1、 说明"></a>1、 说明</h4><p>ClassPathXmlApplicationContext ioc &#x3D;new ClassPathXmlApplicationContext(“beans.xml”);</p><p>——为什么读取到 beans.xml</p><h4 id="2、解释一下类加载路径-可以给学员输出一下"><a href="#2、解释一下类加载路径-可以给学员输出一下" class="headerlink" title="2、解释一下类加载路径. 可以给学员输出一下:"></a>2、解释一下类加载路径. 可以给学员输出一下:</h4><p>&#x2F;&#x2F; 获取「<strong>类加载路径</strong>」</p><p>&#x2F;&#x2F; File f &#x3D; new File(this.getClass().getResource(“&#x2F;“).getPath());</p><p>&#x2F;&#x2F; System.out.println(f);</p><p>—输出——项目文件夹\工程名\out\production\工程名</p><h4 id="3、debug-看看-spring-容器结构-x2F-机制-记住你是-OOP-程序员-重要"><a href="#3、debug-看看-spring-容器结构-x2F-机制-记住你是-OOP-程序员-重要" class="headerlink" title="3、debug 看看 spring 容器结构&#x2F;机制, 记住你是 OOP 程序员,重要!"></a>3、debug 看看 spring 容器结构&#x2F;机制, 记住你是 OOP 程序员,重要!</h4><ul><li>老韩说明: 注意配置 debugger, 否则你看到的 debug 视图和老师不一样</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230717215641546.png" alt="image-20230717215641546"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230717215726473.png" alt="image-20230717215726473"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230717215817159.png" alt="image-20230717215817159"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230717215902732.png" alt="image-20230717215902732"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230717215925529.png" alt="image-20230717215925529"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230717220000530.png" alt="image-20230717220000530"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230717220027499.png" alt="image-20230717220027499"></p><h4 id="4、ioc-structure-summary："><a href="#4、ioc-structure-summary：" class="headerlink" title="4、ioc structure summary："></a>4、ioc structure summary：</h4><p>ioc容器(ClassPathXmlApplicationContext)：</p><p>——beanFactory(DefaultListableBeanFactory)</p><p>————beanDefinitionMap(ConcurrentHashMap)</p><p>——————table(ConcurrentHashMap$Node[512])</p><p>——————可以存放beans.xml中的bean节点配置的bean对象信息</p><p>——————<strong>key是 在beans.xml中配置的bean的id，value是这个bean的各种信息(如：属性、属性值、类信息、是不是懒加载等信息)</strong></p><p>————singletonObjects(ConcurrentHashMap)</p><p>——————table(ConcurrentHashMap$Node[512])</p><p>——————在beans.xml文件中配置的对象默认是单例的，会初始化在该table中；还有一些spring初始化的——————单例对象</p><p>————beanDefinitionNames(ArrayList)</p><p>————存放了beans.xml中，所有配置的bean的id，方便查看</p><p><strong>用户想要一个对象—&gt;先去beanDefinitionMap的table中找其定义的位置看看：如果是多例，则直接创建一个对象并返回；如果是单例的，则去singletonObjects的table中取出事先创建好的对象返回给用户</strong></p><h2 id="1-5-手动开发-简单的-Spring-基于-XML-配置的程序"><a href="#1-5-手动开发-简单的-Spring-基于-XML-配置的程序" class="headerlink" title="1.5 手动开发- 简单的 Spring 基于 XML 配置的程序"></a>1.5 手动开发- 简单的 Spring 基于 XML 配置的程序</h2><h3 id="1-5-1-需求说明"><a href="#1-5-1-需求说明" class="headerlink" title="1.5.1 需求说明"></a>1.5.1 需求说明</h3><ol><li><p>自己写一个简单的 Spring 容器, 通过读取 beans.xml， 获取第 1 个 JavaBean: Monster 的对象， 并给该的对象属性赋值， 放入到容器中, 输出该对象信息.</p></li><li><p>也就是说，不使用 Spring 原生框架，我们自己简单模拟实现</p></li><li><p>可以让小伙伴了解 Spring 容器的简单机制</p></li></ol><h3 id="1-5-2-思路分析"><a href="#1-5-2-思路分析" class="headerlink" title="1.5.2 思路分析"></a>1.5.2 思路分析</h3><ol><li>思路分析&#x2F;图解</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230718083350279.png" alt="image-20230718083350279"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.spring.hspapplicationcontext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.study.spring.bean.Monster;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 韩顺平</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 老师解读</span></span><br><span class="line"><span class="comment"> * 1. 这个程序用于实现Spring的一个简单容器机制</span></span><br><span class="line"><span class="comment"> * 2. 后面我们还会详细的实现</span></span><br><span class="line"><span class="comment"> * 3. 这里我们实现如何将beans.xml文件进行解析，并生成对象,放入容器中</span></span><br><span class="line"><span class="comment"> * 4. 提供一个方法 getBean(id) 返回对应的对象</span></span><br><span class="line"><span class="comment"> * 5. 这里就是一个开胃小点心, 理解Spring容器的机制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HspApplicationContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, Object&gt; singletonObjects =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//接收一个容器的配置文件 比如 beans.xml, 该文件默认在src</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HspApplicationContext</span><span class="params">(String iocBeanXmlFile)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 得到类加载路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getResource(<span class="string">&quot;/&quot;</span>).getPath();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 创建 Saxreader</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 得到Document对象</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span></span><br><span class="line">                saxReader.read(<span class="keyword">new</span> <span class="title class_">File</span>(path + iocBeanXmlFile));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 得到rootDocument</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">rootElement</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 得到第一个bean-monster01</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">bean</span> <span class="operator">=</span> (Element) rootElement.elements(<span class="string">&quot;bean&quot;</span>).get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 获取到第一个bean-monster01的相关属性</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> bean.attributeValue(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">classFullPath</span> <span class="operator">=</span> bean.attributeValue(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">        List&lt;Element&gt; property = bean.elements(<span class="string">&quot;property&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历-&gt;老师简化直接获取</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">monsterId</span> <span class="operator">=</span></span><br><span class="line">                Integer.parseInt(property.get(<span class="number">0</span>).attributeValue(<span class="string">&quot;value&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> property.get(<span class="number">1</span>).attributeValue(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">skill</span> <span class="operator">=</span> property.get(<span class="number">2</span>).attributeValue(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. 使用反射创建对象.=&gt; 回顾反射机制</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(classFullPath);</span><br><span class="line">        <span class="comment">//这里o对象就是Monster对象</span></span><br><span class="line">        <span class="type">Monster</span> <span class="variable">o</span> <span class="operator">=</span> (Monster) aClass.newInstance();</span><br><span class="line">        <span class="comment">//给o对象赋值</span></span><br><span class="line">        <span class="comment">//反射来赋值=&gt; 这里老师就简化，直接赋值-&gt;目的就是先理解流程</span></span><br><span class="line">        <span class="comment">//这里的方法就是setter方法</span></span><br><span class="line">        <span class="comment">//Method[] declaredMethods = aClass.getDeclaredMethods();</span></span><br><span class="line">        <span class="comment">//for (Method declaredMethod : declaredMethods) &#123;</span></span><br><span class="line">        <span class="comment">//    declaredMethod.invoke();</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        o.setMonsterId(monsterId);</span><br><span class="line">        o.setName(name);</span><br><span class="line">        o.setSkill(skill);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//8. 将创建好的对象放入到singletonObjects</span></span><br><span class="line">        singletonObjects.put(id, o);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="comment">//这里小伙伴可以再处理</span></span><br><span class="line">        <span class="keyword">return</span> singletonObjects.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-6-🌟Spring-原生容器底层结构"><a href="#1-6-🌟Spring-原生容器底层结构" class="headerlink" title="1.6 🌟Spring 原生容器底层结构"></a>1.6 🌟Spring 原生容器底层结构</h2><h3 id="1-6-1-一图胜千言"><a href="#1-6-1-一图胜千言" class="headerlink" title="1.6.1 一图胜千言"></a>1.6.1 一图胜千言</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230718105740683.png" alt="image-20230718105740683"></p><h3 id="1-6-2-课后作业题"><a href="#1-6-2-课后作业题" class="headerlink" title="1.6.2 课后作业题"></a>1.6.2 课后作业题</h3><ol><li>在 beans.xml 中， 我们注入 2 个 Monster 对象, 但是不指定 id,如下</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.beans.Monster&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monsterId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1010&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;牛魔王~&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;skill&quot;</span> <span class="attr">value</span>=<span class="string">&quot;芭蕉扇~&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.beans.Monster&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monsterId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;牛魔王~~!!&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;skill&quot;</span> <span class="attr">value</span>=<span class="string">&quot;芭蕉扇~~&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>问题 1：运行会不会报错</li></ol><ul><li>答：不会报错，会正常运行</li></ul><ol start="3"><li>问题 2：如果不报错, 你能否找到分配的 id, 并获得到该对象.</li></ol><ul><li>答：<strong>系统会默认分配 id</strong> ,<u>分配 id 的规则是 全类名#0 , 全类名#1 这样的规则来分配 id</u>, 我们可以通过 debug 方式来查看.</li></ul><h1 id="2-Spring-管理-Bean-IOC"><a href="#2-Spring-管理-Bean-IOC" class="headerlink" title="2 Spring 管理 Bean-IOC"></a>2 Spring 管理 Bean-IOC</h1><h2 id="2-1-Spring-配置-x2F-管理-bean-介绍"><a href="#2-1-Spring-配置-x2F-管理-bean-介绍" class="headerlink" title="2.1 Spring 配置&#x2F;管理 bean 介绍"></a>2.1 Spring 配置&#x2F;管理 bean 介绍</h2><h3 id="2-1-1-Bean-管理包括两方面"><a href="#2-1-1-Bean-管理包括两方面" class="headerlink" title="2.1.1 Bean 管理包括两方面"></a>2.1.1 Bean 管理包括两方面</h3><h4 id="2-1-1-1-创建-bean-对象"><a href="#2-1-1-1-创建-bean-对象" class="headerlink" title="2.1.1.1 创建 bean 对象"></a>2.1.1.1 创建 bean 对象</h4><h4 id="2-1-1-2-给-bean-注入属性"><a href="#2-1-1-2-给-bean-注入属性" class="headerlink" title="2.1.1.2 给 bean 注入属性"></a>2.1.1.2 给 bean 注入属性</h4><h3 id="2-1-2-Bean-配置方式"><a href="#2-1-2-Bean-配置方式" class="headerlink" title="2.1.2 Bean 配置方式"></a>2.1.2 Bean 配置方式</h3><h4 id="2-1-2-1-基于-xml-文件配置方式"><a href="#2-1-2-1-基于-xml-文件配置方式" class="headerlink" title="2.1.2.1 基于 xml 文件配置方式"></a>2.1.2.1 基于 xml 文件配置方式</h4><h4 id="2-1-2-2-基于注解方式"><a href="#2-1-2-2-基于注解方式" class="headerlink" title="2.1.2.2 基于注解方式"></a>2.1.2.2 基于注解方式</h4><h2 id="2-2-基于-XML-配置-bean"><a href="#2-2-基于-XML-配置-bean" class="headerlink" title="2.2 基于 XML 配置 bean"></a>2.2 基于 XML 配置 bean</h2><h3 id="2-2-1-通过类型来获取-bean"><a href="#2-2-1-通过类型来获取-bean" class="headerlink" title="2.2.1 通过类型来获取 bean"></a>2.2.1 通过类型来获取 bean</h3><h4 id="2-2-1-1-应用案例"><a href="#2-2-1-1-应用案例" class="headerlink" title="2.2.1.1 应用案例"></a>2.2.1.1 应用案例</h4><p>​● 案例说明:</p><ol><li>通过 spring 的 ioc 容器, 获取一个 bean 对象</li><li>说明：获取 bean 的方式：按类型</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Monster</span> <span class="variable">monster</span> <span class="operator">=</span> ioc.getBean(Monster.class);</span><br></pre></td></tr></table></figure><h4 id="2-2-1-2-细节说明"><a href="#2-2-1-2-细节说明" class="headerlink" title="2.2.1.2 细节说明"></a>2.2.1.2 细节说明</h4><ol><li><p>按类型来获取 bean, 要求 ioc 容器中的同一个类的 bean 只能有一个, 否则会抛出异常 NoUniqueBeanDefinitionException</p></li><li><p>这种方式的应用场景：比如 XxxAction&#x2F;Servlet&#x2F;Controller, 或 XxxService <strong>在一个线程中只需要一个对象实例(单例)的情况</strong></p></li><li><p>老师这里在说明一下: 在容器配置文件(比如 beans.xml)中<strong>给属性赋值, 底层是通过 setter 方法完成的</strong>, 这也是为什么我们需要提供 setter 方法的原因</p></li></ol><h3 id="2-2-2-通过构造器配置-bean"><a href="#2-2-2-通过构造器配置-bean" class="headerlink" title="2.2.2 通过构造器配置 bean"></a>2.2.2 通过构造器配置 bean</h3><h4 id="2-2-2-1-应用案例"><a href="#2-2-2-1-应用案例" class="headerlink" title="2.2.2.1 应用案例"></a>2.2.2.1 应用案例</h4><p>● 案例说明:</p><p>在 spring 的 ioc 容器, 可以通过构造器来配置 bean 对象</p><p>● 完成步骤</p><ol><li>在 beans.xml 配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Monster对象，并且指定构造器</span></span><br><span class="line"><span class="comment">老师解读</span></span><br><span class="line"><span class="comment">1. constructor-arg标签可以指定使用构造器的参数</span></span><br><span class="line"><span class="comment">2. index表示构造器的第几个参数 从0开始计算的</span></span><br><span class="line"><span class="comment">3. 除了可以通过index 还可以通过 name / type 来指定参数方式</span></span><br><span class="line"><span class="comment">4. 解除大家的疑惑, 类的构造器，不能有完全相同类型和顺序的构造器，所以可以通过type来指定</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- index --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;monster03&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Monster&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;200&quot;</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;白骨精&quot;</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;吸人血&quot;</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- name --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;monster04&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Monster&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;200&quot;</span> <span class="attr">name</span>=<span class="string">&quot;monsterId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;白骨精&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;吸人血&quot;</span> <span class="attr">name</span>=<span class="string">&quot;skill&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- type --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;monster05&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Monster&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;300&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.Integer&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;白骨精~&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;吸人血~&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-2-2-使用细节"><a href="#2-2-2-2-使用细节" class="headerlink" title="2.2.2.2 使用细节"></a>2.2.2.2 使用细节</h4><ol><li>通过 index 属性来区分是第几个参数</li><li>通过 type 属性来区分是什么类型(按照顺序)</li></ol><h3 id="2-2-3-通过-p-名称空间配置-bean"><a href="#2-2-3-通过-p-名称空间配置-bean" class="headerlink" title="2.2.3 通过 p 名称空间配置 bean"></a>2.2.3 通过 p 名称空间配置 bean</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在beans标签中添加    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--通过p名称空间来配置bean</span></span><br><span class="line"><span class="comment">    老韩解读</span></span><br><span class="line"><span class="comment">    1. 将光标放在p , 输入alt+enter , 就会自动的添加xmlns</span></span><br><span class="line"><span class="comment">    2. 有时需要多来几次</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;monster06&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Monster&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:monsterId</span>=<span class="string">&quot;500&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:name</span>=<span class="string">&quot;红孩儿&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:skill</span>=<span class="string">&quot;吐火&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-4-引用-x2F-注入其它-bean-对象-某类中有其他类型的数据，也需要初始化"><a href="#2-2-4-引用-x2F-注入其它-bean-对象-某类中有其他类型的数据，也需要初始化" class="headerlink" title="2.2.4 引用&#x2F;注入其它 bean 对象(某类中有其他类型的数据，也需要初始化)"></a>2.2.4 引用&#x2F;注入其它 bean 对象(某类中有其他类型的数据，也需要初始化)</h3><h4 id="2-2-4-1-实例演示"><a href="#2-2-4-1-实例演示" class="headerlink" title="2.2.4.1 实例演示"></a>2.2.4.1 实例演示</h4><p>​● 案例说明:在 spring 的 ioc 容器, 可以<strong>通过 ref 来实现 bean 对象的相互引用</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置MemberServiceImpl对象</span></span><br><span class="line"><span class="comment">    老韩解读</span></span><br><span class="line"><span class="comment">    1. ref=&quot;memberDAO&quot;表示  MemberServiceImpl对象属性memberDAO引用的对象是id=memberDAO</span></span><br><span class="line"><span class="comment">    的对象</span></span><br><span class="line"><span class="comment">    2. 这里就体现出spring容器的依赖注入</span></span><br><span class="line"><span class="comment">    3. 注意再spring容器中, 他是「作为一个整体来执行的」即如果你引用到一个bean对象, 对你配置的顺序没有要求</span></span><br><span class="line"><span class="comment">    4. 建议还是按顺序，好处是阅读的时候，比较方便</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置MemberDAOImpl对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.dao.MemberDAOImpl&quot;</span> <span class="attr">id</span>=<span class="string">&quot;memberDAO&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.service.MemberServiceImpl&quot;</span> <span class="attr">id</span>=<span class="string">&quot;memberService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;memberDAO&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;memberDAO&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-5-引用-x2F-注入内部-bean-对象"><a href="#2-2-5-引用-x2F-注入内部-bean-对象" class="headerlink" title="2.2.5 引用&#x2F;注入内部 bean 对象"></a>2.2.5 引用&#x2F;注入内部 bean 对象</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;memberServiceImpl02&quot;</span><span class="attr">class</span>=<span class="string">&quot;com.study.spring.service.MemberServiceImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;memberDAO&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.dao.MemberDAOImpl&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-6-引用-x2F-注入集合-x2F-数组类型"><a href="#2-2-6-引用-x2F-注入集合-x2F-数组类型" class="headerlink" title="2.2.6 引用&#x2F;注入集合&#x2F;数组类型"></a>2.2.6 引用&#x2F;注入集合&#x2F;数组类型</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Master对象</span></span><br><span class="line"><span class="comment">体会 spring 容器配置特点 依赖注入-非常灵活</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Master&quot;</span> <span class="attr">id</span>=<span class="string">&quot;master&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;太上老君&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--给list属性赋值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monsterList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--引用的方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;monster01&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;monster02&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--内部bean--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Monster&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;老鼠精&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monsterId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;skill&quot;</span> <span class="attr">value</span>=<span class="string">&quot;吃粮食&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--给map属性赋值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monsterMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>monster03<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--这里老师使用的外部bean,引入--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;monster03&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>monster04<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;monster04&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--给set属性赋值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monsterSet&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;monster05&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;monster06&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Monster&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;金角大王&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;skill&quot;</span> <span class="attr">value</span>=<span class="string">&quot;吐水&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monsterId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--给数组属性赋值</span></span><br><span class="line"><span class="comment">    老师多说一句: array标签中使用 value 还是 bean , ref .. 要根据你的业务决定</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monsterName&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>小妖怪<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>大妖怪<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>老妖怪<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--给Properties属性赋值 结构k(String)-v(String)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pros&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;username&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;ip&quot;</span>&gt;</span>127.0.0.1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-6-2-使用细节"><a href="#2-2-6-2-使用细节" class="headerlink" title="2.2.6.2 使用细节"></a>2.2.6.2 使用细节</h4><ol><li><p>主要掌握 List&#x2F;Map&#x2F;Properties 三种集合的使用.</p></li><li><p>Properties 集合的特点</p><ul><li><p>这个 Properties 是 Hashtable 的子类 , 是 key-value 的形式</p></li><li><p>key 是 string 而 value 也是 string</p></li></ul></li></ol><h3 id="2-2-7-通过-util-名称空间创建-list"><a href="#2-2-7-通过-util-名称空间创建-list" class="headerlink" title="2.2.7 通过 util 名称空间创建 list"></a>2.2.7 通过 util 名称空间创建 list</h3><h4 id="2-2-7-1-实例演示"><a href="#2-2-7-1-实例演示" class="headerlink" title="2.2.7.1 实例演示"></a>2.2.7.1 实例演示</h4><p>​● 案例说明</p><p>​spring 的 ioc 容器, 可以通过 util 名称空间创建 list 集合</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">xmlns:util=&quot;http://www.springframework.org/schema/util&quot;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--定义一个util:list 并且指定id 可以达到数据复用</span></span><br><span class="line"><span class="comment">老师说明: 在使用util:list 名称空间时候，需要引入相应的标签, 一般来说通过alt+enter会自动加入</span></span><br><span class="line"><span class="comment">, 如果没有就手动添加一下即可.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;myBookList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>三国演义<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>红楼梦<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>水浒传<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置BookStore对象--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.BookStore&quot;</span> <span class="attr">id</span>=<span class="string">&quot;bookStore&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookList&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;myBookList&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-8-级联属性赋值"><a href="#2-2-8-级联属性赋值" class="headerlink" title="2.2.8 级联属性赋值"></a>2.2.8 级联属性赋值</h3><h4 id="2-2-8-1-实例演示"><a href="#2-2-8-1-实例演示" class="headerlink" title="2.2.8.1 实例演示"></a>2.2.8.1 实例演示</h4><p>​● 案例说明</p><p>​spring 的 ioc 容器, 可以直接给对象属性的属性赋值， 即级联属性赋值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Dept对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Dept&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置Emp对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Emp&quot;</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jack&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这里我希望给dept的name属性指定值[级联属性赋值]--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept.name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Java开发部门&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-9-通过静态工厂获取对象"><a href="#2-2-9-通过静态工厂获取对象" class="headerlink" title="2.2.9 通过静态工厂获取对象"></a>2.2.9 通过静态工厂获取对象</h3><h4 id="2-2-9-1-实例演示"><a href="#2-2-9-1-实例演示" class="headerlink" title="2.2.9.1 实例演示"></a>2.2.9.1 实例演示</h4><p>​● 案例说明</p><p>​在 spring 的 ioc 容器, 可以通过静态工厂获取 bean 对象</p><ol><li>创 建com\study\spring\factory\MyStaticFactory.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStaticFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Monster&gt; monsterMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用 static代码块 进行初始化</span></span><br><span class="line">    <span class="comment">//在java基础的时候，讲过的</span></span><br><span class="line">    <span class="keyword">static</span>  &#123;</span><br><span class="line">        monsterMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        monsterMap.put(<span class="string">&quot;monster01&quot;</span>, <span class="keyword">new</span> <span class="title class_">Monster</span>(<span class="number">100</span>,<span class="string">&quot;牛魔王&quot;</span>,<span class="string">&quot;芭蕉扇&quot;</span>));</span><br><span class="line">        monsterMap.put(<span class="string">&quot;monster02&quot;</span>, <span class="keyword">new</span> <span class="title class_">Monster</span>(<span class="number">200</span>,<span class="string">&quot;狐狸精&quot;</span>,<span class="string">&quot;美人计&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个方法,返回Monster对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Monster <span class="title function_">getMonster</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> monsterMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>修改 beans.xml , 增加配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置monster对象,通过静态工厂获取</span></span><br><span class="line"><span class="comment">   老师解读</span></span><br><span class="line"><span class="comment">   1. 通过静态工厂获取/配置bean</span></span><br><span class="line"><span class="comment">   2. class 是静态工厂类的全路径</span></span><br><span class="line"><span class="comment">   3. factory-method 表示是指定静态工厂类的哪个方法返回对象</span></span><br><span class="line"><span class="comment">   4. constructor-arg value=&quot;monster02&quot; value是指定要返回静态工厂的哪个对象</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;my_monster01&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">class</span>=<span class="string">&quot;com.study.spring.factory.MyStaticFactory&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">factory-method</span>=<span class="string">&quot;getMonster&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;monster02&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-10-通过实例工厂获取对象"><a href="#2-2-10-通过实例工厂获取对象" class="headerlink" title="2.2.10 通过实例工厂获取对象"></a>2.2.10 通过实例工厂获取对象</h3><h4 id="2-2-10-1-实例演示"><a href="#2-2-10-1-实例演示" class="headerlink" title="2.2.10.1 实例演示"></a>2.2.10.1 实例演示</h4><p>​● 案例说明在 spring 的 ioc 容器, 可以通过实例工厂获取 bean 对象</p><p>​● 完成步骤1. 创 建com\study\spring\factory\MyInstanceFactory.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInstanceFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Monster&gt; monster_map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过普通代码块进行初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        monster_map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        monster_map.put(<span class="string">&quot;monster03&quot;</span>, <span class="keyword">new</span> <span class="title class_">Monster</span>(<span class="number">300</span>, <span class="string">&quot;牛魔王~&quot;</span>, <span class="string">&quot;芭蕉扇~&quot;</span>));</span><br><span class="line">        monster_map.put(<span class="string">&quot;monster04&quot;</span>, <span class="keyword">new</span> <span class="title class_">Monster</span>(<span class="number">400</span>, <span class="string">&quot;狐狸精~&quot;</span>, <span class="string">&quot;美人计~&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法返回Monster对象</span></span><br><span class="line">    <span class="keyword">public</span> Monster <span class="title function_">getMonster</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> monster_map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 beans.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置2个实例工厂对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.factory.MyInstanceFactory&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myInstanceFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.factory.MyInstanceFactory&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myInstanceFactory2&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置monster对象, 通过实例工厂</span></span><br><span class="line"><span class="comment">老韩解读</span></span><br><span class="line"><span class="comment">1. factory-bean 指定使用 &#x27;哪个实例工厂&#x27; 对象返回bean</span></span><br><span class="line"><span class="comment">2. factory-method 指定使用实例工厂对象的 &#x27;哪个方法&#x27; 返回bean</span></span><br><span class="line"><span class="comment">3. constructor-arg value=&quot;monster03&quot; 指定获取到实例工厂中的哪个monster</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;my_monster02&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;myInstanceFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getMonster&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;monster03&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;my_monster03&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;myInstanceFactory2&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getMonster&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;monster03&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-12-通过-FactoryBean-获取对象-重点"><a href="#2-2-12-通过-FactoryBean-获取对象-重点" class="headerlink" title="2.2.12 通过 FactoryBean 获取对象(重点)"></a>2.2.12 通过 FactoryBean 获取对象(重点)</h3><h4 id="2-2-12-1-应用实例"><a href="#2-2-12-1-应用实例" class="headerlink" title="2.2.12.1 应用实例"></a>2.2.12.1 应用实例</h4><p>​● 案例说明</p><p>​在 spring 的 ioc 容器,通过 FactoryBean 获取 bean 对象(重点)</p><ol><li>创 建com\study\spring\factory\MyFactoryBean.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Monster&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个就是你配置时候，指定要获取的对象对应key</span></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Monster&gt; monster_map;</span><br><span class="line"></span><br><span class="line">    &#123;   <span class="comment">//代码块，完成初始化</span></span><br><span class="line">        monster_map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        monster_map.put(<span class="string">&quot;monster03&quot;</span>, <span class="keyword">new</span> <span class="title class_">Monster</span>(<span class="number">300</span>, <span class="string">&quot;牛魔王~&quot;</span>, <span class="string">&quot;芭蕉扇~&quot;</span>));</span><br><span class="line">        monster_map.put(<span class="string">&quot;monster04&quot;</span>, <span class="keyword">new</span> <span class="title class_">Monster</span>(<span class="number">400</span>, <span class="string">&quot;狐狸精~&quot;</span>, <span class="string">&quot;美人计~&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Monster <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> monster_map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Monster.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;<span class="comment">//这里指定是否返是单例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 beans.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置monster对象，通过FactoryBean获取</span></span><br><span class="line"><span class="comment">老师解读</span></span><br><span class="line"><span class="comment">1. class 指定使用的FactoryBean</span></span><br><span class="line"><span class="comment">2. key表示就是 MyFactoryBean 属性key</span></span><br><span class="line"><span class="comment">3. value就是你要获取的对象对应key</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;my_monster05&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.factory.MyFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;key&quot;</span> <span class="attr">value</span>=<span class="string">&quot;monster04&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-13-bean-配置信息重用-继承"><a href="#2-2-13-bean-配置信息重用-继承" class="headerlink" title="2.2.13 bean 配置信息重用(继承)"></a>2.2.13 bean 配置信息重用(继承)</h3><h4 id="2-2-13-1-应用实例"><a href="#2-2-13-1-应用实例" class="headerlink" title="2.2.13.1 应用实例"></a>2.2.13.1 应用实例</h4><p>​● 说明</p><p>​在 spring 的 ioc 容器, 提供了一种继承的方式来实现 bean 配置信息的重用</p><p>​● 应用实例演示</p><ol><li>配置 beans.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Monster对象</span></span><br><span class="line"><span class="comment">1. 如果bean指定了 abstract=&quot;true&quot;, 表示该bean对象, 是用于被继承</span></span><br><span class="line"><span class="comment">2. 本身这个bean就不能被获取/实例化</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;monster12&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Monster&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monsterId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;蜈蚣精~&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;skill&quot;</span> <span class="attr">value</span>=<span class="string">&quot;蜇人~&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;monster13&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Monster&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;monster12&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-14-bean-创建顺序"><a href="#2-2-14-bean-创建顺序" class="headerlink" title="2.2.14 bean 创建顺序"></a>2.2.14 bean 创建顺序</h3><h4 id="2-2-14-1-实例演示"><a href="#2-2-14-1-实例演示" class="headerlink" title="2.2.14.1 实例演示"></a>2.2.14.1 实例演示</h4><p>​● 说明</p><ol><li>在 spring 的 ioc 容器, 默认是按照配置的顺序创建 bean 对象</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--测试bean对象的创建顺序</span></span><br><span class="line"><span class="comment">老师解读</span></span><br><span class="line"><span class="comment">1. 在默认情况下, bean创建的顺序是按照配置顺序来的</span></span><br><span class="line"><span class="comment">2. 但是如果我们增加了 depends-on=&quot;department01&quot; 这时就会先创建id= department01对象</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hspedu.bean.Student&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;department01&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;department01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hspedu.bean.Department&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>2.2.14.2 一个问题</p><p>​● 问题说明</p><ol><li>先看下面的配置, 请问两个 bean 创建的顺序是什么? 并分析执行流<ol><li>先创建 id&#x3D;memberDAOImpl</li><li>再创建 id &#x3D; memberServiceImpl</li><li>调用 memberServiceImpl.setMemberDAO() 完成引用</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230720095126833.png" alt="image-20230720095126833"></p><ol start="2"><li><p>先看下面的配置, 请问两个 bean 创建的顺序是什么, 并分析执行流程</p><ol><li>先创建 id &#x3D; memberServiceImpl</li><li>再创建 id&#x3D;memberDAOImpl</li></ol><ol start="3"><li>用 memberServiceImpl.setMemberDAO() 完成引用.   （像是栈</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230720095309694.png" alt="image-20230720095309694"></p><h3 id="2-2-15-bean-对象的单例和多例"><a href="#2-2-15-bean-对象的单例和多例" class="headerlink" title="2.2.15 bean 对象的单例和多例"></a>2.2.15 bean 对象的单例和多例</h3><h4 id="2-2-15-1-应用实例"><a href="#2-2-15-1-应用实例" class="headerlink" title="2.2.15.1 应用实例"></a>2.2.15.1 应用实例</h4><p>​● 说明</p><p>​<u>在 spring 的 ioc 容器, 在默认是按照单例创建的， 即配置一个 bean 对象后， ioc 容器只会创建一个 bean 实例。</u></p><p>​如果,我们希望 ioc 容器配置的某个 bean 对象， 是以多个实例形式创建的则可以通过配置<strong>scope&#x3D;”prototype”</strong> 来指定</p><p><strong>配置 beans.xml：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Cat对象</span></span><br><span class="line"><span class="comment">    老师解读</span></span><br><span class="line"><span class="comment">    1. 在默认情况下 scope属性是 singleton</span></span><br><span class="line"><span class="comment">    2. 在ioc容器中, 只要有一个这个bean对象</span></span><br><span class="line"><span class="comment">    3. 当程序员执行getBean时, 返回的的是同一个对象</span></span><br><span class="line"><span class="comment">    4. 如果我们希望每次getBean返回一个新的Bean对象，则可以scope=&quot;prototype&quot;</span></span><br><span class="line"><span class="comment">    5. 如果bean的配置是 scope=&quot;singleton&quot; lazy-init=&quot;true&quot; 这时,ioc容器就不会提前创建该对象</span></span><br><span class="line"><span class="comment">       , 而是当执行getBean方法的时候，才会创建对象</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.Cat&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小花猫&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-15-2-使用细节"><a href="#2-2-15-2-使用细节" class="headerlink" title="2.2.15.2 使用细节"></a>2.2.15.2 使用细节</h4><ol><li><p><strong>默认是单例 singleton, 在启动容器时, 默认就会创建 , 并放入到 singletonObjects 集合</strong></p></li><li><p>当 <bean scope="prototype" > <strong><u>设置为多实例机制后, 该 bean 是在 getBean()时才创建</u></strong> </p></li><li><p>如果是单例 singleton, 同时希望在 getBean 时才创建 , 可以指定懒加载lazy-init&#x3D;”true” (注意默认是 false)</p></li><li><p><u>通常情况下, lazy-init 就使用默认值 false , 在开发看来, 用空间换时间是值得的,</u> 除非有特殊的要求.</p></li><li><p><strong>如果 scope&#x3D;”prototype” 这时你的 lazy-init 属性的值不管是 ture, 还是 false 都是在getBean 时候，才创建对象.</strong></p></li></ol><h3 id="2-2-16-bean-的生命周期"><a href="#2-2-16-bean-的生命周期" class="headerlink" title="2.2.16 bean 的生命周期"></a>2.2.16 bean 的生命周期</h3><h4 id="2-2-16-1-应用实例"><a href="#2-2-16-1-应用实例" class="headerlink" title="2.2.16.1 应用实例"></a>2.2.16.1 应用实例</h4><p>​● 说明: bean 对象创建是由 JVM 完成的，然后执行如下方法</p><p>​<strong>1.</strong>  执行构造器</p><p>​<strong>2.</strong>  执行 set 相关方法</p><p>​<strong>3.</strong>  调用 bean 的初始化的方法（需要配置）</p><p>​<strong>4.</strong>  使用 bean </p><p>​<strong>5.</strong>  当容器关闭时候，调用 bean 的销毁方法（需要配置）</p><p>​● 应用实例演示</p><ol><li>创建 com.hspedu.spring.beans;</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">House</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">House</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;House() 构造器...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;House setName()=&quot;</span> + name);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//老师解读</span></span><br><span class="line">    <span class="comment">//1. 这个方法是程序员来编写的.</span></span><br><span class="line">    <span class="comment">//2. 根据自己的业务逻辑来写.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;House init()..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//老师解读</span></span><br><span class="line">    <span class="comment">//1. 这个方法是程序员来编写的.</span></span><br><span class="line">    <span class="comment">//2. 根据自己的业务逻辑来写.</span></span><br><span class="line">    <span class="comment">//3. 名字也不是固定的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;House destroy()..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;House&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 beans.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置House对象，演示整个Bean的生命周期</span></span><br><span class="line"><span class="comment">老师解读</span></span><br><span class="line"><span class="comment">1. init-method=&quot;init&quot; 指定bean的初始化方法 , 在setter方法后执行</span></span><br><span class="line"><span class="comment">2. init方法执行的时机，由spring容器来控制</span></span><br><span class="line"><span class="comment">3. destroy-method=&quot;destroy&quot; 指定bean的销毁方法, 在容器关闭的时候执行</span></span><br><span class="line"><span class="comment">4. destroy方法执行的时机，也由spring容器来控制</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.hspedu.spring.bean.House&quot;</span> <span class="attr">id</span>=<span class="string">&quot;house&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;北京豪宅&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-16-2-使用细节"><a href="#2-2-16-2-使用细节" class="headerlink" title="2.2.16.2 使用细节"></a>2.2.16.2 使用细节</h4><ol><li><p>初始化 init 方法和 destory 方法, 是程序员来指定</p></li><li><p>销毁方法就是当关闭容器时，才会被调用.</p></li></ol><h3 id="2-2-17-配置-bean-的后置处理器-【这个比较难】"><a href="#2-2-17-配置-bean-的后置处理器-【这个比较难】" class="headerlink" title="2.2.17 配置 bean 的后置处理器 【这个比较难】"></a>2.2.17 配置 bean 的后置处理器 【这个比较难】</h3><h4 id="2-2-17-1-应用实例"><a href="#2-2-17-1-应用实例" class="headerlink" title="2.2.17.1 应用实例"></a>2.2.17.1 应用实例</h4><p>● 说明</p><ol><li>在 spring 的 ioc 容器,可以配置 <strong>bean 的后置处理器</strong></li><li>该处理器&#x2F;对象会在 <strong>bean 初始化方法<u>调用前</u>和初始化方法<u>调用后</u>被调用</strong></li><li>程序员可以在后置处理器中编写自己的代码</li></ol><p>后置处理器创建好后，也注册在beans.xml中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 什么时候被调用: 在Bean的init方法前被调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bean 传入的在IOC容器中创建/配置Bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName 传入的在IOC容器中创建/配置Bean的id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Object 程序员对传入的bean 进行修改/处理【如果有需要的话】 ,返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;postProcessBeforeInitialization().. bean=&quot;</span></span><br><span class="line">            + bean + <span class="string">&quot; beanName=&quot;</span> + beanName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初步体验案例: 如果类型是House的统一改成 上海豪宅</span></span><br><span class="line">    <span class="comment">//对多个对象进行处理/编程==&gt;切面编程</span></span><br><span class="line">    <span class="keyword">if</span>(bean <span class="keyword">instanceof</span> House) &#123;</span><br><span class="line">        ((House)bean).setName(<span class="string">&quot;上海豪宅~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 什么时候被调用: 在Bean的init方法后被调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bean  传入的在IOC容器中创建/配置Bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName 传入的在IOC容器中创建/配置Bean的id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 程序员对传入的bean 进行修改/处理【如果有需要的话】 ,返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;postProcessAfterInitialization().. bean=&quot;</span></span><br><span class="line">            + bean + <span class="string">&quot; beanName=&quot;</span> + beanName);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置后置处理器对象</span></span><br><span class="line"><span class="comment">老师解读</span></span><br><span class="line"><span class="comment">1. 当我们在beans02.xml 容器配置文件 配置了 MyBeanPostProcessor</span></span><br><span class="line"><span class="comment">2. 这时后置处理器对象，就会作用在该容器创建的Bean对象</span></span><br><span class="line"><span class="comment">3. 已经是针对所有对象编程-&gt;切面编程AOP</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.hspedu.spring.bean.MyBeanPostProcessor&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myBeanPostProcessor&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-17-2-其它说明"><a href="#2-2-17-2-其它说明" class="headerlink" title="2.2.17.2 其它说明"></a>2.2.17.2 其它说明</h4><p>1、 怎么执行到这个方法?&#x3D;&gt; 使用 AOP(反射+动态代理+IO+容器+注解)</p><p>2、有什么用？&#x3D;&gt; 可以对 IOC 容器中所有的对象进行统一处理 ,比如 <strong>日志处理&#x2F;权限的校验&#x2F;安全的验证&#x2F;事务管理.</strong></p><p>​-初步体验案例: 如果类型是 House 的<strong>统一</strong>改成 上海豪宅</p><p>3、针对容器的所有对象吗? 是的&#x3D;&gt;切面编程特点</p><p>4、后面我们会自己实现这个底层机制，这个是一个比较难理解的知识点, 现在不做过多的纠结，后面我会带小伙伴实现这个机制</p><h3 id="2-2-18-通过属性文件给-bean-注入值"><a href="#2-2-18-通过属性文件给-bean-注入值" class="headerlink" title="2.2.18 通过属性文件给 bean 注入值"></a>2.2.18 通过属性文件给 bean 注入值</h3><h4 id="2-2-18-1-应用实例"><a href="#2-2-18-1-应用实例" class="headerlink" title="2.2.18.1 应用实例"></a>2.2.18.1 应用实例</h4><p>​● 说明</p><p>在 spring 的 ioc 容器,通过属性文件给 bean 注入值</p><p>​● 应用实例演示</p><ol><li>src&#x2F; 创建 my.properties</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">monsterId</span>=<span class="string">1000</span></span><br><span class="line"><span class="attr">name</span>=<span class="string">\u4e4c\u9f9f\u7cbe</span></span><br><span class="line"><span class="attr">skill</span>=<span class="string">\u7f29\u8116\u5b50</span></span><br></pre></td></tr></table></figure><ol start="2"><li>修改 src\beans.xml , 继续完成配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line"><span class="comment">&lt;!--指定属性文件</span></span><br><span class="line"><span class="comment">     1. 先把这个文件修改成提示All Problem</span></span><br><span class="line"><span class="comment">     2. 提示错误，将光标放在context 输入alt+enter 就会自动引入namespace</span></span><br><span class="line"><span class="comment">     3. location=&quot;classpath:my.properties&quot; 表示指定属性文件的位置</span></span><br><span class="line"><span class="comment">     4. 提示，需要带上 classpath</span></span><br><span class="line"><span class="comment">     5. 属性文件有中文，需要将其转为unicode编码-&gt; 使用工具</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:my.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;monster100&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hspedu.spring.beans.Monster&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;monsterId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;id&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;name&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;skill&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;skill&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-19-基于-XML-的-bean-的自动装配"><a href="#2-2-19-基于-XML-的-bean-的自动装配" class="headerlink" title="2.2.19 基于 XML 的 bean 的自动装配"></a>2.2.19 基于 XML 的 bean 的自动装配</h3><h4 id="2-2-19-1-应用实例"><a href="#2-2-19-1-应用实例" class="headerlink" title="2.2.19.1 应用实例"></a>2.2.19.1 应用实例</h4><p>​● 说明</p><p>​在 spring 的 ioc 容器,可以实现自动装配 bean</p><p>​● 应用实例演示</p><p>​这里说的 Action 就是我们前面讲过的 Servlet-&gt;充当 Controller</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置OrderDao对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.hspedu.spring.dao.OrderDao&quot;</span> <span class="attr">id</span>=<span class="string">&quot;orderDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置OrderService对象</span></span><br><span class="line"><span class="comment">        老师解读</span></span><br><span class="line"><span class="comment">        1. autowire=&quot;byType&quot; 表示 在创建 orderService时</span></span><br><span class="line"><span class="comment">           通过类型的方式 给对象属性 自动完成赋值/引用</span></span><br><span class="line"><span class="comment">        2. 比如OrderService 对象有 private OrderDao orderDao</span></span><br><span class="line"><span class="comment">        3. 就会在容器中去找有没有 OrderDao类型对象</span></span><br><span class="line"><span class="comment">        4. 如果有，就会自动的装配, 老师提示如果是按照 byType 方式来装配, 这个容器中，不能有两个</span></span><br><span class="line"><span class="comment">          的OrderDao类型对象</span></span><br><span class="line"><span class="comment">        5. 如果你的对象没有属性,  autowire就没有必要写</span></span><br><span class="line"><span class="comment">        6. 其它类推..</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        7. 如果我们设置的是 autowire=&quot;byName&quot; 表示通过名字完成自动装配</span></span><br><span class="line"><span class="comment">        8. 比如下面的 autowire=&quot;byName&quot; class=&quot;com.hspedu.spring.service.OrderService&quot;</span></span><br><span class="line"><span class="comment">           1) 先看 OrderService 属性 private OrderDao orderDao</span></span><br><span class="line"><span class="comment">           2) 再根据这个属性的setXxx()方法的 xxx 来找对象id</span></span><br><span class="line"><span class="comment">           3) public void setOrderDao() 就会找id=orderDao对象来进行自动装配</span></span><br><span class="line"><span class="comment">           4) 如果没有就装配失败</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hspedu.spring.service.OrderService&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">id</span>=<span class="string">&quot;orderService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置OrderAction--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hspedu.spring.web.OrderAction&quot;</span> <span class="attr">id</span>=<span class="string">&quot;orderAction&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>2.2.19.2 其它说明</p><pre><code>1. 这个知识点作为了解即可， 后面我们主要还是使用基于注解的方式(重点.)1. 但是机制和原理类似</code></pre><h2 id="2-3-🌟基于注解配置-bean"><a href="#2-3-🌟基于注解配置-bean" class="headerlink" title="2.3 🌟基于注解配置 bean"></a>2.3 🌟基于注解配置 bean</h2><h3 id="2-3-18-基本使用"><a href="#2-3-18-基本使用" class="headerlink" title="2.3.18 基本使用"></a>2.3.18 基本使用</h3><h4 id="2-3-18-1-说明"><a href="#2-3-18-1-说明" class="headerlink" title="2.3.18.1 说明"></a>2.3.18.1 说明</h4><p>​● 基本介绍基于注解的方式配置 bean, 主要是项目开发中的组件， 比如 Controller、 Service、 和 Dao.</p><p>​● 组件注解的形式有</p><ol><li><p><u>@Component</u> 表示当前注解标识的<strong>是一个组件</strong>，<u>最宽泛，只是把该类注册到spring ioc容器中</u></p></li><li><p><u>@Controller</u> 表示当前注解标识的<strong>是一个控制器， 通常用于 Servlet</strong></p></li><li><p><u>@Service</u> 表示当前注解标识的是一个<strong>处理业务逻辑的类</strong>， 通常用于 Service 类</p></li><li><p><u>@Repository</u> 表示当前注解标识的是<strong>一个持久化层的类</strong>， 通常用于 Dao 类</p></li></ol><h4 id="2-3-18-2-快速入门"><a href="#2-3-18-2-快速入门" class="headerlink" title="2.3.18.2 快速入门"></a>2.3.18.2 快速入门</h4><p>​● 应用实例使用注解的方式来配置  Controller &#x2F; Service &#x2F; Respository &#x2F; Component</p><p>​● 代码实现</p><p>​1. 引入 spring-aop-5.3.8.jar , 在 spring&#x2F;libs 下拷贝即可</p><p>​2.创建 UserAction.java UserService.java, UserDao.java MyComponent.java</p><p>​3.配置 beans.xml(<strong>配置自动扫描的包</strong>)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置自动扫描的包，注意需要加入 context 名称空间 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.study.spring.component&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-18-3-注意事项和细节说明"><a href="#2-3-18-3-注意事项和细节说明" class="headerlink" title="2.3.18.3 注意事项和细节说明"></a>2.3.18.3 注意事项和细节说明</h4><ol><li><p>需要导入 spring-aop-5.3.8.jar , 别忘了</p></li><li><p>必须在 Spring 配置文件中指定”自动扫描的包”，IOC 容器才能够检测到当前项目中哪些类被标识了注解， 注意到导入 context 名称空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置自动扫描的包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hspedu.spring.component&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>可以使用通配符 * 来指定 ，比如 com.hspedu.spring.* 表示<br><strong>–提问: com.hspedu.spring.component 会不会去扫描它的子包?–答：会的</strong></p></li><li><p>Spring 的 IOC 容器不能检测一个使用了@Controller 注解的类到底是不是一个真正的控制器。注解的名称是用于程序员自己识别当前标识的是什么组件。其它的@Service@Repository 也是一样的道理 [也就是说 <em><strong>spring 的 IOC 容器只要检查到注解就会生成对象，但是这个注解的含义 spring 不会识别，注解是给程序员编程方便看的</strong></em>]</p></li><li><p>&lt;context:component-scan base-package&#x3D;”com.hspedu.spring.component”resource-pattern&#x3D;”User* .class” &#x2F;&gt;resource-pattern&#x3D;”User*.class”: <strong>表示只扫描满足要求的类</strong>.[使用的少，不想扫描，不写注解就可以, 知道这个知识点即可]</p></li><li><p>&lt;context:component-scan base-package&#x3D;”com.hspedu.spring.component” &gt;</p><!-- 排除哪些类 , 以 annotaion 注解为例 --><p>&lt;context:exclude-filter type&#x3D;”annotation”expression&#x3D;”org.springframework.stereotype.Service”&#x2F;&gt;</context></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) &lt;context:exclude-filter&gt; 放在&lt;context:component-scan&gt;内，表示扫描过滤掉当前包的某些类</span><br><span class="line">2) type=&quot;annotation&quot; 按照注解类型进行过滤.</span><br><span class="line">3) expression :就是注解的全类名，比如 org.springframework.stereotype.Service 就是@Service 注解的全类名,其它比@Controller @Repository 等 依次类推</span><br><span class="line">4) 上面表示过滤掉 com.hspedu.spring.component 包下，加入了@Service 注解的类</span><br><span class="line">5) 完成测试， 修改 beans.xml, 增加 exclude-filter , 发现 UserService, 不会注入到容器.</span><br></pre></td></tr></table></figure><ol start="6"><li>指定自动扫描哪些注解类</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    需求：如果我们希望按照自己的规则，来扫描包/子包下的某些注解, 可以通过 include-filter</span></span><br><span class="line"><span class="comment">    1. use-default-filters=&quot;false&quot; 表示不使用默认的过滤机制/扫描机制</span></span><br><span class="line"><span class="comment">    2. context:include-filter 表示要去扫描哪些类</span></span><br><span class="line"><span class="comment">    3. type=&quot;annotation&quot; 按照注解方式来扫描/过滤</span></span><br><span class="line"><span class="comment">    4. expression=&quot;org.springframework.stereotype.Service&quot; 指定要扫描的注解的全路径</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hspedu.spring.component&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Service&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Repository&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="7"><li><p>默认情况：<strong>标记注解后，默认把类名首字母小写作为 id 的值。也可以使用注解的 value 属性指定 id 值，并且 value 可以省略。</strong></p></li><li><p>扩展-@Controller 、@Service、@Component 区别 : (回去看看一下老师的讲解的注解基础) <a href="https://zhuanlan.zhihu.com/p/454638478">https://zhuanlan.zhihu.com/p/454638478</a></p></li></ol><h3 id="2-3-19-🌟手动开发简单的-Spring-基于注解配置的程序"><a href="#2-3-19-🌟手动开发简单的-Spring-基于注解配置的程序" class="headerlink" title="2.3.19 🌟手动开发简单的 Spring 基于注解配置的程序"></a>2.3.19 🌟手动开发简单的 Spring 基于注解配置的程序</h3><p> -老韩要求: 小伙伴要至少独立写 2 遍</p><h4 id="2-3-19-1-需求说明"><a href="#2-3-19-1-需求说明" class="headerlink" title="2.3.19.1 需求说明"></a>2.3.19.1 需求说明</h4><ol><li><p><strong>自 己 写 一 个 简 单 的 Spring 容 器 , 通 过 读 取 类 的 注 解 (@Component @Controller@Service @Reponsitory)， 将对象注入到 IOC 容器</strong></p></li><li><p>也就是说，<strong>不使用 Spring 原生框架，我们自己使用 IO+Annotaion+反射+集合 技术实现, 打通 Spring 注解方式开发的技术痛点</strong></p></li></ol><h4 id="2-3-19-2-思路分析"><a href="#2-3-19-2-思路分析" class="headerlink" title="2.3.19.2 思路分析"></a>2.3.19.2 思路分析</h4><ol><li><p>思路分析+程序结构</p><p>1)我们使用注解方式完成, 这里老韩不用 xml 来配</p><p>2)程序框架图</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230725093807908.png" alt="image-20230725093807908"></p><h4 id="2-3-19-3-代码实现"><a href="#2-3-19-3-代码实现" class="headerlink" title="2.3.19.3 代码实现"></a>2.3.19.3 代码实现</h4><p>​● 应用实例</p><ol><li><p>手动实现注解的方式来配置 Controller &#x2F; Service &#x2F; Respository &#x2F; Component</p></li><li><p>我们使用自定义注解来完成.</p><p>● 代码实现</p></li><li><p>仍然使用前面的 \com\hspedu\spring\component\ 包下的类</p></li><li><p>创建 ComponentScan.java</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解读</span></span><br><span class="line"><span class="comment"> * 1. <span class="doctag">@Target</span>(ElementType.TYPE)指定我们的ComponentScan注解可以修饰 Type程序元素</span></span><br><span class="line"><span class="comment"> * 2. <span class="doctag">@Retention</span>(RetentionPolicy.RUNTIME) 指定ComponentScan注解 保留范围</span></span><br><span class="line"><span class="comment"> * 3. String value() default &quot;&quot;; 表示ComponentScan 可以传入 value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ComponentScan &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>创 建 HspSpringConfig.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.spring.annotation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 韩顺平</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 这是一个配置类, 作用类似我们原生spring的 beans.xml 容器配置文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.hspedu.spring.component&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HspSpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>创 建 HspSpringApplicationContext.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HspSpringApplicationContext 类的作用类似Spring原生ioc容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HspSpringApplicationContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Class configClass;</span><br><span class="line">    <span class="comment">//ioc我存放的就是通过反射创建的对象(基于注解方式)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Object&gt; ioc =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HspSpringApplicationContext</span><span class="params">(Class configClass)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.configClass = configClass;</span><br><span class="line">        System.out.println(<span class="string">&quot;this.configClass=&quot;</span> + <span class="built_in">this</span>.configClass);</span><br><span class="line">        <span class="comment">//获取要扫描的包</span></span><br><span class="line">        <span class="comment">//1. 先得到HspSpringConfig配置的的@ComponentScan(value = &quot;com.hspedu.spring.component&quot;)</span></span><br><span class="line">        <span class="type">ComponentScan</span> <span class="variable">componentScan</span> <span class="operator">=</span></span><br><span class="line">                (ComponentScan) <span class="built_in">this</span>.configClass.getDeclaredAnnotation(ComponentScan.class);</span><br><span class="line">        <span class="comment">//2. 通过componentScan的value=&gt; 即要扫描的包</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> componentScan.value();</span><br><span class="line">        System.out.println(<span class="string">&quot;要扫描的包= &quot;</span> + path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到要扫描的包下的所有资源(类 .class)⚠️要去out目录下，而不是src目录</span></span><br><span class="line">        <span class="comment">//1.得到类的加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span></span><br><span class="line">                HspApplicationContext.class.getClassLoader();</span><br><span class="line">        <span class="comment">//2. 通过类的加载器获取到要扫描的包的资源 url=》类似一个路径</span></span><br><span class="line">        path = path.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>);<span class="comment">//一定要把. 替换成 /</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">resource</span> <span class="operator">=</span></span><br><span class="line">                classLoader.getResource(path);</span><br><span class="line">        System.out.println(<span class="string">&quot;resource=&quot;</span> + resource);</span><br><span class="line">        <span class="comment">//3. 将要加载的资源(.class) 路径下的文件进行遍历=&gt;io</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(resource.getFile());</span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            File[] files = file.listFiles();</span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;=&quot;</span> + f.getAbsolutePath());</span><br><span class="line">                <span class="comment">//D:\hspedu_spring\spring\out\production\spring\com\hspedu\spring\component\UserService.class</span></span><br><span class="line">                <span class="comment">//获取到 com.hspedu.spring.component.UserService</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">fileAbsolutePath</span> <span class="operator">=</span> f.getAbsolutePath();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//这里我们只处理.class文件</span></span><br><span class="line">                <span class="keyword">if</span> (fileAbsolutePath.endsWith(<span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//1. 获取到类名</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span></span><br><span class="line">                            fileAbsolutePath.substring(fileAbsolutePath.lastIndexOf(<span class="string">&quot;\\&quot;</span>) + <span class="number">1</span>, fileAbsolutePath.indexOf(<span class="string">&quot;.class&quot;</span>));</span><br><span class="line">                    <span class="comment">//System.out.println(&quot;className=&quot; + className);</span></span><br><span class="line">                    <span class="comment">//2. 获取类的完整的路径(全类名)</span></span><br><span class="line">                    <span class="comment">//老师解读 path.replace(&quot;/&quot;,&quot;.&quot;) =&gt; com.hspedu.spring.component.</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">classFullName</span> <span class="operator">=</span> path.replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;.&quot;</span>) +  <span class="string">&quot;.&quot;</span> + className;</span><br><span class="line">                    <span class="comment">//System.out.println(&quot;classFullName=&quot; + classFullName);</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//3. 判断该类是不是需要注入容器, 就看该类是不是有注解 @Component @Service..</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//这时，我们就得到老该类的Class对象</span></span><br><span class="line">                        <span class="comment">//Class clazz = Class.forName(classFullName)</span></span><br><span class="line">                        <span class="comment">//老师说一下</span></span><br><span class="line">                        <span class="comment">//1. Class clazz = Class.forName(classFullName) 可以反射加载类</span></span><br><span class="line">                        <span class="comment">//2. classLoader.loadClass(classFullName); 可以反射类的Class</span></span><br><span class="line">                        <span class="comment">//3. 区别是 : 上面方式后调用来类的静态方法, 下面方法不会</span></span><br><span class="line">                        <span class="comment">//4. aClass.isAnnotationPresent(Component.class) 判断该类是否有 @Component</span></span><br><span class="line">                        Class&lt;?&gt; aClass = classLoader.loadClass(classFullName);</span><br><span class="line">                        <span class="keyword">if</span> (aClass.isAnnotationPresent(Component.class) ||</span><br><span class="line">                                aClass.isAnnotationPresent(Controller.class) ||</span><br><span class="line">                                aClass.isAnnotationPresent(Service.class) ||</span><br><span class="line">                                aClass.isAnnotationPresent(Repository.class)) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//这里老师演示一个Component注解指定value,分配id</span></span><br><span class="line">                            <span class="comment">//老师就是演示了一下机制.</span></span><br><span class="line">                            <span class="keyword">if</span>(aClass.isAnnotationPresent(Component.class)) &#123;</span><br><span class="line">                                <span class="comment">//获取到该注解</span></span><br><span class="line">                                <span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> aClass.getDeclaredAnnotation(Component.class);</span><br><span class="line">                                <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> component.value();</span><br><span class="line">                                <span class="keyword">if</span>(!<span class="string">&quot;&quot;</span>.endsWith(id)) &#123;</span><br><span class="line">                                    className = id;<span class="comment">//替换</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//这时就可以反射对象，并放入到容器中</span></span><br><span class="line">                            Class&lt;?&gt; clazz = Class.forName(classFullName);</span><br><span class="line">                            <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">                            <span class="comment">//放入到容器中, 将类名的首字母小写作为id</span></span><br><span class="line">                            <span class="comment">//StringUtils</span></span><br><span class="line"></span><br><span class="line">                            ioc.put(StringUtils.uncapitalize(className) , instance);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写方法返回对容器中对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ioc.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-19-4-注意事项和细节说明"><a href="#2-3-19-4-注意事项和细节说明" class="headerlink" title="2.3.19.4 注意事项和细节说明"></a>2.3.19.4 注意事项和细节说明</h4><p>还可以通过@Component(value &#x3D; “xx”) @Controller(value &#x3D; “yy”) @Service(value &#x3D; “zz”)中指定的 value, 给 bean 分配 id</p><h3 id="2-3-20-自动装配"><a href="#2-3-20-自动装配" class="headerlink" title="2.3.20 自动装配"></a>2.3.20 自动装配</h3><h4 id="2-3-20-1-应用实例"><a href="#2-3-20-1-应用实例" class="headerlink" title="2.3.20.1 应用实例"></a>2.3.20.1 应用实例</h4><p>​● 基本说明</p><ol><li><p>基于注解配置 bean，也可实现自动装配，使用的注解是：@AutoWired 或者 @Resource</p></li><li><p><strong>@AutoWired 的规则说明</strong></p><ol><li>🌟在 IOC 容器中查找待装配的组件的<strong>类型</strong>，如果有唯一的 bean 匹配，则使用该 bean 装配 </li><li>🌟如待装配的类型对应的 bean 在 IOC 容器中有多个，则使用<strong>待装配的属性的属性名作为 id 值</strong>再进行查找, 找到就装配，找不到就抛异常</li></ol></li><li><p><strong>@Resource 的规则说明</strong></p><ol><li>🌟@Resource 有两个属性是比较重要的,分是 name 和 type,Spring 将@Resource 注解的name 属性解析为 bean 的名字,而 type 属性则解析为 bean 的类型.所以如果使用 name 属性,则使用 byName 的自动注入策略,而使用 type 属性时则使用 byType 自动注入策略(同样，容器中只能有一个该类型的对象)</li><li>🌟如果@Resource 没有指定 name 和 type ,则先使用byName注入策略(用你的对象名字找ioc容器中的id), 如果匹配不上,再使用 byType 策略(ioc容器中该类型对象必须唯一), 如果都不成功，就会报错</li></ol></li><li><p>总结：<strong>不管是@Autowired 还是 @Resource都保证属性名是规范的写法就可以注入.</strong></p></li></ol><h4 id="2-3-20-2-注意事项和细节说明"><a href="#2-3-20-2-注意事项和细节说明" class="headerlink" title="2.3.20.2 注意事项和细节说明"></a>2.3.20.2 注意事项和细节说明</h4><ol><li>如待装配的类型对应的 bean 在 IOC 容器中有多个， 则使用待装配的属性的属性名作为 id 值再进行查找, 找到就装配， 找不到就抛异常</li></ol><h3 id="2-3-21-泛型依赖注入"><a href="#2-3-21-泛型依赖注入" class="headerlink" title="2.3.21 泛型依赖注入"></a>2.3.21 泛型依赖注入</h3><h4 id="2-3-21-1-泛型依赖解释"><a href="#2-3-21-1-泛型依赖解释" class="headerlink" title="2.3.21.1 泛型依赖解释"></a>2.3.21.1 泛型依赖解释</h4><p>​● 基本说明</p><ol><li><p><strong>为了更好的管理有继承和相互依赖的 bean 的自动装配</strong>， spring 还提供基于泛型依赖的注入机制</p></li><li><p>在继承关系复杂情况下， 泛型依赖注入就会有很大的优越性</p></li></ol><h4 id="2-3-21-2-应用实例"><a href="#2-3-21-2-应用实例" class="headerlink" title="2.3.21.2 应用实例"></a>2.3.21.2 应用实例</h4><p>​● 应用实例需求</p><ol><li>各个类关系图</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230725145512754.png" alt="image-20230725145512754"></p><ol start="2"><li>传统方法是将 PhoneDao &#x2F;BookDao 自动装配到 BookService&#x2F;PhoneSerive 中，当这种继承关系多时，就比较麻烦，可以使用 spring 提供的泛型依赖注入</li></ol><p>(跟配置mybatis plus的service层、impl层、mapper层之间的关系很像)</p><h1 id="3-AOP"><a href="#3-AOP" class="headerlink" title="3 AOP"></a>3 AOP</h1><h2 id="3-1-官方文档"><a href="#3-1-官方文档" class="headerlink" title="3.1 官方文档"></a>3.1 官方文档</h2><h3 id="3-1-1-AOP-讲解"><a href="#3-1-1-AOP-讲解" class="headerlink" title="3.1.1 AOP 讲解:"></a>3.1.1 AOP 讲解:</h3><p>spring-framework-5.3.8&#x2F;docs&#x2F;reference&#x2F;html&#x2F;core.html#aop</p><h3 id="3-1-2-AOP-APIs"><a href="#3-1-2-AOP-APIs" class="headerlink" title="3.1.2 AOP APIs :"></a>3.1.2 AOP APIs :</h3><p>spring-framework-5.3.8&#x2F;docs&#x2F;reference&#x2F;html&#x2F;core.html#aop-api</p><h2 id="3-2-动态代理-精致小案例"><a href="#3-2-动态代理-精致小案例" class="headerlink" title="3.2 动态代理-精致小案例"></a>3.2 动态代理-精致小案例</h2><h3 id="3-2-1-需求说明"><a href="#3-2-1-需求说明" class="headerlink" title="3.2.1 需求说明"></a>3.2.1 需求说明</h3><p>● 需求说明</p><ol><li>有 Vehicle(交通工具接口, 有一个 run 方法), 下面有两个实现类 Car 和 Ship</li><li>当运行 Car 对象 的 run 方法和 Ship 对象的 run 方法时，输入如下内容, 注意观察前后有统一的输出.</li></ol><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230725153717459.png" alt="image-20230725153717459" style="zoom:50%;" /><h3 id="3-2-2-解决方案-传统方式"><a href="#3-2-2-解决方案-传统方式" class="headerlink" title="3.2.2 解决方案-传统方式"></a>3.2.2 解决方案-传统方式</h3><ol><li><p>传统的解决思路， 在各个方法的[前， 执行过程, 后]输出日志提示信息</p></li><li><p>来思考一下， 解决方案好吗? &#x3D;&#x3D;&#x3D;&gt; 代码冗余, 其实就是单个对象的调用,并没有很好的解决</p></li></ol><h3 id="3-2-3-解决方案-🌟动态代理方式"><a href="#3-2-3-解决方案-🌟动态代理方式" class="headerlink" title="3.2.3 解决方案-🌟动态代理方式 !!!!!!!!"></a>3.2.3 解决方案-🌟动态代理方式 !!!!!!!!</h3><p>● 解决方案 2-代码实现</p><ol><li>动态代理解决思路，在调用方法时，使用反射机制，根据方法去决定调用哪个对象方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.spring.proxy2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 韩顺平</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 接口，该接口有run方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fly</span><span class="params">(<span class="type">int</span> height)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.spring.proxy2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VehicleProxyProvider 该类可以返回一个代理对象.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VehicleProxyProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个属性</span></span><br><span class="line">    <span class="comment">//target_vehicle 表示真正要执行的对象</span></span><br><span class="line">    <span class="comment">//该对象实现了Vehicle接口</span></span><br><span class="line">    <span class="keyword">private</span> Vehicle target_vehicle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VehicleProxyProvider</span><span class="params">(Vehicle target_vehicle)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target_vehicle = target_vehicle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，可以返回一个代理对象, 该代理对象可以通过反射机制调用到被代理对象的方法</span></span><br><span class="line">    <span class="comment">//老师解读</span></span><br><span class="line">    <span class="comment">//1. 这个方法非常重要， 理解有一定难度</span></span><br><span class="line">    <span class="keyword">public</span> Vehicle <span class="title function_">getProxy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span></span><br><span class="line">                target_vehicle.getClass().getClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到要代理的对象/被执行对象 的接口信息,底层是通过接口来完成调用</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = target_vehicle.getClass().getInterfaces();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建InvocationHandler 对象</span></span><br><span class="line">        <span class="comment">//因为 InvocationHandler 是接口，所以我们可以通过匿名对象的方式来创建该对象</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * public interface InvocationHandler &#123;</span></span><br><span class="line"><span class="comment">         *  public Object invoke(Object proxy, Method method, Object[] args)</span></span><br><span class="line"><span class="comment">         *         throws Throwable;</span></span><br><span class="line"><span class="comment">         * &#125;</span></span><br><span class="line"><span class="comment">         * invoke 方法是将来执行我们的target_vehicle的方法时，会调用到</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * invoke 方法是将来执行我们的target_vehicle的方法时，会调用到</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> o 表示代理对象</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> method 就是通过代理对象调用方法时，的哪个方法 代理对象.run()</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> args : 表示调用 代理对象.run(xx) 传入的参数</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span> 表示 代理对象.run(xx) 执行后的结果.</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object o, Method method, Object[] args)</span></span><br><span class="line">                    <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;交通工具开始运行了....&quot;</span>);</span><br><span class="line">                <span class="comment">//这里是我们的反射基础 =&gt; OOP</span></span><br><span class="line">                <span class="comment">//method 是？: public abstract void com.hspedu.spring.proxy2.Vehicle.run()</span></span><br><span class="line">                <span class="comment">//target_vehicle 是?: Ship对象</span></span><br><span class="line">                <span class="comment">//args 是null</span></span><br><span class="line">                <span class="comment">//这里通过反射+动态绑定机制，就会执行到被代理对象的方法</span></span><br><span class="line">                <span class="comment">//执行完毕就返回</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target_vehicle, args);</span><br><span class="line">                System.out.println(<span class="string">&quot;交通工具停止运行了....&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          public static Object newProxyInstance(ClassLoader loader,</span></span><br><span class="line"><span class="comment">                                          Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="comment">                                          InvocationHandler h)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          老师解读</span></span><br><span class="line"><span class="comment">          1. Proxy.newProxyInstance() 可以返回一个代理对象</span></span><br><span class="line"><span class="comment">          2. ClassLoader loader: 类的加载器.</span></span><br><span class="line"><span class="comment">          3. Class&lt;?&gt;[] interfaces 就是将来要代理的对象的接口信息</span></span><br><span class="line"><span class="comment">          4. InvocationHandler h 调用处理器/对象 有一个非常重要的方法invoke</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">proxy</span> <span class="operator">=</span></span><br><span class="line">                (Vehicle)Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.spring.proxy2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 韩顺平</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVehicle</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//OOP基础=&gt;java基础</span></span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">vehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ship</span>();</span><br><span class="line">        <span class="comment">//动态绑定</span></span><br><span class="line">        vehicle.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">proxyRun</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建Ship对象</span></span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">vehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建VehicleProxyProvider对象, 并且我们传入的要代理的对象</span></span><br><span class="line">        <span class="type">VehicleProxyProvider</span> <span class="variable">vehicleProxyProvider</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">VehicleProxyProvider</span>(vehicle);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取代理对象, 该对象可以代理执行方法</span></span><br><span class="line">        <span class="comment">//老师解读</span></span><br><span class="line">        <span class="comment">//1. porxy 编译类型 Vehicle</span></span><br><span class="line">        <span class="comment">//2. 运行类型 是代理类型 class com.sun.proxy.$Proxy9</span></span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">proxy</span> <span class="operator">=</span> vehicleProxyProvider.getProxy();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;proxy的编译类型是 Vehicle&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;proxy的运行类型是 &quot;</span> + proxy.getClass());</span><br><span class="line">        <span class="comment">//下面老韩就要给大家解读/debug怎么 执行到 代理对象的 public Object invoke(Object o, Method method, Object[] args)</span></span><br><span class="line">        <span class="comment">//梳理完毕. proxy的编译类型是 Vehicle, 运行类型是 class com.sun.proxy.$Proxy9</span></span><br><span class="line">        <span class="comment">//所以当执行run方法时，会执行到 代理对象的invoke</span></span><br><span class="line">        <span class="comment">//如何体现动态 [1. 被代理的对象 2. 方法]</span></span><br><span class="line">        <span class="comment">//proxy.run();</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> proxy.fly(<span class="number">10000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result=&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-动态代理深入"><a href="#3-3-动态代理深入" class="headerlink" title="3.3 动态代理深入"></a>3.3 动态代理深入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.spring.aop.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 韩顺平</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 可以返回一个动态代理对象, 可以执行SmartDog对象的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProxyProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义我们要执行的目标对象, 该对象需要实现SmartAnimalable</span></span><br><span class="line">    <span class="keyword">private</span> SmartAnimalable target_obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyProxyProvider</span><span class="params">(SmartAnimalable target_obj)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target_obj = target_obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法, 可以返回代理对象，该代理对象可以执行目标对象</span></span><br><span class="line">    <span class="keyword">public</span> SmartAnimalable <span class="title function_">getProxy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 先到的类加载器/对象</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> target_obj.getClass().getClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 得到要执行的目标对象的接口信息</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = target_obj.getClass().getInterfaces();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 创建InvocationHandler</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;方法执行前-日志-方法名-&quot;</span> + method.getName() + <span class="string">&quot;-参数 &quot;</span></span><br><span class="line">                            + Arrays.asList(args)); <span class="comment">//这里从AOP看，就是一个横切关注点-前置通知</span></span><br><span class="line">                    <span class="comment">//使用反射调用方法</span></span><br><span class="line">                    result = method.invoke(target_obj, args);</span><br><span class="line">                    System.out.println(<span class="string">&quot;方法执行正常结束-日志-方法名-&quot;</span> + method.getName() + <span class="string">&quot;-结果result= &quot;</span></span><br><span class="line">                            + result);<span class="comment">//从AOP看, 也是一个横切关注点-返回通知</span></span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">//如果反射执行方法时，出现异常,就会进入到catch&#123;&#125;</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;方法执行异常-日志-方法名-&quot;</span> + method.getName()</span><br><span class="line">                            + <span class="string">&quot;-异常类型=&quot;</span> + e.getClass().getName());<span class="comment">//从AOP看, 也是一个横切关注点-异常通知</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;<span class="comment">//不管你是否出现异常,最终都会执行到finally&#123;&#125;</span></span><br><span class="line">                    <span class="comment">//从AOP的角度看, 也是一个横切关注点-最终通知</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;方法最终结束-日志-方法名-&quot;</span> + method.getName());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        <span class="type">SmartAnimalable</span> <span class="variable">proxy</span> <span class="operator">=</span></span><br><span class="line">                (SmartAnimalable)Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-老韩分析：-问题再次出现"><a href="#3-4-老韩分析：-问题再次出现" class="headerlink" title="3.4 老韩分析： 问题再次出现"></a>3.4 老韩分析： 问题再次出现</h2><h3 id="3-4-1-问题提出"><a href="#3-4-1-问题提出" class="headerlink" title="3.4.1 问题提出"></a>3.4.1 问题提出</h3><p>​● 问题提出</p><ol><li>在 MyProxyProvider.java 中, 我们的输出语句功能比较弱，在实际开发中，我们希望是以一个方法的形式，嵌入到真正执行的目标方法前，怎么办?</li><li>也就是如图分析</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230725164754136.png" alt="image-20230725164754136"></p><h3 id="3-4-2-用老韩的土方法解决"><a href="#3-4-2-用老韩的土方法解决" class="headerlink" title="3.4.2 用老韩的土方法解决"></a>3.4.2 用老韩的土方法解决</h3><ol><li><p>需求分析： 使用老韩的土方法解决前面的问题 &#x3D;&gt; 后面使用 Spring 的 AOP 组件完成, 先过苦日子， 再过甜日子</p></li><li><p>先新建一个包，把相关文件拷贝过来，进行修改完成，思路更加清晰.</p></li></ol><p>老师学习小技巧:新建一个包，保留原来的代码</p><p>具体实现方式省略…………把红框里的代码在同一类中自行封装成一个个方法即可</p><ol start="3"><li>该方法问题分析：耦合度高</li></ol><h3 id="3-4-3-对土方法解耦-开发简易的-AOP-类"><a href="#3-4-3-对土方法解耦-开发简易的-AOP-类" class="headerlink" title="3.4.3 对土方法解耦-开发简易的 AOP 类"></a>3.4.3 对土方法解耦-开发简易的 AOP 类</h3><p>把这些方法抽出，放到一个类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 韩顺平</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 我们自己编写一个一个极简的AOP类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HspAOP</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们一个方法,在目标对象执行前执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HspAOP-方法执行前-日志-方法名-&quot;</span> + method.getName() + <span class="string">&quot;-参数 &quot;</span></span><br><span class="line">                + Arrays.asList(args)); <span class="comment">//这里从AOP看，就是一个横切关注点-前置通知</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们一个方法,在目标对象执行后执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(Method method, Object result)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HspAOP-方法执行正常结束-日志-方法名-&quot;</span> + method.getName() + <span class="string">&quot;-结果result= &quot;</span> + result);<span class="comment">//从AOP看, 也是一个横切关注点-返回通知</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-4-再次分析-提出-Spring-AOP"><a href="#3-4-4-再次分析-提出-Spring-AOP" class="headerlink" title="3.4.4 再次分析-提出 Spring AOP"></a>3.4.4 再次分析-提出 Spring AOP</h3><h4 id="3-4-4-1-土方法-不够灵活"><a href="#3-4-4-1-土方法-不够灵活" class="headerlink" title="3.4.4.1 土方法 不够灵活"></a>3.4.4.1 土方法 不够灵活</h4><h4 id="3-4-4-2-土方法-复用性差"><a href="#3-4-4-2-土方法-复用性差" class="headerlink" title="3.4.4.2 土方法 复用性差"></a>3.4.4.2 土方法 复用性差</h4><h4 id="3-4-4-3-土方法-还是一种硬编码-因为没有注解和反射支撑"><a href="#3-4-4-3-土方法-还是一种硬编码-因为没有注解和反射支撑" class="headerlink" title="3.4.4.3 土方法 还是一种硬编码(因为没有注解和反射支撑)"></a>3.4.4.3 土方法 还是一种硬编码(因为没有注解和反射支撑)</h4><h4 id="3-4-4-4-Spring-AOP-闪亮登场-底层是-ASPECTJ"><a href="#3-4-4-4-Spring-AOP-闪亮登场-底层是-ASPECTJ" class="headerlink" title="3.4.4.4 Spring AOP 闪亮登场-底层是 ASPECTJ"></a>3.4.4.4 Spring AOP 闪亮登场-底层是 ASPECTJ</h4><h4 id="3-4-4-5-有了前面的技术引导，-理解-Spring-AOP-就水到渠成"><a href="#3-4-4-5-有了前面的技术引导，-理解-Spring-AOP-就水到渠成" class="headerlink" title="3.4.4.5 有了前面的技术引导， 理解 Spring AOP 就水到渠成"></a>3.4.4.5 有了前面的技术引导， 理解 Spring AOP 就水到渠成</h4><h2 id="3-5-AOP-的基本介绍"><a href="#3-5-AOP-的基本介绍" class="headerlink" title="3.5 AOP 的基本介绍"></a>3.5 AOP 的基本介绍</h2><p>​● 什么是 AOP</p><p>​AOP 的全称(aspect oriented programming) ，<strong>面向切面编程</strong></p><p>​● 2 张示意图说明 AOP 的相关概念</p><ol><li>一张简易图说明 AOP</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230725224710622.png" alt="image-20230725224710622"></p><ol start="2"><li>一张详细图说明 AOP</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230725225233953.png" alt="image-20230725225233953"></p><p>● AOP 实现方式</p><ol><li><p>基于动态代理的方式[内置 aop 实现]</p></li><li><p>使用框架 aspectj 来实现</p></li></ol><h2 id="3-6-AOP-编程快速入门"><a href="#3-6-AOP-编程快速入门" class="headerlink" title="3.6 AOP 编程快速入门"></a>3.6 AOP 编程快速入门</h2><h2 id="3-6-1-基本说明"><a href="#3-6-1-基本说明" class="headerlink" title="3.6.1 基本说明"></a>3.6.1 基本说明</h2><p>​● 说明</p><ol><li><p>需要引入核心的 aspect 包</p></li><li><p>在切面类中声明通知方法</p><ol><li>前置通知：@Before</li><li>返回通知：@AfterReturning</li><li>异常通知：@AfterThrowing</li><li>后置通知：@After</li><li>环绕通知：@Around</li></ol></li></ol><h3 id="3-6-2-快速入门实例"><a href="#3-6-2-快速入门实例" class="headerlink" title="3.6.2 快速入门实例"></a>3.6.2 快速入门实例</h3><p>​● 需求说明</p><p>​我们使用 aop 编程的方式，来实现手写的动态代理案例效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.spring.aop.aspectj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.Signature;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切面类 , 类似于我们以前自己写的MyProxyProvider,但是功能强大很多</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Order(value = 1)</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//表示是一个切面类[底层切面编程的支撑(动态代理+反射+动态绑定...)]</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">//会将SmartAnimalAspect3注入到容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmartAnimalAspect3</span> &#123;</span><br><span class="line">    <span class="comment">//希望将f1方法切入到SmartDog-getSum前执行-前置通知</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 老师解读</span></span><br><span class="line"><span class="comment">     * 1. <span class="doctag">@Before</span> 表示前置通知:即在我们的目标对象执行方法前执行</span></span><br><span class="line"><span class="comment">     * 2. value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float)</span></span><br><span class="line"><span class="comment">     * 指定切入到哪个类的哪个方法  形式是: 访问修饰符 返回类型 全类名.方法名(形参列表)</span></span><br><span class="line"><span class="comment">     * 3. showBeginLog方法可以理解成就是一个切入方法, 这个方法名是可以程序员指定  比如:showBeginLog</span></span><br><span class="line"><span class="comment">     * 4. JoinPoint joinPoint 在底层执行时，由AspectJ切面框架，会给该切入方法传入joinPoint对象, 通过                                                   * 该方法，程序员可以获取到相关信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showBeginLog</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="comment">//通过连接点对象joinPoint 可以获取方法签名</span></span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        System.out.println(<span class="string">&quot;SmartAnimalAspect3-切面类showBeginLog()-方法执行前-日志-方法名-&quot;</span> + signature.getName() + <span class="string">&quot;-参数 &quot;</span></span><br><span class="line">                + Arrays.asList(joinPoint.getArgs()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回通知：即把showSuccessEndLog方法切入到目标对象方法正常执行完毕后的地方</span></span><br><span class="line">    <span class="comment">//老韩解读</span></span><br><span class="line">    <span class="comment">//1. 如果我们希望把目标方法执行的结果，返回给切入方法</span></span><br><span class="line">    <span class="comment">//2. 可以再 @AfterReturning 增加属性 , 比如 returning = &quot;res&quot;</span></span><br><span class="line">    <span class="comment">//3. 同时在切入方法增加 Object res</span></span><br><span class="line">    <span class="comment">//4. 注意: returning = &quot;res&quot; 和 Object res 的 res名字一致</span></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float))&quot;, returning = &quot;res&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showSuccessEndLog</span><span class="params">(JoinPoint joinPoint, Object res)</span> &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        System.out.println(<span class="string">&quot;SmartAnimalAspect3-切面类showSuccessEndLog()-方法执行正常结束-日志-方法名-&quot;</span> + signature.getName() + <span class="string">&quot; 返回的结果是=&quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常通知：即把showExceptionLog方法切入到目标对象方法执行发生异常的的catch&#123;&#125;</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float))&quot;, throwing = &quot;throwable&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showExceptionLog</span><span class="params">(JoinPoint joinPoint, Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        System.out.println(<span class="string">&quot;SmartAnimalAspect3-切面类showExceptionLog()-方法执行异常-日志-方法名-&quot;</span> + signature.getName() + <span class="string">&quot; 异常信息=&quot;</span> + throwable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终通知：即把showFinallyEndLog方法切入到目标方法执行后(不管是否发生异常,都要执行 finally&#123;&#125;)</span></span><br><span class="line">    <span class="meta">@After(value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showFinallyEndLog</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        System.out.println(<span class="string">&quot;SmartAnimalAspect3-切面类showFinallyEndLog()-方法最终执行完毕-日志-方法名-&quot;</span> + signature.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用AOP时，记得在beans.xml中添加以下代码，以开启基于注解的 AOP 功能 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-6-3-细节说明"><a href="#3-6-3-细节说明" class="headerlink" title="3.6.3 细节说明"></a>3.6.3 细节说明</h3><ol><li><p>关于切面类方法命名可以自己规范一下, 比如 showBeginLog(), showSuccessEndLog(), showExceptionLog() , showFinallyEndLog()</p></li><li><p>切入表达式的更多配置，比如使用模糊配置@Before(value&#x3D;”execution(* com.hspedu.aop.proxy.SmartDog.*(..))”)</p></li><li><p>表示所有访问权限，所有包的下所有有类的所方法，都会被执行该前置通知方法</p></li></ol><p>​@Before(value&#x3D;”execution(* <em>.</em>(..))”)</p><ol start="4"><li><strong>当 spring 容器开启了 <!-- 开启基于注解的 AOP 功能 -->&lt; aop:aspectj-autoproxy&#x2F;&gt; , 我们获取注入的对象, 需要以接口的类型来获取, 因为你注入的对象.getClass() 已经是代理类型了!</strong></li><li><strong>当 spring 容器开启了 <!-- 开启基于注解的 AOP 功能 -->&lt; aop:aspectj-autoproxy&#x2F;&gt;  , 我们获取注入的对象, 也可以通过 id 来获取, 但是也要转成接口类型</strong></li></ol><h2 id="3-7-AOP-切入表达式"><a href="#3-7-AOP-切入表达式" class="headerlink" title="3.7 AOP-切入表达式"></a>3.7 AOP-切入表达式</h2><h3 id="3-7-1-具体使用"><a href="#3-7-1-具体使用" class="headerlink" title="3.7.1 具体使用"></a>3.7.1 具体使用</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230726083322753.png" alt="image-20230726083322753"></p><h3 id="3-7-2-注意事项和细节"><a href="#3-7-2-注意事项和细节" class="headerlink" title="3.7.2 注意事项和细节"></a>3.7.2 注意事项和细节</h3><ol><li><p>切入表达式可以指向类的方法, 这时切入表达式会对该类&#x2F;对象生效(类名.*)</p></li><li><p>切入表达式也可以<strong>指向接口的方法</strong>, 这时切入表达式会**<u>对实现了接口的类&#x2F;对象生效</u>**</p></li><li><p>切入表达式也可以对没有实现接口的类，进行切入</p></li><li><p>老师补充: 动态代理 jdk 的 Proxy 与 Spring 的 CGlib</p></li></ol><p>🌟<a href="https://www.cnblogs.com/threeAgePie/p/15832586.html">https://www.cnblogs.com/threeAgePie/p/15832586.html</a></p><p>—对没有实现接口的类生成的代理是CGlib动态代理</p><h4 id="两个动态代理的区别"><a href="#两个动态代理的区别" class="headerlink" title="两个动态代理的区别"></a>两个动态代理的区别</h4><ol><li>JDK动态代理是面向接口的，只能增强实现类中接口中存在的方法。CGlib是面向父类的，可以增强父类的所有方法</li><li>JDK得到的对象是JDK代理对象实例，而CGlib得到的对象是被代理对象的子类</li></ol><h2 id="3-8-AOP-JoinPoint"><a href="#3-8-AOP-JoinPoint" class="headerlink" title="3.8 AOP-JoinPoint"></a>3.8 AOP-JoinPoint</h2><h3 id="3-8-1-应用实例"><a href="#3-8-1-应用实例" class="headerlink" title="3.8.1 应用实例"></a>3.8.1 应用实例</h3><p>​● 通过 JoinPoint 可以获取到调用方法的签名</p><p>​● 应用实例需求</p><p>说明: 在调用前置通知获取到调用方法的签名, 和其它相关信息</p><p>​● 应用实例-代码实现</p><p>​前面我们已经举例说明过了</p><p>​● 其它常用方法一览</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeMethod</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">joinPoint.getSignature().getName(); <span class="comment">// 获取目标方法名    </span></span><br><span class="line">joinPoint.getSignature().getDeclaringType().getSimpleName(); <span class="comment">// 获取目标方法所属类的简单类名</span></span><br><span class="line">joinPoint.getSignature().getDeclaringTypeName(); <span class="comment">// 获取目标方法所属类的类名</span></span><br><span class="line">joinPoint.getSignature().getModifiers(); <span class="comment">// 获取目标方法声明类型(public、 private、protected)</span></span><br><span class="line">  Object[] args = joinPoint.getArgs(); <span class="comment">// 获取传入目标方法的参数， 返回一个数组</span></span><br><span class="line">  joinPoint.getTarget(); <span class="comment">// 获取被代理的对象joinPoint.getThis(); // 获取代理对象自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-9-AOP-返回通知获取结果"><a href="#3-9-AOP-返回通知获取结果" class="headerlink" title="3.9 AOP-返回通知获取结果"></a>3.9 AOP-返回通知获取结果</h2><h3 id="3-9-1-应用实例"><a href="#3-9-1-应用实例" class="headerlink" title="3.9.1 应用实例"></a>3.9.1 应用实例</h3><p>​● 如何在返回通知方法获取返回结果</p><p>​看一个需求:</p><p>​在返回通知方法获取返回的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 如果我们希望把目标方法执行的结果，返回给切入方法</span></span><br><span class="line"><span class="comment">//2. 可以再 @AfterReturning 增加属性 , 比如 returning = &quot;res&quot;</span></span><br><span class="line"><span class="comment">//3. 同时在切入方法增加 Object res</span></span><br><span class="line"><span class="comment">//4. 注意: returning = &quot;res&quot; 和 Object res 的 res名字一致</span></span><br><span class="line"><span class="meta">@AfterReturning(value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float))&quot;, returning = &quot;res&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showSuccessEndLog</span><span class="params">(JoinPoint joinPoint, Object res)</span> &#123;</span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">    System.out.println(<span class="string">&quot;SmartAnimalAspect3-切面类showSuccessEndLog()-方法执行正常结束-日志-方法名-&quot;</span> + signature.getName() + <span class="string">&quot; 返回的结果是=&quot;</span> + res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-10-AOP-异常通知中获取异常"><a href="#3-10-AOP-异常通知中获取异常" class="headerlink" title="3.10 AOP-异常通知中获取异常"></a>3.10 AOP-异常通知中获取异常</h2><p>同理……</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异常通知：即把showExceptionLog方法切入到目标对象方法执行发生异常的的catch&#123;&#125;</span></span><br><span class="line"><span class="meta">@AfterThrowing(value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float))&quot;, throwing = &quot;throwable&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showExceptionLog</span><span class="params">(JoinPoint joinPoint, Throwable throwable)</span> &#123;</span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">    System.out.println(<span class="string">&quot;SmartAnimalAspect3-切面类showExceptionLog()-方法执行异常-日志-方法名-&quot;</span> + signature.getName() + <span class="string">&quot; 异常信息=&quot;</span> + throwable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-11-AOP-环绕通知【了解】"><a href="#3-11-AOP-环绕通知【了解】" class="headerlink" title="3.11 AOP-环绕通知【了解】"></a>3.11 AOP-环绕通知【了解】</h2><h3 id="3-11-1-应用实例"><a href="#3-11-1-应用实例" class="headerlink" title="3.11.1 应用实例"></a>3.11.1 应用实例</h3><p>​● 环绕通知可以完成其它四个通知要做的事情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示环绕通知的使用-了解</span></span><br><span class="line"><span class="comment">//老师解读</span></span><br><span class="line"><span class="comment">//1. @Around: 表示这是一个环绕通知[完成其它四个通知的功能]</span></span><br><span class="line"><span class="comment">//2. value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float)) 切入点表达式</span></span><br><span class="line"><span class="comment">//3. doAround 表示要切入的方法 - 调用结构 try-catch-finally</span></span><br><span class="line"><span class="meta">@Around(value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.相当于前置通知完成的事情</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        List&lt;Object&gt; argList = Arrays.asList(args);</span><br><span class="line">        System.out.println(<span class="string">&quot;AOP环绕通知[-前置通知]&quot;</span> + methodName + <span class="string">&quot;方法开始了--参数有：&quot;</span> + argList);</span><br><span class="line">        <span class="comment">//在环绕通知中一定要调用joinPoint.proceed()来执行目标方法</span></span><br><span class="line">        result = joinPoint.proceed();</span><br><span class="line">        <span class="comment">//2.相当于返回通知完成的事情</span></span><br><span class="line">        System.out.println(<span class="string">&quot;AOP环绕通知[-返回通知]&quot;</span> + methodName + <span class="string">&quot;方法结束了--结果是：&quot;</span> + result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        <span class="comment">//3.相当于异常通知完成的事情</span></span><br><span class="line">        System.out.println(<span class="string">&quot;AOP环绕通知[-异常通知]&quot;</span> + methodName + <span class="string">&quot;方法抛异常了--异常对象：&quot;</span> + throwable);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.相当于最终通知完成的事情</span></span><br><span class="line">        System.out.println(<span class="string">&quot;AOP环绕通知[-后置通知]&quot;</span> + methodName + <span class="string">&quot;方法最终结束了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-12-AOP-切入点表达式重用"><a href="#3-12-AOP-切入点表达式重用" class="headerlink" title="3.12 AOP-切入点表达式重用"></a>3.12 AOP-切入点表达式重用</h2><h3 id="3-12-1-应用实例"><a href="#3-12-1-应用实例" class="headerlink" title="3.12.1 应用实例"></a>3.12.1 应用实例</h3><p>● 切入点表达式重用(其实就是把切入表达式提取出来，这样可以避免当一个方法需要多次切入时，每个切入方法都需要重写一遍切入表达式的情况)</p><p>为了统一管理切入点表达式，可以使用切入点表达式重用技术</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个切入点, 在后面使用时可以直接引用, 提高了复用性</span></span><br><span class="line"><span class="meta">@Pointcut(value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float)))</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string">public void myPointCut() &#123;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//希望将myPointCut方法切入到SmartDog-getSum前执行-前置通知</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * 老师解读</span></span><br><span class="line"><span class="string"> * 1. @Before 表示前置通知:即在我们的目标对象执行方法前执行</span></span><br><span class="line"><span class="string"> * 2. value = &quot;</span>execution(<span class="keyword">public</span> <span class="type">float</span> com.hspedu.spring.aop.aspectj.SmartDog.getSum(<span class="type">float</span>, <span class="type">float</span>)</span><br><span class="line"> * 指定切入到哪个类的哪个方法  形式是: 访问修饰符 返回类型 全类名.方法名(形参列表)</span><br><span class="line"> * <span class="number">3.</span> showBeginLog方法可以理解成就是一个切入方法, 这个方法名是可以程序员指定  比如:showBeginLog</span><br><span class="line"> * <span class="number">4.</span> JoinPoint joinPoint 在底层执行时，由AspectJ切面框架， 会给该切入方法传入 joinPoint对象</span><br><span class="line"> * , 通过该方法，程序员可以获取到 相关信息</span><br><span class="line"> *</span><br><span class="line"> * <span class="meta">@param</span> joinPoint</span><br><span class="line"> */</span><br><span class="line"><span class="comment">//@Before(value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float))&quot;)</span></span><br><span class="line"><span class="comment">//这里我们使用定义好的切入点</span></span><br><span class="line"><span class="meta">@Before(value = &quot;myPointCut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showBeginLog</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">    <span class="comment">//通过连接点对象joinPoint 可以获取方法签名</span></span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">    System.out.println(<span class="string">&quot;SmartAnimalAspect-切面类showBeginLog()[使用的myPointCut()]-方法执行前-日志-方法名-&quot;</span> + signature.getName() + <span class="string">&quot;-参数 &quot;</span></span><br><span class="line">            + Arrays.asList(joinPoint.getArgs()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回通知：即把showSuccessEndLog方法切入到目标对象方法正常执行完毕后的地方</span></span><br><span class="line"><span class="comment">//老韩解读</span></span><br><span class="line"><span class="comment">//1. 如果我们希望把目标方法执行的结果，返回给切入方法</span></span><br><span class="line"><span class="comment">//2. 可以再 @AfterReturning 增加属性 , 比如 returning = &quot;res&quot;</span></span><br><span class="line"><span class="comment">//3. 同时在切入方法增加 Object res</span></span><br><span class="line"><span class="comment">//4. 注意: returning = &quot;res&quot; 和 Object res 的 res名字一致</span></span><br><span class="line"><span class="comment">//@AfterReturning(value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float))&quot;, returning = &quot;res&quot;)</span></span><br><span class="line"><span class="comment">//使用切入点</span></span><br><span class="line"><span class="meta">@AfterReturning(value = &quot;myPointCut()&quot;, returning = &quot;res&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showSuccessEndLog</span><span class="params">(JoinPoint joinPoint, Object res)</span> &#123;</span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">    System.out.println(<span class="string">&quot;SmartAnimalAspect-切面类showSuccessEndLog()-方法执行正常结束-日志-方法名-&quot;</span> + signature.getName() + <span class="string">&quot; 返回的结果是=&quot;</span> + res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//异常通知：即把showExceptionLog方法切入到目标对象方法执行发生异常的的catch&#123;&#125;</span></span><br><span class="line"><span class="comment">//@AfterThrowing(value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float))&quot;, throwing = &quot;throwable&quot;)</span></span><br><span class="line"><span class="comment">//直接使用切入点表达式</span></span><br><span class="line"><span class="meta">@AfterThrowing(value = &quot;myPointCut()&quot;, throwing = &quot;throwable&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showExceptionLog</span><span class="params">(JoinPoint joinPoint, Throwable throwable)</span> &#123;</span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">    System.out.println(<span class="string">&quot;SmartAnimalAspect-切面类showExceptionLog()-方法执行异常-日志-方法名-&quot;</span> + signature.getName() + <span class="string">&quot; 异常信息=&quot;</span> + throwable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终通知：即把showFinallyEndLog方法切入到目标方法执行后(不管是否发生异常,都要执行 finally&#123;&#125;)</span></span><br><span class="line"><span class="comment">//@After(value = &quot;execution(public float com.hspedu.spring.aop.aspectj.SmartDog.getSum(float, float))&quot;)</span></span><br><span class="line"><span class="comment">//直接使用切入点</span></span><br><span class="line"><span class="meta">@After(value = &quot;myPointCut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showFinallyEndLog</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">    System.out.println(<span class="string">&quot;SmartAnimalAspect-切面类showFinallyEndLog()-方法最终执行完毕-日志-方法名-&quot;</span> + signature.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-13-AOP-切面优先级问题"><a href="#3-13-AOP-切面优先级问题" class="headerlink" title="3.13 AOP-切面优先级问题"></a>3.13 AOP-切面优先级问题</h2><h3 id="3-13-1-应用实例"><a href="#3-13-1-应用实例" class="headerlink" title="3.13.1 应用实例"></a>3.13.1 应用实例</h3><p>​● 切面优先级问题:</p><p>​如果同一个方法，有多个切面在同一个切入点切入，那么执行的优先级如何控制.</p><p>​● 基本语法:</p><p>​@order(value&#x3D;n) 来控制 n 值越小，优先级越高.</p><h3 id="3-13-2-注意事项和细节说明"><a href="#3-13-2-注意事项和细节说明" class="headerlink" title="3.13.2 注意事项和细节说明"></a>3.13.2 注意事项和细节说明</h3><ol><li>不能理解成： 优先级高的每个消息通知都先执行， 这个和方法调用机制(和 Filter 过滤器链式调用类似)</li></ol><p><strong>优先级越高，前置通知先执行(队列)，但其他的通知都是最后执行(栈)</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230726092923563.png" alt="image-20230726092923563"></p><h2 id="3-14-AOP-基于-XML-配置-AOP"><a href="#3-14-AOP-基于-XML-配置-AOP" class="headerlink" title="3.14 AOP-基于 XML 配置 AOP"></a>3.14 AOP-基于 XML 配置 AOP</h2><h3 id="3-14-1-应用实例"><a href="#3-14-1-应用实例" class="headerlink" title="3.14.1 应用实例"></a>3.14.1 应用实例</h3><p>​● 基本说明:</p><p>​前面我们是通过注解来配置 aop 的， 在 spring 中， 我们也可以通过 xml 的方式来配置 AOP</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--使用XML配置，完成AOP编程--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置一个切面类对象-bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.hspedu.spring.aop.xml.SmartAnimalAspect&quot;</span> <span class="attr">id</span>=<span class="string">&quot;smartAnimalAspect&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置一个SmartDog对象-bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.hspedu.spring.aop.xml.SmartDog&quot;</span> <span class="attr">id</span>=<span class="string">&quot;smartDog&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切面类, 细节一定要引入 xmlns:aop--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(public float com.hspedu.spring.aop.xml.SmartDog.getSum(float, float)))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切面的前置，返回, 异常, 最终通知--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;smartAnimalAspect&quot;</span> <span class="attr">order</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置前置通知--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;showBeginLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--返回通知--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;showSuccessEndLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">returning</span>=<span class="string">&quot;res&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--异常通知--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;showExceptionLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;throwable&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--最终通知--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;showFinallyEndLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置环绕通知--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;aop:around method=&quot;&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="4-手动实现-Spring-底层机制【-初始化-IOC容器-依赖注入-BeanPostProcessor-机制-AOP】"><a href="#4-手动实现-Spring-底层机制【-初始化-IOC容器-依赖注入-BeanPostProcessor-机制-AOP】" class="headerlink" title="4 手动实现 Spring 底层机制【 初始化 IOC容器+依赖注入+BeanPostProcessor 机制+AOP】"></a>4 手动实现 Spring 底层机制【 初始化 IOC容器+依赖注入+BeanPostProcessor 机制+AOP】</h1><h3 id="4-1-1-引言：-前面我们实际上已经用代码简单实现了"><a href="#4-1-1-引言：-前面我们实际上已经用代码简单实现了" class="headerlink" title="4.1.1 引言： 前面我们实际上已经用代码简单实现了"></a>4.1.1 引言： 前面我们实际上已经用代码简单实现了</h3><h4 id="4-1-1-1-Spring-XML-注入-bean"><a href="#4-1-1-1-Spring-XML-注入-bean" class="headerlink" title="4.1.1.1 Spring XML 注入 bean"></a>4.1.1.1 Spring XML 注入 bean</h4><h4 id="4-1-1-2-Spring-注解方式注入-bean"><a href="#4-1-1-2-Spring-注解方式注入-bean" class="headerlink" title="4.1.1.2 Spring 注解方式注入 bean"></a>4.1.1.2 Spring 注解方式注入 bean</h4><h4 id="4-1-1-3-Spring-AOP-动态代理实现"><a href="#4-1-1-3-Spring-AOP-动态代理实现" class="headerlink" title="4.1.1.3 Spring AOP 动态代理实现"></a>4.1.1.3 Spring AOP 动态代理实现</h4><h3 id="4-1-2-继续思考-原生-Spring-如何实现依赖注入和-singleton、-prototype"><a href="#4-1-2-继续思考-原生-Spring-如何实现依赖注入和-singleton、-prototype" class="headerlink" title="4.1.2 继续思考-原生 Spring 如何实现依赖注入和 singleton、 prototype"></a>4.1.2 继续思考-原生 Spring 如何实现依赖注入和 singleton、 prototype</h3><h4 id="4-1-2-1-实例演示-Maven-项目"><a href="#4-1-2-1-实例演示-Maven-项目" class="headerlink" title="4.1.2.1 实例演示-Maven 项目"></a>4.1.2.1 实例演示-Maven 项目</h4><p>其实就是第二章，去看一下即可……</p><p>​● 快速给小伙伴完成这个小案例(提示： 创建新项目, 不和原来的 Spring 混在一起)</p><ol><li><h5 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h5></li><li><h5 id="修改-pom-xml-引入需要的-jar-包"><a href="#修改-pom-xml-引入需要的-jar-包" class="headerlink" title="修改 pom.xml, 引入需要的 jar 包"></a>修改 pom.xml, 引入需要的 jar 包</h5></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加入spring开发的基本包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加入spring开发切面编程需要的包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><h5 id="创-建UserAction-java"><a href="#创-建UserAction-java" class="headerlink" title="创 建UserAction.java"></a>创 建UserAction.java</h5></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 就是一个Controller</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//也可以使用@Controller</span></span><br><span class="line"><span class="comment">//在默认情况下 我们配置@Component @Controller @Service @Repository 是单例</span></span><br><span class="line"><span class="comment">//@Scope(value = &quot;prototype&quot;) 表示以多实例形式，返回UserAction bean</span></span><br><span class="line"><span class="comment">//老师思考:Spring容器底层如何实现</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//@Scope(value = &quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAction</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><h5 id="创-建UserDao-java"><a href="#创-建UserDao-java" class="headerlink" title="创 建UserDao.java"></a>创 建UserDao.java</h5></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以使用@Repository</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserDao-hi()---&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><h5 id="创-建UserService-java"><a href="#创-建UserService-java" class="headerlink" title="创 建UserService.java"></a>创 建UserService.java</h5></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以使用@Service</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="comment">//老师思考：加入 @Autowired , Spring容器时如何实现依赖注入?</span></span><br><span class="line">    <span class="comment">//也可以使用@Resource</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.hi();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里我们需要指定init() 是初始化方法</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserService-init()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><h5 id="创建-beans-xml"><a href="#创建-beans-xml" class="headerlink" title="创建 beans.xml"></a>创建 beans.xml</h5></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置自动扫描的包, 同时引入对应的名称空间--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--老师说明：</span></span><br><span class="line"><span class="comment">    1. 如果我们是普通的java项目, beans.xml 放在src下</span></span><br><span class="line"><span class="comment">    2. 如果我们是java maven 项目, beans.xml 放在 src/main/resources</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hspedu.spring.component&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hspedu.spring.aop&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--启用基于注解方式的AOP功能--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置后置处理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.hspedu.spring.process.MyBeanPostProcessor&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myBeanPostProcessor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="7"><li><h5 id="创建-AppMain-java"><a href="#创建-AppMain-java" class="headerlink" title="创建 AppMain.java"></a>创建 AppMain.java</h5></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试看看是否可以得到spring容器中的bean , 同时看看依赖注入是否OK</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ioc</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserAction</span> <span class="variable">userAction</span> <span class="operator">=</span> (UserAction) ioc.getBean(<span class="string">&quot;userAction&quot;</span>);</span><br><span class="line">        <span class="type">UserAction</span> <span class="variable">userAction2</span> <span class="operator">=</span> (UserAction) ioc.getBean(<span class="string">&quot;userAction&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;userAction=&quot;</span> + userAction);</span><br><span class="line">        System.out.println(<span class="string">&quot;userAction2=&quot;</span> + userAction2);</span><br><span class="line"></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) ioc.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;userDao=&quot;</span> + userDao);</span><br><span class="line"></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ioc.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;userService=&quot;</span> + userService);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试一下当前的依赖注入</span></span><br><span class="line">        userService.m1();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试一下AOP</span></span><br><span class="line">        <span class="type">SmartAnimalable</span> <span class="variable">smartDog</span> <span class="operator">=</span> ioc.getBean(SmartAnimalable.class);</span><br><span class="line">        smartDog.getSum(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-2-思考问题"><a href="#4-1-2-2-思考问题" class="headerlink" title="4.1.2.2 思考问题"></a>4.1.2.2 思考问题</h4><h5 id="4-1-2-2-1-Spring-底层实现-如何实现-IOC-容器创建和初始化【前面我们实现过，-现在要再深入】"><a href="#4-1-2-2-1-Spring-底层实现-如何实现-IOC-容器创建和初始化【前面我们实现过，-现在要再深入】" class="headerlink" title="4.1.2.2.1 Spring 底层实现, 如何实现 IOC 容器创建和初始化【前面我们实现过， 现在要再深入】"></a>4.1.2.2.1 Spring 底层实现, 如何实现 IOC 容器创建和初始化【前面我们实现过， 现在要再深入】</h5><h5 id="4-1-2-2-2-Spring-底层实现-如何实现-getBean-根据-singleton-和-prototype-来返回-bean-实例"><a href="#4-1-2-2-2-Spring-底层实现-如何实现-getBean-根据-singleton-和-prototype-来返回-bean-实例" class="headerlink" title="4.1.2.2.2 Spring 底层实现, 如何实现 getBean, 根据 singleton 和 prototype 来返回 bean 实例"></a>4.1.2.2.2 Spring 底层实现, 如何实现 getBean, 根据 singleton 和 prototype 来返回 bean 实例</h5><h3 id="4-1-3-继续思考-原生-Spring-如何实现-BeanPostProcessor"><a href="#4-1-3-继续思考-原生-Spring-如何实现-BeanPostProcessor" class="headerlink" title="4.1.3 继续思考-原生 Spring 如何实现 BeanPostProcessor"></a>4.1.3 继续思考-原生 Spring 如何实现 BeanPostProcessor</h3><h4 id="4-1-3-1-实例演示"><a href="#4-1-3-1-实例演示" class="headerlink" title="4.1.3.1 实例演示"></a>4.1.3.1 实例演示</h4><ol><li>创 建MyBeanPostProcessor.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在Bean的 init初始化方法前调用-&gt; 这个知识点，在前面讲解后置处理器时讲过的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;postProcessBeforeInitialization 被 调 用 &quot;</span> + beanName + <span class="string">&quot; bean= &quot;</span> + bean.getClass());</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在Bean的 init初始化方法后调用-&gt; 这个知识点，在前面讲解后置处理器时讲过的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postProcessAfterInitialization 被 调 用 &quot;</span> + beanName + <span class="string">&quot; bean= &quot;</span> + bean.getClass());</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-2-思考问题"><a href="#4-1-3-2-思考问题" class="headerlink" title="4.1.3.2 思考问题"></a>4.1.3.2 思考问题</h4><h5 id="4-1-3-2-1-Spring-底层实现-如何实现-Bean-后置处理器机制"><a href="#4-1-3-2-1-Spring-底层实现-如何实现-Bean-后置处理器机制" class="headerlink" title="4.1.3.2.1 Spring 底层实现, 如何实现 Bean 后置处理器机制"></a>4.1.3.2.1 Spring 底层实现, 如何实现 Bean 后置处理器机制</h5><p>——当然是动态代理呀</p><h3 id="4-1-4-继续思考-原生-Spring-是如何实现-AOP"><a href="#4-1-4-继续思考-原生-Spring-是如何实现-AOP" class="headerlink" title="4.1.4 继续思考-原生 Spring 是如何实现 AOP"></a>4.1.4 继续思考-原生 Spring 是如何实现 AOP</h3><h4 id="4-1-4-1-实例演示"><a href="#4-1-4-1-实例演示" class="headerlink" title="4.1.4.1 实例演示"></a>4.1.4.1 实例演示</h4><p>看第三章…… </p><h4 id="4-1-4-2-简单分析-AOP-和-BeanPostProcessor-关系"><a href="#4-1-4-2-简单分析-AOP-和-BeanPostProcessor-关系" class="headerlink" title="4.1.4.2 简单分析 AOP 和 BeanPostProcessor 关系"></a>4.1.4.2 简单分析 AOP 和 BeanPostProcessor 关系</h4><p>……</p><p>老韩解读：</p><ul><li>AOP 底层是基于 BeanPostProcessor 机制的.</li><li>即在 Bean 创建好后，<strong>根据是否需要 AOP 处理</strong>，决定返回代理对象，还是原生 Bean</li><li>在返回代理对象时，就可以根据要代理的类和方法来返回</li><li>其实这个机制并不难，本质就是在 BeanPostProcessor 机制 + 动态代理技术</li></ul><h4 id="4-1-4-3-思考问题"><a href="#4-1-4-3-思考问题" class="headerlink" title="4.1.4.3 思考问题"></a>4.1.4.3 思考问题</h4><h5 id="4-1-4-3-1-Spring-底层实现-如何实现-AOP-编程"><a href="#4-1-4-3-1-Spring-底层实现-如何实现-AOP-编程" class="headerlink" title="4.1.4.3.1 Spring 底层实现, 如何实现 AOP 编程"></a>4.1.4.3.1 Spring 底层实现, 如何实现 AOP 编程</h5><h3 id="4-1-5-我们的目标-不用-Spring-框架-模拟-Spring-底层实现-也能完成相同的功能"><a href="#4-1-5-我们的目标-不用-Spring-框架-模拟-Spring-底层实现-也能完成相同的功能" class="headerlink" title="4.1.5 我们的目标: 不用 Spring 框架, 模拟 Spring 底层实现, 也能完成相同的功能"></a>4.1.5 我们的目标: 不用 Spring 框架, 模拟 Spring 底层实现, 也能完成相同的功能</h3><h2 id="4-2-🌟Spring-整体架构分析"><a href="#4-2-🌟Spring-整体架构分析" class="headerlink" title="4.2 🌟Spring 整体架构分析"></a>4.2 🌟Spring 整体架构分析</h2><h3 id="4-2-1-🌟一图胜千言"><a href="#4-2-1-🌟一图胜千言" class="headerlink" title="4.2.1 🌟一图胜千言"></a>4.2.1 🌟一图胜千言</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727094752719.png" alt="image-20230727094752719"></p><h2 id="4-3-手动实现-Spring-底层机制"><a href="#4-3-手动实现-Spring-底层机制" class="headerlink" title="4.3 手动实现 Spring 底层机制"></a>4.3 手动实现 Spring 底层机制</h2><p>【初始化 IOC 容器+依赖注入+BeanPostProcessor 机制+AOP】</p><h3 id="4-3-1-实现任务阶段-1-编写自己-Spring-容器，-实现扫描包，-得到-bean-的-class-对象"><a href="#4-3-1-实现任务阶段-1-编写自己-Spring-容器，-实现扫描包，-得到-bean-的-class-对象" class="headerlink" title="4.3.1 实现任务阶段 1- 编写自己 Spring 容器， 实现扫描包， 得到 bean 的 class 对象"></a>4.3.1 实现任务阶段 1- 编写自己 Spring 容器， 实现扫描包， 得到 bean 的 class 对象</h3><h4 id="4-3-1-1-知识扩展：-类加载器"><a href="#4-3-1-1-知识扩展：-类加载器" class="headerlink" title="4.3.1.1 知识扩展： 类加载器"></a>4.3.1.1 知识扩展： 类加载器</h4><p>​● java 的类加载器 3 种</p><p>​Bootstrap 类加载器————–对应路径 jre&#x2F;lib</p><p>​Ext 类加载器——————–对应路径 jre&#x2F;lib&#x2F;ext</p><p>​App 类加载器——————-对应路径 classpath</p><h4 id="4-3-1-2-说明-编写自己-Spring-容器，-实现扫描包，-得到-bean-的-class-对象"><a href="#4-3-1-2-说明-编写自己-Spring-容器，-实现扫描包，-得到-bean-的-class-对象" class="headerlink" title="4.3.1.2 说明: 编写自己 Spring 容器， 实现扫描包， 得到 bean 的 class 对象"></a>4.3.1.2 说明: 编写自己 Spring 容器， 实现扫描包， 得到 bean 的 class 对象</h4><h3 id="🌟看p12-P41"><a href="#🌟看p12-P41" class="headerlink" title="🌟看p12-P41"></a>🌟看p12-P41</h3><p>先了解spring底层机制 具体实现日后有空再说</p><p>JDBC等知识由于之后都用mybatis等工具，也先不学</p><p>事务先不学了，之后补！</p>]]></content>
      
      
      <categories>
          
          <category> Spring开发框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API接口开放平台</title>
      <link href="/2023/07/11/API%E6%8E%A5%E5%8F%A3%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/"/>
      <url>/2023/07/11/API%E6%8E%A5%E5%8F%A3%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="API开放平台"><a href="#API开放平台" class="headerlink" title="API开放平台"></a>API开放平台</h1><h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><ol><li><p>前端开发需要用到后台接口</p></li><li><p>使用现成的系统的功能</p></li></ol><h3 id="做一个API接口平台："><a href="#做一个API接口平台：" class="headerlink" title="做一个API接口平台："></a>做一个API接口平台：</h3><ol><li>防止攻击(安全性)</li><li>不能随便调用(限制、开通)</li><li>统计调用次数</li><li>计费</li><li>流量保护</li><li>API接入</li></ol><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>做一个提供API接口调用的平台：</p><ul><li><p>用户可以注册登录，开通接口调用权限。用户可以使用接口，并且每次调用会进行统计。</p></li><li><p>管理员可以发布接口、下线接口、接入接口，以及可视化接口的调用情况、数据。</p></li></ul><h3 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711194146565.png" alt="image-20230711194146565"></p><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><ul><li><p>Ant Design Pro</p></li><li><p>React</p></li><li><p>Ant Design Procomponents</p></li><li><p>Umi</p></li><li><p>Umi Request(Axios的封装)</p></li></ul><h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><ul><li><p>Spring Boot</p></li><li><p>Spring Boot Starter(SDK开发)</p></li><li><p>网关、限流、日志实现 —–&gt; dubbo+nacos</p></li></ul><h3 id="项目开发的阶段划分"><a href="#项目开发的阶段划分" class="headerlink" title="项目开发的阶段划分"></a>项目开发的阶段划分</h3><h4 id="1、初始化和展示"><a href="#1、初始化和展示" class="headerlink" title="1、初始化和展示"></a>1、初始化和展示</h4><p>项目介绍、设计、技术选型</p><p>基础项目的搭建</p><p>接口管理</p><p>用户查看接口</p><h4 id="2、接口调用"><a href="#2、接口调用" class="headerlink" title="2、接口调用"></a>2、接口调用</h4><ol><li>继续开发接口管理前端页面</li><li>开发模拟API接口</li><li>开发调用这个接口的代码</li><li>保证调用的安全性(API签名认证)</li><li>客户端SDK的开发</li></ol><h4 id="3、接口计量与保护"><a href="#3、接口计量与保护" class="headerlink" title="3、接口计量与保护"></a>3、接口计量与保护</h4><ol><li>开发接口发布&#x2F;下线的功能(管理员)</li><li>前端去浏览接口、查看接口文档、申请签名(注册)、在线调试(用户)</li><li>统计用户调用接口次数</li><li>优化系统 - API网关</li></ol><h5 id="开发接口发布-x2F-下线的功能-管理员"><a href="#开发接口发布-x2F-下线的功能-管理员" class="headerlink" title="开发接口发布&#x2F;下线的功能(管理员)"></a>开发接口发布&#x2F;下线的功能(管理员)</h5><h6 id="发布接口-仅管理员可用-："><a href="#发布接口-仅管理员可用-：" class="headerlink" title="发布接口(仅管理员可用)："></a>发布接口(仅管理员可用)：</h6><ol><li>检查该接口是否存在</li><li>判断该接口是否可以调用</li><li>修改接口数据库中的状态字段为1</li></ol><h6 id="下线接口："><a href="#下线接口：" class="headerlink" title="下线接口："></a>下线接口：</h6><ol><li>检查该接口是否存在</li><li>判断该接口是否可以调用</li><li>修改接口数据库中的状态字段为0</li></ol><p>前端去浏览接口、查看接口文档</p><p>–动态路由，用url来传递id，加载不同的接口信息</p><p>申请签名(注册) ：</p><p>用户在注册成功时，自动分配 accessKey、secretKey</p><p>扩展：用户可以申请更换签名</p><p>在线调用</p><p>​请求参数的类型(直接用 json 类型)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;username&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>先跑通整个流程，再去针对不同的请求或接口类型来设计界面和表单，给用户更好的体验(可以参考postman)</p><p>调用流程：</p><p>使用走后端方式流程：(后端相当于中转站，防止用户直接拿到接口的地址，从而绕过系统自行调用)</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230716140059896.png" alt="image-20230716140059896" style="zoom:50%;" /><p>流程：</p><pre><code>1. 前端将用户输入的请求参数和要测试的接口发送给平台后端2. (在调用前可以做一些调用)3. 平台后端去调用模拟接口</code></pre><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求参数要注意大小写！</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;userName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;don&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h4><p>判断该接口是否可以调用时 由固定方法名改为根据测试地址来调用</p><p>用户测试接口 由固定方法名-&gt;根据测试地址来调用</p><p>模拟接口改为从数据库校验 akey</p><h4 id="4、管理、统计分析"><a href="#4、管理、统计分析" class="headerlink" title="4、管理、统计分析"></a>4、管理、统计分析</h4><ol><li><p>开发接口调用次数的统计</p></li><li><p>优化整个系统的架构</p><p>a. 网关是什么？</p><p>b. 网关的作用？</p><p>c. 网关的应用场景及实现</p><p>d. 结合业务去应用网关</p></li></ol><h6 id="接口调用次数统计"><a href="#接口调用次数统计" class="headerlink" title="接口调用次数统计"></a>接口调用次数统计</h6><p>​<strong>1、需求：用户每次调用接口成功，次数+1</strong></p><p>​2、给用户分配或者用户自主申请接口调用次数</p><p>​业务流程：</p><p>​1、用户调用接口</p><p>​2、修改数据库，调用次数+1</p><h4 id="5、鉴权"><a href="#5、鉴权" class="headerlink" title="5、鉴权"></a>5、鉴权</h4><ol><li>实现<strong>统一</strong>的用户鉴权、统一的接口调用次数统计（把API网关应用到项目中）<ul><li>用到的<strong>网关相关特性</strong><ul><li>路由：用户原本直接请求模拟接口，在模拟接口鉴权；现在，我们在网关对用户进行鉴权，网关鉴权通过后再将请求重定向到模拟接口。</li><li>统一鉴权(accessKey、secretKey)</li><li>统一业务处理(每次请求接口后，调用次数都要+1)</li><li>访问控制(黑白名单)</li><li>流量染色(记录请求是否为网关来的，但是这样的话，在最终接口处还要对请求进行判断,看看有没有被染色)</li><li>统一日志(记录每次的请求与响应)</li></ul></li><li>业务逻辑<ol><li>用户发送请求到API网关</li><li>请求日志</li><li>(黑白名单)</li><li>用户鉴权(判断ak、sk是否合法)</li><li>请求的模拟接口是否存在？</li><li>请求转发，调用模拟接口</li><li>响应日志</li><li>调用成功，接口调用次数+1</li><li>调用失败，返回一个规范的错误码</li></ol></li></ul></li></ol><h4 id="6、网关"><a href="#6、网关" class="headerlink" title="6、网关"></a>6、网关</h4><ol><li>补充完整网关的业务逻辑(怎么去操作数据库、怎么复用之前的方法——RPC)</li><li>完善系统，开发一个监控统计功能</li></ol><h5 id="网关业务逻辑"><a href="#网关业务逻辑" class="headerlink" title="网关业务逻辑"></a>网关业务逻辑</h5><p>问题：网关项目比较纯净，没有操作数据库的包、并且还要调用我们之前写过的代码？复制粘贴维护麻烦</p><p>理想：直接请求到其他项目的方法</p><h6 id="怎么调用其他项目的方法？："><a href="#怎么调用其他项目的方法？：" class="headerlink" title="怎么调用其他项目的方法？："></a>怎么调用其他项目的方法？：</h6><ol><li>复制代码、环境</li><li>HTTP请求(提供一个接口、供其他项目使用)<ul><li>server开发一个接口(地址、请求方法、参数、返回值)</li><li>client使用HTTP Client之类的代码包去发送HTTP请求</li></ul></li><li>RPC<ul><li>作用：像调用本地方法一样调用远程方法</li><li>对开发者更透明，减少了很多沟通成本</li><li>RPC向远程服务器发送请求时，未必要使用HTTP协议，比如 TCP&#x2F;IP(性能更高、内部服务更适用)等等等等</li></ul></li><li>把公共项目打包成jar包，其他项目去引用(客户端SDK)</li></ol><p>![image-20230719103013425](&#x2F;Users&#x2F;donn&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230719103013425.png)</p><h6 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h6><ol><li>请求转发</li></ol><p>用一个前缀匹配断言：所有路径为 &#x2F;api&#x2F;** 的请求转发到<a href="http://localhost:8123/api/">http://localhost:8123/api/</a>**</p><p>例如：<a href="http://localhost:8090/api/name/">http://localhost:8090/api/name/</a>** &#x3D;&#x3D;&#x3D;&gt; <a href="http://localhost:8123/api/name/">http://localhost:8123/api/name/</a>**</p><p>模拟接口请求地址：<a href="http://localhost:8123/api/name/get?name=123">http://localhost:8123/api/name/get?name=123</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddResponseHeader=source,</span> <span class="string">donn</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">api_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8123</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/api/**</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>编写业务逻辑</p><p>使用了GlobalFilter全局请求拦截处理(类似AOP)</p></li></ol><p>​因为网关项目没引入MuBatis等操作数据库的类库，如果该操作较为复杂，可以由backend增删改查项目提供接口，我们直接调用，不用再重复写逻辑。</p><ul><li>HTTP请求 (用HTTPClient、用RestTemplate、Feign)</li><li>RPC (Dubbo)</li></ul><h6 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h6><p>预期是等模拟接口调用完成，才调用响应日志、统计调用次数</p><p>但实际上 chain.filter 方法立即返回了，直到filter过滤器 return 后才调用了模拟接口</p><p>原因：chain.filter 是一个异步操作，理解为前端的 promise</p><p>解决方案：利用response装饰者，增强原有的response的处理能力</p><h6 id="Dubbo框架-RPC实现"><a href="#Dubbo框架-RPC实现" class="headerlink" title="Dubbo框架(RPC实现)"></a>Dubbo框架(RPC实现)</h6><p>​两种使用方式：</p><ol><li><p>Spring Boot 代码(注解 + 编程式)：写java接口，服务提供者和消费者都去引用这个接口 </p></li><li><p>IDL (接口调用语言)：创建一个公共的接口定义文件，服务提供者和消费者读取这个文件，优点是跨语言、所有的框架都认识</p></li></ol><p>底层是Triple协议</p><h5 id="整合运用："><a href="#整合运用：" class="headerlink" title="整合运用："></a>整合运用：</h5><ol><li>backend项目作为服务提供者，提供三个方法</li></ol><ul><li>去数据库中查是否已分配给用户</li><li>查询数据库，模拟接口是否存在，以及请求方法是否匹配</li><li>调用成功后 调用次数+1 invokeCount</li></ul><ol start="2"><li>Gataway项目作为服务调用者，调用这三个方法</li></ol><h4 id="7、完善网关、接口调用信息可视化、展望……"><a href="#7、完善网关、接口调用信息可视化、展望……" class="headerlink" title="7、完善网关、接口调用信息可视化、展望……"></a>7、完善网关、接口调用信息可视化、展望……</h4><ol><li>完成网关业务逻辑<ul><li>实际情况应该是去数据库查看是否已分配给用户(ak、sk是否合法)<ul><li>先根据accessKey判断用户是否存在，查到secretKey</li><li>对比secretKey和用户传的加密后的secretKey是否一致</li></ul></li><li>从数据库查询模拟接口是否存在，以及请求方式是否匹配(还可以校验请求参数)</li><li>调用成功后，调用次数+1 （invoke count</li></ul></li><li>开发管理员分析的功能</li><li>上线</li></ol><h6 id="如何获取接口转发服务器的地址"><a href="#如何获取接口转发服务器的地址" class="headerlink" title="如何获取接口转发服务器的地址"></a>如何获取接口转发服务器的地址</h6><p>​网关启动时， 获取所有的接口信息，维护到内存的hashmap中；有请求时，根据请求的url路径或者其他参数[比如host请求头]来判断应该转发到哪台服务器，以及用于校验接口是否存在</p><h6 id="公共服务："><a href="#公共服务：" class="headerlink" title="公共服务："></a>公共服务：</h6><p>​目的是让方法、实体类在多个项目间复用，重复编写</p><pre><code>1. 数据库中查询是否已分配给用户密钥(accessKey，返回用户信息，为空表示不存在)1. 从数据库查询模拟接口是否存在(请求路径、请求方法、请求参数、返回接口信息，为空表示不存在)1. 调用次数+1 (accessKey(标识用户)、接口路径)</code></pre><p>步骤：</p><ol><li>新建干净的maven项目，只保留必要的公共依赖</li><li>抽取service和实体类</li><li>install本地 maven包</li><li>让服务提供方引入common包，测试是否正常运行</li><li>让服务消费方引入common包</li></ol><h6 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h6><ol><li><p>怎么让其他用户也上传接口？</p><p>需要提供一个机制(界面)，让用户输入自己的接口host(服务器地址)、接口信息，将接口信息写入数据库。</p><p>将接口信息写入数据库之前，要对接口进行校验，比如测试调用，保证接口正常。并遵循我们项目的要求(并且使用我们的sdk)</p></li><li><p>在interfaceInfo表中加入host字段，区分服务器地址，让接口提供者更灵活地接入系统。</p></li><li><p>网关判断是否还有调用次数</p></li><li><p>网关限流、提高性能等等</p></li></ol><h5 id="开发统计分析："><a href="#开发统计分析：" class="headerlink" title="开发统计分析："></a>开发统计分析：</h5><p>提供可视化平台，用图表的方式展示所有的调用情况，便于调整业务</p><h6 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h6><p>​各接口总调用次数占比(饼图)前3的接口，从而分析出哪些接口没人用(降低资源或者下线)以及高频接口(增加资源、提高收费)</p><h6 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h6><h6 id="前端："><a href="#前端：" class="headerlink" title="前端："></a>前端：</h6><p>​展示饼图——推荐使用线程的库</p><p>​ECharts、AntV</p><ul><li>看官网</li><li>进入实例页面</li><li>找到想要的图</li><li>在线调试</li><li>复制代码</li><li>改为真实数据</li></ul><h6 id="后端："><a href="#后端：" class="headerlink" title="后端："></a>后端：</h6><p>​1. SQL查询调用数据</p><p>​select interfaceInfoId, sum(totalNum) as totalNum from interface_info group by interfaceInfoId order by totalNum desc limit 3;</p><p>​2. 业务层去关联查询接口信息</p><h6 id="上线："><a href="#上线：" class="headerlink" title="上线："></a>上线：</h6><p>前端：参考用户中心的上线方式</p><p>后端：</p><ul><li>backend项目：web项目，部署springboot的jar包(对外的)</li><li>gateway项目：web项目，部署springboot的jar包(对外的)</li><li>interface 模拟接口项目：web项目，部署springboot的jar包(不建议对外暴露的)</li></ul><p>如果自己学习用：单个服务器部署这三个项目足够</p><p>如果想搞大事：多个服务器建议在同一内网，内网交互会更快，且更安全</p><p>设计库表：</p><p>哪个用户？哪个接口？</p><p>用户 &lt;&#x3D;&#x3D;多对多&#x3D;&#x3D;&gt; 接口</p><p>因此需要再创建一个表：</p><p>用户调用接口关系表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用户调用接口关系表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> tjyapi.`user_interface_info`</span><br><span class="line">(</span><br><span class="line">    `id` <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment comment <span class="string">&#x27;主键&#x27;</span> <span class="keyword">primary</span> key,</span><br><span class="line">  `userId` <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;调用用户id&#x27;</span>,</span><br><span class="line">  `interfaceInfoId` <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;接口id&#x27;</span>,</span><br><span class="line">    `totalNum` <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;总调用次数&#x27;</span>,</span><br><span class="line">    `leftNum` <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;剩余调用次数&#x27;</span>,</span><br><span class="line">  `status` <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;0-正常 1-禁用&#x27;</span>,</span><br><span class="line">  `createTime` datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    `updateTime` datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">CURRENT_TIMESTAMP</span> comment <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">    `isDelete` tinyint <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;是否删除 0-未删 1-已删,</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">) comment &#x27;</span>用户调用接口关系表<span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure><p>步骤：</p><pre><code>1. 开发基本增删改查(给管理员用)1. 开发用户调用接口次数+1的功能(service)</code></pre><p>​问题：</p><p>​——如果每个接口的方法都写调用次数+1，是不是比较麻烦？</p><p>​——致命问题：接口开发者需要自己去添加统计代码</p><p>使用AOP切面的优点：独立于接口，在每个接口调用后统计次数+1</p><p>AOP切面的缺点：存在于单个项目中，如果每个团队都要开发自己的接口，那么都需要写AOP切面—还是没有解决 问题</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230717140031212.png" alt="image-20230717140031212"></p><h3 id="网关相关知识："><a href="#网关相关知识：" class="headerlink" title="网关相关知识："></a>网关相关知识：</h3><p>​网关的优点：统一进行一些操作，处理一些问题</p><ul><li><p>路由</p><ul><li><p>起到转发的作用，比如有接口 A 和接口 B，网关会记录这些信息，根据用户访问的地址和参数，转发请求到对应的接口（服务器&#x2F;集群）</p><p>&#x2F;a&#x3D;＞接口A</p><p>&#x2F;b&#x3D;＞接口B</p></li></ul></li><li><p>统一鉴权</p><ul><li>判断用户是否有权限进行操作，无论访问什么接口，都统一去判断，不用重复写</li></ul></li><li><p>统一跨域处理</p><ul><li>网关统一处理跨域</li></ul></li><li><p>缓存</p></li><li><p>流量染色</p><ul><li>给请求(流量)添加一些标识，一般是设置在请求头中，添加新的请求头</li></ul></li><li><p>访问控制</p><ul><li>黑白名单，比如限制DDOS IP</li></ul></li><li><p>统一业务处理</p><ul><li>把每个项目中都要做的通用逻辑放到上层(网关)，统一处理，比如本项目的接口调用次数统计</li></ul></li><li><p>发布控制</p><ul><li>灰度发布，比如上线新接口，先给新接口分配20%流量，慢慢增加，最终替代老接口</li></ul></li><li><p>负载均衡</p><ul><li>在路由的基础上</li></ul></li></ul><p>​&#x2F;c&#x3D;＞服务 A &#x2F; 集群A（随机转发到其中的某一个机器）</p><ul><li>统一接口保护<ul><li>限制请求</li><li>信息脱敏</li><li>降级(熔断)</li><li>限流</li><li>超时时间</li></ul></li><li>统一日志<ul><li>统一的请求、响应信息记录</li></ul></li><li>统一文档<ul><li>将下游项目的文档进行聚合，在一个页面统一查看</li></ul></li></ul><h4 id="网关的分类"><a href="#网关的分类" class="headerlink" title="网关的分类"></a>网关的分类</h4><ol><li>全局网关(接入层网关)：作用是负载均衡、请求日志等，不和业务逻辑绑定</li><li>业务网关(微服务网关)：会有一些业务逻辑，作用是将请求转发到不同的业务&#x2F;项目&#x2F;接口&#x2F;服务</li></ol><h4 id="实现：-1"><a href="#实现：-1" class="headerlink" title="实现："></a>实现：</h4><ol><li><p>Nginx( 全局网关 )、Kong网关( API网关 Kong: <a href="https://github.com/Kong/kong">https://github.com/Kong/kong</a> )，编程成本高</p></li><li><p>Spring Cloud Gateway (取代了 Zuul) 性能高，可以用Java代码来写逻辑，易于学习</p></li></ol><p>参考文章：<a href="https://blog.csdn.net/qq_21040559/article/details/122961395">https://blog.csdn.net/qq_21040559/article/details/122961395</a></p><p>网关技术选型：<a href="https://zhuanlan.zhihu.com/p/500587132">https://zhuanlan.zhihu.com/p/500587132</a></p><h4 id="Spring-Cloud-Gateway用法"><a href="#Spring-Cloud-Gateway用法" class="headerlink" title="Spring Cloud Gateway用法"></a>Spring Cloud Gateway用法</h4><p>官网：<a href="https://spring.io/projects/spring-cloud-gateway">https://spring.io/projects/spring-cloud-gateway</a></p><h5 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h5><p>路由：根据什么条件，转发请求到哪里</p><p>断言：一组规则、条件，用来确定如何转发路由</p><p>过滤器：对请求进行一系列处理，比如添加请求头、添加请求参数</p><h5 id="请求流程："><a href="#请求流程：" class="headerlink" title="请求流程："></a>请求流程：</h5><ol><li>客户端发起请求</li><li>Handler Mapping：根据断言，去将请求转发到对应的路由</li><li>Web Handler：处理请求(一层层经过过滤器)</li><li>实际调用服务</li></ol><h5 id="两种配置方式："><a href="#两种配置方式：" class="headerlink" title="两种配置方式："></a>两种配置方式：</h5><ol><li>配置式(application.yaml中配置) 方便、规范</li><li>编程式     相对麻烦、灵活</li></ol><h5 id="断言：-一些条件"><a href="#断言：-一些条件" class="headerlink" title="断言：(一些条件)"></a>断言：(一些条件)</h5><ol><li>after：在什么时间之后</li><li>before……</li></ol><p>……等等多种因素都能放进来考虑</p><p>建议开启日志——方便发现问题：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">org:</span></span><br><span class="line">      <span class="attr">springframework:</span></span><br><span class="line">        <span class="attr">cloud:</span></span><br><span class="line">          <span class="attr">gateway:</span> <span class="string">trace</span></span><br></pre></td></tr></table></figure><h5 id="过滤器："><a href="#过滤器：" class="headerlink" title="过滤器："></a>过滤器：</h5><p>基本(对请求头、响应头进行增删改查)</p><p>​在某设定路由下，做自定义的事(如添加请求头、添加请求体参数等等等等)</p><p>​或者 访问某路由如果失败，会转而访问另一个设定的路由(降级)</p><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><ol><li>管理员可以对接口信息进行增删改查</li><li>用户可以访问前台，查看接口信息</li></ol><h3 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h3><h4 id="接口信息表"><a href="#接口信息表" class="headerlink" title="接口信息表"></a>接口信息表</h4><p>id</p><p>name 接口名称</p><p>description  描述</p><p>url 接口地址</p><p>type请求类型</p><p>requestHeader请求头</p><p>responseHeader  响应头</p><p>status 接口状态 0-关闭 1-开启</p><p>isDelete</p><p>createTime</p><p>updateTime</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">use tjyapi;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 接口信息</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> tjyapi.`interface_info`</span><br><span class="line">(</span><br><span class="line">    `id` <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment comment <span class="string">&#x27;主键&#x27;</span> <span class="keyword">primary</span> key,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;接口名称&#x27;</span>,</span><br><span class="line">    `description` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">null</span> comment <span class="string">&#x27;描述&#x27;</span>,</span><br><span class="line">    `url` <span class="type">varchar</span>(<span class="number">512</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;接口地址&#x27;</span>,</span><br><span class="line">    `requestHeader` text <span class="keyword">null</span> comment <span class="string">&#x27;请求头&#x27;</span>,</span><br><span class="line">    `responseHeader` text <span class="keyword">null</span> comment <span class="string">&#x27;响应头&#x27;</span>,</span><br><span class="line">    `status` <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;接口状态 0-关闭 1-开启&#x27;</span>,</span><br><span class="line">    `<span class="keyword">method</span>` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;接口类型&#x27;</span>,</span><br><span class="line">    `userId` <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;创建人&#x27;</span>,</span><br><span class="line">    `createTime` datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    `updateTime` datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">CURRENT_TIMESTAMP</span> comment <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">    `isDelete` tinyint <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;是否删除 1-已删&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;接口信息&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;唐果&#x27;</span>, <span class="string">&#x27;江胤祥&#x27;</span>, <span class="string">&#x27;www.hui-russel.net&#x27;</span>, <span class="string">&#x27;7IE&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;姜烨磊&#x27;</span>, <span class="number">7</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;范浩&#x27;</span>, <span class="string">&#x27;崔振家&#x27;</span>, <span class="string">&#x27;www.peter-schmeler.info&#x27;</span>, <span class="string">&#x27;Pj0&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;黄钰轩&#x27;</span>, <span class="number">12857921</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;唐航&#x27;</span>, <span class="string">&#x27;孔健雄&#x27;</span>, <span class="string">&#x27;www.tanner-bednar.name&#x27;</span>, <span class="string">&#x27;Hi9QM&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;宋昊然&#x27;</span>, <span class="number">18787</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;袁子默&#x27;</span>, <span class="string">&#x27;石明杰&#x27;</span>, <span class="string">&#x27;www.mitsuko-zboncak.net&#x27;</span>, <span class="string">&#x27;4q&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;周涛&#x27;</span>, <span class="number">954194648</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;朱博涛&#x27;</span>, <span class="string">&#x27;秦昊焱&#x27;</span>, <span class="string">&#x27;www.rey-ondricka.biz&#x27;</span>, <span class="string">&#x27;GhO&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;王瑾瑜&#x27;</span>, <span class="number">43144</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;陆绍齐&#x27;</span>, <span class="string">&#x27;曹鸿涛&#x27;</span>, <span class="string">&#x27;www.cathleen-gusikowski.org&#x27;</span>, <span class="string">&#x27;pP0Z&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;尹乐驹&#x27;</span>, <span class="number">23494</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;尹思聪&#x27;</span>, <span class="string">&#x27;贺钰轩&#x27;</span>, <span class="string">&#x27;www.jeni-bartell.co&#x27;</span>, <span class="string">&#x27;ZZdsp&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;冯果&#x27;</span>, <span class="number">25646340</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;崔钰轩&#x27;</span>, <span class="string">&#x27;冯熠彤&#x27;</span>, <span class="string">&#x27;www.timothy-legros.org&#x27;</span>, <span class="string">&#x27;Qr&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;龙乐驹&#x27;</span>, <span class="number">275486388</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;马子骞&#x27;</span>, <span class="string">&#x27;邹晋鹏&#x27;</span>, <span class="string">&#x27;www.tori-wisoky.io&#x27;</span>, <span class="string">&#x27;cwVv&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;熊俊驰&#x27;</span>, <span class="number">9055718270</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;李嘉懿&#x27;</span>, <span class="string">&#x27;毛弘文&#x27;</span>, <span class="string">&#x27;www.tawna-murazik.info&#x27;</span>, <span class="string">&#x27;d8H&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;钟靖琪&#x27;</span>, <span class="number">596652</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;龚绍齐&#x27;</span>, <span class="string">&#x27;崔伟祺&#x27;</span>, <span class="string">&#x27;www.bart-dare.biz&#x27;</span>, <span class="string">&#x27;VM&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;陆乐驹&#x27;</span>, <span class="number">720475</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;严熠彤&#x27;</span>, <span class="string">&#x27;许炫明&#x27;</span>, <span class="string">&#x27;www.lane-schoen.com&#x27;</span>, <span class="string">&#x27;pc05M&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;余健雄&#x27;</span>, <span class="number">481356844</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;邵凯瑞&#x27;</span>, <span class="string">&#x27;郭智渊&#x27;</span>, <span class="string">&#x27;www.von-rempel.org&#x27;</span>, <span class="string">&#x27;FSiqa&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;龙博超&#x27;</span>, <span class="number">1368599</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;赖果&#x27;</span>, <span class="string">&#x27;杨天宇&#x27;</span>, <span class="string">&#x27;www.kourtney-lubowitz.name&#x27;</span>, <span class="string">&#x27;3C&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;韩修杰&#x27;</span>, <span class="number">6026675</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;段浩宇&#x27;</span>, <span class="string">&#x27;韩鸿涛&#x27;</span>, <span class="string">&#x27;www.rupert-schmeler.co&#x27;</span>, <span class="string">&#x27;mMo&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;魏远航&#x27;</span>, <span class="number">76</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;沈炎彬&#x27;</span>, <span class="string">&#x27;张昊天&#x27;</span>, <span class="string">&#x27;www.sheri-kerluke.co&#x27;</span>, <span class="string">&#x27;adMn1&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;薛明&#x27;</span>, <span class="number">3551</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;高黎昕&#x27;</span>, <span class="string">&#x27;谢志泽&#x27;</span>, <span class="string">&#x27;www.sterling-adams.org&#x27;</span>, <span class="string">&#x27;baP&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;金明哲&#x27;</span>, <span class="number">91</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;胡语堂&#x27;</span>, <span class="string">&#x27;覃浩然&#x27;</span>, <span class="string">&#x27;www.khalilah-breitenberg.biz&#x27;</span>, <span class="string">&#x27;gDtv&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;雷睿渊&#x27;</span>, <span class="number">21221843</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;陆雨泽&#x27;</span>, <span class="string">&#x27;曾雪松&#x27;</span>, <span class="string">&#x27;www.jonas-fritsch.co&#x27;</span>, <span class="string">&#x27;XvfU&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;侯智渊&#x27;</span>, <span class="number">472525914</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tjyapi.`interface_info` (`name`, `description`, `url`, `responseHeader`, `status`, `<span class="keyword">method</span>`, `userId`, `isDelete`) <span class="keyword">values</span> (<span class="string">&#x27;邓昊焱&#x27;</span>, <span class="string">&#x27;秦胤祥&#x27;</span>, <span class="string">&#x27;www.aron-buckridge.com&#x27;</span>, <span class="string">&#x27;fBh3&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;丁子默&#x27;</span>, <span class="number">12000</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="前端项目脚手架："><a href="#前端项目脚手架：" class="headerlink" title="前端项目脚手架："></a>前端项目脚手架：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 在终端运行</span><br><span class="line">npm i @ant-design/pro-cli -g</span><br><span class="line">2. 进入你放的目录的终端，自动创建项目</span><br><span class="line">pro create 项目名称</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">版本信息：</span><br><span class="line">donn@Macc ~ % node -v</span><br><span class="line">v16.13.0</span><br><span class="line">donn@Macc ~ % npm -v       </span><br><span class="line">8.1.0</span><br></pre></td></tr></table></figure><p>运行一下空项目：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711212835653.png" alt="image-20230711212835653"></p><p>前端：ant design pro 脚手架</p><p>后端：直接使用模板 springboot-init</p><h4 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h4><p>增删改查、登录(复制粘贴)</p><p>前端接口调用：openapi插件自动生成</p><p>openapi规范</p><h4 id="模拟接口项目-tjyapi-interface"><a href="#模拟接口项目-tjyapi-interface" class="headerlink" title="模拟接口项目 tjyapi-interface"></a>模拟接口项目 tjyapi-interface</h4><p>提供三个模拟接口</p><ol><li>GET接口</li><li>POST接口(url传参)</li><li>POST接口(Restful)</li></ol><h4 id="调用接口"><a href="#调用接口" class="headerlink" title="调用接口"></a>调用接口</h4><p>几种 HTTP 调用方式：</p><ol><li><p>HttpClient</p></li><li><p>RestTemplate</p></li><li><p>第三方库(OKHTTP、Hutool)</p></li></ol><p>Hutool：<a href="https://www.hutool.cn/">https://www.hutool.cn</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://doc.hutool.cn/pages/HttpUtil/#%E6%A6%82%E8%BF%B0">https://doc.hutool.cn/pages/HttpUtil/#概述</a></p><h3 id="API签名认证"><a href="#API签名认证" class="headerlink" title="API签名认证"></a>API签名认证</h3><h5 id="本质："><a href="#本质：" class="headerlink" title="本质："></a>本质：</h5><pre><code>1. 签发签名1. 使用签名(校验签名)</code></pre><h5 id="为什么需要？"><a href="#为什么需要？" class="headerlink" title="为什么需要？"></a>为什么需要？</h5><ol><li>保证安全性，不能随便来一个人都能调用</li></ol><h5 id="怎么实现？"><a href="#怎么实现？" class="headerlink" title="怎么实现？"></a>怎么实现？</h5><p>通过http request header头 传递参数</p><p><strong>参数1:</strong> accessKey：调用的标识 userA、userB(复杂、无序、无规律)</p><p><strong>参数2:</strong> secretKey： 密钥——–<strong>该参数不传递到请求头中，通过私下约定进行同步</strong></p><p>可以暂时理解为用户名和密码，区别为：ak、sk是无状态的；你每次访问都需携带正确的ak、sk才能访问</p><p>自行编写代码给每个用户生成ak、sk</p><p>千万不能把密钥直接在服务器之间传递，因为有可能被拦截</p><p>(所以要对密码进行进一步处理)</p><p><strong>参数3:</strong> 用户请求参数</p><p><strong>参数4:</strong> sign 参数</p><p>加密方式：对称加密、非对称加密、md5签名</p><p>用户参数：abc + 密钥 &#x3D;&gt; 签名生成算法 &#x3D;&gt; 不可解密的值</p><p>abc + miyao &#x3D;&gt; dnasufbnusfuisdafiuadbfouiadbfuiasdbofibdaiksfbefewdf</p><p><strong>服务端用一样的方式生成签名，只要结果和用户传来的一致，就表示一致</strong> </p><p>怎么防重放？</p><p><strong>参数5:</strong> 每次请求时都 + nonce随机数，只能用一次</p><p>服务端要保存用过的随机数</p><p><strong>参数6:</strong> 加timestamp时间戳，校验时间戳是否过期</p><p><strong>API签名认证是一个很灵活的设计，具体有哪些参数，参数名如何 一定要根据具体场景来，(比如userId、appId、version、固定值等等)</strong></p><p>思考：开发者每次调用接口都要自己写签名算法？</p><h3 id="——开发一个简单易用的SDK"><a href="#——开发一个简单易用的SDK" class="headerlink" title="——开发一个简单易用的SDK"></a>——开发一个简单易用的SDK</h3><p>理想情况：开发者只需要关心调用哪些接口、传递哪些参数，就跟调用自己写的代码一样简单。</p><p>——开发一个starter的好处：</p><p>开发者引入后，可以直接在application.yaml中写配置，自动创建客户端</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230715142059798.png" alt="image-20230715142059798"></p><p>spring-boot-configuration-processor的作用是自动生成配置的代码提示</p>]]></content>
      
      
      <categories>
          
          <category> 项目开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb</title>
      <link href="/2023/07/04/JavaWeb/"/>
      <url>/2023/07/04/JavaWeb/</url>
      
        <content type="html"><![CDATA[<p> 本博客参照了韩顺平老师的 JavaWeb 课程讲义！</p><h1 id="7-Tomcat"><a href="#7-Tomcat" class="headerlink" title="7 Tomcat"></a>7 Tomcat</h1><h2 id="7-1-官方文档"><a href="#7-1-官方文档" class="headerlink" title="7.1 官方文档"></a>7.1 官方文档</h2><h3 id="7-1-1-地址-https-tomcat-apache-org-tomcat-8-0-doc"><a href="#7-1-1-地址-https-tomcat-apache-org-tomcat-8-0-doc" class="headerlink" title="7.1.1 地址: https://tomcat.apache.org/tomcat-8.0-doc/"></a>7.1.1 地址: <a href="https://tomcat.apache.org/tomcat-8.0-doc/">https://tomcat.apache.org/tomcat-8.0-doc/</a></h3><h2 id="7-2-WEB开发介绍"><a href="#7-2-WEB开发介绍" class="headerlink" title="7.2 WEB开发介绍"></a>7.2 WEB开发介绍</h2><ol><li><p>WEB，在英语中 web 表示网&#x2F;网络资源(页面, 图片, css, js)意思，它用于表示 WEB 服务器(主机)供浏览器访问的资源</p></li><li><p>WEB 服务器(主机)上供外界访问的 web 资源分为：</p></li></ol><ul><li>静态web资源（如 html 页面）：指web页面中供人们浏览的数据始终是不变。</li><li>动态web资源，比如 Servlet(java)、PHP 等</li></ul><ol start="3"><li>静态web 资源开发技术</li></ol><ul><li>Html、CSS、js 等</li></ul><ol start="4"><li>常用动态web 资源开发技术：</li></ol><ul><li>Servlet、SpringBoot、SpringvVC、 PHP、ASP.NET 等</li></ul><h2 id="7-3-JavaWeb开发技术栈图"><a href="#7-3-JavaWeb开发技术栈图" class="headerlink" title="7.3 JavaWeb开发技术栈图"></a>7.3 JavaWeb开发技术栈图</h2><p>-一图胜千言</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230704161447451.png" alt="image-20230704161447451"></p><h2 id="7-4-BS-与-CS-开发介绍"><a href="#7-4-BS-与-CS-开发介绍" class="headerlink" title="7.4 BS 与 CS 开发介绍"></a>7.4 BS 与 CS 开发介绍</h2><h3 id="7-4-1-BS开发"><a href="#7-4-1-BS开发" class="headerlink" title="7.4.1 BS开发"></a>7.4.1 BS开发</h3><p><strong>B</strong>: browser(浏览器,种类太多 ff, chrome, ie, edge) </p><p><strong>S</strong>: Server(服务端,考虑很多)<br><strong>示意图:</strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230704162955992.png" alt="image-20230704162955992" style="zoom:30%;" /><p>对BS的解读:</p><ol><li><p>兼容性，因为浏览器的种类很多，发现你号的程序，在某个浏览器会出观问题，其它浏览器正常</p></li><li><p>安全性，通常情况下，Bs 安全性不如 CS 好控制</p></li><li><p>易用性，BS 好于CS，浏览器可直接下载</p></li><li><p>扩展性，BS相对统一，只需要写 Server</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230704163213955.png" alt="image-20230704163213955"></p><h3 id="7-4-2-CS开发"><a href="#7-4-2-CS开发" class="headerlink" title="7.4.2 CS开发"></a>7.4.2 CS开发</h3><p><strong>C</strong>: Client(客户端) </p><p><strong>S</strong>: Server(服务端) </p><p><strong>示意图:</strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230704163427794.png" alt="image-20230704163427794" style="zoom:30%;" /><h2 id="7-5-JavaWeb服务软件"><a href="#7-5-JavaWeb服务软件" class="headerlink" title="7.5 JavaWeb服务软件"></a>7.5 JavaWeb服务软件</h2><h3 id="7-5-1-JavaWeb服务器软件介绍"><a href="#7-5-1-JavaWeb服务器软件介绍" class="headerlink" title="7.5.1 JavaWeb服务器软件介绍"></a>7.5.1 JavaWeb服务器软件介绍</h3><p>1.学习Javaweb 开发，需要先安装 JavaWeb 服务软件【我们把安装了 Javaweb 服务软件主机称为 web服务器&#x2F;Javaweb 服务器】，然后在web 服务器中开发相应的 web 资源。[ Javaweb 服务器，Mysql服务器]</p><p>2.老韩提问：学习Javaweb 开发，为什么必须要先装 WEB 服务软件？</p><p>答：需要安装，理解 Tomcat 本质就是一个Java 程序，但是这个 Java 程序可以处理来自浏览器的 HTTP 请求，和我们前面讲的 java 网络服务（多人聊天,Server)</p><h3 id="7-5-2-手写简单-Web-服务程序"><a href="#7-5-2-手写简单-Web-服务程序" class="headerlink" title="7.5.2 手写简单 Web 服务程序"></a>7.5.2 手写简单 <strong>Web</strong> 服务程序</h3><p><strong>1.</strong> 需求**:** 手写 <strong>MyWebServer.java ,</strong> 让大家体验一下 <strong>JavaWeb</strong> 服务本质 </p><p> <strong>提醒</strong>: 这里，我们需要使用到 Java基础(IO&#x2F;网络),</p><p>​<a href="http://localhost:9999/">http://localhost:9999</a> 表示浏览器向localhost(127.0.0.1)表示本机的9999端口发出请求</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230704164133005.png" alt="image-20230704164133005" style="zoom:50%;" /><p><strong>2.</strong> <strong>创建</strong> <strong>hspedu_mytomcat</strong> <strong>的</strong> <strong>Java</strong> <strong>应用程序</strong>.</p><p><strong>3.</strong> <strong>创建</strong> <strong>D:\idea_java_projects\hspedu_mytomcat\src\hello.html</strong></p><p>​Hello, I AM WEB Server!</p><p><strong>4.</strong> <strong>创建</strong> <strong>D:\idea_java_projects\hspedu_mytomcat\src\MyWebServer.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTomcat</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.在 9999 端口监听</span></span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="comment">//如果 serverSocket 没有关闭，就等待连接, 不停的等待 </span></span><br><span class="line">    <span class="keyword">while</span> (!serverSocket.isClosed()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;=====我的 web 服务在 9999 端口监听=====&quot;</span>); </span><br><span class="line">    <span class="comment">//2. 等待浏览器/客户端连接, 得到 socket</span></span><br><span class="line">    <span class="comment">// 该 socket 用于通信</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">    <span class="comment">//3. 通过 socket 得到 输出流，[]</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream(); <span class="comment">// 返回给浏览器/客户端</span></span><br><span class="line">    <span class="comment">//4. 读取 hello.html 文件返回即可=&gt; 如何读取文件内容 </span></span><br><span class="line">    <span class="comment">// 得到文件输入流(字符输入流), 和 src/hello.html </span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src/hello.html&quot;</span>)); </span><br><span class="line">    <span class="type">String</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 循环读取 hello.html</span></span><br><span class="line">    <span class="keyword">while</span> ((buf = bufferedReader.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">      outputStream.write(buf.getBytes()); &#125;</span><br><span class="line">      outputStream.close();</span><br><span class="line">    socket.close(); </span><br><span class="line">    &#125;</span><br><span class="line">    serverSocket.close();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5.</strong> <strong>完成测试</strong>: <strong>浏览器</strong> <strong><a href="http://localhost:9999/">http://localhost:9999/</a></strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230704165444597.png" alt="image-20230704165444597" style="zoom:33%;" /><h3 id="7-5-3-常用-JavaWeb-服务软件"><a href="#7-5-3-常用-JavaWeb-服务软件" class="headerlink" title="7.5.3 常用 JavaWeb 服务软件"></a>7.5.3 常用 JavaWeb 服务软件</h3><p><strong>1.</strong> <strong>Tomcat</strong>:由 <strong>Apache</strong> 组织提供的一种 <strong>Web</strong> 服务器，提供对 <strong>jsp</strong> 和 <strong>Servlet</strong> 的支持。它是一种轻量级的 <strong>javaWeb</strong> 容器(服务器)，也是当前应用最广的 <strong>JavaWeb</strong> 服务器(免费)。</p><p><strong>2.</strong> <strong>Jboss:是一个遵从</strong> <strong>JavaEE</strong> <strong>规范的、它支持所有的</strong> <strong>JavaEE</strong> <strong>规范(免费)。</strong></p><p><strong>3.</strong> <strong>GlassFish</strong>: 由 <strong>Oracle</strong> <strong>公司开发的一款</strong> <strong>JavaWeb</strong> <strong>服务器，是一款商业服务器，达到产品级质量(应用很少)。</strong></p><p><strong>4.</strong> <strong>Resin:是CAUCHO</strong> <strong>公司的产品，是一个非常流行的服务器，对</strong> <strong>servlet</strong> <strong>和</strong> <strong>JSP</strong> <strong>提供了良好的支持， 性能也比较优良(收费)。</strong></p><p><strong>5.</strong> <strong>WebLogic</strong>【很猛】:是 <strong>Oracle</strong> <strong>公司的产品，支持</strong> <strong>JavaEE</strong> <strong>规范， 而且不断的完善以适应新的开发要求，适合大型项目(收费，用的不多，适合大公司)。</strong></p><h2 id="7-6-Tomcat"><a href="#7-6-Tomcat" class="headerlink" title="7.6 Tomcat"></a>7.6 Tomcat</h2><h3 id="7-6-1-Tomcat下载和安装"><a href="#7-6-1-Tomcat下载和安装" class="headerlink" title="7.6.1 Tomcat下载和安装"></a><strong>7.6.1 Tomcat</strong>下载和安装</h3><p><strong>1. Tomcat</strong> 官方站点:**<a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a> **</p><p><strong>2.</strong> <strong>获取</strong> <strong>Tomcat</strong> <strong>安装程序包</strong></p><p><strong>tar.gz</strong>文件是<u>Linux</u>操作系统下的安装版本</p><p><strong>zip</strong>文件是<u>Windows</u>系统下的压缩版本</p><p><strong>3.</strong> <strong>使用</strong> <strong>zip</strong> <strong>包安装</strong> <strong>Tomcat</strong></p><p>**4. which version <a href="https://tomcat.apache.org/whichversion.html">https://tomcat.apache.org/whichversion.html</a> ,**可以看到 <strong>Tomcat</strong> <strong>仍然是支持</strong> <strong>jsp</strong> <strong>和</strong> <strong>el</strong></p><p><strong>5.</strong> Tomcat <strong>最好的小伙伴是</strong> <strong>JSP+EL</strong></p><h3 id="7-6-2-Tomcat启动"><a href="#7-6-2-Tomcat启动" class="headerlink" title="7.6.2 Tomcat启动"></a><strong>7.6.2 Tomcat</strong>启动</h3><p>windows系统：双击 <strong>bin</strong> 目录下的 <strong>startup.bat</strong> 文件</p><p>macos：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">🌟进入tomcat安装目录的bin目录下</span><br><span class="line">cd /Applications/压缩包资源/apache-tomcat-9.0.73/bin</span><br><span class="line"></span><br><span class="line">🌟启动tomcat</span><br><span class="line">./startup.sh</span><br><span class="line">🌟关闭tomcat</span><br><span class="line">./shutdown.sh</span><br><span class="line">🌟查看版本信息</span><br><span class="line">./version.sh</span><br></pre></td></tr></table></figure><p><strong>输入</strong> <strong><a href="http://localhost:8080/%EF%BC%8C%E6%98%BE%E7%A4%BA%E5%A6%82%E4%B8%8B%E7%95%8C%E9%9D%A2%E4%BB%A3%E8%A1%A8%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F">http://localhost:8080/，显示如下界面代表安装成功</a></strong>, <strong>默认在</strong> <strong>8080</strong> <strong>端口</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230705084311991.png" alt="image-20230705084311991"></p><p><strong>在开发中，我们可以看一下哪些端口在监听：</strong> netstat -anb</p><h3 id="7-6-3-Tomcat启动故障排除"><a href="#7-6-3-Tomcat启动故障排除" class="headerlink" title="7.6.3 Tomcat启动故障排除"></a><strong>7.6.3 Tomcat</strong>启动故障排除</h3><p><strong>1.</strong> 双击 <strong>startup.bat</strong> 文件，出现一个小黑窗口然后就没了，原因是因为没有配置好<strong>JAVA_HOME</strong> 环境变量<strong>Tomcat</strong> <strong>本质是一个</strong> <strong>Java</strong> <strong>程序，所以要</strong> <strong>jdk,</strong> <strong>会去根据</strong> <strong>JAVA_HOME</strong> <strong>使用指定</strong> <strong>jdk</strong></p><p><strong>2. JAVA_HOME</strong> <strong>必须全大写</strong></p><p><strong>3. JAVA_HOME</strong> <strong>中间必须是下划线</strong></p><p><strong>4. JAVA_HOME</strong> <strong>配置的路径只需要配置到</strong> <strong>jdk</strong> <strong>的安装目录即可。不需要带上</strong> <strong>bin</strong> <strong>目录</strong></p><p><strong>5.</strong> <strong>端口</strong> <strong>8080</strong> <strong>被占用</strong> **[**查看端口<u>netstat -anb</u>,使用的非常多]</p><p><strong>6.</strong> <strong>如果其它服务程序占用了</strong> <strong>8080</strong> <strong>端口，可以关闭该服务，或者修改</strong> <strong>Tomcat</strong> <strong>服务的默认 端口</strong> **8080 [**后面讲]</p><h3 id="7-6-4-Tomcat-目录结构"><a href="#7-6-4-Tomcat-目录结构" class="headerlink" title="7.6.4 Tomcat 目录结构"></a><strong>7.6.4 Tomcat</strong> 目录结构</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230705085601438.png" alt="image-20230705085601438"></p><p>解读<br><strong>1. server.xml</strong> <strong>用于配置</strong> <strong>tomcat的基本设置(启动端口，关闭端口,主机名)</strong></p><p><strong>2. wex.xml 用于指定 tomcat 运行时配置(比如servlet等</strong>.)</p><p><strong>3. webapps 目录是存放web应用，就是网站</strong></p><h3 id="7-6-5-catalina-启动-Tomcat-Windows"><a href="#7-6-5-catalina-启动-Tomcat-Windows" class="headerlink" title="7.6.5 catalina 启动 Tomcat(Windows)"></a>7.6.5 catalina 启动 Tomcat(Windows)</h3><p><strong>1.</strong> 进入到 <strong>Tomcat</strong> 的 <strong>bin</strong> 目录下</p><p><strong>2.</strong> <strong>执行命令:</strong> <strong>catalina run</strong></p><h3 id="7-6-6-停止-Tomcat"><a href="#7-6-6-停止-Tomcat" class="headerlink" title="7.6.6 停止 Tomcat"></a>7.6.6 停止 Tomcat</h3><p><strong>进入</strong> <strong>Tomcat</strong> <strong>的</strong> <strong>bin</strong> <strong>目录下的</strong> <strong>shutdown.bat</strong> <strong>双击，就可以停止</strong> <strong>Tomcat</strong> <strong>服务器</strong>(windows)</p><h3 id="7-6-7-修改-Tomcat-服务端口"><a href="#7-6-7-修改-Tomcat-服务端口" class="headerlink" title="7.6.7 修改 Tomcat 服务端口"></a>7.6.7 修改 Tomcat 服务端口</h3><p><strong>1. Tomcat</strong> 目录下的 <strong>conf</strong> 目录，修改 <strong>server.xml</strong> 配置文件</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230705152146388.png" alt="image-20230705152146388"></p><p><strong>2.</strong> <strong>老韩说明:</strong> <strong><a href="http://localhost/">http://localhost</a> ,</strong> <strong>默认是访问</strong> <strong>80</strong> <strong>端口</strong>,<strong>即</strong> <a href="http://localhost**等价**http//localhost:80">http://localhost**等价**http://localhost:80</a></p><h3 id="7-6-8-Tomcat-服务中部署-WEB-应用"><a href="#7-6-8-Tomcat-服务中部署-WEB-应用" class="headerlink" title="7.6.8 Tomcat 服务中部署 WEB 应用"></a>7.6.8 Tomcat 服务中部署 <strong>WEB</strong> 应用</h3><ul><li>什么是<strong>Web</strong>应用</li></ul><ol><li><p>WEB应用是多个web资源的集合。简单的说，可以把web应用理解为硬盘上的一个目录，这个目录用于管理多个web资源。</p></li><li><p>web应用通常也称之为web应用程序，或web工程，通俗的说就是网站。</p></li></ol><ul><li><strong>Web应用</strong>组成</li></ul><p>一个 WEB 应用由多个WEB 资源或其它文件组成，包括html 文件、css 文件、js文件、动态web页面、java 程序、支持jar 包、配置文件等。开发人员在开发 web 应用时，按照规定目录结构存放这些文件。否则，在把 web 应用交给 web 服务器管理时，不仅可能会使web 应用无法访问，还会导致 web 服务器启动报错。</p><ul><li>Javaweb程序&#x2F;应用&#x2F;工程目录结构</li></ul><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230706111003709.png" alt="image-20230706111003709" style="zoom: 40%;" /><ul><li>部署方式1：将web工程的目录拷贝到 Tomcat 的webapps 目录下</li></ul><ol><li><p>news web工程(目前都是静态资源 html， 图片）</p></li><li><p>将该news目录&#x2F;文件夹 拷贝到 Tomcat 的webapps目录下</p></li><li><p>浏览器输入：<a href="http://ip[域名]:port/news/子目录.../文件名">http://ip[域名]:port/news/子目录.../文件名</a></p></li></ol><ul><li>部署方式2：</li></ul><p>在tomcat下的 conf&#x2F;Catalina&#x2F;localhost&#x2F; 目录中，添加配置文件，可以映射到其他位置的web应用(在其他地方寻找web应用，解决磁盘空间分配问题)</p><p><strong>ROOT 的工程的访问:</strong></p><ol><li><p>在浏览器地址栏中输入访问地址如下：<a href="http://ip[域名]:port，">http://ip[域名]:port，</a><u>没有web工程&#x2F; 应用名时，默认访问的是 ROOT 工程</u></p></li><li><p>在浏览器地址栏中输入的访问地址如下: <a href="http://ip[域名]:port/工程名/">http://ip[域名]:port/工程名/</a> ，没有资源名,<strong>则默认访问</strong> <strong>index.jsp</strong> <strong>页面</strong></p></li></ol><h3 id="7-6-9-浏览器访问-Web-服务过程详解"><a href="#7-6-9-浏览器访问-Web-服务过程详解" class="headerlink" title="7.6.9 浏览器访问 Web 服务过程详解"></a>7.6.9 浏览器访问 Web 服务过程详解</h3><h4 id="7-6-9-1-回顾前面的-JavaWeb-开发技术栈图"><a href="#7-6-9-1-回顾前面的-JavaWeb-开发技术栈图" class="headerlink" title="7.6.9.1 回顾前面的 JavaWeb 开发技术栈图"></a>7.6.9.1 回顾前面的 JavaWeb 开发技术栈图</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230704161447451.png" alt="image-20230704161447451"></p><h4 id="7-6-9-2-浏览器访问-web-服务器文件-UML-时序图"><a href="#7-6-9-2-浏览器访问-web-服务器文件-UML-时序图" class="headerlink" title="7.6.9.2 浏览器访问 web 服务器文件 UML 时序图!!!"></a>7.6.9.2 浏览器访问 web 服务器文件 UML 时序图!!!</h4><p><strong>1.</strong> 说明</p><p>下面，我们对浏览器访问web服务器资源(html,css,图片,js)做详解，通过一个时序图加强对这个重要过程的理解,重要，核心</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230706111724367.png" alt="image-20230706111724367"></p><h2 id="7-7-IDEA-开发-JavaWeb-工程"><a href="#7-7-IDEA-开发-JavaWeb-工程" class="headerlink" title="7.7 IDEA 开发 JavaWeb 工程"></a>7.7 IDEA 开发 JavaWeb 工程</h2><h3 id="7-7-1-开发-javaweb-工程-amp-配置-TomCat-amp-启动项目"><a href="#7-7-1-开发-javaweb-工程-amp-配置-TomCat-amp-启动项目" class="headerlink" title="7.7.1 开发 javaweb 工程 &amp; 配置 TomCat &amp; 启动项目"></a>7.7.1 开发 javaweb 工程 &amp; 配置 TomCat &amp; 启动项目</h3><p>1.需求&#x2F;图解：使用 IDEA 开发 Javaweb 工程fishweb，并将网页部署到 fishweb 工程，看老师演示</p> <img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230706112454090.png" alt="image-20230706112454090" style="zoom:33%;" /><h3 id="7-7-2-注意事项和细节"><a href="#7-7-2-注意事项和细节" class="headerlink" title="7.7.2 注意事项和细节"></a>7.7.2 注意事项和细节</h3><h4 id="1-热加载选项说明"><a href="#1-热加载选项说明" class="headerlink" title="1. 热加载选项说明"></a>1. 热加载选项说明</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230706135810014.png" alt="image-20230706135810014"></p><p>解读：</p><p>(1)on update action ：表示当我们<strong>更新操作</strong>时，Tomcat 会自动更新类和资源（<u>当jsp&#x2F;html文件修改时，可以生效，但是如果你修改的java 文件，需要 Redepoly 才会生效</u>）</p><p>(2) on frame deactivation ：表示 <strong>IDEA 失去焦点</strong>（(比如最小化)，也会导致jsp&#x2F;html 发生更新，但是java 修改了，还是需要 Redeploy</p><h4 id="2-端口修改"><a href="#2-端口修改" class="headerlink" title="2. 端口修改"></a>2. 端口修改</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230706140054643.png" alt="image-20230706140054643" style="zoom:50%;" /><p><strong>这里修改的端口， 只会影响到当前的项目，而不是去修改 server.xml</strong></p><h4 id="3-out-目录是什么"><a href="#3-out-目录是什么" class="headerlink" title="3.out 目录是什么"></a>3.out 目录是什么</h4><p>当tomcat 启动时，会生成 out 目录，该目录就是原项目资源的映射，我们浏览器访问的资源是 out 目录</p><h4 id="4-当我们从外部拷贝资源到项目（图片，文件，js，css-等"><a href="#4-当我们从外部拷贝资源到项目（图片，文件，js，css-等" class="headerlink" title="4.当我们从外部拷贝资源到项目（图片，文件，js，css 等)"></a>4.当我们从外部拷贝资源到项目（图片，文件，js，css 等)</h4><p>如果出现 404 不能访问错误,解决方式 rebulid project -＞重启 Tomcat</p><h3 id="7-7-3-JavaWeb-工程的目录介绍"><a href="#7-7-3-JavaWeb-工程的目录介绍" class="headerlink" title="7.7.3 JavaWeb 工程的目录介绍"></a><strong>7.7.3 JavaWeb</strong> 工程的目录介绍</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230706141714376.png" alt="image-20230706141714376"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230706141833960.png" alt="image-20230706141833960"></p><h1 id="8-动态-WEB-开发核心-Servlet"><a href="#8-动态-WEB-开发核心-Servlet" class="headerlink" title="8 动态 WEB 开发核心-Servlet"></a>8 动态 WEB 开发核心-Servlet</h1><h2 id="8-1-官方文档"><a href="#8-1-官方文档" class="headerlink" title="8.1 官方文档"></a>8.1 官方文档</h2><h3 id="8-1-1-地址-https-tomcat-apache-org-tomcat-8-0-doc-servletapi-index-html"><a href="#8-1-1-地址-https-tomcat-apache-org-tomcat-8-0-doc-servletapi-index-html" class="headerlink" title="8.1.1 地址: https://tomcat.apache.org/tomcat-8.0-doc/servletapi/index.html"></a>8.1.1 地址: <a href="https://tomcat.apache.org/tomcat-8.0-doc/servletapi/index.html">https://tomcat.apache.org/tomcat-8.0-doc/servletapi/index.html</a></h3><h3 id="8-1-3-Servlet和Tomcat的关系-一句话-Tomcat支持Servlet"><a href="#8-1-3-Servlet和Tomcat的关系-一句话-Tomcat支持Servlet" class="headerlink" title="8.1.3 Servlet和Tomcat的关系:一句话,Tomcat支持Servlet"></a>8.1.3 Servlet和Tomcat的关系:一句话,Tomcat支持Servlet</h3><h2 id="8-2-为什么会出现-Servlet"><a href="#8-2-为什么会出现-Servlet" class="headerlink" title="8.2 为什么会出现 Servlet"></a>8.2 为什么会出现 Servlet</h2><p>提出需求**:** 请用你现有的<strong>html css javascript</strong>，开发网站，比如可以让用户留言**&#x2F;<strong>购物</strong>&#x2F;<strong>支付</strong>,** 你能搞定吗**?**</p><p>—不能，因为无法操作数据库</p><ul><li>引入我们动态网页(能和用户交互)技术 <strong>&#x3D;&#x3D;&#x3D;&gt; Servlet</strong></li><li>对Java Web 技术体系的流程图改造说明(细化).[整体的概念]</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230706145610695.png" alt="image-20230706145610695"></p><h2 id="8-3-什么是-Servlet"><a href="#8-3-什么是-Servlet" class="headerlink" title="8.3 什么是 Servlet"></a>8.3 什么是 Servlet</h2><ul><li><p>什么是Servlet</p><ul><li>Servlet 在开发动态 WEB 工程中，得到广泛的应用，掌握好 Servlet 非常重要,Servlet(基石)是 SpringvC 的基础</li></ul></li><li><p>Servlet(java 服务器小程序)，它的特点：</p><ul><li>他是由服务器端调用和执行的(一句话：是Tomcat解析和执行）</li><li>他是用java语言编号的，本质就是Java类</li><li>他是按照Servlet规范开发的（除 了tomcat-&gt;Servlet weblogic-&gt;Servlet)</li><li>功能强大，可以完成几乎所有的网站功能(在以前，我们老程员，使用Servlet开发网站）技术栈要求高</li></ul></li></ul><h2 id="8-4-Servlet在JavaWeb项目位置"><a href="#8-4-Servlet在JavaWeb项目位置" class="headerlink" title="8.4 Servlet在JavaWeb项目位置"></a>8.4 Servlet在JavaWeb项目位置</h2><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230707084620291.png" alt="image-20230707084620291"></p><h2 id="8-5-Servlet基本使用"><a href="#8-5-Servlet基本使用" class="headerlink" title="8.5 Servlet基本使用"></a>8.5 Servlet基本使用</h2><h3 id="8-5-1-Servlet开发方式说明"><a href="#8-5-1-Servlet开发方式说明" class="headerlink" title="8.5.1 Servlet开发方式说明"></a><strong>8.5.1 Servlet</strong>开发方式说明</h3><ol><li><p>servlet3.0 前使用 <strong>web.xml , servlet3.0</strong> 版本以后**(**包括 **3.0)**支持注解， 同时支持 <strong>web.xml</strong> 配置</p></li><li><p><strong>如何查看</strong> <strong>servlet版本[如图]</strong></p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230707085030431.png" alt="image-20230707085030431"></p><ol start="3"><li><p>讲解SpringBoot 时，我们用注解方式，从 ssm,springboot 后面全部使用注解</p></li><li><p>这专门讲 servlet， 为让大家更清晰知道 servlet 使用原理，老师用配置方式（说明: 原生的 Servlet 在项目中使用很少</p></li><li><p>不管使用哪种方式，本质都一样</p></li></ol><h3 id="8-5-2-快速入门-手动开发-Servlet"><a href="#8-5-2-快速入门-手动开发-Servlet" class="headerlink" title="8.5.2 快速入门- 手动开发 Servlet"></a>8.5.2 快速入门- 手动开发 Servlet</h3><p>需求说明</p><p>1、开发一个 Helloservlet</p><p>2、当浏览器 访问 <a href="http://localhost:8080/web%E5%BA%94%E7%94%A8%E5%90%8D/helloServlet">http://localhost:8080/web应用名/helloServlet</a> 时，后台输出 “hi HelloServelt”</p><ul><li>具体步骤<ul><li>编写类Helloservlet去实现 Servlet <strong>接口</strong></li><li>实现 service 方法，处理请求，并响应数据</li><li>在 web.xml 中去配置 servlet 程序的访问地址</li></ul></li></ul><p>1.创建 hspedu_servlet JavaWeb 工程，并配置好Tomcat</p><p>2.添加servlet-api.jar(在tomcat&#x2F;lib下)到工程,因为servlet.jar不是jdk自带的,要引入</p><p>3.在src下包<strong>com.hspedu.servlet.HelloServlet.java</strong>，并实现Servlet接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/7/7</span></span><br><span class="line"><span class="comment"> * 09:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="comment">//当创建HelloServlet时，会调用init方法</span></span><br><span class="line">    <span class="comment">//该方法只会被调用一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servlet被调用~~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回Servlet的配置信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * service 方法是专门用来处理请求和响应的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy 被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.在web.xml配置HelloServlet，即:给HelloServlet提供对外访问地址</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  1.web.xml主要用来配置该web应用使用到的Servlet  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  2.servlet-name:给Servlet取名(程序员决定)，该名字唯一</span></span><br><span class="line"><span class="comment">      3.servlet-class：Servlet的类的全路径：Tomcat在反射生成该Servlet需要使用</span></span><br><span class="line"><span class="comment">      4.url-pattern：该servlet访问的url的配置(路径)</span></span><br><span class="line"><span class="comment">      这时我们应访问：http://localhost:8080/servlet/helloServlet</span></span><br><span class="line"><span class="comment">      5.url-pattern 取名是程序员决定的</span></span><br><span class="line"><span class="comment">      6.load-on-startup:表示在tomcat启动时，会自动加载servlet实例</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.study.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/helloServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>5.通过浏览器访问HelloServlet ,看是否正确(记住要redeploy[快]或者restart[慢])</p><p><a href="http://localhost:8080/servlet/helloServlet">http://localhost:8080/servlet/helloServlet</a></p><h3 id="8-5-3-浏览器调用-Servlet-流程分析"><a href="#8-5-3-浏览器调用-Servlet-流程分析" class="headerlink" title="8.5.3 浏览器调用 Servlet 流程分析"></a>8.5.3 浏览器调用 Servlet 流程分析</h3><p>一图胜千言</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230707095156118.png" alt="image-20230707095156118"></p><p>如果在web.xml中未查询到请求的资源，则会返回404错误！</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230707095634908.png" alt="image-20230707095634908"></p><p><strong>Servlet常驻内存，属于单例模式</strong></p><h3 id="8-5-4-Servlet生命周期"><a href="#8-5-4-Servlet生命周期" class="headerlink" title="8.5.4 Servlet生命周期"></a><strong>8.5.4 Servlet</strong>生命周期</h3><p>● 主要有三个方法：</p><p><strong>1. init()：</strong>初始化阶段</p><p><strong>2. service()：</strong>处理浏览器请求阶段</p><p><strong>3. destroy()：</strong>终止阶段</p><ul><li><strong>示意图</strong></li></ul><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230707100629527.png" alt="image-20230707100629527" style="zoom:40%;" /><ul><li><p><strong>初始化阶段</strong></p><ul><li><p>servlet 容器(比如：Tomcat)&#x2F;加载 Servlet，加载完成后，Servlet 容器会创建一个 Servlet 实例</p><p>并调用 init()方法，init()方法只会调用一次，Servlet 容器在下面的情况装载 Servlet:</p><ul><li><p>Servlet 容器 (Tomcat) 启动时自动装载某些 servlet，实现这个需要在 web.xml 文件中添加</p><p><load-on-startup>1</load-on-startup>1 表示装载的顺序</p></li><li><p>在servlet 容器启动后，浏览器首次向 servlet 发送请求(这个前面说过）</p></li><li><p>Servlet 重新部署后(比如 tomcat 进行 redeploy 【*<u><strong>redeploy 会销毁所有的 servlet 实例!!!</strong></u>*】）。</p><p>浏览器再向 Servlet 发送第1次请求(或配置了tomcat启动自动装载)</p></li></ul></li></ul></li><li><p><strong>处理浏览器请求阶段</strong>(service <strong>方法</strong>)</p></li><li><p>每收到一个http 请求，服务器就会产生一个新的线程去处理[线程]</p></li><li><p>创建一个用于封装 HTTP 请求消息的 <strong>ServletRequest 对象</strong>和一个代表 HTTP 响应消息的<strong>ServletResponse</strong> 对象</p></li><li><p>然后调用 Servlet 的 service()方法并将请求和响应对象作为参数传递进去</p></li><li><p>终止阶段 destory 方法(体现 Servlet 完整的生命周期)</p><ul><li><p>当web 应用被終止，或者 servlet 容器終止运行，或者Servlet 类重新装载时，会调用 destroy(方法</p></li><li><p>比如重启 tomcat,或者redeploy web 应用</p></li></ul></li></ul><h3 id="8-5-5-GET-和-POST-请求的分发处理"><a href="#8-5-5-GET-和-POST-请求的分发处理" class="headerlink" title="8.5.5 GET 和 POST 请求的分发处理"></a>8.5.5 GET 和 POST 请求的分发处理</h3><ul><li><p>开发 servlet，通常编写 doGet、doPost 方法。来对表单的get 和 post 请求进行分发处理</p></li><li><p>代码演示 HelloServlet.java   register.html</p></li></ul><ol><li>创建 servlet\web\register.html</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">title</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>注册用户<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:8080/servlet/helloServlet&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">            u: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注册用户&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.</strong> 修改 <strong>servlet\src\com\hspedu\servlet\HelloServlet.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//思考-&gt;从 servletRequest 对象来获取请求方式-&gt;</span></span><br><span class="line">        <span class="comment">//1. ServletRequest 没有得到提交方式的方法</span></span><br><span class="line">        <span class="comment">//2. ServletRequest 看看 ServletRequest 子接口有没有相关方法</span></span><br><span class="line">        <span class="comment">//3. 老师小技巧:ctrl+alt+b =&gt; 可以看到接口的子接口和实现子类</span></span><br><span class="line">        <span class="comment">//4. 把 servletReqeust 转成 HttpServletRequest 引用</span></span><br><span class="line">        <span class="comment">//5. 仍然是 Java 基础的 OOP</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> httpServletRequest.getMethod();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;GET&quot;</span>.equals(method)) &#123;</span><br><span class="line">            doGet();    <span class="comment">//用 doGet() 处理 GET 请求 &#125;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;POST&quot;</span>.equals(method)) &#123;</span><br><span class="line">            doPost();   <span class="comment">//用 doPost() 处理 POST 请求</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doGet被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doPost被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="8-5-6-通过继承-HttpServlet-开发-Servlet"><a href="#8-5-6-通过继承-HttpServlet-开发-Servlet" class="headerlink" title="8.5.6 通过继承 HttpServlet 开发 Servlet"></a>8.5.6 通过继承 HttpServlet 开发 Servlet</h3><ul><li>HttpServlet 介绍</li></ul><p>在实际项目中，都是使用继承 HttpServlet 类开发 Servlet 程序，更加方便</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230707112036074.png" alt="image-20230707112036074" style="zoom:50%;" /><ul><li>HttpServlet 介绍</li></ul><p>1、通过继承 HttpServlet 开发一个 HiServlet</p><p>2、当浏览器 访问 <a href="http://localhost:8080/web">http://localhost:8080/web</a> 应用名&#x2F;hiServlet 时，后台输出 “hi HiServelt”</p><ul><li>具体的开发步骤</li></ul><ol><li>编写一个类去继承 HttpServlet 类</li><li>根据业务需要重写 doGet 或 doPost 方法</li><li>到 web.xml 中的配置 Servlet 程序</li></ol><ul><li>应用实例</li></ul><p>1.创建HiServlet.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/7/7</span></span><br><span class="line"><span class="comment"> * 13:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HiServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HiServlet doGet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HiServlet doPost&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.修改web.xml完成配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HiServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.study.servlet.HiServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HiServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hiServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.完成测试</p><p><a href="http://localhost:8080/servlet/hiServlet">http://localhost:8080/servlet/hiServlet</a></p><h3 id="8-5-7-IDEA-开发-Servlet-程序"><a href="#8-5-7-IDEA-开发-Servlet-程序" class="headerlink" title="8.5.7 IDEA 开发 Servlet 程序"></a>8.5.7 IDEA 开发 Servlet 程序</h3><ul><li>说明</li></ul><p>编手动开发 Servlet 需要程序员自己配置 Servlet ,比较麻烦，在工作中，直接使用 IDEA 开发 Servlet 会更加方便</p><ul><li>应用实例</li></ul><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230707140732732.png" alt="image-20230707140732732" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230707140642567.png" alt="image-20230707140642567" style="zoom: 50%;" /><h3 id="8-5-8-Servlet-注意事项和细节"><a href="#8-5-8-Servlet-注意事项和细节" class="headerlink" title="8.5.8 Servlet 注意事项和细节"></a>8.5.8 Servlet 注意事项和细节</h3><ol><li>Servlet 是一个供其他 Java 程序（Servlet 引擎） 调用的 Java 类， 不能独立运行</li><li>针对浏览器的多次 Servlet 请求，通常情况下，服务器只会创建一个 Servlet 实例对象，也就是说 Servlet 实例对象一旦创建，它就会驻留在内存中，为后续的其它请求服务，直至web 容器退出&#x2F;或者 redeploy 该 web 应用，servlet 实例对象才会销毁 【示意图】</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230710085610919.png" alt="image-20230710085610919" style="zoom:50%;" /><ol start="3"><li><p>在 Servlet 的整个生命周期内，init 方法只被调用一次。而对每次请求都导致 Servlet 引擎调用一次 servlet 的 service 方法。</p></li><li><p>对于每次访问请求，Servlet 引擎都会创建一个新的 HttpServletRequest 请求对象和一个新的 HttpServletResponse 响应对象，然后将这两个对象作为参数传递给它调用的 Servlet的 service()方法，service 方法再根据请求方式分别调用 doXXX 方法</p></li><li><p>如果在<servlet>元素中配置了一个<load-on-startup>元素，那么 WEB 应用程序在启动时，就会装载并创建 Servlet 的实例对象、以及调用 Servlet 实例对象的 init()方法         应用场景：(定时发送邮件的服务&#x2F;自动启动-&gt;完成任务)</p></li></ol><h2 id="8-6-Servlet-注解方式"><a href="#8-6-Servlet-注解方式" class="headerlink" title="8.6 Servlet - 注解方式"></a>8.6 Servlet - 注解方式</h2><h3 id="8-6-1-快速入门"><a href="#8-6-1-快速入门" class="headerlink" title="8.6.1 快速入门"></a>8.6.1 快速入门</h3><ul><li>具体步骤</li></ul><ol><li><p>编写类OkServlet去继承HttpServlet</p></li><li><p>注解方式配置OkServlet, 一个Servlet支持配置多个urlPattern</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.servlet.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/7/7</span></span><br><span class="line"><span class="comment"> * 14:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 1.注解方式配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@WebServlet</span>是一个注解</span></span><br><span class="line"><span class="comment"> * 2.源码：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Target</span>(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Retention</span>(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Documented</span></span></span><br><span class="line"><span class="comment"> * public <span class="doctag">@interface</span> WebServlet &#123;</span></span><br><span class="line"><span class="comment"> *     String name() default &quot;&quot;;</span></span><br><span class="line"><span class="comment"> *     String[] value() default &#123;&#125;;</span></span><br><span class="line"><span class="comment"> *     String[] urlPatterns() default &#123;&#125;;</span></span><br><span class="line"><span class="comment"> *     int loadOnStartup() default -1;</span></span><br><span class="line"><span class="comment"> *     WebInitParam[] initParams() default &#123;&#125;;</span></span><br><span class="line"><span class="comment"> *     boolean asyncSupported() default false;</span></span><br><span class="line"><span class="comment"> *     String smallIcon() default &quot;&quot;;</span></span><br><span class="line"><span class="comment"> *     String largeIcon() default &quot;&quot;;</span></span><br><span class="line"><span class="comment"> *     String description() default &quot;&quot;;</span></span><br><span class="line"><span class="comment"> *     String displayName() default &quot;&quot;;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * 3.urlPatterns 对应 &lt;url-patterns&gt;&lt;url-patterns/&gt;</span></span><br><span class="line"><span class="comment"> * 4.&#123;&quot;/ok1&quot;,&quot;/ok2&quot;&#125; 可以给OkServlet配置多个url-pattern</span></span><br><span class="line"><span class="comment"> * 5.用户在浏览器可以这样访问：http://localhost:8080/servlet/ok2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &#123;&quot;/ok1&quot;,&quot;/ok2&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OkServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;注解方式 OkServlet doPost&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;注解方式 OkServlet doGet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>注解方式是如何实现的？</p><p>——Tomcat对包进行扫描，如果发现某个类被@WebServlet修饰，就说明该类是Servlet，就读取注解中的urlPatterns，然后进行下一步……(看请求的资源是否能从注解中找到……，找到则得到urlPatterns，去hashmap中看该servlet是否已经加载过……)</p><h3 id="8-6-2-Servlet-urlPattern-配置"><a href="#8-6-2-Servlet-urlPattern-配置" class="headerlink" title="8.6.2 Servlet urlPattern 配置"></a>8.6.2 Servlet urlPattern 配置</h3><h4 id="8-6-2-1-精确匹配"><a href="#8-6-2-1-精确匹配" class="headerlink" title="8.6.2.1 精确匹配"></a>8.6.2.1 精确匹配</h4><p>——最简单、普遍的路径设置方式</p><p>配置路径 : @WebServlet(“&#x2F;ok&#x2F;zs”)</p><p>访问 servlet: localhost:8080&#x2F;servlet&#x2F;ok&#x2F;zs</p><h4 id="8-6-2-2-目录匹配"><a href="#8-6-2-2-目录匹配" class="headerlink" title="8.6.2.2 目录匹配"></a>8.6.2.2 目录匹配</h4><p>—— * 表示：零层、任意单层、任意多层</p><p>配置路径 : @WebServlet(“&#x2F;ok&#x2F;*”)</p><p>访问文件: localhost:8080&#x2F;servlet&#x2F;ok&#x2F;aaa localhost:8080&#x2F;servlet&#x2F;ok&#x2F;bbb</p><h4 id="8-6-2-3-扩展名匹配"><a href="#8-6-2-3-扩展名匹配" class="headerlink" title="8.6.2.3 扩展名匹配"></a>8.6.2.3 扩展名匹配</h4><p>——必须保证后缀为 .action</p><p>配置路径 : @WebServlet(“**.action”)*</p><p>访问文件: localhost:8080&#x2F;hsp&#x2F;zs.action localhost:8080&#x2F;hsp&#x2F;ls.action</p><p>提示: @WebServlet(“&#x2F;*.action”) , 不能带 &#x2F; , 否则 tomcat 报错</p><h4 id="8-6-2-4-任意匹配"><a href="#8-6-2-4-任意匹配" class="headerlink" title="8.6.2.4 任意匹配"></a>8.6.2.4 任意匹配</h4><p>配置路径 : @WebServlet(“&#x2F;“) @WebServlet(“&#x2F;**”)*</p><p>访问文件: localhost:8080&#x2F;hsp&#x2F;aaa localhost:8080&#x2F;hsp&#x2F;bbb localhost:8080&#x2F;hsp&#x2F;ccc</p><p>提醒： &#x2F; 和 &#x2F;*的配置， 会匹配所有的请求， 这个比较不实用</p><h4 id="8-6-2-5-注意事项和使用细节"><a href="#8-6-2-5-注意事项和使用细节" class="headerlink" title="8.6.2.5 注意事项和使用细节"></a>8.6.2.5 注意事项和使用细节</h4><p>1、 当 Servlet 配置了 “&#x2F;“, 会覆盖 tomcat 的 DefaultServlet,（当其他的 utl-pattern 都匹配不上时 ，都会走这个 Servlet, 这样可以拦截到其它静态资源,比如D:\hspedu_javaweb_temp\hspedu_servlet\web\hi.html [举例]查看：tomcat&#x2F;conf&#x2F;web.xml , 配置的 DefaultServlet</p><p>「The default servlet for all web applications, that serves static resources.这个默认的 servlet 是处理静态资源的，一旦拦截，静态资源不能处理」</p><p>2、当 Servelt 配置了 “&#x2F;**”, 表示可以匹配任意访问路径*</p><p>3、提示: 建议不要使用 &#x2F; 和 &#x2F;*, 建议尽量使用精确匹配</p><p>4、优先级遵守: 精确路径 &gt; 目录路径 &gt; 扩展名路径 &gt; &#x2F;* &gt; &#x2F;</p><h2 id="8-8-🌟关联篇：-HTTP-协议"><a href="#8-8-🌟关联篇：-HTTP-协议" class="headerlink" title="8.8 🌟关联篇： HTTP 协议"></a>8.8 🌟关联篇： HTTP 协议</h2><h3 id="8-8-1请求头、响应头介绍"><a href="#8-8-1请求头、响应头介绍" class="headerlink" title="8.8.1请求头、响应头介绍"></a>8.8.1请求头、响应头介绍</h3><p><a href="https://github.com/Tangjiayang/picodemo/blob/main/img/HTTP%E5%B8%B8%E8%A7%81%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%B4-%E8%AF%B4%E6%98%8E.pdf">https://github.com/Tangjiayang/picodemo/blob/main/img/HTTP%E5%B8%B8%E8%A7%81%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%B4-%E8%AF%B4%E6%98%8E.pdf</a></p><h3 id="8-8-2HTTP状态码"><a href="#8-8-2HTTP状态码" class="headerlink" title="8.8.2HTTP状态码"></a>8.8.2HTTP状态码</h3><p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。</p><p>HTTP状态码的英文为HTTP Status Code。</p><h4 id="下面是常见的HTTP状态码："><a href="#下面是常见的HTTP状态码：" class="headerlink" title="下面是常见的HTTP状态码："></a>下面是常见的HTTP状态码：</h4><p><strong>200 -</strong> <strong>请求成功</strong></p><p><strong>301 -</strong> <strong>资源（网页等）被永久转移到其它URL</strong></p><p><strong>404 -</strong> <strong>请求的资源（网页等）不存在</strong></p><p><strong>500 -</strong> <strong>内部服务器错误</strong></p><h4 id="HTTP状态码分类"><a href="#HTTP状态码分类" class="headerlink" title="HTTP状态码分类"></a>HTTP状态码分类</h4><p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：</p><table><thead><tr><th>HTTP状态码分类</th><th></th></tr></thead><tbody><tr><td><strong>分类</strong></td><td><strong>分类描述</strong></td></tr><tr><td><strong>1*</strong>*</td><td><strong>信息，服务器收到请求，需要请求者继续执行操作</strong></td></tr><tr><td><strong>2*</strong>*</td><td><strong>成功，操作被成功接收并处理</strong></td></tr><tr><td><strong>3*</strong>*</td><td><strong>重定向，需要进一步的操作以完成请求</strong></td></tr><tr><td><strong>4*</strong>*</td><td><strong>客户端错误，请求包含语法错误或无法完成请求</strong></td></tr><tr><td><strong>5*</strong>*</td><td><strong>服务器错误，服务器在处理请求的过程中发生了错误</strong></td></tr></tbody></table><h4 id="HTTP状态码列表"><a href="#HTTP状态码列表" class="headerlink" title="HTTP状态码列表:"></a>HTTP状态码列表:</h4><table><thead><tr><th>状态码</th><th><strong>状态码英文名称</strong></th><th><strong>中文描述</strong></th></tr></thead><tbody><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http100">100</a></strong></td><td><strong>Continue</strong></td><td><strong>继续。客户端应继续其请求</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http101">101</a></strong></td><td><strong>Switching Protocols</strong></td><td><strong>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http200">200</a></strong></td><td><strong>OK</strong></td><td><strong>请求成功。一般用于GET与POST请求</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http201">201</a></strong></td><td><strong>Created</strong></td><td><strong>已创建。成功请求并创建了新的资源</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http200">202</a></strong></td><td><strong>Accepted</strong></td><td><strong>已接受。已经接受请求，但未处理完成</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http203">203</a></strong></td><td><strong>Non-Authoritative Information</strong></td><td><strong>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http204">204</a></strong></td><td><strong>No Content</strong></td><td><strong>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http205">205</a></strong></td><td><strong>Reset Content</strong></td><td><strong>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http206">206</a></strong></td><td><strong>Partial Content</strong></td><td><strong>部分内容。服务器成功处理了部分GET请求</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http300">300</a></strong></td><td><strong>Multiple Choices</strong></td><td><strong>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http301">301</a></strong></td><td><strong>Moved Permanently</strong></td><td><strong>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http302">302</a></strong></td><td><strong>Found</strong></td><td><strong>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http303">303</a></strong></td><td><strong>See Other</strong></td><td><strong>查看其它地址。与301类似。使用GET和POST请求查看</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http304">304</a></strong></td><td><strong>Not Modified</strong></td><td><strong>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http305">305</a></strong></td><td><strong>Use Proxy</strong></td><td><strong>使用代理。所请求的资源必须通过代理访问</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http306">306</a></strong></td><td><strong>Unused</strong></td><td><strong>已经被废弃的HTTP状态码</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http307">307</a></strong></td><td><strong>Temporary Redirect</strong></td><td><strong>临时重定向。与302类似。使用GET请求重定向</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http400">400</a></strong></td><td><strong>Bad Request</strong></td><td><strong>客户端请求的语法错误，服务器无法理解</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http401">401</a></strong></td><td><strong>Unauthorized</strong></td><td><strong>请求要求用户的身份认证</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http402">402</a></strong></td><td><strong>Payment Required</strong></td><td><strong>保留，将来使用</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http403">403</a></strong></td><td><strong>Forbidden</strong></td><td><strong>服务器理解请求客户端的请求，但是拒绝执行此请求</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http404">404</a></strong></td><td><strong>Not Found</strong></td><td><strong>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http405">405</a></strong></td><td><strong>Method Not Allowed</strong></td><td><strong>客户端请求中的方法被禁止</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http406">406</a></strong></td><td><strong>Not Acceptable</strong></td><td><strong>服务器无法根据客户端请求的内容特性完成请求</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http407">407</a></strong></td><td><strong>Proxy Authentication Required</strong></td><td><strong>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http408">408</a></strong></td><td><strong>Request Time-out</strong></td><td><strong>服务器等待客户端发送的请求时间过长，超时</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http409">409</a></strong></td><td><strong>Conflict</strong></td><td><strong>服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http410">410</a></strong></td><td><strong>Gone</strong></td><td><strong>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http411">411</a></strong></td><td><strong>Length Required</strong></td><td><strong>服务器无法处理客户端发送的不带Content-Length的请求信息</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http412">412</a></strong></td><td><strong>Precondition Failed</strong></td><td><strong>客户端请求信息的先决条件错误</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http413">413</a></strong></td><td><strong>Request Entity Too Large</strong></td><td><strong>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http414">414</a></strong></td><td><strong>Request-URI Too Large</strong></td><td><strong>请求的URI过长（URI通常为网址），服务器无法处理</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http415">415</a></strong></td><td><strong>Unsupported Media Type</strong></td><td><strong>服务器无法处理请求附带的媒体格式</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http416">416</a></strong></td><td><strong>Requested range not satisfiable</strong></td><td><strong>客户端请求的范围无效</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http417">417</a></strong></td><td><strong>Expectation Failed</strong></td><td><strong>服务器无法满足Expect的请求头信息</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http500">500</a></strong></td><td><strong>Internal Server Error</strong></td><td><strong>服务器内部错误，无法完成请求</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http501">501</a></strong></td><td><strong>Not Implemented</strong></td><td><strong>服务器不支持请求的功能，无法完成请求</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http502">502</a></strong></td><td><strong>Bad Gateway</strong></td><td><strong>充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http503">503</a></strong></td><td><strong>Service Unavailable</strong></td><td><strong>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http504">504</a></strong></td><td><strong>Gateway Time-out</strong></td><td><strong>充当网关或代理的服务器，未及时从远端服务器获取请求</strong></td></tr><tr><td><strong><a href="https://www.w3cschool.cn/http/g9prxfmx.html#http505">505</a></strong></td><td><strong>HTTP Version not supported</strong></td><td><strong>服务器不支持请求的HTTP协议的版本，无法完成处理</strong></td></tr></tbody></table><h3 id="GET请求行和请求头解析："><a href="#GET请求行和请求头解析：" class="headerlink" title="GET请求行和请求头解析："></a>GET请求行和请求头解析：</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230710100130745.png" alt="image-20230710100130745"></p><h3 id="POST请求行和请求头解析："><a href="#POST请求行和请求头解析：" class="headerlink" title="POST请求行和请求头解析："></a>POST请求行和请求头解析：</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230710101351184.png" alt="image-20230710101351184"></p><h3 id="何时使用-get-x2F-post-？"><a href="#何时使用-get-x2F-post-？" class="headerlink" title="何时使用 get &#x2F; post ？"></a>何时使用 get &#x2F; post ？</h3><p>get和post方法功能类似的，使用建议：<br>1、get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式；<br>2、在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；</p><p>区别表现如下：</p><ol><li>get是从服务器上获取数据，post是向服务器传送数据。</li><li>get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。</li><li>对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。</li><li>get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。</li><li>get安全性非常低，post安全性较高。但是执行效率却比Post方法好。</li></ol><p><strong>若符合下列任一情况，则用POST方法：</strong></p><ul><li>请求的结果有持续性的副作用，例如，数据库内添加新的数据行。</li><li>若使用GET方法，则表单上收集的数据可能让URL过长。</li><li>要传送的数据不是采用7位的ASCII编码。</li></ul><p><strong>若符合下列任一情况，则用GET方法：</strong></p><ul><li>请求是为了查找资源，HTML表单数据仅用来帮助搜索。</li><li>请求结果无持续性的副作用。</li><li>收集的数据及HTML表单内的输入字段名称的总长不超过1024个字符。</li></ul><p>原文链接：<a href="https://blog.csdn.net/qq_47443027/article/details/114696716">https://blog.csdn.net/qq_47443027/article/details/114696716</a></p><h3 id="响应体："><a href="#响应体：" class="headerlink" title="响应体："></a>响应体：</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230710211832628.png" alt="image-20230710211832628"></p><h3 id="常见状态码说明："><a href="#常见状态码说明：" class="headerlink" title="常见状态码说明："></a>常见状态码说明：</h3><h4 id="302"><a href="#302" class="headerlink" title="302"></a>302</h4><p>​资源被转移了，返回给你302 还告诉你该去哪里找不见的资源，因此浏览器需要发送两次请求才能访问到原来的资源(只发生一次302的情况)</p><h4 id="304"><a href="#304" class="headerlink" title="304"></a>304</h4><p>(在浏览器允许缓存的情况下)浏览器在请求某资源时，如果有该资源的缓存，就会把该资源的最后修改日期也发给服务器。</p><p>如果最后修改日期 &#x3D; 服务器端该资源的最后修改日期，则服务器告诉浏览器请求的资源未修改过，返回304，不返回资源给浏览器，让浏览器去自己的缓存去找。</p><h4 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h4><h5 id="MIME-介绍："><a href="#MIME-介绍：" class="headerlink" title="MIME 介绍："></a>MIME 介绍：</h5><ol><li><p>MIME 是 HTTP 协议中数据类型。 MIME 的英文全称是”Multipurpose Internet Mail Extensions” 多功能 Internet 邮件扩充服务。 MIME 类型的格式是**”大类型&#x2F;小类型”**，并与某一种文件的扩展名相对应</p></li><li><p>在响应包的Content-Type 就有指定</p></li></ol><h5 id="常见的-MIME-类型："><a href="#常见的-MIME-类型：" class="headerlink" title="常见的 MIME 类型："></a>常见的 MIME 类型：</h5><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711083211146.png" alt="image-20230711083211146" style="zoom: 67%;" /><h2 id="8-9-ServletConfig"><a href="#8-9-ServletConfig" class="headerlink" title="8.9 ServletConfig"></a>8.9 ServletConfig</h2><h3 id="8-9-1-ServletConfig-基本介绍"><a href="#8-9-1-ServletConfig-基本介绍" class="headerlink" title="8.9.1 ServletConfig 基本介绍"></a>8.9.1 ServletConfig 基本介绍</h3><ol><li>ServletConfig 类是为 Servlet 程序的<strong>配置信息的类</strong></li><li>Servlet 程序和 ServletConfig 对象都是由 Tomcat 负责创建</li><li>Servlet 程序默认是第 1 次访问的时候创建， <u>ServletConfig 在 Servlet 程序创建时， 就创建一个对应的 ServletConfig 对象</u>(每个servlet都有一个对应的servletConfig)</li></ol><p>8.9.2 ServletConfig 类能干什么</p><ul><li><p>获取 Servlet 程序的 <strong>servlet-name</strong> 的值</p></li><li><p>获取<strong>初始化参数 init-param</strong></p></li><li><p>获取 <strong>ServletContext 对象</strong></p></li></ul><h3 id="8-9-3-ServletConfig"><a href="#8-9-3-ServletConfig" class="headerlink" title="8.9.3 ServletConfig"></a>8.9.3 ServletConfig</h3><p>应用实例</p><p>● 需求: 编写 DBServlet.java 完成如下功能</p><ol><li><p>在 web.xml 配置连接 mysql 的用户名和密码</p></li><li><p>在 DBServlet 执行 doGet()&#x2F;doPost() 时，可以获取到 web.xml 配置的用户名和密码</p></li><li><p>示意图(思路分析)</p></li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711084923867.png" alt="image-20230711084923867" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;DBServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.study.servlet.DBServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;username&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;donn&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;password&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;<span class="number">123456</span>&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">ServletConfig</span> <span class="variable">servletConfig</span> <span class="operator">=</span> getServletConfig();</span><br><span class="line">    System.out.println(servletConfig.getInitParameter(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">    System.out.println(servletConfig.getInitParameter(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-10-ServletContext"><a href="#8-10-ServletContext" class="headerlink" title="8.10 ServletContext"></a>8.10 ServletContext</h2><p><strong><u><em>——多个Servlet共享的数据空间</em></u></strong></p><h3 id="8-10-1-为什么需要-ServletContext"><a href="#8-10-1-为什么需要-ServletContext" class="headerlink" title="8.10.1 为什么需要 ServletContext"></a>8.10.1 为什么需要 ServletContext</h3><ol><li>先看一个需求： 如果我们希望统计某个 web 应用的所有 Servlet 被访问的次数， 怎么办?</li></ol><p>​方案1-DB:</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711091848410.png" alt="image-20230711091848410" style="zoom:50%;" /><p>​方案2-ServletContext：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711092040710.png" alt="image-20230711092040710"></p><h3 id="8-10-2-ServletContext-基本介绍"><a href="#8-10-2-ServletContext-基本介绍" class="headerlink" title="8.10.2 ServletContext 基本介绍"></a>8.10.2 ServletContext 基本介绍</h3><ol><li><p>ServletContext 是一个接口， 它表示 Servlet 上下文对象</p></li><li><p><strong>一个 web 工程，只有一个 ServletContext 对象实例</strong></p></li><li><p><strong>ServletContext 对象 是在 web 工程启动的时候创建，在 web 工程停止的时销毁</strong>  </p></li><li><p>ServletContext 对象可以通过 <strong>ServletConfig.getServletContext 方法</strong>获得对 ServletContext对象的引用，也可以通过 **this.getServletContext()**来获得其对象的引用。</p></li><li><p>由于一个 WEB 应用中的所有 Servlet 共享同一个 ServletContext 对象，因此 Servlet 对象之间可以通过 ServletContext 对象来实现多个 Servlet 间通讯。<strong>ServletContext 对象通常也被称之为域对象</strong>。【示意图】</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711092825430.png" alt="image-20230711092825430"></p><h3 id="8-10-3-ServletContext-可以做什么"><a href="#8-10-3-ServletContext-可以做什么" class="headerlink" title="8.10.3 ServletContext 可以做什么"></a>8.10.3 ServletContext 可以做什么</h3><ol><li><p>获取 web.xml 中配置的上下文参数 context-param [信息和整个 web 应用相关， 而不是属于某个 Servlet]</p></li><li><p><strong>获取当前的工程路径</strong>，格式: &#x2F;工程路径 &#x3D;&#x3D;&gt; 比如 &#x2F;servlet.          <strong>其实就是&#x2F;工程名</strong></p></li><li><p>获取<strong>工程部署后在服务器硬盘上的绝对路径</strong>( 比 如 :D:\hspedu_javaweb\servlet\out\artifacts\servlet_war_exploded)</p></li><li><p>像 Map 一样存取数据, 多个 Servlet 共享数据</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711093633773.png" alt="image-20230711093633773"></p><p>8.10.4 应用实例 </p><p>1-获取工程相关信息</p><p>● 需求如下：</p><ol><li>获取 web.xml 中配置的上下文参数 context-param</li><li>获取当前的工程路径， 格式: &#x2F;工程路径</li><li>获取工程部署后在服务器硬盘上的绝对路径</li></ol><p>● 代码实现 - 具体看 项目中的代码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">ServletConfig</span> <span class="variable">servletConfig</span> <span class="operator">=</span> getServletConfig();</span><br><span class="line">    System.out.println(servletConfig.getInitParameter(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">    System.out.println(servletConfig.getInitParameter(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;公共数据：&quot;</span> + servletConfig.getServletContext().getInitParameter(<span class="string">&quot;website&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;工程路径&quot;</span> + servletConfig.getServletContext().getContextPath());</span><br><span class="line">  <span class="comment">// “/”表示项目发布后的根目录(out目录中)</span></span><br><span class="line">    System.out.println(<span class="string">&quot;绝对路径&quot;</span> + servletConfig.getServletContext().getRealPath(<span class="string">&quot;/&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-10-5-应用实例-2-简单的网站访问次数计数器"><a href="#8-10-5-应用实例-2-简单的网站访问次数计数器" class="headerlink" title="8.10.5 应用实例 2-简单的网站访问次数计数器"></a>8.10.5 应用实例 2-简单的网站访问次数计数器</h3><p>……</p><h2 id="8-11-HttpServletRequest"><a href="#8-11-HttpServletRequest" class="headerlink" title="8.11 HttpServletRequest"></a>8.11 HttpServletRequest</h2><h3 id="8-11-1-HttpServletRequest-介绍"><a href="#8-11-1-HttpServletRequest-介绍" class="headerlink" title="8.11.1 HttpServletRequest 介绍"></a>8.11.1 HttpServletRequest 介绍</h3><p><strong><u>——http请求中的信息都被封装在HttpServletRequest中</u></strong></p><ol><li>HttpServletRequest 对象代表客户端的请求</li><li>当客户端&#x2F;浏览器通过 HTTP 协议访问服务器时，<strong>HTTP 请求头中的所有信息都封装在这个对象中</strong></li><li>通过这个对象的方法，可以获得客户端这些信息。</li></ol><h3 id="8-11-2-HttpServletRequest-类图"><a href="#8-11-2-HttpServletRequest-类图" class="headerlink" title="8.11.2 HttpServletRequest 类图"></a>8.11.2 HttpServletRequest 类图</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711102743263.png" alt="image-20230711102743263"></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711102808631.png" alt="image-20230711102808631" style="zoom:50%;" /><h3 id="8-11-3-HttpServletRequest-常用方法"><a href="#8-11-3-HttpServletRequest-常用方法" class="headerlink" title="8.11.3 HttpServletRequest 常用方法"></a>8.11.3 HttpServletRequest 常用方法</h3><ol><li><p>getRequestURI() 获取请求的<strong>资源路径</strong></p><p>即  <a href="http://localhost:8080/servlet/loginServlet%E4%B8%AD%E7%9A%84%E3%80%8Cservlet/loginServlet%E3%80%8D">http://localhost:8080/servlet/loginServlet中的「servlet/loginServlet」</a></p></li><li><p>getRequestURL() 获取请求的统一资源定位符 （ 绝 对 路 径 ）<a href="http://localhost:8080/servlet/loginServlet">http://localhost:8080/servlet/loginServlet</a></p></li><li><p>getRemoteHost() 获取客户端的主机, getRemoteAddr()</p></li><li><p>getHeader() 获取请求头                <strong>request.getHeader(“Cookie(例)”) 可以获取http请求头中的任意信息</strong></p></li><li><p>getParameter() 获取请求的参数</p></li><li><p>getParameterValues() 获取请求的参数（多个值的时候使用） , 比如 checkbox, 返回的数组</p><p><strong>可以获取前端表单传来的数据，根据键(前端标签中的name属性)获取值</strong></p></li><li><p>getMethod() 获取请求的方式 GET 或 POST</p></li><li><p>setAttribute(key, value); <strong>设置域数据</strong></p></li><li><p>getAttribute(key); <strong>获取域数据</strong></p></li><li><p>🌟getRequestDispatcher() <u><strong>获取请求转发对象, 请求转发的核心对象</strong></u></p></li></ol><h3 id="8-11-4-HttpServletRequest-应用实例"><a href="#8-11-4-HttpServletRequest-应用实例" class="headerlink" title="8.11.4 HttpServletRequest 应用实例"></a>8.11.4 HttpServletRequest 应用实例</h3><p>……</p><h3 id="8-11-5-HttpServletRequest-注意事项和细节"><a href="#8-11-5-HttpServletRequest-注意事项和细节" class="headerlink" title="8.11.5 HttpServletRequest 注意事项和细节"></a>8.11.5 HttpServletRequest 注意事项和细节</h3><ol><li>获 取 doPost 参数中文乱码解决方案 , 注 意 setCharacterEncoding(“utf-8”) 要 写 在request.getParameter()前(在接受参数前设置字体 )。</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711110015613.png" alt="image-20230711110015613" style="zoom:50%;" /><ol start="2"><li>注意：如果通过 PrintWriter writer, 有返回数据给浏览器，建议将<strong>获取参数代码写在writer.print() 之前</strong>，否则可能获取不到参数值(doPost)</li><li>处理 http <strong>响应数据中文乱码</strong>问题 (改变编码为utf-8)</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711110448507.png" alt="image-20230711110448507" style="zoom:50%;" /><ol start="4"><li>再次理解 Http 协议响应 Content-Type 的含义, 比如 text&#x2F;plain(以文本方式解析)    application&#x2F;x-tar(表示返回的是文件，浏览器会以下载文件的方式处理)</li></ol><h3 id="8-11-7-请求转发"><a href="#8-11-7-请求转发" class="headerlink" title="8.11.7 请求转发"></a>8.11.7 请求转发</h3><h4 id="8-11-7-1-为什么需要请求转发"><a href="#8-11-7-1-为什么需要请求转发" class="headerlink" title="8.11.7.1 为什么需要请求转发"></a>8.11.7.1 为什么需要请求转发</h4><ol><li>目前我们学习的都是一次请求， 对应一个 Servlet， 如图</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711111006356.png" alt="image-20230711111006356" style="zoom: 50%;" /><ol start="2"><li>但是在实际开发中，往往业务比较复杂，需要在一次请求中，<strong>使用到多个 Servlet 完成一个任务(Servlet 链, 流水作业)</strong> 如图:</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711111046853.png" alt="image-20230711111046853"></p><h4 id="8-11-7-2-请求转发说明"><a href="#8-11-7-2-请求转发说明" class="headerlink" title="8.11.7.2 请求转发说明"></a>8.11.7.2 请求转发说明</h4><ol><li><p>实现请求转发： 请求转发指一个 web 资源收到客户端请求后， 通知服务器去调用另外一个 web 资源进行处理</p></li><li><p>HttpServletRequest 对象(也叫 Request 对象)提供了一个 getRequestDispatcher 方法，该方法返回一个 RequestDispatcher 对象，<strong>调用这个对象的 forward 方法可以实现请求转发</strong></p></li><li><p>request 对象同时也是一个域对象，开发人员通过 request 对象在实现转发时，把数据通过 request 对象带给其它 web 资源处理</p><ul><li><p>setAttribute方法</p></li><li><p>getAttribute方法</p></li><li><p>removeAttribute方法</p></li><li><p>getAttributeNames方法</p></li></ul></li></ol><h4 id="8-11-7-3-实现请求转发"><a href="#8-11-7-3-实现请求转发" class="headerlink" title="8.11.7.3 实现请求转发"></a>8.11.7.3 实现请求转发</h4><p>请求转发原理示意图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711134908152.png" alt="image-20230711134908152"></p><h4 id="8-11-7-4-请求转发应用实例"><a href="#8-11-7-4-请求转发应用实例" class="headerlink" title="8.11.7.4 请求转发应用实例"></a>8.11.7.4 请求转发应用实例</h4><p>……</p><p>请求转发中，各个servlet可以共享request域对象的原因：</p><p>​因为请求转发的方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  “/manageServlet”为发送的对象(转发给谁)</span></span><br><span class="line"><span class="comment">//其中:“/” 会被解析成“/项目名” (前面一定是表示该服务器的http://工程名：端口)</span></span><br><span class="line"><span class="comment">//manageServlet为资源名</span></span><br><span class="line"><span class="comment">//🌟因此，请求转发是不能转发到外网的(只能在服务器主机内部进行转发)</span></span><br><span class="line"><span class="type">RequestDispatcher</span> <span class="variable">requestDispatcher</span> <span class="operator">=</span> request.getRequestDispatcher(<span class="string">&quot;/manageServlet&quot;</span>);</span><br><span class="line"><span class="comment">//而此处的request将被传给下一个servlet，所以可以共享request对象中的数据！！！！</span></span><br><span class="line">requestDispatcher.forward(request, response);</span><br></pre></td></tr></table></figure><h4 id="8-11-7-5-请求转发注意事项和细节"><a href="#8-11-7-5-请求转发注意事项和细节" class="headerlink" title="8.11.7.5 请求转发注意事项和细节"></a>8.11.7.5 请求转发注意事项和细节</h4><ol><li><p>🌟<strong>浏览器地址不会变化(地址会保留在第 1 个 servlet 的 url)</strong></p></li><li><p>在同一次 HTTP 请求中，进行多次转发，仍然是一次 HTTP 请求</p></li><li><p>在同一次 HTTP 请求中，进行多次转发，多个 Servlet 可以共享 request 域&#x2F;对象的数据(因为始终是同一个 request 对象)</p></li><li><p>可以转发到 WEB-INF 目录下(后面做项目使用)</p></li><li><p><strong>不能访问当前 WEB 工程外的资源</strong></p></li><li><p><u>因为浏览器地址栏会停止在第一个 servlet ,如果你刷新页面，会再次发出请求(并且会带数据), 所以在支付页面情况下，不要使用请求转发，否则会造成重复支付</u></p></li></ol><h3 id="8-11-8-课后作业"><a href="#8-11-8-课后作业" class="headerlink" title="8.11.8 课后作业"></a>8.11.8 课后作业</h3><p>……</p><h2 id="8-12-HttpServletResponse"><a href="#8-12-HttpServletResponse" class="headerlink" title="8.12 HttpServletResponse"></a>8.12 HttpServletResponse</h2><h3 id="8-12-1-HttpServletResponse-介绍"><a href="#8-12-1-HttpServletResponse-介绍" class="headerlink" title="8.12.1 HttpServletResponse 介绍"></a>8.12.1 HttpServletResponse 介绍</h3><ol><li><p>每次 HTTP 请求， Tomcat 会创建一个 HttpServletResponse 对象传递给 Servlet 程序去使用。</p></li><li><p><strong>HttpServletRequest 表示请求过来的信息</strong>，<strong>HttpServletResponse 表示所有<u>响应</u>的信息</strong>，如果<u>需要设置返回给客户端的信息</u>，通过 HttpServletResponse 对象来进行设置即可</p></li></ol><h3 id="8-12-2-HttpServletResponse-类图"><a href="#8-12-2-HttpServletResponse-类图" class="headerlink" title="8.12.2 HttpServletResponse 类图"></a>8.12.2 HttpServletResponse 类图</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711152642270.png" alt="image-20230711152642270"></p><h3 id="8-12-3-向客户端返回数据方法"><a href="#8-12-3-向客户端返回数据方法" class="headerlink" title="8.12.3 向客户端返回数据方法"></a>8.12.3 向客户端返回数据方法</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711152728428.png" alt="image-20230711152728428"></p><ol><li>字节流 getOutputStream(); <strong>常用于下载</strong>（处理二进制数据）</li><li>字符流 getWriter(); 常用于<strong>回传</strong>字符串</li><li>(细节：)两个流<strong>同时只能使用一个</strong>。 使用了字节流，就不能再使用字符流，反之亦然，否则就会报错</li></ol><h3 id="8-12-4-向客户端返回数据应用实例"><a href="#8-12-4-向客户端返回数据应用实例" class="headerlink" title="8.12.4 向客户端返回数据应用实例"></a>8.12.4 向客户端返回数据应用实例</h3><ol><li>需求： 浏览器请求 , 返回 hello, world</li></ol><p>……</p><h3 id="8-12-5-向客户端返回数据注意事项和细节"><a href="#8-12-5-向客户端返回数据注意事项和细节" class="headerlink" title="8.12.5 向客户端返回数据注意事项和细节"></a>8.12.5 向客户端返回数据注意事项和细节</h3><ol><li>处理中文乱码问题-方案 1</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711153139236.png" alt="image-20230711153139236" style="zoom:50%;" /><ol start="2"><li>处理中文乱码问题-方案 2(常用，方便)</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711153202800.png" alt="image-20230711153202800" style="zoom:50%;" /><h3 id="8-12-6-请求重定向"><a href="#8-12-6-请求重定向" class="headerlink" title="8.12.6 请求重定向"></a>8.12.6 请求重定向</h3><h4 id="8-12-6-1-请求重定向介绍"><a href="#8-12-6-1-请求重定向介绍" class="headerlink" title="8.12.6.1 请求重定向介绍"></a>8.12.6.1 请求重定向介绍</h4><ol><li><p>请求重定向指： 一个 web 资源收到客户端请求后， <u><strong>通知客户端去访问另外一个 web资源</strong></u>， 这称之为请求重定向</p></li><li><p>请求重定向原理示意图</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230711153900776.png" alt="image-20230711153900776"></p><h4 id="8-12-6-2-请求重定向应用实例"><a href="#8-12-6-2-请求重定向应用实例" class="headerlink" title="8.12.6.2 请求重定向应用实例"></a>8.12.6.2 请求重定向应用实例</h4><ol><li>需 求 ： 演示请求重定向的使用当访问 DownServlet 下 载 文 件 ， 重定向到DownServletNew 下载文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. sendRedirect 本质就会 返回 302 状态码 Location: /servlet/downservletNew</span></span><br><span class="line"><span class="comment">//2．因此 302和/servlet/downservletNew 是浏览器解析，而不是服务器</span></span><br><span class="line"><span class="comment">//3．浏览器在解析 /servlet/downservletnew =&gt; http://localhost:8080/downServletNew</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1:</span></span><br><span class="line">response.sendRedirect(<span class="string">&quot;/servlet/downServletNew&quot;</span>);</span><br><span class="line"><span class="comment">//方法2:</span></span><br><span class="line">response.setStatus(<span class="number">302</span>);</span><br><span class="line">response.setHeader(<span class="string">&quot;Location&quot;</span>,<span class="string">&quot;/servlet/downServletNew&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="8-12-6-3-请求重定向注意事项和细节"><a href="#8-12-6-3-请求重定向注意事项和细节" class="headerlink" title="8.12.6.3 请求重定向注意事项和细节"></a>8.12.6.3 请求重定向注意事项和细节</h4><ol><li><p>最佳应用场景：网站迁移， 比如原域名是 <a href="http://www.hsp.com/">www.hsp.com</a> 迁移到 <a href="http://www.hsp.cn/">www.hsp.cn</a> ， 但是百度抓取的还是原来网址.</p></li><li><p>浏览器地址会发生变化，本质是两次 http 请求.</p></li><li><p><strong>不能共享 Request 域中的数据，本质是两次 http 请求，会生成两个 HttpServletRequest对象</strong></p></li><li><p><u>不能重定向到 &#x2F;WEB-INF 下的资源</u></p></li><li><p>可以重定向到 Web 工程以外的资源， 比如 到 <a href="http://www.baidu.com/">www.baidu.com</a> </p></li><li><p>重定向有两种方式, <strong>推荐使用第 1 种.</strong></p></li><li><p>动态获取到 application context(这个是指该项目在tomcat上运行时的项目名称，重定向时每次都需要填上，因此在修改时会比较麻烦，我们可以采取动态获取的方式简化它</p><p>使用方法：getServletContext().getContextPath()获取即可)</p></li></ol><h3 id="8-12-7-课后作业"><a href="#8-12-7-课后作业" class="headerlink" title="8.12.7 课后作业"></a>8.12.7 课后作业</h3><ol><li><p>编写一个 MyPayServlet , 能够接收到提交的数据</p></li><li><p>编写一个简单的支付页面 pay.html(如图)</p></li><li><p>如果支付金额大于 100, 则重定向到 payok.html, 否则重定向到原来的 pay.html</p></li></ol><p>​……</p><h1 id="10-手动实现-Tomcat-底层机制-自己设计-Servlet"><a href="#10-手动实现-Tomcat-底层机制-自己设计-Servlet" class="headerlink" title="10 手动实现 Tomcat 底层机制+ 自己设计 Servlet"></a>10 手动实现 Tomcat 底层机制+ 自己设计 Servlet</h1><h2 id="10-1-先看一个小案例，-引出对-Tomcat-底层实现思考"><a href="#10-1-先看一个小案例，-引出对-Tomcat-底层实现思考" class="headerlink" title="10.1 先看一个小案例， 引出对 Tomcat 底层实现思考"></a>10.1 先看一个小案例， 引出对 Tomcat 底层实现思考</h2><h3 id="10-1-1-完成小案例"><a href="#10-1-1-完成小案例" class="headerlink" title="10.1.1 完成小案例"></a>10.1.1 完成小案例</h3><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230712184414696.png" alt="image-20230712184414696" style="zoom:50%;" /><ol start="0"><li>我们准备使用 Maven 来创建一个 WEB 项目, 老师先简单给小伙伴介绍一下 Maven 是什么, 更加详细的使用，我们还会细讲, 现在先使用一把</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230712184444044.png" alt="image-20230712184444044" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230712184525975.png" alt="image-20230712184525975" style="zoom:67%;" /><ol><li>先创建一个 Maven 的 Web 项目 hsp-tomcat</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230712185354190.png" alt="image-20230712185354190" style="zoom:50%;" /><ul><li>配置阿里 maven 镜像</li></ul><p>​在maven的settings.xml文件中修改mirror标签中的内容即可</p><ol start="2"><li>修改 D:\java_projects2\hsp\pom.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.donn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mytomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>mytomcat Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--1.引入javax.servlet-api.jar，为了开发servlet</span></span><br><span class="line"><span class="comment">          2.&lt;dependency&gt;标签表示引入一个包</span></span><br><span class="line"><span class="comment">          3.groudId：包的公司信息：javax.servlet</span></span><br><span class="line"><span class="comment">          4.artifactId：项目名：javax.servlet-api</span></span><br><span class="line"><span class="comment">            groupId+artifactId 将以目录形式体现(在仓库中组成jar包路径</span></span><br><span class="line"><span class="comment">          5.version：版本信息</span></span><br><span class="line"><span class="comment">          6.scope：表示引入包的作用范围</span></span><br><span class="line"><span class="comment">            在什么地方、在什么阶段生效</span></span><br><span class="line"><span class="comment">            &lt;scope&gt;provided&lt;/scope&gt; 表示tomcat本身有jar包，</span></span><br><span class="line"><span class="comment">            在编译、测试时有效，但是打包发布后不要带上这个包</span></span><br><span class="line"><span class="comment">            (意思就是打包时，项目会有自带的该jar包，</span></span><br><span class="line"><span class="comment">            但是编译、测试时没有，provided指只在编译测试时添加该jar包)</span></span><br><span class="line"><span class="comment">          7.下载的包在指定的本地仓库</span></span><br><span class="line"><span class="comment">          --&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>mytomcat<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>创建 D:\java_projects2\hsp\src\main\webapp\cal.html</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>计算器<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>计算器<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/calServlet&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    num1:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;num1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    num2:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;num2&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li><p>创建 java 目录，存放 java 源文件.</p></li><li><p>创建 CalServlet.java</p></li><li><p>修改 web.xml , 配置 Servlet</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">web-app</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>CalServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.donn.servlet.CalServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>CalServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/calServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="7"><li>修改CalServlet.java, 完成计算任务</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.donn.servlet; <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/7/12</span></span><br><span class="line"><span class="comment"> * 22:27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.donn.utils.WebUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doPost(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//接受提交的数据进行计算</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">num1</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;num1&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">num2</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;num2&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> WebUtils.parseInt(num1, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> WebUtils.parseInt(num2, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> i1 + i2;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        writer.print(<span class="string">&quot;&lt;h1&gt;&quot;</span> + i1 + <span class="string">&quot;+&quot;</span> + i2 + <span class="string">&quot;=&quot;</span> + res + <span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>创 建 工 具 类\utils\WebUtils.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.donn.utils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/7/12</span></span><br><span class="line"><span class="comment"> * 22:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个字符串数字，转成 int, 如果转换失败，就返回传入 defaultVal</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strNum</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> defaultVal</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">parseInt</span><span class="params">(String strNum, <span class="type">int</span> defaultVal)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(strNum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            System.out.println(strNum + <span class="string">&quot; 格式不对，转换失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> defaultVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-1-3-完成测试"><a href="#10-1-3-完成测试" class="headerlink" title="10.1.3 完成测试"></a>10.1.3 完成测试</h3><h4 id="10-1-3-1-配置-tomcat"><a href="#10-1-3-1-配置-tomcat" class="headerlink" title="10.1.3.1 配置 tomcat"></a>10.1.3.1 配置 tomcat</h4><h4 id="10-1-3-2-启动-tomcat"><a href="#10-1-3-2-启动-tomcat" class="headerlink" title="10.1.3.2 启动 tomcat"></a>10.1.3.2 启动 tomcat</h4><h4 id="10-1-3-3-浏览器访问-http-localhost-8080-cal-html"><a href="#10-1-3-3-浏览器访问-http-localhost-8080-cal-html" class="headerlink" title="10.1.3.3 浏览器访问: http://localhost:8080/cal.html"></a>10.1.3.3 浏览器访问: <a href="http://localhost:8080/cal.html">http://localhost:8080/cal.html</a></h4><h3 id="10-1-4-思考问题-Tomcat-底层实现-和-调用到-Servlet-流程"><a href="#10-1-4-思考问题-Tomcat-底层实现-和-调用到-Servlet-流程" class="headerlink" title="10.1.4 思考问题: Tomcat 底层实现 和 调用到 Servlet 流程?"></a>10.1.4 思考问题: Tomcat 底层实现 和 调用到 Servlet 流程?</h3><h3 id="10-1-5-我们的目标"><a href="#10-1-5-我们的目标" class="headerlink" title="10.1.5 我们的目标:"></a>10.1.5 我们的目标:</h3><p><u><strong>不用 Tomcat, 不用系统提供的 Servlet, 模拟 Tomcat 底层实现并能调用我们自己设计的 Servle, 也能完成相同的功能</strong></u></p><h2 id="10-2-🌟Tomcat-整体架构分析"><a href="#10-2-🌟Tomcat-整体架构分析" class="headerlink" title="10.2 🌟Tomcat 整体架构分析"></a>10.2 🌟Tomcat 整体架构分析</h2><h3 id="10-2-1-一图胜千言"><a href="#10-2-1-一图胜千言" class="headerlink" title="10.2.1 一图胜千言"></a>10.2.1 一图胜千言</h3><p>● 说明: Tomcat 有三种运行模式（BIO, NIO, APR） , 因为老师核心讲解的是 <strong>Tomcat 如何接收客户端请求， 解析请求, 调用 Servlet ,</strong> 并返回结果的机制流程, 采用 BIO 线程模型来模拟.[绘图]</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230713085315598.png" alt="image-20230713085315598"></p><h2 id="10-4-手动实现-Tomcat-底层机制-自己设计-Servlet"><a href="#10-4-手动实现-Tomcat-底层机制-自己设计-Servlet" class="headerlink" title="10.4 手动实现 Tomcat 底层机制+ 自己设计 Servlet"></a>10.4 手动实现 Tomcat 底层机制+ 自己设计 Servlet</h2><h3 id="10-4-1-实现任务阶段-1-编写自己-Tomcat-能给浏览器返回-Hi-Hspedu"><a href="#10-4-1-实现任务阶段-1-编写自己-Tomcat-能给浏览器返回-Hi-Hspedu" class="headerlink" title="10.4.1 实现任务阶段 1- 编写自己 Tomcat, 能给浏览器返回 Hi, Hspedu"></a>10.4.1 实现任务阶段 1- 编写自己 Tomcat, 能给浏览器返回 Hi, Hspedu</h3><h4 id="10-4-1-1-基于-socket-开发服务端-流程"><a href="#10-4-1-1-基于-socket-开发服务端-流程" class="headerlink" title="10.4.1.1 基于 socket 开发服务端-流程"></a>10.4.1.1 基于 socket 开发服务端-流程</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230713090001942.png" alt="image-20230713090001942" style="zoom:50%;" /><h4 id="10-4-1-2-需求分析"><a href="#10-4-1-2-需求分析" class="headerlink" title="10.4.1.2 需求分析"></a>10.4.1.2 需求分析</h4><ol><li>需求分析如图, 浏览器请求 <a href="http://localhost:8080/">http://localhost:8080/</a>??, 服务端返回 hi , donn</li></ol><h4 id="10-4-1-3-分析-代码实现"><a href="#10-4-1-3-分析-代码实现" class="headerlink" title="10.4.1.3 分析+代码实现"></a>10.4.1.3 分析+代码实现</h4><h4 id="●-分析示意图"><a href="#●-分析示意图" class="headerlink" title="● 分析示意图"></a>● 分析示意图</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230713093415805.png" alt="image-20230713093415805" style="zoom:50%;" /><p>● 代码实现</p><ol><li>创 建DonnTomcatV1.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.donn.tomcat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/7/13</span></span><br><span class="line"><span class="comment"> * 09:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 接受客户端请求，并返回相关信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DonnTomcatV1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8081</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;mytomcat在8081端口监听&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!serverSocket.isClosed())&#123;</span><br><span class="line">            <span class="comment">//等待浏览器的连接</span></span><br><span class="line">            <span class="comment">//如果有连接来，就创建一个socket</span></span><br><span class="line">            <span class="comment">//这个socket就是服务器和浏览器连接的通道</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="comment">//先接受浏览器发送的数据</span></span><br><span class="line">            <span class="comment">//inputStream是字节流 =BufferedReader为字符流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            <span class="type">String</span> <span class="variable">mes</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//循环地读取</span></span><br><span class="line">            System.out.println(<span class="string">&quot;接受到浏览器发送的数据&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (((mes = bufferedReader.readLine()) != <span class="literal">null</span>))&#123;</span><br><span class="line">                <span class="comment">//判断mes的长度是否为0</span></span><br><span class="line">                <span class="keyword">if</span>(mes.length() == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(mes);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//tomcat回送httpResponse</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="comment">//构建一个 http 响应的头</span></span><br><span class="line">            <span class="comment">// \r\n 表示换行</span></span><br><span class="line">            <span class="comment">// http 响应体，需要前面有两个换行 \r\n\r\n</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">respHeader</span> <span class="operator">=</span> <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;Content-Type: text/html;charset=utf-8\r\n\r\n&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">resp</span> <span class="operator">=</span> respHeader + <span class="string">&quot;hi, donn&quot;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;========我们的 tomcat 给浏览器会送的数据======&quot;</span>);</span><br><span class="line">            System.out.println(resp);</span><br><span class="line">            outputStream.write(resp.getBytes());</span><br><span class="line">            <span class="comment">//将 resp 字符串以 byte[] 方式返回</span></span><br><span class="line">            outputStream.flush();</span><br><span class="line">            outputStream.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-4-1-4-测试-浏览器-：-http-localhost-8081"><a href="#10-4-1-4-测试-浏览器-：-http-localhost-8081" class="headerlink" title="10.4.1.4 测试 浏览器 ： http://localhost:8081/"></a>10.4.1.4 测试 浏览器 ： <a href="http://localhost:8081/">http://localhost:8081/</a></h4><h4 id="10-4-1-5-问题分析：-没有使用-BIO-线程模型，-没有实现多线程，-性能差"><a href="#10-4-1-5-问题分析：-没有使用-BIO-线程模型，-没有实现多线程，-性能差" class="headerlink" title="10.4.1.5 问题分析： 没有使用 BIO 线程模型， 没有实现多线程， 性能差"></a>10.4.1.5 问题分析： 没有使用 BIO 线程模型， 没有实现多线程， 性能差</h4><h3 id="10-4-2-实现任务阶段-2-使用-BIO-线程模型，-支持多线程"><a href="#10-4-2-实现任务阶段-2-使用-BIO-线程模型，-支持多线程" class="headerlink" title="10.4.2 实现任务阶段 2__ 使用 BIO 线程模型， 支持多线程"></a>10.4.2 实现任务阶段 2__ 使用 BIO 线程模型， 支持多线程</h3><h4 id="10-4-2-1-BIO-线程模型介绍"><a href="#10-4-2-1-BIO-线程模型介绍" class="headerlink" title="10.4.2.1 BIO 线程模型介绍"></a>10.4.2.1 BIO 线程模型介绍</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230713093624025.png" alt="image-20230713093624025"></p><h4 id="10-4-2-2-需求分析-x2F-图解"><a href="#10-4-2-2-需求分析-x2F-图解" class="headerlink" title="10.4.2.2 需求分析&#x2F;图解"></a>10.4.2.2 需求分析&#x2F;图解</h4><ol><li>需求分析如图, 浏览器请求 <a href="http://localhost:8081/">http://localhost:8081</a>, 服务端返回 hi , donn, 后台donntomcat 使用 BIO 线程模型,支持多线程&#x3D;&gt; 对前面的开发模式进行改造</li></ol><h4 id="10-4-2-3-分析-代码实现"><a href="#10-4-2-3-分析-代码实现" class="headerlink" title="10.4.2.3 分析+代码实现"></a>10.4.2.3 分析+代码实现</h4><p>示意图：</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230713100725181.png" alt="image-20230713100725181" style="zoom:50%;" /><p>创建线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.donn.tomcat.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/7/13</span></span><br><span class="line"><span class="comment"> * 09:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * DonnRequestHandler对象是一个线程对象</span></span><br><span class="line"><span class="comment"> * 处理一个http请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DonnRequestHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DonnRequestHandler</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//在这里，我们对客户端进行交互</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="comment">//转换成字符流,方便按行读取</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;==donnTomcatV2接收到的数据如下==&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">mes</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//输出消息</span></span><br><span class="line">            <span class="keyword">while</span> (((mes = bufferedReader.readLine()) != <span class="literal">null</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(mes.length() == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(mes);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//构建http响应头</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">respHeader</span> <span class="operator">=</span> <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;Content-Type: text/html;charset=utf-8\r\n\r\n&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">resp</span> <span class="operator">=</span> respHeader + <span class="string">&quot;&lt;h1&gt;bye～ donn&lt;/h1&gt;&quot;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;V2返回的数据&quot;</span>);</span><br><span class="line">            <span class="comment">//返回数据给我们的浏览器 -&gt; 封装成http响应</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            outputStream.write(resp.getBytes());</span><br><span class="line">            outputStream.flush();</span><br><span class="line">            outputStream.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.donn.tomcat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.donn.tomcat.handler.DonnRequestHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/7/13</span></span><br><span class="line"><span class="comment"> * 09:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DonnTomcatV2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8081</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;myTomcatV2在8081端口监听&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!serverSocket.isClosed())&#123;</span><br><span class="line">            <span class="comment">//等待浏览器的连接</span></span><br><span class="line">            <span class="comment">//如果有连接来，就创建一个socket</span></span><br><span class="line">            <span class="comment">//这个socket就是服务器和浏览器连接的通道</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DonnRequestHandler</span>(socket)).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-4-2-5-问题分析：-HspTomcat-只是简单返回结果，-没有和-Servlet、-web-xml-关联"><a href="#10-4-2-5-问题分析：-HspTomcat-只是简单返回结果，-没有和-Servlet、-web-xml-关联" class="headerlink" title="10.4.2.5 问题分析： HspTomcat 只是简单返回结果， 没有和 Servlet、 web.xml 关联"></a>10.4.2.5 问题分析： HspTomcat 只是简单返回结果， 没有和 Servlet、 web.xml 关联</h4><h3 id="10-4-3-实现任务阶段-3-处理-Servlet"><a href="#10-4-3-实现任务阶段-3-处理-Servlet" class="headerlink" title="10.4.3 实现任务阶段 3- 处理 Servlet"></a>10.4.3 实现任务阶段 3- 处理 Servlet</h3><h4 id="10-4-3-1-Servlet-生命周期-回顾"><a href="#10-4-3-1-Servlet-生命周期-回顾" class="headerlink" title="10.4.3.1 Servlet 生命周期-回顾"></a>10.4.3.1 Servlet 生命周期-回顾</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230713101011930.png" alt="image-20230713101011930" style="zoom:50%;" /><h4 id="10-4-3-2-需求分析-x2F-图解"><a href="#10-4-3-2-需求分析-x2F-图解" class="headerlink" title="10.4.3.2 需求分析&#x2F;图解"></a>10.4.3.2 需求分析&#x2F;图解</h4><p>● 需求分析如图, 浏览器请求 <a href="http://localhost:8080/hspCalServlet">http://localhost:8080/hspCalServlet</a>, 提交数据， 完成计算任务， 如果 servlet 不存在， 返回 404</p><h4 id="10-4-3-3-分析-代码实现"><a href="#10-4-3-3-分析-代码实现" class="headerlink" title="10.4.3.3 分析+代码实现"></a>10.4.3.3 分析+代码实现</h4><p>● 分析示意图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230713101359727.png" alt="image-20230713101359727"></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230713101431086.png" alt="image-20230713101431086" style="zoom:50%;" /><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.donn.tomcat.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/7/13</span></span><br><span class="line"><span class="comment"> * 10:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 1. DonnRequest的作用是封装http请求的数据</span></span><br><span class="line"><span class="comment"> * 2. 比如method(GET)、uri(资源名)、参数列表(num1=10&amp;num2=30)</span></span><br><span class="line"><span class="comment"> * 3. DonnRequest的作用等价原生servlet中的HttpServletRequest</span></span><br><span class="line"><span class="comment"> * 4. 这里先只考虑get请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DonnRequest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这三个参数都存在于http请求中的第一行中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line">    <span class="keyword">private</span> String uri;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放参数列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String,String&gt; parametersMapping = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getParameter</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(parametersMapping.containsKey(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> parametersMapping.get(name);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     * inputStream与http请求的socket关联</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DonnRequest</span><span class="params">(InputStream inputStream)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            <span class="comment">//读取第一行</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">readLine</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">            method = readLine.split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> readLine.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>].indexOf(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (index == -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//说明没有参数列表</span></span><br><span class="line">                uri = readLine.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                uri = readLine.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>].substring(<span class="number">0</span>,index);</span><br><span class="line">                <span class="comment">//获取参数列表</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">parameters</span> <span class="operator">=</span> readLine.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>].substring(index + <span class="number">1</span>);</span><br><span class="line">                String[] parametersPair = parameters.split(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(parametersPair != <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (String parameter :parametersPair) &#123;</span><br><span class="line">                        String[] split = parameter.split(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span>(split.length == <span class="number">2</span>)&#123;</span><br><span class="line">                            parametersMapping.put(split[<span class="number">0</span>],split[<span class="number">1</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里不能关闭，inputStream和socket关联</span></span><br><span class="line"><span class="comment">//            inputStream.close();</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回顾-Tomcat-工作架构图"><a href="#回顾-Tomcat-工作架构图" class="headerlink" title="回顾 Tomcat 工作架构图"></a>回顾 Tomcat 工作架构图</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230713101359727.png" alt="image-20230713101359727"></p><h1 id="11-WEB-工程路径专题"><a href="#11-WEB-工程路径专题" class="headerlink" title="11 WEB 工程路径专题"></a>11 WEB 工程路径专题</h1><h2 id="11-3-WEB-工程路径注意事项和细节"><a href="#11-3-WEB-工程路径注意事项和细节" class="headerlink" title="11.3 WEB 工程路径注意事项和细节"></a>11.3 WEB 工程路径注意事项和细节</h2><h3 id="11-3-1-注意事项和细节说明"><a href="#11-3-1-注意事项和细节说明" class="headerlink" title="11.3.1 注意事项和细节说明"></a>11.3.1 注意事项和细节说明</h3><ol><li>Web 工程的相对路径和绝对路径：</li></ol><p>相对路径：</p><p>● .表示当前目录</p><p>● ..表示上一级目录</p><p>● 资源名 表示当前目录的资源名</p><p>绝对路径： <a href="http://ip:port/工程路径/资源路径">http://ip:port/工程路径/资源路径</a></p><ol start="2"><li><p>在实际开发中， 路径都使用绝对路径， 而不是相对路径</p></li><li><p>在 web 中 &#x2F; 斜杠 如果被浏览器解析， 得到的地址是： <strong><a href="http://ip[域名]:port/">http://ip[域名]:port/</a></strong></p><p>比如:  &lt;ahref&#x3D;”&#x2F;“&gt;斜杠</a></p></li><li><p>在 web 中 &#x2F; 斜杠如果被服务器解析，得到的地址是: **<a href="http://ip[域名]:port/工程路径/**，你也可以理解成">http://ip[域名]:port/工程路径/**，你也可以理解成</a> &#x2F;工程路径&#x2F; </p><p>下面的几种情况就是如此:</p></li></ol><p>​● <url-pattern>&#x2F;servelturl</url-pattern></p><p>​● servletContext.getRealPath(“&#x2F;“); &#x3D;&#x3D;&gt; 是得到执行路径&#x2F;工作路径</p><p>​● request.getRequestDispatcher(“&#x2F;“);</p><ol start="5"><li><p>在 javaWeb 中 路径<u><strong>最后</strong></u>带 &#x2F; 和不带 &#x2F; 含义不同, 一定要小心,比如</p><p> &lt; a href&#x3D;”&#x2F;a&#x2F;servlet03”&gt;网址</a> 中的<strong>servlet03 表示资源</strong></p><p>&lt; a href&#x3D;”&#x2F;a&#x2F;servlet03&#x2F;“&gt;网址</a> 中的<strong>servlet03 表示路径</strong></p></li><li><p>🌟特别说明： 重定向 response.sendRediect(“&#x2F;“); 这条语句虽然是在服务器执行的， 但是,服务器是把斜杠 &#x2F; 发送给浏览器解析。 因此得到地址 <a href="http://ip[域名]:port/">http://ip[域名]:port/</a></p></li></ol><p><strong>小结</strong>： 在<strong>编写资源路径时</strong> , 考虑这么几点</p><p>(1) 这个路径前面有没有 &#x2F;</p><p>(2) <strong>这个路径在哪里被解析</strong> [服务器还是浏览器] , 如果前面有 &#x2F; , 并且是在 浏览器被解析的 被解析成 <a href="http://ip:port/">http://ip:port/</a> , 如果在服务器端被解析 , 被解析成 &#x2F;工程路径&#x2F;</p><p>(3) 如果这个路径， 前面没有 &#x2F; , 并且在浏览器被解析， 则以浏览器当前的地址栏 去掉资源部分， 作为一个相对路径，再拼接这条路径.</p><p>(4) 这个路径， 最后有没有 &#x2F; , 如果最后有&#x2F; 表示路径， 如果没有 &#x2F; 表示资源</p><h1 id="12-Web-开发会话技术-Cookie-amp-Session"><a href="#12-Web-开发会话技术-Cookie-amp-Session" class="headerlink" title="12 Web 开发会话技术 Cookie&amp;Session"></a>12 Web 开发会话技术 Cookie&amp;Session</h1><h2 id="12-1-会话"><a href="#12-1-会话" class="headerlink" title="12.1 会话"></a>12.1 会话</h2><h3 id="12-1-1-基本介绍"><a href="#12-1-1-基本介绍" class="headerlink" title="12.1.1 基本介绍"></a>12.1.1 基本介绍</h3><ol><li><p>什么是会话？</p><p>​会话可简单理解为：<u>用户开一个浏览器，点击多个超链接，访问服务器多个 web 资源，然后关闭浏览器</u>，整个过程称之为一个会话。</p></li><li><p>会话过程中要解决的一些问题？</p><p>每个用户在使用浏览器与服务器进行会话的过程中，不可避免各自会产生一些数据，服务器要想办法为每个用户保存这些数据</p><p>例如：多个用户点击超链接通过一个 servlet 各自购买了一个商品，服务器应该想办法把每一个用户购买的商品保存在各自的地方，以便于这些用户点结帐 servlet 时，结帐servlet 可以得到用户各自购买的商品为用户结帐</p></li></ol><h3 id="12-1-2-会话的两种技术"><a href="#12-1-2-会话的两种技术" class="headerlink" title="12.1.2 会话的两种技术"></a>12.1.2 会话的两种技术</h3><h4 id="12-1-2-1-Session"><a href="#12-1-2-1-Session" class="headerlink" title="12.1.2.1 Session"></a>12.1.2.1 Session</h4><h4 id="12-1-2-2-Cookie"><a href="#12-1-2-2-Cookie" class="headerlink" title="12.1.2.2 Cookie"></a>12.1.2.2 Cookie</h4><h2 id="12-2-Cookie-有什么用"><a href="#12-2-Cookie-有什么用" class="headerlink" title="12.2 Cookie 有什么用"></a>12.2 Cookie 有什么用</h2><p>思考问题 1-抛砖引玉☞</p><p>​大家在访问某个网站的时候，是否能看到提示你上次登录网站的时间,而且要注意的是不同用户上次登录的时间肯定是不一样的，这是怎么实现的?</p><p>思考问题 2-抛砖引玉☞</p><p>​大家在访问某个购物网站的时候，是否能看到提示你曾经浏览过的商品，不同用户浏览过的商品肯定不一样，这是怎么实现的?</p><p>解决之道—cookie 技术</p><p>​Cookie(小甜饼)是客户端技术，<strong>服务器把每个用户的数据以 cookie 的形式写给用户各自的浏览器</strong>。当用户使用浏览器再去访问服务器中的 web 资源时，就会带着各自的数据去。这样，web 资源处理的就是用户各自的数据了。【简单示意图】</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230713193537687.png" alt="image-20230713193537687"></p><h2 id="12-3-cookie-介绍"><a href="#12-3-cookie-介绍" class="headerlink" title="12.3 cookie 介绍"></a>12.3 cookie 介绍</h2><h3 id="12-3-1-二说-cookie"><a href="#12-3-1-二说-cookie" class="headerlink" title="12.3.1 二说 cookie"></a>12.3.1 二说 cookie</h3><ol><li>Cookie 是服务器在客户端保存用户的信息， 比如登录名， 浏览历史等, 就可以以 cookie方式保存.</li><li>Cookie 信息就像是小甜饼(cookie 中文)一样，数据量并不大，服务器端在需要的时候可以从客户端&#x2F;浏览器读取(http 协议)，可以通过图来理解</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230713193754793.png" alt="image-20230713193754793" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230713194449881.png" alt="image-20230713194449881" style="zoom:50%;" /><ol start="3"><li>再次说明: <strong>cookie 数据是保存在浏览器的</strong></li></ol><h3 id="12-3-2-cookie-可以用来做啥"><a href="#12-3-2-cookie-可以用来做啥" class="headerlink" title="12.3.2 cookie 可以用来做啥"></a>12.3.2 cookie 可以用来做啥</h3><ol><li><p>保存上次登录时间等信息</p></li><li><p>保存用户名，密码, 在一定时间不用重新登录</p></li><li><p>网站的个性化，比如定制网站的服务，内容</p></li></ol><h2 id="12-4-cookie-基本使用"><a href="#12-4-cookie-基本使用" class="headerlink" title="12.4 cookie 基本使用"></a>12.4 cookie 基本使用</h2><h3 id="12-4-1-文档：-java-ee-api-中英文对照版-chm"><a href="#12-4-1-文档：-java-ee-api-中英文对照版-chm" class="headerlink" title="12.4.1 文档： java_ee_api_中英文对照版.chm"></a>12.4.1 文档： java_ee_api_中英文对照版.chm</h3><h3 id="12-4-2-cookie-常用方法"><a href="#12-4-2-cookie-常用方法" class="headerlink" title="12.4.2 cookie 常用方法"></a>12.4.2 cookie 常用方法</h3><ol><li><p>Cookie 有点象一张表(K-V)， 分两列， 一个是名字， 一个是值， 数据类型都是 String </p></li><li><p>如何创建一个 Cookie(在服务端创建的)</p></li></ol><p>​Cookie c&#x3D;new Cookie(String name,String val);    c.setMaxAge();&#x2F;&#x2F;保存时间</p><ol start="3"><li><p>如何将一个 Cookie 添加到客户端</p><p>response.addCookie(c);</p></li><li><p>如何读取 cookie(在服务器端读取到 cookie 信息)</p><p>request.getCookies();</p></li></ol><h2 id="12-7-cookie-生命周期"><a href="#12-7-cookie-生命周期" class="headerlink" title="12.7 cookie 生命周期"></a>12.7 cookie 生命周期</h2><h3 id="12-7-1-介绍"><a href="#12-7-1-介绍" class="headerlink" title="12.7.1 介绍"></a>12.7.1 介绍</h3><ol><li>Cookie 的生命周期指的是如何管理 Cookie 什么时候被销毁（删除）</li><li>setMaxAge()</li></ol><p>​● 正数，表示在指定的秒数后过期  <strong>过期后，浏览器不会删除该cookie，只是不再携带该cookie</strong></p><p>​● 负数，表示浏览器关闭， Cookie 就会被删除（默认值是-1）</p><p>​● 0， 表示马上删除 Cookie<strong>设置为0后，浏览器会把该cookie直接删除</strong></p><h2 id="12-8-cookie-有效路径"><a href="#12-8-cookie-有效路径" class="headerlink" title="12.8 cookie 有效路径"></a>12.8 cookie 有效路径</h2><h3 id="12-8-1-有效路径规则"><a href="#12-8-1-有效路径规则" class="headerlink" title="12.8.1 有效路径规则"></a>12.8.1 有效路径规则</h3><ol><li>Cookie 有效路径 Path 的设置</li><li>Cookie 的 path 属性可以有效的<strong>过滤哪些 Cookie 可以发送给服务器，哪些不发</strong>。 path属性是通过请求的地址来进行有效的过滤</li><li>规则如下:</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230714164006880.png" alt="image-20230714164006880" style="zoom: 67%;" /><p><strong>没设置默认为项目工程路径</strong></p><h2 id="12-10-Cookie-注意事项和细节"><a href="#12-10-Cookie-注意事项和细节" class="headerlink" title="12.10 Cookie 注意事项和细节"></a>12.10 Cookie 注意事项和细节</h2><ol><li>一个 Cookie 只能标识一种信息， 它至少含有一个标识该信息的名称（NAME） 和设置值（VALUE） 。</li><li><strong>一个 WEB 站点可以给一个浏览器发送多个 Cookie，一个浏览器也可以存储多个 WEB 站点提供的 Cookie。</strong></li><li>cookie 的总数量没有限制，但是每个域名的 COOKIE 数量和每个 COOKIE 的大小是有限制的 (不同的浏览器限制不同, 知道即可) , <strong>Cookie 不适合存放数据量大的信息</strong>。</li><li>注意，删除 cookie 时，path 必须一致，否则不会删除</li><li>Java servlet 中 cookie <strong>中文乱码</strong>解决</li></ol><p>​如果存放中文的 cookie, 默认报错, <u>可以通过 URL 编码和解码来解决</u>, <strong>不建议存放中文的 cookie 信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过将中文转化成utf-8形式的String，便可以将转化的结果放入cookie中了</span></span><br><span class="line"><span class="type">String</span> <span class="variable">urlName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;韩顺平教育&quot;</span>, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是这样的话，在获取cookie中信息时，我们对读出的cookie数据进行解码，从而转换成中文</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="comment">//处理的中文乱码问题</span></span><br><span class="line"><span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">  writer.println( cookie.getName()+ URLDecoder.decode(cookie.getValue(),<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-11-session-有什么用"><a href="#12-11-session-有什么用" class="headerlink" title="12.11 session 有什么用"></a>12.11 session 有什么用</h2><p>思考两个问题—抛砖引玉</p><ol><li>不同的用户登录网站后，不管该用户浏览该网站的哪个页面，都可显示登录人的名字，还可以随时去查看自己的购物车中的商品, 是如何实现的?</li><li>也就是说，一个用户在浏览网站不同页面时，服务器是如何知道是张三在浏览这个页面，还是李四在浏览这个页面?</li></ol><ul><li>方案1  :  可以把每个用户的信息都存到服务器的一个数据库中，再用一个‘🔑’来确定哪个用户对应db中的哪条记录</li><li>方案2  :  也可以将用户信息直接保存到cookie中，但是当切换用户后cookie内容不变，不安全；而且cookie作为传输的数据容易泄露，不便于传输敏感信息</li></ul><p>解决之道—session 技术</p><ol><li><p>Session 是服务器端技术，服务器在运行时为每一个用户的浏览器创建一个其独享的session 对象&#x2F;集合( 其实相当于前面说的方案1 )</p></li><li><p>由于 session 为各个用户浏览器独享，所以用户在访问服务器的不同页面时，可以从各自的 session 中读取&#x2F;添加数据, 从而完成相应任务</p></li></ol><h2 id="12-12-session-基本原理"><a href="#12-12-session-基本原理" class="headerlink" title="12.12 session 基本原理"></a>12.12 session 基本原理</h2><h3 id="12-12-1-Sesson-原理示意图"><a href="#12-12-1-Sesson-原理示意图" class="headerlink" title="12.12.1 Sesson 原理示意图"></a>12.12.1 Sesson 原理示意图</h3><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230714220951863.png" alt="image-20230714220951863" style="zoom:50%;" /><ol><li>当用户打开浏览器，访问某个网站, 操作 session 时，服务器就会在内存(在服务端)为该浏览器分配一个 session 对象，该 session 对象被这个浏览器独占, 如图⬆️</li><li>这个 session 对象也可看做是一个容器&#x2F;集合,session 对象默认存在时间为 30min(这是在tomcat&#x2F;conf&#x2F;web.xml)，也可修改</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230714221054233.png" alt="image-20230714221054233" style="zoom: 50%;" /><h3 id="12-12-2-Session-可以做什么"><a href="#12-12-2-Session-可以做什么" class="headerlink" title="12.12.2 Session 可以做什么"></a>12.12.2 Session 可以做什么</h3><ol><li>网上商城中的购物车</li><li>保存登录用户的信息</li><li>将数据放入到 Session 中， 供用户在访问不同页面时， 实现跨页面访问数据</li><li>防止用户非法登录到某个页面</li><li>…..</li></ol><h3 id="12-12-3-如何理解-Session"><a href="#12-12-3-如何理解-Session" class="headerlink" title="12.12.3 如何理解 Session"></a>12.12.3 如何理解 Session</h3><ol><li>session 存储结构示意图</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230714221456503.png" alt="image-20230714221456503" style="zoom: 50%;" /><ol start="2"><li>你可以把 session 看作是一容器类似 HashMap，有两列(K-V)，每一行就是 session 的一个属性。</li><li>每个属性包含有两个部分，一个是该属性的名字(String)，另外一个是它的值(Object)</li></ol><h2 id="12-13-session-常用方法"><a href="#12-13-session-常用方法" class="headerlink" title="12.13 session 常用方法"></a>12.13 session 常用方法</h2><h3 id="12-13-1-网上去找文档"><a href="#12-13-1-网上去找文档" class="headerlink" title="12.13.1 网上去找文档"></a>12.13.1 网上去找文档</h3><h4 id="12-13-2-Session-的基本使用"><a href="#12-13-2-Session-的基本使用" class="headerlink" title="12.13.2 Session 的基本使用"></a>12.13.2 Session 的基本使用</h4><ol><li><p><strong>创建</strong>&#x2F;<strong>获取</strong> Session， API 一样</p><ul><li>HttpSession session &#x3D; request.<strong>getSession();</strong></li><li><u>第 1 次调用是创建 Session 会话， 之后调用是获取创建好的 Session 对象</u></li></ul></li><li><p>向 session 添加属性session.setAttribute(String name,Object val);</p></li><li><p>从 session 得到某个属性Object obj&#x3D;session.getAttribute(String name);</p></li><li><p>从 session 删除调某个属性:</p><ul><li>hs.removeAttribute(String name);</li></ul></li><li><p>isNew(); 判断是不是刚创建出来的 Session</p></li><li><p>每个 Session 都有 1 个唯一标识 Id 值。 通过 getId() 得到 Session 的会话 id 值，<br><strong>即cookie中的JSESSIONID</strong></p></li></ol><h2 id="12-14-session-底层实现机制"><a href="#12-14-session-底层实现机制" class="headerlink" title="12.14 session 底层实现机制"></a>12.14 session 底层实现机制</h2><h3 id="12-14-1-原理分析图-一图胜千言"><a href="#12-14-1-原理分析图-一图胜千言" class="headerlink" title="12.14.1 原理分析图(一图胜千言)"></a>12.14.1 原理分析图(一图胜千言)</h3><p>● session 底层实现机制图解(重要)</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230714222324161.png" alt="image-20230714222324161" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230714222400458.png" alt="image-20230714222400458" style="zoom:60%;" /><p><strong>如果在本次会话中，服务器为浏览器创建了session空间(说明产生了一组新的「sessionId + session体」的结构出现)，那么服务器会让浏览器将set sessionid信息放入cookie中</strong></p><h3 id="12-14-3-Session-实现原理动画"><a href="#12-14-3-Session-实现原理动画" class="headerlink" title="12.14.3 Session 实现原理动画"></a>12.14.3 Session 实现原理动画</h3><p>● 服务器是如何实现一个 session 为一个用户浏览器服务的</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230715092237931.png" alt="image-20230715092237931" style="zoom:50%;" /><h2 id="12-15-session-生命周期"><a href="#12-15-session-生命周期" class="headerlink" title="12.15 session 生命周期"></a>12.15 session 生命周期</h2><h3 id="12-15-1-Session-生命周期-说明"><a href="#12-15-1-Session-生命周期-说明" class="headerlink" title="12.15.1 Session 生命周期-说明"></a>12.15.1 Session 生命周期-说明</h3><ol><li><p>public void <strong>setMaxInactiveInterval</strong>(int interval) 设置 Session 的超时时间（以<strong>秒</strong>为单位） ，超过指定的时长， Session 就会被销毁。</p></li><li><p>值为正数的时候，设定 Session 的超时时长。</p></li><li><p><strong>负数表示永不超时</strong></p></li><li><p>public int **getMaxInactiveInterval()**获取 Session 的超时时间</p></li><li><p>public void <strong>invalidate() 让当前 Session 会话立即无效</strong></p></li><li><p>如果没有调用 setMaxInactiveInterval() 来指定 Session 的生命时长，Tomcat 会以 Session默认时长为准，<strong>Session 默认的超时为 30 分钟</strong>， 可以在 <strong>tomcat 的 web.xml 设置</strong></p></li><li><p>Session 的生命周期指的是 ：客户端&#x2F;浏览器<strong>两次请求最大间隔时长</strong>，而不是累积时长。**<u>即当客户端访问了自己的 session，session 的生命周期将从 0 开始重新计算。</u>**(解读: 指的是同一个会话两次请求之间的间隔时间)</p></li><li><p>🌟底层: <strong>Tomcat 用一个线程来轮询会话状态，如果某个会话的空闲时间超过设定的最大值，则将该会话销毁</strong></p></li></ol><h1 id="14-JavaWeb-三大组件之监听器-Listener"><a href="#14-JavaWeb-三大组件之监听器-Listener" class="headerlink" title="14 JavaWeb 三大组件之监听器 Listener"></a>14 JavaWeb 三大组件之监听器 Listener</h1><h2 id="14-1-官方文档"><a href="#14-1-官方文档" class="headerlink" title="14.1 官方文档"></a>14.1 官方文档</h2><h3 id="14-1-1-文档……"><a href="#14-1-1-文档……" class="headerlink" title="14.1.1 文档……"></a>14.1.1 文档……</h3><h2 id="14-2-Listener-监听器介绍"><a href="#14-2-Listener-监听器介绍" class="headerlink" title="14.2 Listener 监听器介绍"></a>14.2 Listener 监听器介绍</h2><ol><li><p>Listener 监听器它是 JavaWeb 的三大组件之一。 JavaWeb 的三大组件分别是： Servlet 程序、 Listener 监听器、 Filter 过滤器</p></li><li><p>Listener 是 JavaEE 的规范，就是接口</p></li><li><p><strong>监听器的作用是，监听某种变化(一般就是<u>对象创建&#x2F;销毁, 属性变化</u>), 触发对应方法完成相应的任务</strong></p></li><li><p>JavaWeb 中的监听器（共八个）, 目前最常用的是 <strong>ServletContextListener</strong></p></li></ol><h2 id="14-3-JavaWeb-的监听器"><a href="#14-3-JavaWeb-的监听器" class="headerlink" title="14.3 JavaWeb 的监听器"></a>14.3 JavaWeb 的监听器</h2><h3 id="14-3-1-ServletContextListener-监听器"><a href="#14-3-1-ServletContextListener-监听器" class="headerlink" title="14.3.1 ServletContextListener 监听器"></a>14.3.1 ServletContextListener 监听器</h3><ol><li><p>作用： 🌟<strong>监听 ServletContext 创建或销毁</strong>(当我们 <strong>Web 应用启动时， 就会创建 ServletContext</strong>)，即生命周期监听， 应用场景</p><ol><li>加载初始化的配置文件； 比如 spring 的配置文件</li><li>任务调度（配合定时器 Timer&#x2F;TimerTask)</li></ol></li><li><p>相关方法</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> <span class="comment">//创建 Servletcontext 时触发 </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> <span class="comment">//销毁 Servletcontext 时触发</span></span><br></pre></td></tr></table></figure><ol start="3"><li>应 用 实 例 创 建  MyServletContextListener.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServletContextListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent servletContextEvent&#123;</span></span><br><span class="line"><span class="params">  System.out.println(<span class="string">&quot;ServletContext 创建，完成 WEB 项目初始化的工作..&quot;</span>)</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent servletContextEvent)</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;ServletContext 销毁, 完成资源回收工作..&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>在 web.xml 配置 MyServletContextListener</li></ol><h3 id="14-3-2-ServletContextAttributeListener-监听器"><a href="#14-3-2-ServletContextAttributeListener-监听器" class="headerlink" title="14.3.2 ServletContextAttributeListener 监听器"></a>14.3.2 ServletContextAttributeListener 监听器</h3><ol><li>作用： 🌟<strong>监听 ServletContext 属性变化</strong></li><li>相关方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">attributeAdded</span><span class="params">(ServletContextAttributeEvent event)</span> <span class="comment">//添加属性时调用</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">attributeReplaced</span><span class="params">(ServletContextAttributeEvent event)</span> <span class="comment">//替换属性时调用</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">attributeRemoved</span><span class="params">(ServletContextAttributeEvent event)</span> <span class="comment">//移除属性时调用</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>使用少</strong>,再给大家举个例(后面的监听器类似)</li></ol><p>创 建MyServletContextAttributeListener.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServletContextAttributeListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextAttributeListener</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeAdded</span><span class="params">(ServletContextAttributeEvent servletContextAttributeEvent)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;添加了 servletContext 属性名= &quot;</span>+servletContextAttributeEvent.getName() + <span class="string">&quot; 属 性 值 =&quot;</span> +servletContextAttributeEvent.getValue());</span><br><span class="line">&#125; </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeRemoved</span><span class="params">(ServletContextAttributeEvent servletContextAttributeEvent)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;删除了 servletContext 属性&quot;</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeReplaced</span><span class="params">(ServletContextAttributeEvent servletContextAttributeEvent)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;替换了 servletContext 属性 &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-3-3-其它监听器-使用较少"><a href="#14-3-3-其它监听器-使用较少" class="headerlink" title="14.3.3 其它监听器-使用较少"></a>14.3.3 其它监听器-使用较少</h3><h4 id="14-3-3-1-HttpSessionListener-监听器"><a href="#14-3-3-1-HttpSessionListener-监听器" class="headerlink" title="14.3.3.1 HttpSessionListener 监听器"></a>14.3.3.1 HttpSessionListener 监听器</h4><ol><li>作用： 🌟<strong>监听 Session <u>创建或销毁</u>， 即生命周期监听</strong></li><li>相关方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sessionCreated</span><span class="params">(HttpSessionEvent se)</span>  <span class="comment">//创建 session 时调用 </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sessionDestroyed</span><span class="params">(HttpSessionEvent se)</span><span class="comment">//销毁 session 时调用</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用方法和前面一样, <strong><u>可以用于监控用户上线，离线</u></strong></li></ol><h4 id="14-3-3-2-HttpSessionAttributeListener-监听器"><a href="#14-3-3-2-HttpSessionAttributeListener-监听器" class="headerlink" title="14.3.3.2 HttpSessionAttributeListener 监听器"></a>14.3.3.2 HttpSessionAttributeListener 监听器</h4><ol><li>作用： 🌟<strong>监听 Session <u>属性的变化</u></strong></li><li>相关方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">attributeAdded</span><span class="params">(ServletRequestAttributeEvent srae)</span> <span class="comment">//添加属性时</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">attributeReplaced</span><span class="params">(ServletRequestAttributeEvent srae)</span> <span class="comment">//替换属性时</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">attributeRemoved</span><span class="params">(ServletRequestAttributeEvent srae)</span> <span class="comment">//移除属性时</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用少 ， 使用方法和前面一样。</li></ol><h4 id="14-3-3-3-ServletRequestListener-监听器"><a href="#14-3-3-3-ServletRequestListener-监听器" class="headerlink" title="14.3.3.3 ServletRequestListener 监听器"></a>14.3.3.3 ServletRequestListener 监听器</h4><ol><li><p>ServletRequestListener 监听器</p></li><li><p>作用：<strong>监听 Request 创建或销毁，即 Request 生命周期监听</strong></p></li><li><p>🌟<strong>可以用来监控, 某个 IP 访问我们网站的频率, 日志记录 ,访问资源的情况</strong></p></li></ol><h4 id="14-3-3-4-ServletRequestAttributeListener-监听器"><a href="#14-3-3-4-ServletRequestAttributeListener-监听器" class="headerlink" title="14.3.3.4 ServletRequestAttributeListener 监听器"></a>14.3.3.4 ServletRequestAttributeListener 监听器</h4><ol><li>作用： 监听 Request 属性变化</li></ol><p>……</p><h4 id="14-3-3-5-HttpSessionBindingListener-感知监听器"><a href="#14-3-3-5-HttpSessionBindingListener-感知监听器" class="headerlink" title="14.3.3.5 HttpSessionBindingListener 感知监听器"></a>14.3.3.5 HttpSessionBindingListener 感知监听器</h4><p>……</p><h4 id="14-3-3-6-HttpSessionActivationListener-感知监听器"><a href="#14-3-3-6-HttpSessionActivationListener-感知监听器" class="headerlink" title="14.3.3.6 HttpSessionActivationListener 感知监听器"></a>14.3.3.6 HttpSessionActivationListener 感知监听器</h4><p>……</p><h1 id="15-JavaWeb-三大组件之-过滤器-Filter"><a href="#15-JavaWeb-三大组件之-过滤器-Filter" class="headerlink" title="15 JavaWeb 三大组件之 过滤器 Filter"></a>15 JavaWeb 三大组件之 过滤器 Filter</h1><h2 id="15-1-官方文档"><a href="#15-1-官方文档" class="headerlink" title="15.1 官方文档"></a>15.1 官方文档</h2><h3 id="15-1-1-文档：-……"><a href="#15-1-1-文档：-……" class="headerlink" title="15.1.1 文档： ……"></a>15.1.1 文档： ……</h3><h2 id="15-2-Filter-过滤器说明"><a href="#15-2-Filter-过滤器说明" class="headerlink" title="15.2 Filter 过滤器说明"></a>15.2 Filter 过滤器说明</h2><h3 id="15-2-1-为啥要过滤器-需求示意图"><a href="#15-2-1-为啥要过滤器-需求示意图" class="headerlink" title="15.2.1 为啥要过滤器-需求示意图"></a>15.2.1 为啥要过滤器-需求示意图</h3><p>● 一图胜千言 </p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230715181935717.png" alt="image-20230715181935717"></p><h3 id="15-2-2-过滤器介绍"><a href="#15-2-2-过滤器介绍" class="headerlink" title="15.2.2 过滤器介绍"></a>15.2.2 过滤器介绍</h3><ol><li>Filter 过滤器它是 JavaWeb 的三大组件之一(Servlet 程序、 Listener 监听器、 Filter 过滤器)</li><li>Filter 过滤器是 JavaEE 的规范，是接口<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230715182105900.png" alt="image-20230715182105900" style="zoom: 50%;" /></li><li>Filter 过滤器它的作用是：拦截请求，过滤响应。</li><li>应用场景</li></ol><ul><li>权限检查</li><li>日志操作</li><li>事务管理</li></ul><h2 id="15-3-Filter-过滤器基本原理"><a href="#15-3-Filter-过滤器基本原理" class="headerlink" title="15.3 Filter 过滤器基本原理"></a>15.3 Filter 过滤器基本原理</h2><p>● 一图胜千言</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230715182618162.png" alt="image-20230715182618162" style="zoom:50%;" /><h2 id="15-4-Filter-过滤器快速入门"><a href="#15-4-Filter-过滤器快速入门" class="headerlink" title="15.4 Filter 过滤器快速入门"></a>15.4 Filter 过滤器快速入门</h2><p>● 需求: 在 web 工程下， 有后台管理目录 manage， 要求该目录下所有资源（html、 图片、jsp 、 Servlet 等） <strong>用户登录后才能访问</strong></p><p>听老师说明, <strong>完成模块的套路&#x2F;流程</strong>[多年的体会]</p><ol><li>先完成一个正确的流程-看到一个效果-&gt; 写后面代码就可以验证</li><li>加入其它的功能[加入 session,验证合法性]</li><li>完善功能</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 老韩解读</span></span><br><span class="line"><span class="comment"> * 1. filter在web项目启动时, 由tomcat 来创建filter实例, 只会创建一个</span></span><br><span class="line"><span class="comment"> * 2. 会调用filter默认的无参构造器, 同时会调用 init方法, 只会调用一次</span></span><br><span class="line"><span class="comment"> * 3. 在创建filter实例时，同时会创建一个FilterConfig对象,并通过init方法传入</span></span><br><span class="line"><span class="comment"> * 4. 通过FilterConfig对象，程序员可以获取该filter的相关配置信息</span></span><br><span class="line"><span class="comment"> * 5. 当一个http请求和该filter的的url-patter匹配时，就会调用doFilter方法</span></span><br><span class="line"><span class="comment"> * 6. 在调用doFilter方法时,tomcat会同时创建ServletRequest 和 ServletResponse 和 FilterChain对象</span></span><br><span class="line"><span class="comment"> * , 并通过doFilter传入.</span></span><br><span class="line"><span class="comment"> * 7. 如果后面的请求目标资源(jsp,servlet..) 会使用到request，和 response，那么会继续传递</span></span><br><span class="line"><span class="comment"> * 8. 老师的提醒:到javaweb - ssm - springboot , 有 浏览器和 web服务器(tomcat)参与, 而这两个部分不是我们</span></span><br><span class="line"><span class="comment"> *    程序员自己写，所以理解起来比 java se要困难!!!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ManageFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">//当Tomcat 创建 Filter创建，就会调用该方法，进行初始化</span></span><br><span class="line">        <span class="comment">//老韩提醒：回忆我们自己实现tomcat底层机制+servlet程序， 就会了然</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ManageFilter init被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest,</span></span><br><span class="line"><span class="params">                         ServletResponse servletResponse,</span></span><br><span class="line"><span class="params">                         FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;ManageFilter doFilter() 被调用=&quot;</span> + (++count));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//到每次调用该filter时，doFilter就会被调用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果这里，没有调用继续请求的方法，则就停止</span></span><br><span class="line">        <span class="comment">//如果继续访问目标资源-&gt; 等价于放行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//老师说明：在调用过滤器前，servletRequest对象=request已经被创建并封装</span></span><br><span class="line">        <span class="comment">//所以：我们这里就可以通过servletRequest获取很多信息, 比如访问url , session</span></span><br><span class="line">        <span class="comment">//比如访问的参数 ... 就可以做事务管理，数据获取，日志管理等</span></span><br><span class="line">        <span class="comment">//获取到session</span></span><br><span class="line">        <span class="comment">//可以继续使用 httpServletRequest 方法.</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入密码=&quot;</span> + httpServletRequest.getParameter(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> httpServletRequest.getSession();</span><br><span class="line">        <span class="comment">//获取username session对象, 还可以继续使用</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">username</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (username != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//老韩解读filterChain.doFilter(servletRequest, servletResponse)</span></span><br><span class="line">            <span class="comment">//1. 继续访问目标资源url</span></span><br><span class="line">            <span class="comment">//2. servletRequest 和 servletResponse 对象会传递给目标资源/文件</span></span><br><span class="line">            <span class="comment">//3. 一定要理解filter传递的两个对象，再后面的servlet/jsp 是同一个对象(指的是在一次http请求)</span></span><br><span class="line">            System.out.println(<span class="string">&quot;servletRequest=&quot;</span> + servletRequest);</span><br><span class="line">            System.out.println(<span class="string">&quot;日志信息==&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;访问的用户名=&quot;</span> + username.toString());</span><br><span class="line">            System.out.println(<span class="string">&quot;访问的url=&quot;</span> + httpServletRequest.getRequestURL());</span><br><span class="line">            System.out.println(<span class="string">&quot;访问的IP=&quot;</span> + httpServletRequest.getRemoteAddr());</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//说明没有登录过..回到登录页面</span></span><br><span class="line">            servletRequest.getRequestDispatcher(<span class="string">&quot;/login.jsp&quot;</span>).</span><br><span class="line">                    forward(servletRequest, servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//当filter被销毁时，会调用该方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ManageFilter destroy()被调用..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>●在 web.xml 配置过滤器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--老师解读:filter一般写在其它servlet的前面</span></span><br><span class="line"><span class="comment">        1. 观察我们发现filter 配置和 servlet 非常相似. filter也是被tomcat管理和维护</span></span><br><span class="line"><span class="comment">        2. url-pattern 就是当请求的url 和 匹配的时候，就会调用该filter</span></span><br><span class="line"><span class="comment">        3. /manage/* 第一个 / 解析成 http://ip:port/工程路径</span></span><br><span class="line"><span class="comment">        4. 完整的路径就是 http://ip:port/工程路径/manage/* 当请求的资源url满足该条件时</span></span><br><span class="line"><span class="comment">        都会调用filter , /manage/admin.jsp</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ManageFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.hspedu.filter.ManageFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ManageFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/manage/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="15-5-Filter-过滤器-url-pattern"><a href="#15-5-Filter-过滤器-url-pattern" class="headerlink" title="15.5 Filter 过滤器 url-pattern"></a>15.5 Filter 过滤器 url-pattern</h2><p>1、 url-pattern : Filter 的拦截路径, 即<strong>浏览器在请求什么位置的资源时， 过滤器会进行拦截过滤</strong> </p><p>2、<strong>精确匹配</strong> <url-pattern>&#x2F;a.jsp</url-pattern> 对应的 请求地址 <a href="http://ip[域名]:port/工程路径/a.jsp">http://ip[域名]:port/工程路径/a.jsp</a> 会拦截</p><p>3、 <strong>目录匹配</strong> <url-pattern>&#x2F;manage&#x2F;*</url-pattern>对应的 请求地址 <a href="http://ip[域名]:port/工程路径/manage/xx">http://ip[域名]:port/工程路径/manage/xx</a> , 即 web 工程 manage 目录下所有资源 会拦截</p><p>4、 <strong>后缀名匹配</strong> <url-pattern>*.jsp</url-pattern> 后缀名可变， 比如 *.action *.do 等等对应的 请求地址 <a href="http://ip[域名]:port/工程路径/xx.jsp">http://ip[域名]:port/工程路径/xx.jsp</a> , 后缀名为 .jsp 请求会拦截</p><p><strong>5、 Filter 过滤器它只关心请求的地址是否匹配， 不关心请求的资源是否存在</strong></p><h2 id="15-6-Filter-过滤器生命周期"><a href="#15-6-Filter-过滤器生命周期" class="headerlink" title="15.6 Filter 过滤器生命周期"></a>15.6 Filter 过滤器生命周期</h2><p>● Filter 生命周期图解</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230716085623113.png" alt="image-20230716085623113"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 老韩解读</span></span><br><span class="line"><span class="comment"> * 1. filter在web项目启动时, 由tomcat 来创建filter实例, 只会创建一个</span></span><br><span class="line"><span class="comment"> * 2. 会调用filter默认的无参构造器, 同时会调用 init方法, 只会调用一次</span></span><br><span class="line"><span class="comment"> * 3. 在创建filter实例时，同时会创建一个FilterConfig对象,并通过init方法传入</span></span><br><span class="line"><span class="comment"> * 4. 通过FilterConfig对象，程序员可以获取该filter的相关配置信息</span></span><br><span class="line"><span class="comment"> * 5. 当一个http请求和该filter的的url-patter匹配时，就会调用doFilter方法</span></span><br><span class="line"><span class="comment"> * 6. 在调用doFilter方法时,tomcat会同时创建ServletRequest 和 ServletResponse 和 FilterChain对象</span></span><br><span class="line"><span class="comment"> * , 并通过doFilter传入.</span></span><br><span class="line"><span class="comment"> * 7. 如果后面的请求目标资源(jsp,servlet..) 会使用到request，和 response，那么会继续传递</span></span><br><span class="line"><span class="comment"> * 8. 老师的提醒:到javaweb - ssm - springboot , 有 浏览器和 web服务器(tomcat)参与, 而这两个部分不是我们</span></span><br><span class="line"><span class="comment"> *    程序员自己写，所以理解起来比 java se要困难!!!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ManageFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">//当Tomcat 创建 Filter创建，就会调用该方法，进行初始化</span></span><br><span class="line">        <span class="comment">//老韩提醒：回忆我们自己实现tomcat底层机制+servlet程序， 就会了然</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ManageFilter init被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest,</span></span><br><span class="line"><span class="params">                         ServletResponse servletResponse,</span></span><br><span class="line"><span class="params">                         FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;ManageFilter doFilter() 被调用=&quot;</span> + (++count));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//到每次调用该filter时，doFilter就会被调用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果这里，没有调用继续请求的方法，则就停止</span></span><br><span class="line">        <span class="comment">//如果继续访问目标资源-&gt; 等价于放行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//老师说明：在调用过滤器前，servletRequest对象=request已经被创建并封装</span></span><br><span class="line">        <span class="comment">//所以：我们这里就可以通过servletRequest获取很多信息, 比如访问url , session</span></span><br><span class="line">        <span class="comment">//比如访问的参数 ... 就可以做事务管理，数据获取，日志管理等</span></span><br><span class="line">        <span class="comment">//获取到session</span></span><br><span class="line">        <span class="comment">//可以继续使用 httpServletRequest 方法.</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入密码=&quot;</span> + httpServletRequest.getParameter(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> httpServletRequest.getSession();</span><br><span class="line">        <span class="comment">//获取username session对象, 还可以继续使用</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">username</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (username != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//老韩解读filterChain.doFilter(servletRequest, servletResponse)</span></span><br><span class="line">            <span class="comment">//1. 继续访问目标资源url</span></span><br><span class="line">            <span class="comment">//2. servletRequest 和 servletResponse 对象会传递给目标资源/文件</span></span><br><span class="line">            <span class="comment">//3. 一定要理解filter传递的两个对象，再后面的servlet/jsp 是同一个对象(指的是在一次http请求)</span></span><br><span class="line">            System.out.println(<span class="string">&quot;servletRequest=&quot;</span> + servletRequest);</span><br><span class="line">            System.out.println(<span class="string">&quot;日志信息==&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;访问的用户名=&quot;</span> + username.toString());</span><br><span class="line">            System.out.println(<span class="string">&quot;访问的url=&quot;</span> + httpServletRequest.getRequestURL());</span><br><span class="line">            System.out.println(<span class="string">&quot;访问的IP=&quot;</span> + httpServletRequest.getRemoteAddr());</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//说明没有登录过..回到登录页面</span></span><br><span class="line">            servletRequest.getRequestDispatcher(<span class="string">&quot;/login.jsp&quot;</span>).</span><br><span class="line">                    forward(servletRequest, servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//当filter被销毁时，会调用该方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ManageFilter destroy()被调用..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>🌟 <strong>如果后面的请求目标资源(jsp,servlet..) 会使用到request 和 response，那么会继续传递——即使访问的url不同了，但是只要还是被这个filter拦截，那么就是传递相同的request 和 response</strong></p><h2 id="15-7-FilterConfig"><a href="#15-7-FilterConfig" class="headerlink" title="15.7 FilterConfig"></a>15.7 FilterConfig</h2><p>● FilterConfig 接口图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230716090922457.png" alt="image-20230716090922457" style="zoom:50%;" /><p>● FilterConfig 说明</p><ol><li>FilterConfig 是 Filter 过滤器的配置类</li><li>Tomcat 每次创建 Filter 的时候，也会创建一个 FilterConfig 对象，这里包含了 Filter 配置文件的配置信息。</li><li>FilterConfig 对象作用是<strong>获取 filter 过滤器的配置内容</strong></li></ol><p>● 应用实例 FilterConfig_.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 老师解读： 演示FilterConfig使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HspFilterConfig</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String ip; <span class="comment">//从配置获取的ip</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HspFilterConfig init() 被调用..&quot;</span>);</span><br><span class="line">        <span class="comment">//通过filterConfig 获取相关的参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filterName</span> <span class="operator">=</span> filterConfig.getFilterName();</span><br><span class="line">        ip = filterConfig.getInitParameter(<span class="string">&quot;ip&quot;</span>);</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> filterConfig.getServletContext();</span><br><span class="line">        <span class="comment">//可以获取到该filter所有的配置参数名</span></span><br><span class="line">        Enumeration&lt;String&gt; initParameterNames =</span><br><span class="line">                filterConfig.getInitParameterNames();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历枚举</span></span><br><span class="line">        <span class="keyword">while</span> (initParameterNames.hasMoreElements()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;名字=&quot;</span> + initParameterNames.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;filterName= &quot;</span> + filterName);</span><br><span class="line">        System.out.println(<span class="string">&quot;ip= &quot;</span> + ip);</span><br><span class="line">        System.out.println(<span class="string">&quot;servletContext= &quot;</span> + servletContext);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过forbidden ip 来进行控制</span></span><br><span class="line">        <span class="comment">//先获取到访问ip</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">remoteAddr</span> <span class="operator">=</span> servletRequest.getRemoteAddr();</span><br><span class="line">        <span class="keyword">if</span>(remoteAddr.contains(ip)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;封杀该网段..&quot;</span>);</span><br><span class="line">            servletRequest.getRequestDispatcher(<span class="string">&quot;/login.jsp&quot;</span>).</span><br><span class="line">                    forward(servletRequest,servletResponse);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//继续访问目标资源</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 web.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HspFilterConfig<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.hspedu.filter.HspFilterConfig<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这里就是给该filter配置的参数-有程序员根据业务逻辑来设置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>ip<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>127.0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>port<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>8888<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>email<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>hsp@sohu.com<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HspFilterConfig<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/abc/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="15-8-FilterChain-过滤器链"><a href="#15-8-FilterChain-过滤器链" class="headerlink" title="15.8 FilterChain 过滤器链"></a>15.8 FilterChain 过滤器链</h2><h3 id="15-8-1-一句话-FilterChain-在处理某些复杂业务时，-一个过滤器不够，-可以设计多个过滤器共同完成过滤任务，-形成过滤器链。"><a href="#15-8-1-一句话-FilterChain-在处理某些复杂业务时，-一个过滤器不够，-可以设计多个过滤器共同完成过滤任务，-形成过滤器链。" class="headerlink" title="15.8.1 一句话: FilterChain: 在处理某些复杂业务时， 一个过滤器不够， 可以设计多个过滤器共同完成过滤任务， 形成过滤器链。"></a>15.8.1 一句话: FilterChain: 在处理某些复杂业务时， 一个过滤器不够， 可以设计多个过滤器共同完成过滤任务， 形成过滤器链。</h3><h4 id="15-8-2-基本原理示意图"><a href="#15-8-2-基本原理示意图" class="headerlink" title="15.8.2 基本原理示意图"></a>15.8.2 基本原理示意图</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230716093408721.png" alt="image-20230716093408721"></p><h3 id="15-8-3-应用实例-AFilter-java-BFilter-java-hi-jsp-web-xml"><a href="#15-8-3-应用实例-AFilter-java-BFilter-java-hi-jsp-web-xml" class="headerlink" title="15.8.3 应用实例 AFilter.java BFilter.java hi.jsp web.xml"></a>15.8.3 应用实例 AFilter.java BFilter.java hi.jsp web.xml</h3><ol><li>需求： 演示过滤器链的使用</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230716093621006.png" alt="image-20230716093621006"></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230716094326928.png" alt="image-20230716094326928" style="zoom: 50%;" /><p>15.8.4 FilterChain 注意事项和细节</p><ol><li><p><strong>多个 filter 和目标资源</strong>在<u>一次 http 请求</u>， <u>在同一个线程中</u></p></li><li><p>当一个请求 url 和 filter 的 url-pattern 匹配时, 才会被执行, 如果有多个匹配上， 就会顺序执行， 形成一个 filter 调用链(底层可以使用一个数据结构搞定)</p></li><li><p>多个 filter 共同执行时,因为是一次 http 请求, <strong>使用同一个 request 对象</strong></p></li><li><p>多个 filter <strong>执行顺序</strong>， <strong>和 web.xml 配置顺序保持一致.</strong></p></li><li><p>chain.doFilter(req, resp)方法 <strong>将执行下一个过滤器的 doFilter 方法, 如果后面没有过滤器，则执行目标资源。</strong></p></li></ol><p><strong>小结</strong>： 注意执行过滤器链时, 顺序是(用前面的案例分析) Http请求 -&gt; A 过滤器 dofilter()-&gt; A 过滤器前置代码 -&gt; A 过滤器 chain.doFilter() -&gt; B 过滤器 dofilter() -&gt; B 过滤器前置代码 -&gt; B过滤器 chain.doFilter() -&gt; 目标文件 -&gt; B过滤器后置代码 -&gt; A过滤器后置代码 -&gt;返回给浏览器页面&#x2F;数据</p><p>🌟<strong>后置代码指：过滤器中 doFilter()方法中，chain.doFilter()之后的代码</strong></p><h1 id="18-线程数据共享和安全-ThreadLocal"><a href="#18-线程数据共享和安全-ThreadLocal" class="headerlink" title="18 线程数据共享和安全 -ThreadLocal"></a>18 线程数据共享和安全 -ThreadLocal</h1><h2 id="18-1-什么是-ThreadLocal"><a href="#18-1-什么是-ThreadLocal" class="headerlink" title="18.1 什么是 ThreadLocal"></a>18.1 什么是 ThreadLocal</h2><ol><li>ThreadLocal 的作用， 可以实现在同一个线程数据共享, 从而解决多线程数据安全问题.</li><li>ThreadLocal 可以给当前线程关联一个数据(普通变量、对象、数组)set 方法 [源码!]</li><li>ThreadLocal 可以像 Map 一样存取数据，key 为当前线程, get 方法</li><li>每一个 ThreadLocal 对象，只能为当前线程关联一个数据，如果要为当前线程关联多个数据，就需要使用多个 ThreadLocal 对象实例</li><li>每个 ThreadLocal 对象实例定义的时候，一般为 static 类型</li><li>ThreadLocal 中保存数据，在线程销毁后，会自动释放</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230716164123672.png" alt="image-20230716164123672" style="zoom: 67%;" /><h2 id="18-2-快速入门-ThreadLocal"><a href="#18-2-快速入门-ThreadLocal" class="headerlink" title="18.2 快速入门 ThreadLocal"></a>18.2 快速入门 ThreadLocal</h2><p>● 需求: 演示 ThreadLocal (作用： 在一个线程中, 共享数据(线程安全))的使用-画图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建ThreadLocal对象, 做成public static.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Object&gt; threadLocal1 = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Object&gt; threadLocal2 = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Task 是线程类 -&gt; 内部类 / 线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">            <span class="type">Pig</span> <span class="variable">pig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pig</span>();</span><br><span class="line">            <span class="comment">//给threadLocal1 对象放入set dog , 隔山打牛</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Task 放入了 dog= &quot;</span> + dog);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                老韩解读</span></span><br><span class="line"><span class="comment">                public void set(T value) &#123;</span></span><br><span class="line"><span class="comment">                    //1. 获取当前线程, 关联到当前线程!</span></span><br><span class="line"><span class="comment">                    Thread t = Thread.currentThread();</span></span><br><span class="line"><span class="comment">                    //2. 通过线程对象, 获取到ThreadLocalMap</span></span><br><span class="line"><span class="comment">                    //   ThreadLocalMap 类型 ThreadLocal.ThreadLocalMap</span></span><br><span class="line"><span class="comment">                    ThreadLocalMap map = getMap(t);</span></span><br><span class="line"><span class="comment">                    //3. 如果map不为null, 将数据(dog,pig..) 放入map </span></span><br><span class="line"><span class="comment">                    -key:threadLocal value:存放的数据</span></span><br><span class="line"><span class="comment">                    //从这个源码我们已然看出一个threadlocal只能关联一个数据，如果你set, 就会替换</span></span><br><span class="line"><span class="comment">                    //4. 如果map为null, 就创建一个和当前线程关联的ThreadLocalMap, 并且该数据放入</span></span><br><span class="line"><span class="comment">                    if (map != null)</span></span><br><span class="line"><span class="comment">                        map.set(this, value);</span></span><br><span class="line"><span class="comment">                    else</span></span><br><span class="line"><span class="comment">                        createMap(t, value);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            threadLocal1.set(dog);</span><br><span class="line">            <span class="comment">//threadLocal1.set(pig);//替换</span></span><br><span class="line">            threadLocal2.set(pig);<span class="comment">//这个数据就会threadLocal2关联，并且都被当前Thread管理</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Task 在run 方法中 线程=&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">T1Service</span>().update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>()).start();<span class="comment">//主线程启动一个新的线程,注意不是主线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-3-ThreadLocal-源码解读-画图"><a href="#18-3-ThreadLocal-源码解读-画图" class="headerlink" title="18.3 ThreadLocal 源码解读+画图"></a>18.3 ThreadLocal 源码解读+画图</h2><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230716181639550.png" alt="image-20230716181639550"></p><ol start="3"><li>老韩说明: 这里涉及到的弱引用，涉及到知识点很多，暂不深入</li></ol><p>一个Thread有一个 threadLocals(TheadLocalMap类型) ，threadLocals中有一个table，table中有许多桶，每个桶都是Entry类型，（Entry的key是ThreadLocal类型，value是你存进去的数据)</p><h3 id="⚠️疑问："><a href="#⚠️疑问：" class="headerlink" title="⚠️疑问："></a>⚠️疑问：</h3><p>！！！threadLocals中只有一个table，table中存着该线程存放的许多Entry，问：为什么不把Entry直接放在threadLocals下面，而是要多加一层table？</p>]]></content>
      
      
      <categories>
          
          <category> Web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2023/06/20/Linux/"/>
      <url>/2023/06/20/Linux/</url>
      
        <content type="html"><![CDATA[<p>本博客参照了韩顺平老师的Linux课程，b站可搜！</p><h1 id="Linux学习🚀"><a href="#Linux学习🚀" class="headerlink" title="Linux学习🚀"></a>Linux学习🚀</h1><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620231850984.png" alt="image-20230620231850984" style="zoom:50%;" /><h2 id="基础篇："><a href="#基础篇：" class="headerlink" title="基础篇："></a>基础篇：</h2><h3 id="Linux入门："><a href="#Linux入门：" class="headerlink" title="Linux入门："></a>Linux入门：</h3><h4 id="linux的应用领域："><a href="#linux的应用领域：" class="headerlink" title="linux的应用领域："></a>linux的应用领域：</h4><ul><li><strong>个人桌面领域</strong><ul><li>此领域是传统Linux应用薄弱的环节，近些年来随着ubuntu、fedora等优秀桌面环境的兴起，Linux在个人桌面领域的占有率正在逐渐的提高</li></ul></li><li><strong>服务器领域</strong><ul><li>linux在<u>服务器领域的应用是最强的</u>。</li><li>linux <u><em>免费、稳定、高效</em></u> 等特点在这里得到了很好的体现，尤其在一些高端领域尤为广泛( c&#x2F;c+ + &#x2F;php&#x2F;java&#x2F;python) .</li></ul></li><li><strong>嵌入式领域</strong><ul><li>linux运行稳定、对网络的良好支持性，低成本，且<strong>可以根据需要进行软件裁剪</strong>，内核最小可以达到几百KB等特点，使其近些年来在嵌入式领域的应用得到非常大的提高；</li><li>主要应用：机顶盒、数宇电视、网络电话、程控交换机、手机、PDA、智能家居、智能硬件等都是其应用领域。以后在物联网中应用会更加广泛。</li></ul></li></ul><h3 id="vm和Linux安装："><a href="#vm和Linux安装：" class="headerlink" title="vm和Linux安装："></a>vm和Linux安装：</h3><p>……跟着老师的教程走，mac用户就去网上搜教程即可</p><h4 id="网络连接的三种方式："><a href="#网络连接的三种方式：" class="headerlink" title="网络连接的三种方式："></a>网络连接的三种方式：</h4><ol><li><p>桥接模式</p></li><li><p>NAT模式</p></li><li><p>主机模式</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/IMG_31492E73D3F2-1.jpeg" alt="IMG_31492E73D3F2-1"></p><h4 id="虚拟机克隆-方便快速构建集群"><a href="#虚拟机克隆-方便快速构建集群" class="headerlink" title="虚拟机克隆(方便快速构建集群)"></a>虚拟机克隆(方便快速构建集群)</h4><p>​如果你已经安装了一合linux操作系统，你还想再更多的，老韩提示大家：没有必要再重新安装，你只需要克隆就可以。</p><ul><li>方式1：直接拷贝一份安装好的虛拟机文件</li><li>方式2：使用vmware的克隆操作，注意，克隆时，需要先关闭linux系统</li></ul><h4 id="虚拟机快照"><a href="#虚拟机快照" class="headerlink" title="虚拟机快照"></a>虚拟机快照</h4><p>如果你在使用虛拟机系统的时候(比如linux），你想<strong>回到原先的某一个状态</strong>，也就是说你担心可能有些误操作造成系统异常，需要回到原先某个正常运行的状态，vmware也提供了这样的功能，就叫快照管理。</p><h4 id="安装vmtools"><a href="#安装vmtools" class="headerlink" title="安装vmtools"></a>安装vmtools</h4><ul><li><p>介绍</p><ol><li><p>vmtools 安装后，可以让我们在windows下重好的管理vm虛拟机</p></li><li><p>可以设置windows和centos的共享文件夹</p></li></ol></li></ul><h3 id="Linux目录结构："><a href="#Linux目录结构：" class="headerlink" title="Linux目录结构："></a>Linux目录结构：</h3><h2 id="实操篇："><a href="#实操篇：" class="headerlink" title="实操篇："></a>实操篇：</h2><h2 id="高级篇："><a href="#高级篇：" class="headerlink" title="高级篇："></a>高级篇：</h2>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程</title>
      <link href="/2023/06/07/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
      <url>/2023/06/07/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><h2 id="Chapter1-Introduction"><a href="#Chapter1-Introduction" class="headerlink" title="Chapter1 Introduction"></a>Chapter1 Introduction</h2><h3 id="软件工程学科产生的背景："><a href="#软件工程学科产生的背景：" class="headerlink" title="软件工程学科产生的背景："></a>软件工程学科产生的背景：</h3><h4 id="软件危机："><a href="#软件危机：" class="headerlink" title="软件危机："></a>软件危机：</h4><h5 id="从结果来看，软件危机体现在："><a href="#从结果来看，软件危机体现在：" class="headerlink" title="从结果来看，软件危机体现在："></a>从结果来看，软件危机体现在：</h5><ul><li>软件质量差、可靠性难以保证</li><li>成本难以控制</li><li>开发进度难以把握</li><li>可维护性较差</li></ul><h5 id="从原因来看，软件危机由以下两点导致："><a href="#从原因来看，软件危机由以下两点导致：" class="headerlink" title="从原因来看，软件危机由以下两点导致："></a>从原因来看，软件危机由以下两点导致：</h5><ol><li>不断增长的系统复杂性</li><li>未有效采用软件工程方法进行开发</li></ol><h3 id="Frequently-asked-questions-about-software-engineering"><a href="#Frequently-asked-questions-about-software-engineering" class="headerlink" title="Frequently asked questions about software engineering"></a><strong>Frequently asked questions about software engineering</strong></h3><table><thead><tr><th><strong>Question</strong></th><th><strong>Answer</strong></th></tr></thead><tbody><tr><td>What  is software?</td><td><strong>Computer  programs</strong> and <strong>associated documentation</strong>. Software products may be developed for  a particular customer or may be developed for a general market.</td></tr><tr><td>What  are the attributes of good software?</td><td>Good  software should deliver the required functionality and performance to the  user and should be maintainable, dependable and usable.</td></tr><tr><td>What  is software engineering?</td><td>Software  engineering is an engineering discipline that is concerned with all aspects  of software production.</td></tr><tr><td>What  are the fundamental software engineering activities?</td><td>Software  specification(规范), software development, software validation(验证) and software  evolution(演进).</td></tr><tr><td>What  is the difference between software engineering and computer science?</td><td>Computer  science focuses on theory and fundamentals; software engineering is concerned  with the practicalities of developing and delivering useful software.</td></tr><tr><td>What  is the difference between software engineering and system engineering?</td><td>System  engineering is concerned with all aspects of computer-based systems  development including hardware, software and process engineering. Software  engineering is part of this more general process.</td></tr><tr><td>What are the key challenges facing  software engineering?</td><td>Coping with increasing diversity,  demands for reduced delivery times and developing trustworthy software.</td></tr><tr><td>What  are the costs of software engineering?</td><td>Roughly  60% of software costs are development costs, 40% are testing costs. For  custom software, evolution costs often exceed development costs.</td></tr><tr><td>What  are the best software engineering techniques and methods?</td><td>While  all software projects have to be professionally managed and developed,  <strong>different techniques are appropriate for different types of system</strong>. For  example, games should always be developed using a series of prototypes  whereas safety critical control systems require a complete and analyzable  specification to be developed. You can’t, therefore, say that one method is  better than another.</td></tr></tbody></table><h3 id="好的软件的基本属性"><a href="#好的软件的基本属性" class="headerlink" title="好的软件的基本属性"></a>好的软件的基本属性</h3><ul><li>可接受性(满足用户的需求，用户能用，好用)</li><li>可依赖性和信息安全性</li><li>效率高</li><li>可维护性</li></ul><h3 id="软件过程——四项基本活动"><a href="#软件过程——四项基本活动" class="headerlink" title="软件过程——四项基本活动"></a>软件过程——四项基本活动</h3><ol><li><strong>软件规格说明</strong>（like 需求分析</li><li><strong>软件开发</strong></li><li><strong>软件确认</strong>（like 验收</li><li><strong>软件演化</strong>（like 维护</li></ol><h2 id="Chapter2-软件过程"><a href="#Chapter2-软件过程" class="headerlink" title="Chapter2 软件过程"></a>Chapter2 软件过程</h2><h3 id="2-1软件过程模型"><a href="#2-1软件过程模型" class="headerlink" title="2.1软件过程模型"></a>2.1软件过程模型</h3><h4 id="瀑布模型："><a href="#瀑布模型：" class="headerlink" title="瀑布模型："></a>瀑布模型：</h4><p>​如果每阶段做的事是正确的，就能保证最终结果的正确</p><p>​系统需求&lt;&#x3D;&gt;软件需求&lt;&#x3D;&gt;需求分析&lt;&#x3D;&gt;设计&lt;&#x3D;&gt;编码&lt;&#x3D;&gt;测试&lt;&#x3D;&gt;运行</p><h5 id="瀑布模型的优点："><a href="#瀑布模型的优点：" class="headerlink" title="瀑布模型的优点："></a>瀑布模型的优点：</h5><p>虽然瀑布模型是一个比较 “老”的。甚至过时的开发模型，但其优点为：</p><ul><li><p>在决定系统怎样做之前，存在一个需求阶段。<strong>鼓励对系统“做什么” 进行规约</strong>（即设计之前的规约）。</p></li><li><p>在建造构件之前。存在一个设计阶段，<strong>鼓励规划系统结构</strong>（即编码之前的设计）。</p></li><li><p><u>在每一阶段结束时进行复审，允许获取方和用户的参与。</u></p></li><li><p>前一步工作产品可作为下一步被认可的。文档化的基线。允许基线和配置早期接受控制。</p></li></ul><h5 id="瀑布模型的缺点："><a href="#瀑布模型的缺点：" class="headerlink" title="瀑布模型的缺点："></a>瀑布模型的缺点：</h5><p>瀑布模型下，客户和开发者可能会过早地冻结了需求，这样的话后续就不能发生进一步的变化(除非返工)</p><ul><li><p>客户<u>必须能够完整、正确和清晰地表达他们的需求</u>：开发人员一开始就必须理解需求。</p></li><li><p>缺乏灵活性。一旦软件需求存在偏差，就会导致开发出的软件产品不能满足用户的实际要求(需要返工)。</p></li><li><p>在一个项目的早期阶段，过分地强调了基线和里程碑处的文档,可能要花费更多的时间，用于建立一些用处不大的文档。</p></li><li><p>直到项目结束之前，都不能演示系统的能力,增加了项目的风险。</p></li></ul><h4 id="增量模型："><a href="#增量模型：" class="headerlink" title="增量模型："></a>增量模型：</h4><p>​该模型有一个假设：假设需求可以分段，成为一系列增量产品，每一增量可以分别地开发。</p><p>系统开发体现为一系列的版本(增量)，每个版本在前一版本的基础上增加一些功能。</p><h5 id="增量模型的优点："><a href="#增量模型的优点：" class="headerlink" title="增量模型的优点："></a>增量模型的优点：</h5><p>作为瀑布模型的第一个变体，具有瀑布模型的所有优点。</p><p>此外，它还有以下优点：</p><ul><li><p>更容易获得用户的反馈</p></li><li><p>第一个可交付版本所需要的成本和时间是很少的：</p></li><li><p>开发由增量表示的小系统所承担的风险是不大的：</p></li><li><p>由于很快发布了第一个版本，因此可以减少用户需求的变更：</p></li><li><p>允许增量投资，即在项目开始时，可以仅对一个或两个增量投资。</p></li></ul><p>注：如果采用增量投资方式，那么客户就可以对一些增量进行招标。</p><p>然后，开发人员按提出的截止期限进行增量开发，这样客户就可以用多个契约来管理组织的资源和成本。</p><h5 id="增量模型的缺点："><a href="#增量模型的缺点：" class="headerlink" title="增量模型的缺点："></a>增量模型的缺点：</h5><p>如果增量模型不适于某些项目，或使用有误，则有以下缺点：</p><ul><li><p>﻿如果没有对用户的变更要求进行规划，那么产生的初始增量可能会造成后来增量的不稳定；</p></li><li><p>﻿如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发(返工)，重新发布：</p></li><li><p>管理发生的成本、进度和配置的复杂性，可能会超出一些组织的能力。</p></li><li><p>过程不可见：管理者需要定期交付成果来衡量进度。如果系统开发迅速，则生成反映系统每个版本的文档并不具有成本效益。</p></li></ul><h4 id="集成和配置："><a href="#集成和配置：" class="headerlink" title="集成和配置："></a>集成和配置：</h4><p>​该方法依赖于可复用的构件或系统。</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230610130513298.png" alt="image-20230610130513298"></p><h4 id="演化模型："><a href="#演化模型：" class="headerlink" title="演化模型："></a>演化模型：</h4><p>（针对一开始不能明确需求的情况：</p><p>是一种有弹性的过程模式，由一些小的开发步组成，每一步都历经<strong>需求分析、设计、实现和验证</strong></p><h4 id="喷泉模型："><a href="#喷泉模型：" class="headerlink" title="喷泉模型："></a>喷泉模型：</h4><p>​特征：<strong>迭代、无缝</strong></p><h2 id="chapter1-软件工程概论"><a href="#chapter1-软件工程概论" class="headerlink" title="chapter1 软件工程概论"></a>chapter1 软件工程概论</h2><h3 id="1-1-软件的定义及特点"><a href="#1-1-软件的定义及特点" class="headerlink" title="1.1 软件的定义及特点"></a>1.1 软件的定义及特点</h3><h3 id="1-2-软件工程的起源和概念"><a href="#1-2-软件工程的起源和概念" class="headerlink" title="1.2 软件工程的起源和概念"></a>1.2 软件工程的起源和概念</h3><h3 id="1-3-软件开发的本质和基本手段"><a href="#1-3-软件开发的本质和基本手段" class="headerlink" title="1.3 软件开发的本质和基本手段"></a>1.3 软件开发的本质和基本手段</h3><h3 id="1-4-软件工程框架"><a href="#1-4-软件工程框架" class="headerlink" title="1.4 软件工程框架"></a>1.4 软件工程框架</h3><h2 id="chapter2-软件过程"><a href="#chapter2-软件过程" class="headerlink" title="chapter2 软件过程"></a>chapter2 软件过程</h2><h3 id="2-1软件生存周期过程的概念"><a href="#2-1软件生存周期过程的概念" class="headerlink" title="2.1软件生存周期过程的概念"></a>2.1软件生存周期过程的概念</h3><h3 id="2-2软件生存周期过程的分类"><a href="#2-2软件生存周期过程的分类" class="headerlink" title="2.2软件生存周期过程的分类"></a>2.2软件生存周期过程的分类</h3><h3 id="2-3软件生存周期模型的概念"><a href="#2-3软件生存周期模型的概念" class="headerlink" title="2.3软件生存周期模型的概念"></a>2.3软件生存周期模型的概念</h3><h3 id="2-4常见的软件生存周期模型"><a href="#2-4常见的软件生存周期模型" class="headerlink" title="2.4常见的软件生存周期模型"></a>2.4常见的软件生存周期模型</h3><h4 id="瀑布模型：-1"><a href="#瀑布模型：-1" class="headerlink" title="瀑布模型："></a>瀑布模型：</h4><p>​如果每阶段做的事是正确的，就能保证最终结果的正确</p><p>​系统需求&lt;&#x3D;&gt;软件需求&lt;&#x3D;&gt;需求分析&lt;&#x3D;&gt;设计&lt;&#x3D;&gt;编码&lt;&#x3D;&gt;测试&lt;&#x3D;&gt;运行</p><h5 id="瀑布模型的优点：-1"><a href="#瀑布模型的优点：-1" class="headerlink" title="瀑布模型的优点："></a>瀑布模型的优点：</h5><p>虽然瀑布模型是一个比较 “老”的。甚至过时的开发模型，但其优点为：</p><ul><li><p>在决定系统怎样做之前，存在一个需求阶段。<strong>鼓励对系统“做什么” 进行规约</strong>（即设计之前的规约）。</p></li><li><p>在建造构件之前。存在一个设计阶段，<strong>鼓励规划系统结构</strong>（即编码之前的设计）。</p></li><li><p><u>在每一阶段结束时进行复审，允许获取方和用户的参与。</u></p></li><li><p>前一步工作产品可作为下一步被认可的。文档化的基线。允许基线和配置早期接受控制。</p></li></ul><h5 id="瀑布模型的缺点：-1"><a href="#瀑布模型的缺点：-1" class="headerlink" title="瀑布模型的缺点："></a>瀑布模型的缺点：</h5><ul><li><p>客户<u>必须能够完整、正确和清晰地表达他们的需求</u>：开发人员一开始就必须理解需求。</p></li><li><p>缺乏灵活性。一旦软件需求存在偏差，就会导致开发出的软件产品不能满足用户的实际要求。</p></li><li><p>在一个项目的早期阶段，过分地强调了基线和里程碑处的文档,可能要花费更多的时间，用于建立一些用处不大的文档。</p></li><li><p>直到项目结束之前，都不能演示系统的能力,增加了项目的风险。</p></li></ul><h4 id="增量模型：-1"><a href="#增量模型：-1" class="headerlink" title="增量模型："></a>增量模型：</h4><p>​该模型有一个假设：假设需求可以分段，成为一系列增量产品，每一增量可以分别地开发。</p><h5 id="增量模型的优点：-1"><a href="#增量模型的优点：-1" class="headerlink" title="增量模型的优点："></a>增量模型的优点：</h5><p>作为瀑布模型的第一个变体，具有瀑布模型的所有优点。</p><p>此外，它还有以下优点：</p><ul><li><p>第一个可交付版本所需要的成本和时间是很少的：</p></li><li><p>开发由增量表示的小系统所承担的风险是不大的：</p></li><li><p>由于很快发布了第一个版本，因此可以减少用户需求的变更：</p></li><li><p>允许增量投资，即在项目开始时，可以仅对一个或两个增量投资。</p></li></ul><p>注：如果采用增量投资方式，那么客户就可以对一些增量进行招标。</p><p>然后，开发人员按提出的截止期限进行增量开发，这样客户就可以用多个契约来管理组织的资源和成本。</p><h5 id="增量模型的缺点：-1"><a href="#增量模型的缺点：-1" class="headerlink" title="增量模型的缺点："></a>增量模型的缺点：</h5><p>如果增量模型不适于某些项目，或使用有误，则有以下缺点：</p><ul><li><p>﻿如果没有对用户的变更要求进行规划，那么产生的初始增量可能会造成后来增量的不稳定；</p></li><li><p>﻿如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布：</p></li><li><p>管理发生的成本、进度和配置的复杂性，可能会超出一些组织的能力。</p></li></ul><h4 id="演化模型：-1"><a href="#演化模型：-1" class="headerlink" title="演化模型："></a>演化模型：</h4><p>（针对一开始不能明确需求的情况：</p><p>是一种有弹性的过程模式，由一些小的开发步组成，每一步都历经<strong>需求分析、设计、实现和验证</strong></p><h4 id="喷泉模型：-1"><a href="#喷泉模型：-1" class="headerlink" title="喷泉模型："></a>喷泉模型：</h4><p>​特征：<strong>迭代、无缝</strong></p><h2 id="chapter3-软件需求与软件需求规约"><a href="#chapter3-软件需求与软件需求规约" class="headerlink" title="chapter3 软件需求与软件需求规约"></a>chapter3 软件需求与软件需求规约</h2><h3 id="3-1需求的作用"><a href="#3-1需求的作用" class="headerlink" title="3.1需求的作用"></a>3.1需求的作用</h3><p>​软件开发的工作基础</p><h3 id="3-2需求的定义"><a href="#3-2需求的定义" class="headerlink" title="3.2需求的定义"></a>3.2需求的定义</h3><p>​描述了待开发产品&#x2F;系统功能上的能力、性能参数或其他性质</p><p>需求的基本性质：</p><ul><li>必要性是要求的</li><li>无歧义性            是否只能用一种方式来解释</li><li>可测的 (测试)     能否进行测试，对一定的输入，会有相同的输出</li><li>可跟踪的            从一个开发阶段到另一个阶段能否进行跟踪</li><li>可测量的            能否测量</li></ul><h3 id="3-3需求的分类"><a href="#3-3需求的分类" class="headerlink" title="3.3需求的分类"></a>3.3需求的分类</h3><h4 id="功能需求："><a href="#功能需求：" class="headerlink" title="功能需求："></a>功能需求：</h4><ul><li><p>关于该功能输入的所有假定，或为了验证该功能输入有关检测的假定。</p></li><li><p>﻿功能内的任一次序，这一次序是与外部有关的。</p></li><li><p>﻿对异常条件的响应，包括所有内外部所产生的错误。</p></li><li><p>﻿需求的时序或优先程度。</p></li><li><p>﻿功能之间的互斥规则。</p></li><li><p>﻿系统内部状态的假定。</p></li><li><p>为了该功能的执行，所需要的输入和输出次序。</p></li><li><p>用于转换或内部计算所需要的公式。</p></li></ul><h4 id="性能需求："><a href="#性能需求：" class="headerlink" title="性能需求："></a>性能需求：</h4><p>​规约了一个系统或系统构建必须具有的<strong>性能特性</strong>(速度、准确率、并发等要求)</p><h4 id="外部接口需求："><a href="#外部接口需求：" class="headerlink" title="外部接口需求："></a>外部接口需求：</h4><p>​外部接口需求 (External interface requirement) 规约了系统或系统构件必须与之交互的硬件、软件或数据库元素。它也可能规约其格式、时间或其他因素。</p><ul><li><p>系统接口 (Systeminterfaces)：描述一个应用如何与系统的其他应用进行交互。</p></li><li><p>用户接口 (User interfaces)：规约了软件产品和用户之间接口的逻辑特性。即规约对给用户所显示的数据，对用户所要求的数据以及用户如何控制该用户接口。</p></li><li><p>硬件接口 (Hardware interfaces)：如果软件系统必须与硬件设备进行交互，那么就应说明所要求的支持和协议类型。</p></li><li><p>软件接口 (Software interfaces)：允许与其它软件产品进行交互，如，数据管理系统、操作系统或数学软件包。</p></li><li><p>通讯接口 (Communications interfaces)：规约待开发系统与通讯设施（如，局域网）之间的交互。如果通讯需求包含了系统必须使用的网络类型 (TCP&#x2F;IP. WindowsNT. Novell)，那么有关类型的信息就应包含在SRS中。</p></li></ul><p></p><h4 id="设计约束需求："><a href="#设计约束需求：" class="headerlink" title="设计约束需求："></a>设计约束需求：</h4><p>​设计约束<strong>限制了系统或系统构件</strong>的设计方案。就约束的本身而言。对其进行权衡或调整是相当困难的，甚至是不可能的。<u>它们必须予以满足</u>。这一性质是与其它需求的最主要差别。为了满足功能、性能和其它需求，许多设计约束将对软件项目规划、所需要的附加成本和工作产生直接影响。例如：</p><ul><li>系统必须用C++或其他面向对象语方编写。系统用户接口需要菜单……</li></ul><h4 id="质量属性："><a href="#质量属性：" class="headerlink" title="质量属性："></a>质量属性：</h4><p>​规约了软件产品必须具有的性质是否达到质量方面一个所期望的水平</p><p>​例如：</p><p>​可靠性软件系统在指定环境中没有失败而正常运行的概率。</p><p>​存活性当系统的某一部分系统不能运行时，该软件维续运行或支持关键功能的可能性。</p><p>​可维护性发現和改正一个软件故障或对特定的花明进行修改所要求的平均工作。</p><p>​用户友好性    学习和使用一个软件系统的容易程度。</p><p>​安全性在一个预定的时间内，使软件系统安全的可能性。</p><p>​可移植性软件系统运行的平台类型。</p><h3 id="3-4需求发现"><a href="#3-4需求发现" class="headerlink" title="3.4需求发现"></a>3.4需求发现</h3><p>​需求是怎么来的？</p><h4 id="自悟-Introspection"><a href="#自悟-Introspection" class="headerlink" title="自悟(Introspection)"></a>自悟(Introspection)</h4><p>​需求人员把自己作为系统的最终用户，审视该系统并提出问題：“如果是我使用这一系统，则我需要…”</p><h5 id="适用条件："><a href="#适用条件：" class="headerlink" title="适用条件："></a>适用条件：</h5><p>​需求工程师不能直接与用户进行交流，自悟似乎是一种比较有吸引力的方法，可能确实是必须的。</p><h5 id="成功条件："><a href="#成功条件：" class="headerlink" title="成功条件："></a>成功条件：</h5><p>​若使自悟是成功的，需求人员必须具有比最终用户还要多的应用领域和过程方面的知识，并具有良好的想象能力。</p><h4 id="交谈-Individual-interviews"><a href="#交谈-Individual-interviews" class="headerlink" title="交谈(Individual interviews)"></a>交谈(Individual interviews)</h4><p>为了确定系统应该提供的功能，需求人员通过提出问题，用户回答，直接询问用户想要的是一个什么样的系统。</p><h5 id="成功条件：-1"><a href="#成功条件：-1" class="headerlink" title="成功条件："></a>成功条件：</h5><p>交谈通常是一种比自悟更好的技术。这种途径成功与否依赖于：</p><p>一一需求人员是否具有“<u>正确提出问题</u>的的能力，</p><p>一一回答人员是否具有“<u>揭示需求本意</u>”的能力。</p><p>在在的风险：在交谈期间需求可能不断增长，或是以前没有认识到的合理需求的一种表现，说是“完美蠕行”(Creepingelegance)病症的体现，以至于很难予以控制，可能导致超出项目成本和进度的限制。</p><h5 id="应对措施："><a href="#应对措施：" class="headerlink" title="应对措施："></a>应对措施：</h5><p>项目管理人员和客户管理人员应该定期地对交谈过程的结果进行复車。其中具有挑战的问题是：</p><p>判断：</p><p>一一什么时候对这一增长划界：</p><p>一一什么时候将这一增长通知客户。</p><h4 id="观察-Observation"><a href="#观察-Observation" class="headerlink" title="观察(Observation)"></a>观察(Observation)</h4><p>通过观察用户执行其现行的任务和过程，或通过观察他们如何操作与所期望的新系统有关的现有系统，了解系统运行的环境，特别是了解要建的新系统与现存系统、过程以及工作方法之间必须进行的交互。尽管了解的这些信息可以通过交谈获取，但“第一手材料”一般总是能够比较好的符合现实的。</p><h5 id="存在的风险："><a href="#存在的风险：" class="headerlink" title="存在的风险："></a>存在的风险：</h5><p>一一客户可能抵触这一观察。其原因是他们认为开发者打扰了他们的正常业务。</p><p>一一客户还可能认为开发者在签约之前，就已经熟悉了他们的业务。</p><h4 id="小组会-Group-session"><a href="#小组会-Group-session" class="headerlink" title="小组会(Group session)"></a>小组会(Group session)</h4><p>举行客户和开发人员的联席会议，与客户组织的一些代表共同开发需求。其中：</p><p>一通常是由<u>开发组织的一个代表作为首席需求工程师或软件工程项目经理</u>，主持这一会议。但还可以采用其它形式，这依赖于其应用领城和主持人的能力。主持人的作用主要是掌握会议的进程。</p><p>一必须仔细地选择该小组的成员，不仅要考虑他们对现存的和未来运行环境的理解程度，还要考虑他们的人品。</p><h4 id="提炼-Extraction"><a href="#提炼-Extraction" class="headerlink" title="提炼(Extraction)"></a>提炼(Extraction)</h4><p>复审技术文档（例如，有关需要的陈达，功能和性能目标的陈述，系统规约接口标准，硬件设计文档以及ConOps文档），并提出相关的信息。</p><h5 id="适用条件：-1"><a href="#适用条件：-1" class="headerlink" title="适用条件："></a>适用条件：</h5><p>提炼方法是针对<u><strong>己经有了部分需求文档的情况</strong></u>。依据产品的本来情况，可能有很多文档需要复审，以确定其中是否包含相关联的信息。在有的情况，也可能只有少数文档需要复审。</p><p>在许多项目中，在任何交谈、观察、小组会或自悟之前，应该对该项目的背景文档进行复审，还应对系统规约进行复审，同时了解相关的标准和政策。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li>在任意特定的环境中，每项技术都有其自己的优点和不足。在实施上述任何一项技术时，都可以辅以其他</li></ul><p>方法，例如原型构造，在举行小组会时可以使用原型，方便人员之间的交流。</p><ul><li><p>依据需求工程人员的技能和产品、合同的实际情况，往往需要“组合”地使用这些技术来开发初始需求。</p></li><li><p>执行需求发现这项活动的人，其技能水平将对这项活动的成功具有重大的影响。</p></li><li><p>大型复杂项目和一些有能力的组织，在开发需求文档时，往往使用系统化的需求获取、分析技术和工具。</p></li></ul><p>一些方法提供了 系统化、自动化的功能，并可逐一验证单一需求所具有的五个性质，验证需求规约是否具</p><p>有四个性质。</p><h3 id="3-5需求规约-SRS"><a href="#3-5需求规约-SRS" class="headerlink" title="3.5需求规约(SRS)"></a>3.5需求规约(SRS)</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念:"></a>概念:</h4><p>一个需求规约是一个软件项&#x2F;产品&#x2F;系统所有需求陈述的正式文档，是一个软件产品&#x2F; 系统的概念模型。</p><h4 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质:"></a>基本性质:</h4><p>一般来说，SRS应必须具有以下4个性质：</p><ul><li><p>重要性和稳定性程度 (Banlked for importaance and stability).例如：基本需求、可送的需求和期望的需求。</p></li><li><p>可修改的 (Modifiable)：在不过多地影响其它需求的前提下，可以容易地修改一个单一需求.</p></li><li><p>完整的(Couplete)：没有被遗漏的需求.</p></li><li><p>一致的 (Consistent)：不存在互斥的需求.</p></li></ul><h4 id="格式"><a href="#格式" class="headerlink" title="格式:"></a>格式:</h4><p>引言……总体描述……特定需求……</p><h3 id="3-6需求规约的作用"><a href="#3-6需求规约的作用" class="headerlink" title="3.6需求规约的作用"></a>3.6需求规约的作用</h3><p>第一，是最重要的，作为软件开发组织和用户之间一份事实上的技术合同书；是产品功能及其环境的体现。</p><p>第二，对于项目的其余大多数工作，它是一个管理控制点。</p><p>第三，对于产品的设计，它是一个正式的、受控的起始点。</p><p>第四，是创建产品验收测试计划和用户指南的基础，即基于需求规约一般还会产生另外两个文档——<strong>初始</strong></p><p><strong>测试计划</strong>和<strong>用户系统操作描述</strong>。</p><h3 id="3-7项目的需求及需求规约"><a href="#3-7项目的需求及需求规约" class="headerlink" title="3.7项目的需求及需求规约"></a>3.7项目的需求及需求规约</h3><p>项目需求是客户和开发者之间有关技术合同-产品&#x2F;系统需求的理解，应记录在工作陈述SOW中或其他某一项目文档（例如，项目管理计划）中。</p><p>即<strong>需求规约</strong>(SRS)应只关注产品需求，即：</p><p>​产品&#x2F;系统需求一“交付给客户的产品是什么”</p><p><strong>项目的需求</strong>(SOW)应关注项目工作与管理，即：</p><p>​项目需求-“开发组要做的是什么”</p><h2 id="chapter4-结构化分析方法"><a href="#chapter4-结构化分析方法" class="headerlink" title="chapter4 结构化分析方法"></a>chapter4 结构化分析方法</h2><h3 id="结构化分析："><a href="#结构化分析：" class="headerlink" title="结构化分析："></a>结构化分析：</h3><p>​需求分析的目标<br>​对需求陈述进行分析，解决其中的歧义、不一致等问题以系统化的形式表达用户的需求，即给出问题的形式化或半形式化的描述(称为系统的概念模型，或系统的需求规约或需求规格说明)。作为开发人员和客户间技术契约的基础，并作为而后开发活动的一个基本输入。</p><p>2实现软件需求分析的目标对方法学的需求</p><ul><li>**提供一组术语(符号)**，指导需求抽象中需要关注的主要方面，并用于表达分析中所使用的信息。这些术语形成一个特定的抽象层，即需求层。</li><li>依据这些术语所形成的“空间”，<strong>给出表达模型的工具</strong>,支持表达系统功能形态。</li><li><strong>给出过程指导</strong>，以支持系统化地使用相关信息建造系统模型。</li></ul><p>基本术语：</p><p>模型表达工具</p><p>​数据流图：</p><p>​数据字典：定义数据流和数据存储</p><p>​加工小说明：</p><ul><li>结构化自然语言</li><li>判定表 </li><li>判定树</li></ul><h3 id="结构化方法："><a href="#结构化方法：" class="headerlink" title="结构化方法："></a>结构化方法：</h3><h4 id="结构化分析方法："><a href="#结构化分析方法：" class="headerlink" title="结构化分析方法："></a>结构化分析方法：</h4><p>​</p><h4 id="结构化设计方法"><a href="#结构化设计方法" class="headerlink" title="结构化设计方法"></a>结构化设计方法</h4><h4 id="结构化程序设计方法"><a href="#结构化程序设计方法" class="headerlink" title="结构化程序设计方法"></a>结构化程序设计方法</h4><h2 id="chapter5"><a href="#chapter5" class="headerlink" title="chapter5"></a>chapter5</h2><h2 id="chapter6"><a href="#chapter6" class="headerlink" title="chapter6"></a>chapter6</h2><h2 id="chapter7"><a href="#chapter7" class="headerlink" title="chapter7"></a>chapter7</h2><h2 id="chapter8-软件测试"><a href="#chapter8-软件测试" class="headerlink" title="chapter8 软件测试"></a>chapter8 软件测试</h2><h2 id="chapter9-软件项目管理"><a href="#chapter9-软件项目管理" class="headerlink" title="chapter9 软件项目管理"></a>chapter9 软件项目管理</h2><h2 id="Chapter10-软件开发工具与环境"><a href="#Chapter10-软件开发工具与环境" class="headerlink" title="Chapter10 软件开发工具与环境"></a>Chapter10 软件开发工具与环境</h2>]]></content>
      
      
      <categories>
          
          <category> 软件开发基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2023/06/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/06/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>(参照清华——操作系统课程)：</p><p>os：对硬件的管理和控制 本课程着重对<strong>kernel层</strong>的研究</p><h2 id="Chapter1-概述"><a href="#Chapter1-概述" class="headerlink" title="Chapter1 概述"></a>Chapter1 概述</h2><h4 id="什么是OS？"><a href="#什么是OS？" class="headerlink" title="什么是OS？"></a>什么是OS？</h4><p>CPU —–&gt; 进程</p><p>磁盘 —–&gt; 文件</p><p>内存 —–&gt; 地址空间</p><h5 id="用户角度："><a href="#用户角度：" class="headerlink" title="用户角度："></a>用户角度：</h5><ul><li>管理应用程序</li><li>为应用程序提供服务</li><li>杀死应用程序</li></ul><h5 id="资源角度："><a href="#资源角度：" class="headerlink" title="资源角度："></a>资源角度：</h5><ul><li>资源管理</li><li>管理外设、分配资源</li></ul><h4 id="Kernel层内部组件："><a href="#Kernel层内部组件：" class="headerlink" title="Kernel层内部组件："></a>Kernel层内部组件：</h4><ul><li>CPU调度器</li><li>物理内存管理</li><li>虚拟内存管理</li><li>文件系统管理</li><li>中断处理与设备驱动</li></ul><h4 id="OS-Kernel的特征："><a href="#OS-Kernel的特征：" class="headerlink" title="OS Kernel的特征："></a>OS Kernel的特征：</h4><ul><li><p>并发</p><ul><li>计算机系统中同时存在多个运行的程序，需要OS管理和调度</li></ul></li><li><p>共享</p><ul><li>互斥共享</li></ul></li><li><p>虚拟</p><ul><li>利用<strong>多道程序设计技术</strong>让每个用户都觉得有一个计算机专门为他服务。</li></ul></li><li><p>异步</p><ul><li>程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知</li><li>只要运行环境相同，OS需要保证程序的运行结果也相同</li></ul></li></ul><h2 id="Chapter2-操作系统基础操作"><a href="#Chapter2-操作系统基础操作" class="headerlink" title="Chapter2 操作系统基础操作"></a>Chapter2 操作系统基础操作</h2><h3 id="2-1-操作系统的启动"><a href="#2-1-操作系统的启动" class="headerlink" title="2.1 操作系统的启动"></a>2.1 操作系统的启动</h3><h4 id="开机顺序："><a href="#开机顺序：" class="headerlink" title="开机顺序："></a>开机顺序：</h4><p>​电脑开机后，将先执行bootstrap program程序(引导程序)，引导程序一般位于计算机的固件中，由它初始化系统的内核以及各个组件。</p><h3 id="2-2-中断、异常和系统调用"><a href="#2-2-中断、异常和系统调用" class="headerlink" title="2.2 中断、异常和系统调用"></a>2.2 中断、异常和系统调用</h3><h4 id="中断-from-外设"><a href="#中断-from-外设" class="headerlink" title="中断(from 外设)"></a>中断(from 外设)</h4><ul><li><p>来自不同的硬件设备的计时器和网络的中断</p></li><li><p>异步</p></li><li><p>对用户应用程序是透明的</p></li></ul><h5 id="中断的处理过程："><a href="#中断的处理过程：" class="headerlink" title="中断的处理过程："></a>中断的处理过程：</h5><h6 id="硬件："><a href="#硬件：" class="headerlink" title="硬件："></a>硬件：</h6><ul><li>设置中断标记[CPU初始化]<br>1. 将内部事件、外部事件设置中断标记<br>      1. CPU通过标记获得中断事件的ID(凭借中断向量表)</li></ul><p></p><h6 id="软件："><a href="#软件：" class="headerlink" title="软件："></a>软件：</h6><ul><li>保存当前处理状态</li><li>中断服务程序处理</li><li>清除中断标记</li><li>恢复之前保存的处理状态</li></ul><h4 id="异常-from-不良的应用程序"><a href="#异常-from-不良的应用程序" class="headerlink" title="异常(from 不良的应用程序)"></a>异常(from 不良的应用程序)</h4><ul><li><p>应用程序产生，由于非法指令或者其他坏的处理状态</p></li><li><p>同步</p></li><li><p>杀死或重新执行意想不到的应用程序指令</p></li></ul><h5 id="异常的处理过程："><a href="#异常的处理过程：" class="headerlink" title="异常的处理过程："></a>异常的处理过程：</h5><ul><li>保存现场</li><li>异常处理<ul><li>杀死异常程序</li><li>或者 重新执行异常命令</li></ul></li><li>恢复现场</li></ul><h4 id="系统调用-from-应用程序"><a href="#系统调用-from-应用程序" class="headerlink" title="系统调用(from 应用程序)"></a>系统调用(from 应用程序)</h4><ul><li><p>应用程序主动向OS发送服务请求</p></li><li><p>同步或异步</p></li><li><p>等待后继续执行</p></li></ul><h5 id="系统调用的处理过程："><a href="#系统调用的处理过程：" class="headerlink" title="系统调用的处理过程："></a>系统调用的处理过程：</h5><p>​调用系统函数 如printf()后，会触发系统调用，在屏幕上打印</p><p><u>将OS能提供的系统调用进行某种集成，形成各色各样的API供开发人员使用</u></p><ul><li><p>Win32 API 用于Windows</p></li><li><p>POSIX API 用于 POSIX-based systems(such as: UNIX、LINUX、MAX OS X)</p></li><li><p>Java API 用于 JVM</p><ol><li>通常情况下，每个系统调用有自己的序号，系统调用接口根据这些序号维护表的索引</li><li>系统调用接口 调用内核态中的系统调用，返回系统调用的状态和结果(其返回值)</li><li>用户不需要知道系统调用是如何实现的，只需要获取各个API的作用即可；操作系统接口的细节大部分隐藏在API中</li></ol></li></ul><p><strong>🌟用户从系统调用的库中调用系统调用接口，在调用系统调用接口时，会触发一个从用户态-&gt;内核态的转换，执行内核态中的系统调用。</strong></p><p>系统调用的开销会大于普通的函数调用，因为：</p><p>​系统调用会从用户态切换到内核态，需要两次建立函数空间，而函数调用只有自己唯一的栈空间</p><h4 id="跨越操作系统边界的开销-中断、异常、系统调用"><a href="#跨越操作系统边界的开销-中断、异常、系统调用" class="headerlink" title="跨越操作系统边界的开销(中断、异常、系统调用)"></a>跨越操作系统边界的开销(中断、异常、系统调用)</h4><p>在执行时间上开销超过应用程序</p><p>开销体现于：</p><ul><li>建立中断&#x2F;异常&#x2F;系统<strong>调用号 与 对应服务例程映射关系的初始化开销</strong>(因为你跨越了OS边界，不能把原本的状态带过去，所以需要一张映射表，由编号找到你需要做的事)</li><li>建立内核堆栈(因为在内核态进行操作，需要在内核态建立变量存储空间)</li><li>验证参数(内核态不信任用户态，需要进行验证)</li><li>内核态映射到用户态的地址空间(内核态产生的数据需要拷贝回用户态)</li><li>内核态独立地址空间(TLB)</li></ul><p>这些开销都是值得的，它们保证了OS的操作安全、可靠！</p><h2 id="Chapter3-连续式内存分配"><a href="#Chapter3-连续式内存分配" class="headerlink" title="Chapter3 连续式内存分配"></a>Chapter3 连续式内存分配</h2><h3 id="计算机体系结构及内存分层体系"><a href="#计算机体系结构及内存分层体系" class="headerlink" title="计算机体系结构及内存分层体系"></a>计算机体系结构及内存分层体系</h3><p>分层……计组里都学过</p><h4 id="操作系统的内存管理方面的四个目标"><a href="#操作系统的内存管理方面的四个目标" class="headerlink" title="操作系统的内存管理方面的四个目标"></a>操作系统的内存管理方面的四个目标</h4><ul><li>抽象<ul><li>逻辑地址空间</li></ul></li><li>保护<ul><li>独立地址空间</li></ul></li><li>共享<ul><li>访问相同内存</li></ul></li><li>虚拟化<ul><li>更多的地址空间</li></ul></li></ul><h3 id="地址空间与地址生成"><a href="#地址空间与地址生成" class="headerlink" title="地址空间与地址生成"></a>地址空间与地址生成</h3><h4 id="1-地址空间定义"><a href="#1-地址空间定义" class="headerlink" title="1.地址空间定义"></a>1.地址空间定义</h4><p>​物理地址空间：硬件支持的地址空间</p><p>​逻辑地址空间：一个运行的程序所拥有的内存范围</p><h4 id="2-地址生成"><a href="#2-地址生成" class="headerlink" title="2.地址生成"></a>2.地址生成</h4><p>​逻辑地址生成：从变量的符号，通过一系列操作(编译、汇编、链接、载入)变为逻辑地址</p><p>​物理地址生成：已知逻辑地址，通过硬件MMU将逻辑地址映射到物理地址</p><h4 id="3-地址安全检查"><a href="#3-地址安全检查" class="headerlink" title="3.地址安全检查"></a>3.地址安全检查</h4><p>​OS记录每一个程序能够访问的地址空间(开始位置和大小)</p><p>​这个表由OS维护，CPU要执行某个程序时，OS检查该程序的地址是否满足表中的限制(不与已占用空间冲突)，能满足则正常执行；否则CPU产生内存访问异常，让OS进行进一步处理。</p><h3 id="连续内存分配：内存碎片与分区的动态分配"><a href="#连续内存分配：内存碎片与分区的动态分配" class="headerlink" title="连续内存分配：内存碎片与分区的动态分配"></a>连续内存分配：内存碎片与分区的动态分配</h3><h4 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h4><p>空闲内存不能被利用</p><ul><li>外部碎片</li></ul><p>在**分配单元<u>间</u>**的未使用内存</p><ul><li>内部碎片</li></ul><p>在**分配单元<u>中</u>**的未使用内存</p><h4 id="分区的动态分配"><a href="#分区的动态分配" class="headerlink" title="分区的动态分配"></a>分区的动态分配</h4><h5 id="常见分配策略"><a href="#常见分配策略" class="headerlink" title="常见分配策略"></a>常见分配策略</h5><h6 id="第一适配"><a href="#第一适配" class="headerlink" title="第一适配"></a>第一适配</h6><p>​放在<strong>第一个</strong>能够满足需求的空闲块中</p><p>​<strong>简单实现：</strong></p><ul><li>对空闲块列表按地址排序</li><li>分配到第一个合适的分区</li><li>回收时进行检查，看看自由分区能不能与相邻的空闲分区合并<ul><li>缺点：产生外部碎片、不确定性</li></ul></li></ul><h6 id="最佳适配"><a href="#最佳适配" class="headerlink" title="最佳适配"></a>最佳适配</h6><p>​在能放下空闲块的分区中，寻找<strong>最小</strong>的分区（避免了分割大空闲块，为了最小化外部碎片产生的尺寸）</p><p>​<strong>简单实现：</strong></p><ul><li>按尺寸排列空闲块列表</li><li>分配时需要寻找最合适的分区</li><li>回收时进行检查，看看自由分区能不能与相邻的空闲分区合并<ul><li>优势：当大部分分配是小尺寸时十分有效</li><li>劣势：会产生外部碎片，重分配(回收)慢，容易产生很多很小的内部碎片</li></ul></li></ul><p></p><h6 id="最差适配"><a href="#最差适配" class="headerlink" title="最差适配"></a>最差适配</h6><p>​在能放下空闲块的分区中，寻找<strong>最大</strong>的分区（为了避免有太多微小的碎片）</p><p>​<strong>简单实现：</strong></p><ul><li>按尺寸排列空闲块列表(从大到小)</li><li>分配时需要寻找最合适的分区(找最大的，所以找非常快)</li><li>回收时进行检查，看看自由分区能不能与相邻的空闲分区合并<ul><li>优势：分配中等大小的块效果最好</li><li>劣势：重分配慢、外部碎片、每次都使用大空闲块可能导致大分区无法被分配</li></ul></li></ul><h4 id="压缩式碎片整理"><a href="#压缩式碎片整理" class="headerlink" title="压缩式碎片整理"></a>压缩式碎片整理</h4><p>​在程序处于等待状态时，将其进行移动，从而消除外部碎片————目的是消除外部碎片</p><h4 id="交换式碎片整理"><a href="#交换式碎片整理" class="headerlink" title="交换式碎片整理"></a>交换式碎片整理</h4><p>​如果运行中的程序需要比较大的内存空间，那么可以让它<u>抢占等待中的程序的内存空间(</u>先将占用了内存空间的等待中的程序转存到硬盘中)</p><p>​问题：将哪个等待中的程序换出呢？什么时候执行换入、换出的操作呢？</p><h2 id="Chapter4-非连续式内存分配"><a href="#Chapter4-非连续式内存分配" class="headerlink" title="Chapter4 非连续式内存分配"></a>Chapter4 非连续式内存分配</h2><h3 id="连续内存分配的缺点："><a href="#连续内存分配的缺点：" class="headerlink" title="连续内存分配的缺点："></a>连续内存分配的缺点：</h3><p>​分配给一个程序的物理内存是连续的、内存利用率较低、有外、内部碎片的问题</p><h3 id="非连续内存分配的优点："><a href="#非连续内存分配的优点：" class="headerlink" title="非连续内存分配的优点："></a>非连续内存分配的优点：</h3><ul><li>更好的内存利用和管理</li><li>允许共享代码与数据</li><li>支持动态加载和动态链接</li></ul><h3 id="非连续内存分配的缺点："><a href="#非连续内存分配的缺点：" class="headerlink" title="非连续内存分配的缺点："></a>非连续内存分配的缺点：</h3><ul><li>如何建立虚拟地址与物理地址之间的联系<ul><li>硬件方案<ul><li>分段(分段和分页的区别：段的大小可以改变、页的大小是固定的)</li><li>分页</li></ul></li><li>软件方案(开销大，不展开讨论)</li></ul></li></ul><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><h4 id="程序的分段地址空间"><a href="#程序的分段地址空间" class="headerlink" title="程序的分段地址空间"></a>程序的分段地址空间</h4><p>​有堆、栈、各种部分  逻辑空间是连续的，但实际上物理地址空间毫无关联(跟分配策略有关)</p><h4 id="分段寻址方案"><a href="#分段寻址方案" class="headerlink" title="分段寻址方案"></a>分段寻址方案</h4><h5 id="段访问机制："><a href="#段访问机制：" class="headerlink" title="段访问机制："></a>段访问机制：</h5><p>​s + addr （段号 + 段内偏移）多地址空间</p><p>​s与addr一起存 单地址空间</p><p>​s通过 <strong>segment table(段表)</strong> 根据段号 查询 段所对应的物理地址，再加上偏移量就 &#x3D; 物理地址段表由OS建立</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><ul><li>逻辑空间：页物理页面：帧</li><li>物理内存被分成大小相同的帧</li></ul><p>一个程序的逻辑地址空间被划分为大小相等的页</p><p>​<strong>🌟(页内偏移大小&#x3D;帧内偏移大小；页号大小 !&#x3D; 帧号大小{在页表中，通过页号得到帧号})</strong></p><ul><li>页映射到帧</li><li>页是连续的虚拟内存</li><li>帧是非连续的物理内存</li><li>不是所有的页都有对应的帧</li></ul><h4 id="分页地址空间"><a href="#分页地址空间" class="headerlink" title="分页地址空间"></a>分页地址空间</h4><p>​帧的物理地址&#x3D;帧号 + 帧内偏移</p><h4 id="页寻址方案——页表"><a href="#页寻址方案——页表" class="headerlink" title="页寻址方案——页表"></a>页寻址方案——页表</h4><h5 id="分页机制性能问题："><a href="#分页机制性能问题：" class="headerlink" title="分页机制性能问题："></a>分页机制性能问题：</h5><h6 id="访问一个内存单元需要2次内存访问"><a href="#访问一个内存单元需要2次内存访问" class="headerlink" title="访问一个内存单元需要2次内存访问"></a>访问一个内存单元需要2次内存访问</h6><p>​        1.用于获取页表项</p><p>​2.根据获得的页表项访问数据</p><h6 id="页表可能非常大"><a href="#页表可能非常大" class="headerlink" title="页表可能非常大"></a>页表可能非常大</h6><h5 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h5><h6 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h6><p>​TLB：缓存近期访问的页-帧转换表项(TLB存于Cache中)</p><h6 id="间接访问"><a href="#间接访问" class="headerlink" title="间接访问"></a>间接访问</h6><p>​二级、多级页表：多次寻址速度降低，但是缩减了页表(时间换空间，但是可以通过TLB提速！)</p><h6 id="反向页表-说实话没听明白，先挖个坑，回顾时填上"><a href="#反向页表-说实话没听明白，先挖个坑，回顾时填上" class="headerlink" title="反向页表(说实话没听明白，先挖个坑，回顾时填上)"></a><u>反向</u>页表(说实话没听明白，先挖个坑，回顾时填上)</h6><p>​程序的地址空间很大时，逻辑地址空间会大于内存的物理地址空间</p><p>​这时 我们<u>不是让页表与逻辑地址空间的大小相对应</u>，而是<strong>让页表与物理地址空间的大小相对应</strong></p><p>​利：</p><ul><li><p>转换表的大小相对于物理内存来说很小</p></li><li><p>转换表的大小跟逻辑地址空间的大小无关</p><p>弊：</p></li><li><p>需要的信息对调了，即现在只能根据帧号找到页号</p></li><li><p>如何转换回来？即如何根据页号找到帧号？</p></li><li><p>需要在反向页表中搜索想要的页号</p></li></ul><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*如何实现呢？</span></span><br><span class="line"><span class="comment">*对页号做hash计算，为了在“帧表”中获取对应的帧号</span></span><br><span class="line"><span class="comment">*页i被放置在“帧表”中f(i)的位置 #f为hash函数</span></span><br><span class="line"><span class="comment">*为了查找页i，执行以下操作：</span></span><br><span class="line"><span class="comment">*对于页i，计算f(i)并使用它作为页寄存器表的索引，获取对应的页寄存器</span></span><br><span class="line"><span class="comment">*检查寄存器标签是否包含i，如果包含，则代表成功获取帧号，否则失败。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Chapter5-虚拟内存"><a href="#Chapter5-虚拟内存" class="headerlink" title="Chapter5 虚拟内存"></a>Chapter5 虚拟内存</h2><h3 id="覆盖技术："><a href="#覆盖技术：" class="headerlink" title="覆盖技术："></a>覆盖技术：</h3><p>​为了在较小的内存中运行较大的程序，常用于多道程序系统，与分区存储管理配合使用</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h4><p>目标：把程序按照其自身逻辑结构，划分为若干个功能上相对独立的程序模块那些不会同时执行的模块共享同一块内存区域，按时间先后来运行。</p><ul><li><p>必要部分 (常用功能)的代码和数据<strong>常驻内存</strong></p></li><li><p>可选部分(不常用功能)在其他程序模块中实现,<u><em>平时存放在外存中，在需要用到时才装入内存</em></u>;</p><ul><li>不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖,即这些模块共用一个分区。</li></ul></li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>程序的划分复杂，费时费力</li><li>经常性的从外存读取数据，实际上是时间换空间</li><li>需要程序员自己把整个程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，增加了程序员的负担;</li></ul><h3 id="交换技术："><a href="#交换技术：" class="headerlink" title="交换技术："></a>交换技术：</h3><p>​多道程序在内存中时,让正在运行的程序或需要运行的程序获得更多的内存资源。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理:"></a>原理:</h4><ul><li>​可将暂时不能运行的程序送到外存，从而获得空闲内存空间。</li><li>​操作系统把一个进程的整个地址空间的内容保存到外存中(换出swap out)，而将外存中的某个进程的地址空间读入到内存中(换入swap in)。换入换出内容的大小为整个程序的地址空间。</li></ul><p></p><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><ul><li>何时交换？<ul><li>只有当内存不够或者有不够的风险时进行交换</li></ul></li><li>交换区的大小<ul><li>必须足够存放用户进程中所有内存映像的拷贝</li><li>必须能对这些内存映像进行直接存取</li></ul></li><li>交换技术:以进程作为交换的单位，需要把进程的整个地址空间都换进换出，增加了处理器的开销。</li></ul><h3 id="覆盖与交换的比较："><a href="#覆盖与交换的比较：" class="headerlink" title="覆盖与交换的比较："></a>覆盖与交换的比较：</h3><p><strong>覆盖技术</strong>只能发生在那些相互之间没有调用关系的程序模块之间。因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构。(移动的最小粒度为一个程序)</p><p><strong>交换技术</strong>是以在内存中的程序大小为单位来进行的，它不需要程序员给出各个模块之间的逻辑覆盖结构。(移动的最小粒度为程序的一个子模块)</p><p>换言之，交换发生在内存中程序与管理程序或操作系统之间，而覆盖则发生在运行程序的内部。</p><h3 id="虚存技术："><a href="#虚存技术：" class="headerlink" title="虚存技术："></a>虚存技术：</h3><p>像覆盖技术那样，<u>不是把程序的所有内容都放在内存中</u>，因而能够运行比当前的空闲内存空间还要大的程序。但做得更好，由<u>操作系统自动来完成，无须程序员的干涉;</u></p><p>像交换技术那样，能够实现进程在内存与外存之间的交换，因而获得更多的空闲内存空间。但做得更好，<u>只对进程的部分内容在内存和外存之间进行交换。</u></p><h4 id="程序的局部性原理-principle-of-locality"><a href="#程序的局部性原理-principle-of-locality" class="headerlink" title="程序的局部性原理(principle of locality):"></a>程序的局部性原理(principle of locality):</h4><p>​指程序在执行过程中的<strong>一个较短时期</strong>，所执行的指令地址和指令的操作数地址，分别<strong>局限于一定区域</strong>。这可以表现为:</p><ul><li><u>时间局部性</u>:一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内;</li><li><u>空间局部性</u>:当前指令和邻近的几条指令，当前访问的数据和邻近的几个数据都集中在一个较小区域内。</li></ul><p>程序的局部性原理表明，从理论上来说，虚拟存储技术是能够实现的，而且在实现了以后应该是能够取得一个满意的效果的。</p><h4 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h4><p>​可以在页式或段式内存管理的基础上实现</p><ul><li><p>在装入程序时，不必将其全部装入到内存，而只需将当前需要执行的部分页面或段装入到内存，就可让程序开始执行；</p></li><li><p>在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序；</p></li><li><p>另一方面，操作系统将内存中暂时不使用的页面或段调出保存在外存上，从而腾出更多空闲空间存放将要装入的程序以及将要调入的页面或段。</p></li></ul><h4 id="基本特征："><a href="#基本特征：" class="headerlink" title="基本特征："></a>基本特征：</h4><ul><li><p>大的用户空间：通过把物理内存与外存相结合，提供给用户的虚拟内存空间通常大于实际的物理内存，即实现了这两者的分离。如32位的虚拟地址理论上可以访问4GB，而可能计算机上仅 有256M的物理内存，但硬盘容量大于4GB。</p></li><li><p>部分交换：与交换技术相比较，虚拟存储的调入和调出是对部分虛拟地址空间进行的：</p></li><li><p>不连续性：物理内存分配的不连续，虚拟地址空间使用的不连续。</p></li></ul><h4 id="虚拟页式内存管理："><a href="#虚拟页式内存管理：" class="headerlink" title="虚拟页式内存管理："></a>虚拟页式内存管理：</h4><ul><li><p>大部分虚拟存储系统都采用虚拟页式存储管理技术，即在<strong>页式存储管理</strong>的基础上，<strong>增加</strong><u>请求调页和页面置换功能</u>。</p></li><li><p>基本思路：</p><ul><li>当一个用户程序要调入内存运行时，<u>不是将该程序的所有页面都装入内存，而是只装入部分的页面</u>，就可启动程序运行。</li><li>在运行的过程中，如果发现要运行的程序或要访问数据<u>不在内存，则向系统发出缺页中断请求</u>，系统在处理这个中断时，将外存中相应的页面调入内存，使得该程序能够继续运行。</li></ul></li></ul><h5 id="页表表项需要增加："><a href="#页表表项需要增加：" class="headerlink" title="页表表项需要增加："></a>页表表项需要增加：</h5><ol><li><strong>驻留位：1表示该页在内存中；0表示在外存中</strong></li><li><strong>保护位</strong>：表示允许对该页做何种类型的访问，如只读、可读写、可执行等</li><li><strong>修改位</strong>：表明此页在内存中是否被修改过。若修改过，在回收此页时需要把这个页的内容同步到外存。</li><li><strong>访问位</strong>：如果最近被访问过，置为1；用于页面置换算法</li></ol><h5 id="缺页中断处理过程："><a href="#缺页中断处理过程：" class="headerlink" title="缺页中断处理过程："></a>缺页中断处理过程：</h5><ol><li><p>如果在内存中有空闲的物理页面，则分配一物理页帧f，然后转第4步：否则转第2步：</p></li><li><p>采用某种页面置换算法，选择一个将被替换的物理页帧f，它所对应的逻辑页为q。如果该页在内存期间被修改过，则需把它写回外存；</p></li><li><p>对q所对应的页表项进行修改，把驻留位置为0；</p></li><li><p>将需要访问的页p裝入到物理页面f当中；</p></li><li><p>修改p所对应的页表项的内容，把驻留位置为1，把物理页帧号置为f</p></li><li><p>重新运行被中断的指令。</p></li></ol><h5 id="后备存储-Backing-Store"><a href="#后备存储-Backing-Store" class="headerlink" title="后备存储 Backing Store"></a>后备存储 Backing Store</h5><h6 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h6><ul><li><p>一个虚拟地址空间的页面可以被映射到一个文件（在二级存储中）中的某个位置</p></li><li><p>代码段：映射到可执行二进制文件</p></li><li><p>动态加载的共享库程序段：映射到动态调用的库文件</p></li><li><p>其它段：可能被映射到交换文件(swap file)</p></li></ul><p>​在何处保存未被映射的页？</p><ul><li><p>能够简单地识别在二级存储器中的页</p></li><li><p>交换空间（磁盘或者文件）：特殊格式，用于存储末被映射的页面</p></li></ul><h2 id="Chapter6-页面置换算法"><a href="#Chapter6-页面置换算法" class="headerlink" title="Chapter6 页面置换算法"></a>Chapter6 页面置换算法</h2><h3 id="局部页面置换算法"><a href="#局部页面置换算法" class="headerlink" title="局部页面置换算法"></a>局部页面置换算法</h3><h4 id="功能与目标"><a href="#功能与目标" class="headerlink" title="功能与目标"></a>功能与目标</h4><p><strong>功能</strong>：缺页，但主存满了，换谁出去？</p><p><strong>目标</strong>：<strong>尽可能减少页面更换的次数</strong>，(通常在局部性原理指导下依据过去的统计数据进行预测)</p><p>&lt;页面锁定&gt;:有些页面必须常驻于内存中，不应参与页面置换算法。(通过在页表中添加 ‘锁定标志位,lock bit’ 判断)</p><h4 id="6-1最优页面置换算法"><a href="#6-1最优页面置换算法" class="headerlink" title="6.1最优页面置换算法"></a>6.1最优页面置换算法</h4><p>​是一种理想情况下的页面置换算法, 该算法使用的前提是OS提前知道接下来要访问的页面，换出近期最不会被用到的页面。</p><p>无实际意义，但可以用于评价别的算法的性能，作为一个理想的标杆</p><h4 id="6-2FIFO算法"><a href="#6-2FIFO算法" class="headerlink" title="6.2FIFO算法"></a>6.2FIFO算法</h4><p>系统维护一个页面的链表，<strong>每次淘汰驻留时间最长的页面</strong>(一个已经在链表中的页面再次被使用并不会刷新该页面的驻留时间，而是继续按原来的计时)</p><p><strong>性能较差</strong>，调出的页面可能是经常被调用的页面，并且有**<u><em>Belady现象</em></u>**</p><h4 id="6-3最近最久未使用算法-LRU"><a href="#6-3最近最久未使用算法-LRU" class="headerlink" title="6.3最近最久未使用算法(LRU)"></a>6.3最近最久未使用算法(LRU)</h4><p>当缺页中断发生时，选择淘汰最久未使用的页面（根据历史，推测未来，依据程序的访问具有局部性</p><p>​LRU算法需要记录每个页面使用时间的先后顺序，<u><strong>开销比较大</strong></u></p><p>两种可能的实现方法：</p><ul><li>维护一个链表，运行新页面：则放在链表头；运行链表中出现过的页面：将该结点移动到链表头部；若要淘汰页面，则删除队尾的页面。</li><li>维护一个栈，刚使用的页面放在栈顶，如果栈中已经有该页面则还需要将栈中记录删去，若要淘汰页面，则删除栈底部的页面(ps:没啥区别啊)</li></ul><h4 id="6-4时钟页面置换算法"><a href="#6-4时钟页面置换算法" class="headerlink" title="6.4时钟页面置换算法"></a>6.4时钟页面置换算法</h4><ul><li>clock页面置换算法，LRU的近似，是对FIFO的一种改进：</li></ul><h5 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h5><ul><li><p>﻿﻿需要用到页表项当中的访问位，当一个页面被装入内存时，把该位初始化为0。然后如果这个页面被访问（读&#x2F;写)，则把该位置为1;</p></li><li><p>﻿把各个页面组织成环形链表（类似钟表面），把指针指向最老的页面（最<br> 先进来）；</p></li><li><p>当发生一个缺页中断时，考察指针所指向的最老页面，若它的访问位为0，立即淘汰：若访问位为1，则把该位置为0，然后指针往下移动一格。如此下去，直到找到被淘汰的页面，然后把指针移动到它的下一格。</p></li></ul><h4 id="6-5二次机会法"><a href="#6-5二次机会法" class="headerlink" title="6.5二次机会法"></a>6.5二次机会法</h4><p><strong>添加脏位</strong>(用于标识有没有被写过)，如果被淘汰的页只被读过，则直接删除；如果该页面被修改过，就需要将更新的数据同步至硬盘。</p><p>用访问位、脏位两个位来判断被淘汰的页面，只有都为0的页面才会立即被淘汰，有1的页面会首先失去一个1，幸免于本轮循环。(脏位由1变0时，也需要写回硬盘)</p><p>给修改过的页面更多的机会留在主存中(<u>其实只针对一种情况：访问位、脏位都为1时，页面被循环轮到后会先把访问位置为0，而不是改变脏位，这样就相当于给这个页面多一条命！</u>)——通过减少写回硬盘的次数来降低开销</p><h4 id="6-6最不常用法"><a href="#6-6最不常用法" class="headerlink" title="6.6最不常用法"></a>6.6最不常用法</h4><p>Least frequency used LFU:</p><h5 id="基本思路：-1"><a href="#基本思路：-1" class="headerlink" title="基本思路："></a>基本思路：</h5><p>​当一个缺页中断产生时，选择被访问次数最少的页面淘汰</p><p>​给主存中的每个页都安排一个计数器，淘汰计数器值最小的页面</p><p>缺点：计数器开销大</p><h4 id="6-7Belady现象"><a href="#6-7Belady现象" class="headerlink" title="6.7Belady现象"></a>6.7Belady现象</h4><p>​在采用FIFO算法时，有时会出现分配的物理页面数增加，缺页率反而提高的现象；</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230605214433150.png" alt="image-20230605214433150" style="zoom:30%;" /><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230605214507498.png" alt="image-20230605214507498" style="zoom:31%;" /><h4 id="6-8局部页面替换算法的问题、工作集模型"><a href="#6-8局部页面替换算法的问题、工作集模型" class="headerlink" title="6.8局部页面替换算法的问题、工作集模型"></a>6.8局部页面替换算法的问题、工作集模型</h4><p><strong>工作集：一个进程当前正在使用的逻辑页面集合，可以用一个二元函数w(t，∆)来表示</strong></p><ul><li><p>t是当前的执行时刻；</p></li><li><p>∆称为工作集窗口 (working set window），即一个定长的页面访问的时同窗口：</p></li><li><p>w(t，∆)一在当前时刻 t 之前的 ∆时间窗口当中的所有页面所组成的集合(随着 t 的变化，该集合也在不断地变化）</p></li><li><p>|w(t，∆）|指工作集的大小，即页面数目。</p></li></ul><p><strong>常驻集：是指在当前时刻，进程实际驻留在内存当中的页面集合。</strong></p><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ol><li><p>工作集是进程在运行过程中固有的性质，而常驻集取决于系统分配给进程的物理页面数日，以及所采用的页面置换算法；</p></li><li><p>如果一个进程的整个工作集都在内存当中，即常驻集&gt;&#x3D;工作集，那么进程将很顺利地运行，而不会造成太多的缺页中断（直到工作集发生剧烈变动，从而过渡到另一个状态）</p></li><li><p>当进程常驻集的大小达到某个数目之后，再给它分配更多的物理页面，缺页率也不会明显下降。</p></li></ol><h3 id="全局页面置换算法："><a href="#全局页面置换算法：" class="headerlink" title="全局页面置换算法："></a>全局页面置换算法：</h3><h4 id="1-工作集页面置换算法"><a href="#1-工作集页面置换算法" class="headerlink" title="1.工作集页面置换算法"></a>1.工作集页面置换算法</h4><p>​如果页面不在工作集中，那么即使没有发生缺页中断，也会把该页面换出。</p><p>​每次都看看自己的常驻集和工作集，常驻集里有，但工作集中没有的页面都会被移除</p><h4 id="2-缺页率页面置换算法"><a href="#2-缺页率页面置换算法" class="headerlink" title="2.缺页率页面置换算法"></a>2.缺页率页面置换算法</h4><h5 id="可变分配策路："><a href="#可变分配策路：" class="headerlink" title="可变分配策路："></a>可变分配策路：</h5><p>​常驻集大小可变，例如：每个进程在刚开始运行的时候，先根据程序大小给它分配一定数目的物理页面，然后在进程运行过程中，再<u>动态地调整常驻集的大小</u>。</p><ul><li>可采用全局页面置换的方式。当发生一个缺页中断时，被置换的页面可以是在其它进程当中，各个并发进程竞争地使用物理页面。</li><li>优缺点：性能较好。但增加了系统开销。</li><li>具体实现：可以使用<strong>缺页率算法</strong> (PPF, page fault freguency)来动态调整常驻集的大小。</li></ul><p><strong>🌟如何动态地调整常驻集的大小？</strong></p><p>​设置一个阈值k，将本次发生缺页的下标 - 上次发生缺页的下标 与 k 进行比较，</p><ul><li><p>如果k比较大，说明中断异常出现的太频繁了，直接将缺失页加入到工作集中(扩大工作集，降低缺页概率)</p></li><li><p>如果k比较小，说明不怎么出现中断，那么执行下述操作：将工作集中不在[t_last, t_current]区间内出现的页面移除   (t_last, t_current指上一次、这次出现中断异常的时间下标)</p></li></ul><h3 id="抖动问题："><a href="#抖动问题：" class="headerlink" title="抖动问题："></a>抖动问题：</h3><ul><li>﻿如果分配给一个进程的物理页面太少，不能包含整个的工作集，即常驻集＜ 工作集，那么进程将会造成很多的缺页中断，需要频繁地在内存与外存之间替换页面，从而使进程的运行速度变得很慢，我们把这种狀态称为 “抖动”。</li><li>﻿产生抖动的原因：随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减小，导致缺页率不断上升。所以<strong>os要选择一个适当的进程数目和进程需要的帧数</strong>，以便在并发水平和缺页率之间达到一个平衡。</li></ul><p>抖动问题在一些情况下可以被本地的页面置换算法改善</p><h2 id="Chapter7-进程和线程"><a href="#Chapter7-进程和线程" class="headerlink" title="Chapter7 进程和线程"></a>Chapter7 进程和线程</h2><h3 id="7-1进程-process-的描述"><a href="#7-1进程-process-的描述" class="headerlink" title="7.1进程(process)的描述"></a>7.1进程(process)的描述</h3><h4 id="进程定义："><a href="#进程定义：" class="headerlink" title="进程定义："></a>进程定义：</h4><p>​一个具有一定功能的程序在一个数据集合上的一次动态执行的过程</p><h4 id="进程组成："><a href="#进程组成：" class="headerlink" title="进程组成："></a>进程组成：</h4><p>包含了一个正在运行的程序的所有状态信息</p><pre><code>        1. 程序的代码        1. 程序处理的数据        1. 程序计数器的值，指示下一条即将运行的指令        1. 一组通用的寄存器的当前值，堆、栈        1. 一组系统资源(如打开的程序)</code></pre><h5 id="进程与程序的联系："><a href="#进程与程序的联系：" class="headerlink" title="进程与程序的联系："></a>进程与程序的联系：</h5><ul><li>﻿程序是产生进程的基础</li><li>﻿<u>程序的每次运行构成不同的进程</u></li><li>﻿进程是程序功能的体现</li><li>﻿通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序。</li></ul><h5 id="进程与程序的区别："><a href="#进程与程序的区别：" class="headerlink" title="进程与程序的区别："></a>进程与程序的区别：</h5><ul><li><p>进程是动态的，程序是静态的：程序是有序代码的集合；进程是程序的执行，进程有核心态&#x2F;用户态</p></li><li><p>进程是暂时的，程序的永久的：进程是一个状态变化的过程，程序可长久保存</p></li><li><p>进程与程序的组成不同：进程的组成包括**<u>程序、数据和进程控制块</u>**（即进程状态信息）</p></li></ul><h4 id="进程的特点："><a href="#进程的特点：" class="headerlink" title="进程的特点："></a>进程的特点：</h4><ul><li>﻿动态性：可动态地创建、结束进程；</li><li>﻿并发性：进程可以被独立调度并占用处理机运行；(并发-&gt;串、并行-&gt;并)</li><li>﻿独立性：不同进程的工作不相互影响：</li><li>﻿制约性：因访问共享数据&#x2F;资源或进程间同步而产生制约。</li></ul><h4 id="进程控制结构："><a href="#进程控制结构：" class="headerlink" title="进程控制结构："></a>进程控制结构：</h4><p>​程序 &#x3D; 算法 + 数据结构</p><p>​描述进程的数据结构：<strong>进程控制块</strong>(Process Control Block, PCB)</p><p>进程控制块：OS管理进程运行所用信息的集合，OS用PCB描述<u>进程的基本情况及运行变化的过程</u>，PCB是进程存在的<strong>唯一标志。</strong></p><h5 id="PCB中包含的内容："><a href="#PCB中包含的内容：" class="headerlink" title="PCB中包含的内容："></a>PCB中包含的内容：</h5><ol><li><p><strong>进程标识信息</strong>。如本进程的标识，本进程的产生者标识(父进程标识)；用户标识。</p></li><li><p><strong>处理机状态信息保存区</strong>。保存进程的运行现场信息：</p><ul><li><p>﻿用户可见寄存器，用户程序可以使用的数据，地址等寄存器。</p></li><li><p>﻿控制和状态寄存器，如程序计数器(PC)，程序状态字 (PSW)。</p></li><li><p>﻿栈指针，过程调用&#x2F;系统调用&#x2F;中断处理和返回时需要用到它。</p></li></ul></li><li><p><strong>进程控制信息</strong></p></li></ol><ul><li><p>调度和状态信息，用于操作系统调度进程并占用处理机使用。</p></li><li><p>进程间通信信息，为支持进程问的与通信相关的各种标识、信号、信件等，这些信息存在接收方的进程控制块中。</p></li><li><p>存储管理信息，包含有指向本进程映像存储空间的数据结构。</p></li><li><p>﻿进程所用资源，说明由进程打开、使用的系统资源，如打开的文件等。</p></li><li><p>﻿有关数据结构连接信息，进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB。</p></li></ul><h5 id="PCB的组织方式"><a href="#PCB的组织方式" class="headerlink" title="PCB的组织方式"></a>PCB的组织方式</h5><ul><li>链表(常用)：同一状态的进程其PCB成一链表，多个状态对应多个不同的链表</li></ul><p>各状态的进程形成不同的链表：就绪链表、阻塞链表</p><ul><li>索引表：同一状态的进程归入一个index表（由index指向PCB)，多个状态对应多个不同的index表</li></ul><p>各状态的进行形成不同的索引表：就绪索引表、阻塞索引表</p><h3 id="7-2进程状态"><a href="#7-2进程状态" class="headerlink" title="7.2进程状态"></a>7.2进程状态</h3><h4 id="进程生命周期管理"><a href="#进程生命周期管理" class="headerlink" title="进程生命周期管理"></a>进程生命周期管理</h4><h5 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h5><h6 id="引起进程创建的三个主要事件："><a href="#引起进程创建的三个主要事件：" class="headerlink" title="引起进程创建的三个主要事件："></a>引起进程创建的三个主要事件：</h6><pre><code>    1. 系统初始化时(创建init进程)    2. **用户请求**创建一个新进程    3. 正在运行的**进程执行**了创建进程的系统调用</code></pre><h5 id="进程运行"><a href="#进程运行" class="headerlink" title="进程运行"></a>进程运行</h5><h6 id="内核选择一个就绪的进程，让它占用处理机并执行"><a href="#内核选择一个就绪的进程，让它占用处理机并执行" class="headerlink" title="内核选择一个就绪的进程，让它占用处理机并执行"></a>内核选择一个就绪的进程<strong>，让它占用处理机</strong>并执行</h6><h5 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h5><h6 id="以下情况下，进程等待："><a href="#以下情况下，进程等待：" class="headerlink" title="以下情况下，进程等待："></a>以下情况下，进程等待：</h6><ol><li>﻿<strong>请求并等待系统服务</strong>，无法马上完成</li><li>﻿<strong>启动某种操作</strong>，无法马上完成</li><li>﻿<strong>需要的数据没有到达</strong></li></ol><p><u>进程只能自己阻塞自己，因为只有进程自身才能知道何时需要等待某种事件的发生。</u></p><h5 id="进程唤醒"><a href="#进程唤醒" class="headerlink" title="进程唤醒"></a>进程唤醒</h5><h6 id="唤醒进程的原因："><a href="#唤醒进程的原因：" class="headerlink" title="唤醒进程的原因："></a>唤醒进程的原因：</h6><ol><li>﻿被阻塞进程需要的资源可被满足</li><li>﻿被阻塞进程等待的事件到达</li><li>﻿将该进程的PCB插入到就绪队列</li></ol><p><u>进程只能被别的进程或操作系统唤醒。</u></p><h5 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h5><h6 id="在以下四种情形下，进程结束："><a href="#在以下四种情形下，进程结束：" class="headerlink" title="在以下四种情形下，进程结束："></a>在以下四种情形下，进程结束：</h6><ul><li><p>正常退出（自愿的）</p></li><li><p>错误退出（自愿的）</p></li><li><p>致命错误（强制性的）</p></li><li><p>被其他进程所杀（强制性的）</p></li></ul><h4 id="进程状态变化模型"><a href="#进程状态变化模型" class="headerlink" title="进程状态变化模型"></a>进程状态变化模型</h4><h5 id="进程的三种基本状态："><a href="#进程的三种基本状态：" class="headerlink" title="进程的三种基本状态："></a>进程的三种<u>基本</u>状态：</h5><p>​进程在生命结束前处于且仅处于三种基本状态之一</p><ul><li><p>运行状态(Running)：当一个进程正在处理机上运行时。</p></li><li><p>就绪状态(Ready)：一个进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。</p></li><li><p>等待状态（又称阻塞状态Blocked)：一个进程正在等待某一事件而暂停运行时。如等待某资源，等待输入&#x2F;输出完成。</p></li></ul><h5 id="进程其它的基本状态："><a href="#进程其它的基本状态：" class="headerlink" title="进程其它的基本状态："></a>进程其它的基本状态：</h5><ul><li><p>创建状态(New)：一个进程正在被创建，还没被转到就绪状态之前的状态。</p></li><li><p>结束状态(Exit)：一个进程正在从系统中消失时的状态，这是因为进程结束或由于其他原因所导致。</p></li></ul><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230606110651191.png" alt="image-20230606110651191" style="zoom:50%;" /><h4 id="进程挂起模型"><a href="#进程挂起模型" class="headerlink" title="进程挂起模型"></a>进程挂起模型</h4><p> 进程挂起：进程不占用内存空间，处于挂起状态的进程映像在磁盘上。</p><h5 id="挂起状态："><a href="#挂起状态：" class="headerlink" title="挂起状态："></a>挂起状态：</h5><ul><li>﻿阻塞挂起状态 (Blocked-suspend）：进程在外存并<strong>等待某事件的出现</strong>；</li><li>﻿就绪挂起状态 (Ready-suspend）：进程在外存，但<strong>只要进入内存，即可运行</strong>；</li></ul><h5 id="挂起-Suspend）：把一个进程从内存转到外存；可能有以下几种情况："><a href="#挂起-Suspend）：把一个进程从内存转到外存；可能有以下几种情况：" class="headerlink" title="挂起 (Suspend）：把一个进程从内存转到外存；可能有以下几种情况："></a>挂起 (Suspend）：把一个进程从内存转到外存；可能有以下几种情况：</h5><ul><li><p>﻿阻塞到阻塞挂起：没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以提交新进程或运行就绪进程；</p></li><li><p>﻿就绪到就绪挂起：当有高优先级阻塞(系统认为会很快就绪的）进程和低优先就绪进程时，系统会选择挂起低优先级就绪进程；</p></li><li><p>﻿运行到就绪挂起：对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态；</p></li></ul><h5 id="在外存时的状态转换："><a href="#在外存时的状态转换：" class="headerlink" title="在外存时的状态转换："></a>在外存时的状态转换：</h5><ul><li>﻿阻塞挂起到就绪挂起：当有阻塞挂起进程因相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程。</li></ul><h5 id="解挂-x2F-激活-Activate）：把一个进程从外存转到内存；可能有以下几种情况："><a href="#解挂-x2F-激活-Activate）：把一个进程从外存转到内存；可能有以下几种情况：" class="headerlink" title="解挂&#x2F;激活 (Activate）：把一个进程从外存转到内存；可能有以下几种情况："></a>解挂&#x2F;激活 (Activate）：把一个进程从外存转到内存；可能有以下几种情况：</h5><ul><li>﻿就绪挂起到就绪：没有就绪进程或挂起就绪进程优先级高于就绪进程时，会进行这种转换；</li><li>﻿阻塞挂起到阻塞：当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起（系统认为会很快出现所等待的事件）进程转换为阻塞进程；</li></ul><h5 id="OS如何通过PCB完成进程的调度？"><a href="#OS如何通过PCB完成进程的调度？" class="headerlink" title="OS如何通过PCB完成进程的调度？"></a>OS如何通过PCB完成进程的调度？</h5><h6 id="🌟状态队列"><a href="#🌟状态队列" class="headerlink" title="🌟状态队列"></a>🌟状态队列</h6><ul><li><p>﻿由操作系统来维护一组队列，用来表示系统当中所有进程的当前状态；</p></li><li><p>﻿<u><strong>不同的状态分别用不同的队列来表示</strong></u>(就绪队列、各种类型的阻塞队列）；</p></li><li><p>每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生变化时，它的PCB从一个状态队列中脱离出来，加入到另外一个队列。</p></li></ul><h3 id="7-3线程"><a href="#7-3线程" class="headerlink" title="7.3线程"></a>7.3线程</h3><h4 id="为什么需要线程？"><a href="#为什么需要线程？" class="headerlink" title="为什么需要线程？"></a>为什么需要线程？</h4><p>​处理并行操作时，如果使用<strong>多进程</strong>方式，会导致开销巨大(进程占用资源、进程切换占用时间、进程共享数据产生开销)</p><p>​因此，我们亟需提出一种实体，满足：1）实体之间可以并发运行；2）实体之间共享地址空间</p><p>​于是 <strong>线程</strong> 被提出！</p><h4 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h4><p>​＞<em>进程当中的一条执行流程。</em></p><p>从两个方面来重新理解进程</p><ul><li>﻿从资源组合的角度：<strong>进程</strong>把一组相关的资源组合起来，<strong>构成了一个资源平台（环境）</strong>，包括地址空间（代码段、数据段）、打开的文件等各种资源；</li><li>﻿从运行的角度：代码在这个资源平台上的一条执行流程（线程）。</li></ul><h5 id="线程的优点："><a href="#线程的优点：" class="headerlink" title="线程的优点："></a>线程的优点：</h5><ul><li>﻿一个进程中可以同时存在多个线程；</li><li>﻿各个线程之间可以并发地执行；</li><li>﻿各个线程之间可以共享地址空间和文件等资源。</li></ul><h5 id="线程的缺点："><a href="#线程的缺点：" class="headerlink" title="线程的缺点："></a>线程的缺点：</h5><ul><li><strong>一个线程崩溃，会导致其所属进程的所有线程崩溃</strong>。(因为线程间共享数据，因此一个线程的数据错误了，其他线程都要遭殃)</li></ul><h5 id="线程所需的资源："><a href="#线程所需的资源：" class="headerlink" title="线程所需的资源："></a>线程所需的资源：</h5><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230606161910704.png" alt="image-20230606161910704" style="zoom:50%;" /><h5 id="线程与进程的比较"><a href="#线程与进程的比较" class="headerlink" title="线程与进程的比较"></a>线程与进程的比较</h5><ul><li><p>﻿进程是资源分配单位，线程是CPU调度单位；</p></li><li><p>﻿进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</p></li><li><p>﻿线程同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系；</p></li><li><p>﻿线程能减少并发执行的时间和空间开销：</p><ul><li><p>线程的创建时间比进程短；(线程无需创建代码块、数据、文件的管理信息)</p></li><li><p>线程的终止时间比进程短；(线程无需创建代码块、数据、文件的管理信息)</p></li><li><p>同一进程内的线程切换时间比进程短；(在同一进程中的线程具有同一个页表，切换时无需切换页表)</p></li><li><p>由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信；</p></li></ul></li></ul><h4 id="线程的实现："><a href="#线程的实现：" class="headerlink" title="线程的实现："></a>线程的实现：</h4><p>​三种主要的实现方式：</p><pre><code> 1. 用户线程：在用户空间实现 2. 内核线程：在内核中实现 3. 轻量级线程：在内核中实现，支持用户线程</code></pre><h5 id="🌟用户线程："><a href="#🌟用户线程：" class="headerlink" title="🌟用户线程："></a>🌟用户线程：</h5><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230606163157885.png" alt="image-20230606163157885" style="zoom:50%;" /><p>OS看不到TCB，只能看到PCB，只知道进程信息，进程中的线程信息由线程库管理。</p><p>在用户空间实现的线程机制，它<strong>不依赖于操作系统的内核</strong>，<strong>由一组用户级的线程库函数来完成线程的管理</strong>，包括进程的创建、终止、同步和调度等。</p><h6 id="用户线程的优点："><a href="#用户线程的优点：" class="headerlink" title="用户线程的优点："></a>用户线程的优点：</h6><ul><li>﻿由于用户线程的维护由相应进程来完成 （通过线程库函数），不需要操作系统内核了解用户线程的存在，<u>可用于不支持线程技术的多进程操作系统；</u></li><li>﻿每个进程都需要它自己私有的线程控制块（TCB）列表，用来跟踪记录它的各个线程的状态信息 (PC、栈指针、寄存器），TCB由线程库函数来维护；</li><li>﻿用户线程的切换也是由线程库函数来完成．无需用户态&#x2F; 核心态切换，所以速度特别快；</li><li>﻿允许每个进程拥有自定义的线程调度算法。</li></ul><h6 id="用户线程的缺点："><a href="#用户线程的缺点：" class="headerlink" title="用户线程的缺点："></a>用户线程的缺点：</h6><ul><li>﻿阻塞性的系统调用如何实现？如果一个线程发起系统调用而阻塞，则整个进程在等待；(因为OS在内核态中只能管理进程，而不能单独地把进程中的某个线程阻塞)</li><li>﻿当一个线程开始运行后，除非它主动地交出CPU的使用权，否则它所在的进程当中的其他线程将无法运行；(同样，因为OS只能管理进程，因为只有OS有管理中断的权利，但是OS看不到线程)</li><li>﻿由于时间片分配给进程，故与其它进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢。</li></ul><h5 id="🌟内核线程："><a href="#🌟内核线程：" class="headerlink" title="🌟内核线程："></a>🌟内核线程：</h5><p>​<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230606164400117.png" alt="image-20230606164400117" style="zoom:50%;" /></p><p><strong>TCB也放在内核中</strong></p><p>是指在操作系统<u>的内核当中实现的一种线程机制</u>，由操作系统的内核来完成线程的创建、终止和管理。</p><ul><li>﻿在支持内核线程的操作系统中，**<u>由内核来维护进程和线程的上下文信息 （PCB和TCB）</u>**；</li><li>﻿线程的创建、终止和切换都是通过系统调用&#x2F;内核函数的方式来进行，由内核来完成，因此系统开销较大；</li><li>在一个进程当中，如果某个内核线程发起系统调用而被阳塞，井不会影响其他内核线程的运行：</li><li>时间片分配给线程，多线程的进程获得更多CPU时间；</li><li>Windows NT和windows 2000&#x2F;xP支持内核线程。</li></ul><h5 id="🌟轻量级进程-了解"><a href="#🌟轻量级进程-了解" class="headerlink" title="🌟轻量级进程(了解)"></a>🌟轻量级进程(了解)</h5><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230606164824053.png" alt="image-20230606164824053" style="zoom:30%;" /><h3 id="7-4上下文切换"><a href="#7-4上下文切换" class="headerlink" title="7.4上下文切换"></a>7.4上下文切换</h3><p>​停止当前运行进程(从运行状态改变成其他状态）并且调度其他进程（转变成运行状态）</p><ul><li>﻿必须在切换之前存储许多部分的进程上下文</li><li>﻿必须能够在之后恢复他们，所以进程不能显示它曾经被暂停过</li><li>﻿必须快速（上下文转换时非常频繁的）</li></ul><p>​需要存储什么上下文？</p><ul><li><p>寄存器(PC, SP， …)，CPU状态，……</p></li><li><p>一些时候可能会费时，所以我们应该尽可能避免</p></li></ul><h3 id="7-5进程控制"><a href="#7-5进程控制" class="headerlink" title="7.5进程控制"></a>7.5进程控制</h3><h4 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h4><p>fork函数：fork函数用于<u>从已经存在的进程中创建一个新的进程</u>。新的进程称为子进程，而原来的进程是父进程。</p><p><strong><u><em>返回值：子进程中返回0，父进程返回子进程id，出错返回-1</em></u></strong></p><p>当一个进程调用fork之后，就有两个二进制代码相同的进程。而且它们都运行到相同的地方。但每个进程都将可以开始它们自己的旅程</p><p>fork()的简单实现</p><ul><li>对子进程分配内存</li><li>复制父进程的内存和CPU寄存器到子进程</li><li>开销昂贵</li></ul><p>在99%的情况下,我们在调用fork()之后调用exec() —依据实际情况得出</p><ul><li>在fork()操作中内存复制是没有作用的（因为你fork完后立马去执行新的程序，会把你复制的东西都覆盖了</li><li>子进程将可能关闭打开的文件和连接</li><li>开销因此是最高的</li></ul><p>vfork()</p><ol><li><p>vfork用于创建一个子进程，子进程和父进程共享地址空间。(fork的子进程有独立的地址空间)</p></li><li><p>vfork保证子进程先运行，在子进程调用exec或exit之后父进程才可能被调度运行。</p></li></ol><ul><li>一个创建进程的系统调用,不需要创建一个同样的内存映像</li><li>一些时候称为轻量级fork()</li><li>子进程应该几乎立即调用exec()</li><li>现在不再使用如果我们使用 copy on write 技术(按需复制，不复制那些会被覆盖的部分，只复制进程创建必须的部分)</li></ul><h4 id="加载和执行进程"><a href="#加载和执行进程" class="headerlink" title="加载和执行进程"></a>加载和执行进程</h4><p>​exec()函数：让当前进程执行新的程序</p><p>​exec()调用允许一个进程”加载”一个不同的程序并且在main开始执行(事实上 _start)</p><p>​它允许一个进程指定参数的数量(argc)和它字符串参数数组(argv)</p><h4 id="等待和终止进程"><a href="#等待和终止进程" class="headerlink" title="等待和终止进程"></a>等待和终止进程</h4><p>​wait()系统调用 是被父进程用来等待子进程的结束</p><ul><li><p>一个子进程向父进程返回一个值，所以父进程必须接受这个值并处理</p></li><li><p>﻿wait()系统调用担任这个要求</p><ul><li><p>﻿它使父进程去睡眠来等待子进程的结果</p></li><li><p>﻿当一个子进程调用exit(的时候，操作系统解锁父进程，并且将通过exit()传递得到的返回值作为wait调用的一个结果(连同子进程的pid一起）如果这里没有子进程存活，wait()立刻返回</p></li><li><p>当然，如果这里有为父进程的僵尸等待，wait(立即返回其中一个值(并且解除僵尸状态）</p></li></ul></li><li><p>﻿进程结束执行之后，它调用exit()</p></li><li><p>﻿这个系统调用：</p><ul><li><p>﻿将这程序的 “结果” 作为一个参数</p></li><li><p>﻿关闭所有打开的文件，连接等等</p></li><li><p>﻿释放内存</p></li><li><p>﻿释放大部分支持进程的操作系统结构</p></li><li><p>﻿检查是否父进程是存活着的：</p><ul><li><p>﻿﻿如果是的话。它保留结果的值直到父进程需要它：在这种情况里。进程没有真正<br> 死亡，但是它进入了僵尸 (zombie&#x2F; defunct)状态</p></li><li><p>﻿如果没有，子进程将被init进程接管，init代替其父进程，释放其所有的数据结构</p></li></ul></li><li><p>﻿清理所有等待的僵尸进程</p></li></ul></li><li><p>﻿进程终止是最终的垃圾收集（资源回收）</p></li></ul><h4 id="进程状态图："><a href="#进程状态图：" class="headerlink" title="进程状态图："></a>进程状态图：</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230606200728246.png" alt="image-20230606200728246" style="zoom:50%;" /><h2 id="Chapter8-CPU调度"><a href="#Chapter8-CPU调度" class="headerlink" title="Chapter8 CPU调度"></a>Chapter8 CPU调度</h2><h3 id="8-1背景"><a href="#8-1背景" class="headerlink" title="8.1背景"></a>8.1背景</h3><h4 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h4><ul><li>从就绪队列中挑选一个进程&#x2F;线程作为CPU将要运行的下一个线程&#x2F;进程</li><li>调度程序：挑选进程&#x2F;线程的内核函数(通过一些调度策略)</li><li>什么时候执行调度？——线程、进程生命周期中状态的转化时，会进行调度</li></ul><p></p><h4 id="CPU调度时间"><a href="#CPU调度时间" class="headerlink" title="CPU调度时间"></a>CPU调度时间</h4><p>​满足一条即可：i): 一个进程从运行状态-&gt;等待状态; ii):一个进程被终结了</p><ul><li>不可抢占：<ul><li>调度程序必须等待事件结束</li></ul></li><li>可抢占：<ul><li>调度程序在中断被响应后执行</li><li>当前的进程从运行切换到就绪，或者一个进程从等待切换到就绪</li><li>当前运行的进程可以被换出</li></ul></li></ul><h3 id="8-2调度准则"><a href="#8-2调度准则" class="headerlink" title="8.2调度准则"></a>8.2调度准则</h3><h4 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h4><h4 id="程序执行模型"><a href="#程序执行模型" class="headerlink" title="程序执行模型"></a>程序执行模型</h4><p>​程序在CPU突发和I&#x2F;O中交替</p><ul><li>每个调度决定都是关于在下一个CPU突发时将哪个工作交给CPU</li><li>在时间分片机制下，线程可能在结束当前CPU突发前被迫放弃CPU</li></ul><h4 id="比较调度算法的准则"><a href="#比较调度算法的准则" class="headerlink" title="比较调度算法的准则"></a>比较调度算法的准则</h4><h5 id="1-CPU使用率"><a href="#1-CPU使用率" class="headerlink" title="1.CPU使用率"></a>1.CPU使用率</h5><ul><li>CPU处于忙状态所占时间的百分比</li></ul><h5 id="2-吞吐量"><a href="#2-吞吐量" class="headerlink" title="2.吞吐量"></a>2.吞吐量</h5><ul><li>在单位时间内完成的进程数量</li></ul><h5 id="3-周转时间"><a href="#3-周转时间" class="headerlink" title="3.周转时间"></a>3.周转时间</h5><ul><li><u>一个进程从初始化到结束，包括所有等待时间</u>所花费的时间</li></ul><h5 id="4-等待时间"><a href="#4-等待时间" class="headerlink" title="4.等待时间"></a>4.等待时间</h5><ul><li>进程在<u>就绪队列</u>中的总时间</li></ul><h5 id="5-响应时间"><a href="#5-响应时间" class="headerlink" title="5.响应时间"></a>5.响应时间</h5><ul><li>从一个请求<u>被提交</u>到<u>产生第一次响应</u>所花费的总时间</li></ul><p>​减少响应时间：及时处理用户的输出并且尽快将输出提供给用户</p><p>​减少平均响应时间波动：在交互系统中，可预测性比高低差异平均更重要</p><p>​增加吞吐量：i): 减少开销(操作系统开销，上下文切换) ii):系统资源的高效利用(CPU，I&#x2F;O设备)、</p><p>​减少等待时间</p><p>​低延迟利于系统与用户的交互</p><p>​即使存在许多交互任务，我们也需要保证吞吐量不受影响</p><p>​</p><h4 id="吞吐量vs延迟"><a href="#吞吐量vs延迟" class="headerlink" title="吞吐量vs延迟"></a>吞吐量vs延迟</h4><p>吞吐量是OS的计算带宽，响应时间是OS的计算延迟</p><h4 id="公平的目标"><a href="#公平的目标" class="headerlink" title="公平的目标"></a>公平的目标</h4><p>​保证每个进程占用相同的CPU时间——会增加平均响应时间(真的要设计成公平的吗？)</p><h3 id="8-3调度算法"><a href="#8-3调度算法" class="headerlink" title="8.3调度算法"></a>8.3调度算法</h3><h4 id="1-先来先服务-FCFS"><a href="#1-先来先服务-FCFS" class="headerlink" title="1.先来先服务(FCFS)"></a>1.先来先服务(FCFS)</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul><li>简单</li></ul><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>平均等待时间波动较大</li><li>花费时间少的任务可能排在花费时间长的任务后面</li><li>可能导致I&#x2F;0和CPU之间的重叠处理<ul><li>﻿CPU密集型进程会导致I&#x2F;0设备闲置时，I&#x2F;0密集型进程也在等待</li></ul></li></ul><h4 id="2-短进程优先-x2F-短剩余时间优先"><a href="#2-短进程优先-x2F-短剩余时间优先" class="headerlink" title="2.短进程优先&#x2F;短剩余时间优先"></a>2.短进程优先&#x2F;短剩余时间优先</h4><p><strong>有抢占式</strong>、<strong>非抢占式</strong>的两种方案</p><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><ul><li>最优的平均等待时间</li></ul><h5 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>可能导致饥饿<ul><li>连续的短任务流会<strong>使长任务饥饿</strong></li><li>短任务可用时，任何长任务的CPU时间都会增加平均等待时间</li></ul></li><li>需要预知未来<ul><li>我们怎么在运行进程之前就提前知道进程要运行多久？<ul><li>最简单的方法——询问用户，如果用户撒谎，就杀死进程</li><li>如果用于不能给出时间，那么OS进行预估(根据之前的记录)</li></ul></li></ul></li></ul><h4 id="3-最高响应比优先"><a href="#3-最高响应比优先" class="headerlink" title="3.最高响应比优先"></a>3.最高响应比优先</h4><p>​在2的基础上进行了改进，考虑R ( R &#x3D; (w + s) &#x2F; s ) w:等待时间 s:执行时间</p><h5 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h5><ul><li>不可抢占</li><li>关注进程等待了多长时间</li><li>防止无限期推迟</li></ul><h5 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>需要预知未来<ul><li>我们怎么在运行进程之前就提前知道进程要运行多久？<ul><li>最简单的方法——询问用户，如果用户撒谎，就杀死进程</li><li>如果用于不能给出时间，那么OS进行预估(根据之前的记录)</li></ul></li></ul></li></ul><h4 id="4-轮询-RR"><a href="#4-轮询-RR" class="headerlink" title="4.轮询(RR)"></a>4.轮询(RR)</h4><ul><li>﻿RR 花销：额外的<strong>上下文切换</strong>开销</li><li>﻿时间量子太大<ul><li>等待时间过长</li><li>极限情况退化成FCFS</li></ul></li><li>﻿时间量子太小<ul><li>反应迅速但是切换频繁，开销大</li><li>吞吐量由于大量的上下文切换开销受到影响</li></ul></li><li>﻿目标：<ul><li>选择一个合适的时间量子</li><li>经验规则：维持上下文切换开销处于1%以内</li></ul></li></ul><p>——RR的优化</p><ul><li>﻿就绪队列被划分成独立的队列：<ul><li>E.g. 前台（交互）, 后台（批处理）</li></ul></li><li>﻿每个队列拥有自己的调度策略<ul><li>E.g. 前台一RR，后台—FCFS</li></ul></li><li>﻿调度必须在队列间进行<ul><li>固定优先级</li><li>﻿先处理前台，然后处理后台</li><li>可能导致饥饿</li><li>时间切片<ul><li>每个队列都得到一个确定的能够调度其进程的CPU总时间</li><li>E.g. 80%给使用RR的前台，20%给使用FCFS的后台</li></ul></li></ul></li></ul><h4 id="5-多级反馈队列"><a href="#5-多级反馈队列" class="headerlink" title="5.多级反馈队列"></a>5.多级反馈队列</h4><ul><li>一个进程可以在不同队列中移动<ul><li>时间量子大小随优先级级别的增加而增加</li><li>如果任务在当前的时间量子中没有完成，则降到下一优先级</li></ul></li></ul><h5 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h5><ul><li>CPU密集型任务的优先级下降很快</li><li>I&#x2F;O密集型任务停留在高优先级</li></ul><h4 id="6-公平共享队列"><a href="#6-公平共享队列" class="headerlink" title="6.公平共享队列"></a>6.公平共享队列</h4><ul><li>FFS控制用户对系统资源的访问<ul><li>一些用户组比其他用户组更重要</li><li>保证不重要的组无法垄断资源</li><li>未使用的资源按照每个组所分配的资源的比例来分配</li><li>没有达到资源使用率目标的组获得更高的优先级</li></ul></li></ul><h3 id="8-4实时调度"><a href="#8-4实时调度" class="headerlink" title="8.4实时调度"></a>8.4实时调度</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>​正确性依赖于时间与功能两方面</p><p>​<u>需要保证<strong>及时性</strong></u>，速度和平均性能没那么重要</p><ul><li><p>强实时系统</p><ul><li>需要在<u>保证的时间内完成重要的任务</u>，必须完成</li></ul></li><li><p>弱实时系统</p><ul><li>要求<u>重要的进程的优先级更高</u>，尽量完成，并非必须</li></ul></li><li><p>硬时限</p><ul><li><p>如果错过了最后期限，可能会发生灾难性或非常严重的后果</p></li><li><p>必须验证：在最坏的情况下也能够满足时限吗？</p></li><li><p>保证确定性</p></li></ul></li><li><p>软时限</p><ul><li><p>理想情况下，时限应该被最大满足。如果有时限没有被满足，那么就相应地降低要求。</p></li><li><p>尽最大努力去保证</p></li></ul></li></ul><h4 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h4><p>​静态、动态优先级调度(在程序执行之前就确定进程的优先级&#x2F;在程序运行过程中，优先级会不断变化)</p><h3 id="8-5多处理器调度"><a href="#8-5多处理器调度" class="headerlink" title="8.5多处理器调度"></a>8.5多处理器调度</h3><ul><li>﻿多处理器的CPU调度更加复杂<ul><li>多个相同的单处理器组成一个多处理器</li><li>优点：负载共享</li></ul></li><li>﻿对称多处理器(SMP)<ul><li>每个处理器运行自己的调度程序</li><li>需要在调度程序中同步</li></ul></li></ul><h3 id="8-6优先级反转"><a href="#8-6优先级反转" class="headerlink" title="8.6优先级反转"></a>8.6优先级反转</h3><p>​现有优先级 T1 &lt; T2 &lt; T3，</p><p>T3和T1都需要用到一块共享资源，T3先执行，锁定了共享资源，T1再执行(抢占了T3)，虽然T1优先于T3，但是T3把T1要用到的资源锁住了，所以T1无法执行完毕，因此让T3继续执行，此时让T2再执行，会抢占T3，<u>这时候，T1需要等待T3，T3在等待T2，就出现了优先级反转问题！</u></p><p>解决方案：</p><ul><li>(当出现资源抢占现象时)低优先级任务继承高优先级任务的优先级</li><li>﻿优先级天花板：<ul><li>“资源” 的优先级和 “所有可以锁定该资源的任务中优先级最高的那个任务” 的优先级相同</li><li>除非优先级高于系统中所有被锁定的资源的优先级上限，否则任务尝试执行临界区的时候会被阻塞</li><li>﻿持有最高优先级上限信号量锁的任务，会继承被该锁所阳塞的任务的优先级</li></ul></li></ul><h2 id="Chapter9-同步"><a href="#Chapter9-同步" class="headerlink" title="Chapter9 同步"></a>Chapter9 同步</h2><h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><ul><li>﻿独立的线程：<ul><li>不和其他线程共享资源或状态</li><li>确定性：一输入状态决定结果</li><li>可重现：一 能够重现起始条件，I&#x2F;0</li><li>调度顺序不重要</li></ul></li><li>﻿合作线程：<ul><li>在多个线程中共享状态</li><li>不确定性</li><li>不可重现</li></ul></li><li>﻿不确定性和不可重现意味着bug可能是间歇性发生的</li></ul><p>进程间合作工作的原因：</p><ul><li>﻿进程&#x2F;线程，计算机&#x2F;设备需要合作</li><li>﻿优点1：共享资源<ul><li>一台电脑，多个用户</li><li>一个银行存款余额，多台ATM机</li><li>嵌入式系统（机器人控制：手臂和手的协调）</li></ul></li><li>﻿优点2：加速<ul><li>I&#x2F;0操作和计算可以重叠</li><li>多处理器 一 将程序分成多个部分井行执行</li></ul></li><li>﻿优点3：模块化<ul><li>将大程序分解成小程序</li></ul></li><li>﻿以编译为例，gcc会调用cpp, cc1, cc2. as, ld，使系统易于扩展</li></ul><p>但是进程并发会带来一些问题，接下来我们要对其进行解决</p><h3 id="一些概念："><a href="#一些概念：" class="headerlink" title="一些概念："></a>一些概念：</h3><h4 id="原子操作："><a href="#原子操作：" class="headerlink" title="原子操作："></a>原子操作：</h4><ul><li>﻿原子操作是指一次不存在任何中断或者失败的执行<ul><li>该执行成功结束</li><li>或者根本没有执行</li><li>并且不应该发现任何<strong>部分执行</strong>的状态</li></ul></li><li>﻿实际上操作往往不是原子的<ul><li>有些看上去是原子操作，实际上不是</li><li>连x++这样的简单语句，实际上是由3条指令构成的</li><li>有时候甚至连单条机器指令都不是原子的</li></ul></li></ul><h4 id="Critical-section-（临界区）"><a href="#Critical-section-（临界区）" class="headerlink" title="Critical section （临界区）"></a>Critical section （临界区）</h4><p>临界区是指进程中的一段需要访问共享资源并且当另一个进程处于相应代码区域时便不会被执行的代码区域</p><h4 id="Mutual-exclusion-（互斥）"><a href="#Mutual-exclusion-（互斥）" class="headerlink" title="Mutual exclusion （互斥）"></a>Mutual exclusion （互斥）</h4><p>当一个进程处于临界区井访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源</p><h4 id="Dead-lock-（死锁）"><a href="#Dead-lock-（死锁）" class="headerlink" title="Dead lock （死锁）"></a>Dead lock （死锁）</h4><p>两个或以上的进程，在相互等待完成特定任务，而最终没法将自身任务进行下去</p><h4 id="Starvation（饥饿）"><a href="#Starvation（饥饿）" class="headerlink" title="Starvation（饥饿）"></a>Starvation（饥饿）</h4><p>一个可执行的进程，被调度器持续忽略，以至于虽然处于可执行状态却不被执行</p><h4 id="Critical-section-临界区）"><a href="#Critical-section-临界区）" class="headerlink" title="Critical section  (临界区）"></a>Critical section  (临界区）</h4><p>临界区是指进程中的一段需要访问共享资源井且当另一个进程处于相应代码区域时便不会被执行的代码区域</p><ul><li>﻿互斥：同一时间临界区中最多存在一个线程</li><li>﻿Progress：如果一个线程想要进入临界区，那么它最终会成功</li><li>有限等待：如果一个线程i处于入口区，那么在i的请求被接受之前，其他线程进入临界区的时间是有限制的</li><li>﻿无忙等待（可选)：如果一个进程在等待进入临界区，那么<strong>在它可以进入之前会被挂起</strong></li></ul><h4 id="Mutual-exclusion（互斥）"><a href="#Mutual-exclusion（互斥）" class="headerlink" title="Mutual exclusion（互斥）"></a>Mutual exclusion（互斥）</h4><p>当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源</p><h3 id="实现对临界区代码的保护"><a href="#实现对临界区代码的保护" class="headerlink" title="实现对临界区代码的保护"></a>实现对临界区代码的保护</h3><h4 id="方案1——禁用硬件中断："><a href="#方案1——禁用硬件中断：" class="headerlink" title="方案1——禁用硬件中断："></a>方案1——禁用硬件中断：</h4><ul><li>﻿没有中断，没有上下文切换，因此没有并发<ul><li>硬件将中断处理延迟到中断被启用之后</li><li>大多数现代计算机体系结构都提供指令来完成</li></ul></li><li>﻿进入临界区<ul><li>禁用中断</li></ul></li><li>﻿离开临界区<ul><li>开启中断</li></ul></li></ul><h5 id="缺点：-4"><a href="#缺点：-4" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>﻿一旦中断被禁用，线程就无法被停止<ul><li>整个系统都会为你停下来</li><li>可能导致其他线程处于饥饿状态</li></ul></li><li>﻿要是临界区可以任意长怎么办<ul><li>无法限制响应中断所需的时间(可能存在硬件影响）</li></ul></li></ul><p>​要小心使用</p><ul><li>一般只能禁止单CPU的中断，那么面对多CPU的情况就无法使 禁用硬件中断失效</li></ul><h4 id="方案2——基于软件的解决方案"><a href="#方案2——基于软件的解决方案" class="headerlink" title="方案2——基于软件的解决方案:"></a>方案2——基于软件的解决方案:</h4><ul><li>﻿﻿Dekker算法 (1965）：第一个针对双线程例子的正确解决方案</li><li>﻿Bakery算法 ( Lamport 1979）：针对n线程的临界区问题解决方案</li><li>﻿复杂<ul><li>需要两个进程间的共享数据项</li></ul></li><li>﻿需要忙等待<ul><li>浪费CPU时间</li></ul></li><li>﻿没有硬件保证的情况下无真正的软件解决方案<ul><li>Peterson算法需要原子的LOAD和STORE指令</li></ul></li></ul><h4 id="方案3——更高级的抽象："><a href="#方案3——更高级的抽象：" class="headerlink" title="方案3——更高级的抽象："></a>方案3——更高级的抽象：</h4><ul><li>﻿大多数现代体系结构都提供特殊的原子操作指令<ul><li>通过特殊的内存访问电路，针对单处理器和多处理器</li></ul></li><li>﻿﻿Test-and-Set 测试和置位<ul><li>从内存中读取值</li><li>测试该值是否为1（然后返回真或假）</li><li>内存值设置为1</li></ul></li><li>﻿交换exchange<ul><li>交换内存中的两个值</li></ul></li></ul><p>我们可以通过Test-and-Set 或 exchange 来实现并发线程的管理</p><h5 id="优点：-4"><a href="#优点：-4" class="headerlink" title="优点："></a>优点：</h5><ul><li>适用于单处理器或者共享主存的多处理器中任意数量的迸程</li><li>简单并且容易证明</li><li>可以用于支持多临界区</li></ul><h5 id="缺点：-5"><a href="#缺点：-5" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>忙等待消耗处理器时间</li><li>当进程离开临界区并且多个进程在等待的时候可能导致<u>饥饿</u></li><li>死锁</li><li>﻿如果一个低优先级的进程拥有临界区并且一个高优先级进程也需求，那么高优先级进程会获得处理器并等待临界区</li></ul><h2 id="Chapter10-信号量和管程"><a href="#Chapter10-信号量和管程" class="headerlink" title="Chapter10 信号量和管程"></a>Chapter10 信号量和管程</h2><h3 id="背景：-1"><a href="#背景：-1" class="headerlink" title="背景："></a>背景：</h3><ul><li>﻿并发问题：竞争条件（竞态条件）<ul><li>多程序并发存在大的问题</li></ul></li><li>﻿同步<ul><li>多线程<strong>共享公共数据的协调执行</strong></li><li>包括互斥与条件同步</li><li>互斥：在同一时间只有一个线程可以执行临界区</li></ul></li><li>﻿确保同步正确很难？<ul><li>需要高层次的编程抽象（如：锁）</li><li>从底层硬件支持编译</li></ul></li></ul><h3 id="信号量："><a href="#信号量：" class="headerlink" title="信号量："></a>信号量：</h3><ul><li><p>是一个整形（sem），有两个原子操作</p></li><li><p>P () :   sem 减1，如果sem&lt;0， 等待，否则继续</p></li><li><p>V () ：sem 加1，如果 sem&lt;&#x3D;0，唤醒一个等待的P</p></li><li><p>﻿信号量是被保护的变量</p><ul><li>初始化完成后，唯一改变一个信号量的值的办法是通过P0和v0</li><li>操作必须是原子</li></ul></li><li><p>﻿P () 能够阻塞，V () 不会阻塞</p></li><li><p>﻿我们假定信号量是   公平的</p><ul><li>没有线程被阻塞在P () if  V () 被无限频繁调用（对于同一个信号量）</li><li>在实践中，FIFO经常被使用</li></ul></li><li><p>﻿两种类型信号量</p><ul><li>二进制信号量：可以是0或1</li><li>一般&#x2F;计数信号量：可取任何非负值</li><li>两者相互表现(给定一个可以实现另一个)</li></ul></li><li><p>﻿信号量可以用在2个方面</p><ul><li>互斥</li><li>条件同步(调度约束一一一个线程等待另一个线程的事情发生）</li></ul></li></ul><h3 id="信号量缺点："><a href="#信号量缺点：" class="headerlink" title="信号量缺点："></a>信号量缺点：</h3><ul><li>信号量的双用途<ul><li>互斥和条件同步</li><li>但等待条件是独立的互斥</li></ul></li><li>读&#x2F;开发代码比较困难<ul><li>程序员必须非常精通信号量</li></ul></li><li>容易出错<ul><li>使用的信号量己经被另一个线程占用</li><li>忘记释放信号量</li></ul></li><li>不能够处理死锁问题</li></ul><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><ul><li><p>﻿什么是管程</p><ul><li>一个锁：指定临界区</li><li>0或者多个条件变量：等待&#x2F;通知信号量用于管理并发访问共享数据</li></ul></li><li><p>﻿一般方法</p><ul><li>收集在对象&#x2F;模块中的相关共享数据</li><li>定义方法来访问共享数据</li></ul></li><li><p>﻿﻿Lock</p><ul><li>Lock::Acquire（ 一 等待直到锁可用，然后抢占锁</li><li>Lock::Release （一释放锁，唤醒等待者如果有</li></ul></li><li><p>﻿﻿Condition Variable</p><ul><li><p>允许等待状态进入临界区</p><ul><li>﻿允许处于等待（睡眠）的线程进入临界区</li><li>﻿某个时刻原子释放锁进入睡眠</li></ul></li><li><p>Wait () operation</p><ul><li>﻿释放锁，睡眠，重新获得锁返回后</li></ul></li><li><p>﻿﻿Signal () operation ( or broadcast () operation )</p><ul><li>唤醒等待者（或者所有等待者），如果有</li></ul></li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/IMG_C86C23D6FA1D-1.jpeg" alt="IMG_C86C23D6FA1D-1" style="zoom:50%;" /><h3 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h3><h4 id="读者—写者问题："><a href="#读者—写者问题：" class="headerlink" title="读者—写者问题："></a>读者—写者问题：</h4><ul><li><p>动机</p><ul><li>共享数据的访问</li></ul></li><li><p>两种类型使用者</p><ul><li>读者：不需要修改数据</li><li>写者：读取和修改数据</li></ul></li><li><p>问题的约束</p><ul><li>允许同一时间有多个读者，但在任何时候只有一个写者</li><li>当没有写者是读者才能访问数据</li><li>当没有读者和写者时写者才能访问数据</li><li>在任何时候只能有一个线程可以操作共享变量</li></ul></li><li><p>﻿多个并发进程的数据集共享</p><ul><li>读者一只读数据集；他们不执行任何更新</li><li>写者-可以读取和写入</li></ul></li><li><p>﻿共享数据</p><ul><li>数据集</li><li>信号量CountMutex初始化为1</li><li>信号量WriteMutex初始化为1</li><li>整数 Rcount 初始化为0</li></ul></li></ul><h5 id="读者优先实现-使用信号量方式-："><a href="#读者优先实现-使用信号量方式-：" class="headerlink" title="读者优先实现(使用信号量方式)："></a>读者优先实现(使用信号量方式)：</h5><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/IMG_4D5569A45E16-1.jpeg" alt="IMG_4D5569A45E16-1" style="zoom:50%;" /><h4 id="哲学家就餐问题："><a href="#哲学家就餐问题：" class="headerlink" title="哲学家就餐问题："></a>哲学家就餐问题：</h4><h2 id="Chapter11-死锁"><a href="#Chapter11-死锁" class="headerlink" title="Chapter11 死锁"></a>Chapter11 死锁</h2><h3 id="死锁问题："><a href="#死锁问题：" class="headerlink" title="死锁问题："></a>死锁问题：</h3><p>​一组阻塞的进程持有一种资源 等待获取 另一个进程所占有的一个资源。</p><h3 id="系统模型："><a href="#系统模型：" class="headerlink" title="系统模型："></a>系统模型：</h3><h4 id="可重复使用的资源"><a href="#可重复使用的资源" class="headerlink" title="可重复使用的资源"></a>可重复使用的资源</h4><ul><li><p>﻿在一个时间只能一个进程使用且不能被删除</p></li><li><p>﻿进程获得资源，后来释放由其他进程重用</p></li><li><p>﻿处理器，I&#x2F;O通道，主和副存储器，设备和数据结构，如文件，数据库和信号量</p></li><li><p>﻿如果每个进程拥有一个资源并请求其它资源，死锁可能发生</p><h4 id="使用资源"><a href="#使用资源" class="headerlink" title="使用资源"></a>使用资源</h4></li><li><p>﻿﻿创建和销毁</p></li><li><p>﻿在I&#x2F;O缓冲区的中断，信号，消息，信息</p></li><li><p>﻿如果接收消息阳塞可能会发生死锁</p></li><li><p>﻿可能少见的组合事件会引起死锁</p></li></ul><h3 id="死锁特征："><a href="#死锁特征：" class="headerlink" title="死锁特征："></a>死锁特征：</h3><p>死锁出现的必要条件：</p><h4 id="1、-互斥："><a href="#1、-互斥：" class="headerlink" title="1、 互斥："></a>1、 互斥：</h4><p>进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</p><h4 id="2、占用并等待："><a href="#2、占用并等待：" class="headerlink" title="2、占用并等待："></a>2、占用并等待：</h4><p>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p><h4 id="3、无抢占"><a href="#3、无抢占" class="headerlink" title="3、无抢占:"></a>3、无抢占:</h4><p>进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</p><h4 id="4、循环等待"><a href="#4、循环等待" class="headerlink" title="4、循环等待:"></a>4、循环等待:</h4><p>存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i&#x3D;0, 1, …, n-1)，Pn等待的资源被P0占有；</p><h3 id="死锁处理方法："><a href="#死锁处理方法：" class="headerlink" title="死锁处理方法："></a>死锁处理方法：</h3><h4 id="死锁预防："><a href="#死锁预防：" class="headerlink" title="死锁预防："></a>死锁预防：</h4><p>破坏任意死锁出现的必要条件：</p><ul><li><p>互斥——共享资源不是必须的，必须占用非共享资源。</p></li><li><p>占用并等待——必须保证当一个进程请求的资源，它不持有任何其他资源。</p><ul><li>需要进程请求并分配其所有资源，它开始执行之前或允许进程请求资源仅当进程没有资源。</li><li>资源利用率低;可能发生饥饿。</li></ul><p></p></li><li><p>无抢占</p><ul><li>如果进程占有某些资源，并请求其它不能被立即分配的资源，则释放当前正占有的资源</li><li>被抢占资源添加到资源列表中</li><li>只有当它能够获得旧的资源以及它请求新的资源，进程可以得到执行</li></ul></li><li><p>循环等待 —对所有资源类型进行<u><strong>排序</strong></u>，并<u><strong>要求每个进程按照资源的顺序进行申请</strong></u>。</p></li></ul><h4 id="死锁避免："><a href="#死锁避免：" class="headerlink" title="死锁避免："></a>死锁避免：</h4><p><u>需要系统具有一些额外的先验信息提供。</u></p><ul><li><p>﻿﻿最简单和最有效的模式是要求每个进程声明它可能需要的每个类型资源的<u>最大数目</u>。</p></li><li><p>﻿资源的分配状态是通过限定<u>提供</u>与<u>分配</u>的资源数量，和进程的<u>最大需求</u>。</p></li><li><p>﻿死锁避免算法<u>动态检查</u>的资源分配状态，以确保永远不会有一个环形等待状态。</p></li><li><p>﻿当一个进程请求可用资源，系统必须判断立即分配是否能<strong>使系统处于安全状态</strong>。</p></li><li><p>﻿系统处于安全状态指：针对所有进程，存在安全序列。</p></li><li><p>﻿序列&lt;P1，p2,……，PN&gt;是安全的：针对每个Pi, Pi要求的资源能够由当前可用的资源+所有的 Pj 持有的资源来满足，其中j&lt;i。</p><ul><li>如果 Pi 资源的需求不是立即可用，那么 Pi 可以等到所有 Pj 完成。</li><li>当 Pi 完成后，P i + 1 可以得到所需要的资源，执行，返回所分配的资源，并终止。</li><li>﻿用同样的方法。Pi+2, Pi+3，和 Pn 能获得其所需的资源。</li></ul></li></ul><h5 id="银行家算法-通过合理分配资源使得死锁避免"><a href="#银行家算法-通过合理分配资源使得死锁避免" class="headerlink" title="银行家算法(通过合理分配资源使得死锁避免)"></a>银行家算法(通过合理分配资源使得死锁避免)</h5><h4 id="死锁检测："><a href="#死锁检测：" class="headerlink" title="死锁检测："></a>死锁检测：</h4><p>​就是银行家算法，看看能不能在现有资源下，让所有进程都跑通(时间复杂度大、开销大)</p><h4 id="死锁恢复："><a href="#死锁恢复：" class="headerlink" title="死锁恢复："></a>死锁恢复：</h4><ul><li>﻿方法1：终止所有的死锁进程</li><li>﻿方法2：在一个时间内终止一个进程直到死锁消除<ul><li>终止进程的顺序应该是：<ul><li>进程的优先级</li><li>进程运行了多久以及需要多少时间才能完成</li><li>进程占用的资源</li><li>进程完成需要的资源</li><li>多少进程需要被终止</li><li>迸程是交互还是批处理</li></ul></li></ul></li></ul><h2 id="Chapter12进程间通信-IPC——Inter-Process-Communication"><a href="#Chapter12进程间通信-IPC——Inter-Process-Communication" class="headerlink" title="Chapter12进程间通信(IPC——Inter Process Communication)"></a>Chapter12进程间通信(IPC——Inter Process Communication)</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="通信模型"><a href="#通信模型" class="headerlink" title="通信模型"></a>通信模型</h4><ul><li><p>﻿进程通信的机制及同步</p></li><li><p>﻿不使用共享变量的迸程通信</p></li><li><p>﻿﻿IPC facility 提供2个操作：</p><ul><li>send(message）一消息大小固定或者可变</li><li>﻿﻿receive (message)</li></ul></li><li><p>﻿如果P和Q想通信，需要：</p><ul><li>在它们之间建立通信链路</li><li>通过 send&#x2F;receive交换消息</li></ul></li><li><p>﻿通信链路的实现</p><ul><li><p>物理（例如，<strong>共享内存</strong>，<strong>硬件总线</strong>）</p></li><li><p>﻿逻辑（例如，逻辑属性）</p></li></ul></li></ul><h4 id="直接与间接通信"><a href="#直接与间接通信" class="headerlink" title="直接与间接通信"></a>直接与间接通信</h4><h5 id="直接通信"><a href="#直接通信" class="headerlink" title="直接通信:"></a>直接通信:</h5><ul><li>进程必须正确的命名对方：<ul><li>send (P, message)        一 发送信息到进程P</li><li>receive (Q, messase） 一 从进程Q接受消息</li></ul></li><li>通信链路的属性:<ul><li>自动建立链路</li><li>一条链路恰好对应一对通信进程</li><li>每对进程之间只有一个链接存在</li><li>链接可以是单向的，但通常为双向的</li></ul></li></ul><h5 id="间接通信"><a href="#间接通信" class="headerlink" title="间接通信:"></a>间接通信:</h5><ul><li>﻿定向从消息队列接收消息<ul><li>每个消息队列都有一个唯一的ID</li><li>只有它们共享了一个消息队列，进程才能够通信</li></ul></li><li>﻿通信链路的属性<ul><li>只有进程共享一个共同的消息队列，才建立链路</li><li>链接可以与许多进程相关联</li><li>每对进程可以共享多个通信链路</li><li>连接可以是单向或双向</li></ul></li><li>﻿操作<ul><li>创建一个新的消息队列</li><li>通过消息队列发送和接收消息</li><li>销毁消息队列</li></ul></li><li>﻿原语的定义如下：<ul><li>send （A, message）一 发送消息到队列A</li><li>receive (A,message）一 从队列 A接受消息</li></ul></li></ul><h4 id="阻塞与非阻塞："><a href="#阻塞与非阻塞：" class="headerlink" title="阻塞与非阻塞："></a>阻塞与非阻塞：</h4><p>​阻塞：异步</p><p>​非阻塞：同步(发送方一定要等到接收方收到消息后再进行下一步操作)</p><h4 id="通信链路缓冲："><a href="#通信链路缓冲：" class="headerlink" title="通信链路缓冲："></a>通信链路缓冲：</h4><ul><li>队列的消息被附加到链路；可以是以下3种方式之一：</li></ul><ol><li><p>﻿﻿﻿0容量<br> 发送方必须等待接收方 (rendezvous)</p></li><li><p>﻿﻿有限容量 —— n messages的有限长度</p><p>​如果队列满，发送方必须等待</p></li><li><p>﻿﻿﻿无限容量——无限长度<br> 发送方不需要等待</p></li></ol><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><ul><li><p><u><strong>软件</strong></u>中断通知事件处理</p></li><li><p>Examples: SIGFPE, SIGKILL, SIGUSR1, SIGSTOP, SIGCONT</p></li><li><p>﻿接收到信号时会发生什么</p><ul><li>Catch:指定信号处理函数被调用</li><li>Ignore：依靠操作系统的默认操作</li></ul></li><li><p>﻿﻿Example: Abort, memory dump, suspend or resume process</p><ul><li>Mask：闭塞信号因此不会传送<ul><li>﻿可能是暂时的（当处理同样类型的信号）</li></ul></li></ul></li><li><p>﻿不足<br> 不能传输要交换的任何数据</p></li></ul><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>​主要是为了 实现使一个进程的输出作为另一个进程的输入(这两个进程都是shell进程的子进程，shell进程为它们之间的通信创建通道)</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>​<a href="https://tangjiayang.github.io/2023/06/02/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">https://tangjiayang.github.io/2023/06/02/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</a></p><p>​一种间接通信方式</p><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><ul><li><p>进程</p><ul><li>每个进程都有私有地址空间</li><li>在每个地址空间内，明确地设置了共享内存段</li></ul></li><li><p>﻿优点</p><ul><li>快速、方便地共享数据</li></ul></li><li><p>﻿不足</p><ul><li>必须同步数据访问</li></ul></li></ul><p></p><h2 id="Chapter13-文件系统"><a href="#Chapter13-文件系统" class="headerlink" title="Chapter13 文件系统"></a>Chapter13 文件系统</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="文件系统和文件"><a href="#文件系统和文件" class="headerlink" title="文件系统和文件"></a>文件系统和文件</h4><ul><li><p>文件系统：一种用于持久性存储的系统抽象</p><ul><li>在存储器上：组织、控制、导航、访问和检索数据</li><li>大多数计算机系统包含文件系统</li><li>个人电脑、服务器、笔记本电脑</li><li>iPod.Tivo &#x2F;机顶盒、手机&#x2F;掌上电脑</li><li>Google 可能是由一个文件系统构成的</li></ul></li><li><p>文件：文件系统中<strong>一个单元的相关数据在操作系统中的抽象</strong></p></li></ul><h5 id="文件系统的功能："><a href="#文件系统的功能：" class="headerlink" title="文件系统的功能："></a>文件系统的功能：</h5><ul><li>﻿分配文件磁盘空间<ul><li>管理<strong>文件块</strong>（哪一块属于哪一个文件）</li><li>管理<strong>空闲空间</strong>(哪一块是空闲的）</li><li>分配算法（策略）</li></ul></li><li>﻿管理文件集合<ul><li><strong>定位</strong>文件及其内容</li><li><strong>命名</strong>：通过名字找到文件的接口</li><li>最常见：分层文件系统</li><li>文件系统类型（组织文件的不同方式）</li></ul></li><li>﻿提供的便利及特征<ul><li><strong>保护</strong>：分层来保护数据安全</li><li><strong>可靠性&#x2F;持久性</strong>：保持文件的持久即使发生崩溃、媒体错误、攻击等</li></ul></li></ul><h5 id="文件和块："><a href="#文件和块：" class="headerlink" title="文件和块："></a>文件和块：</h5><ul><li>﻿文件属性：<ul><li>名称、类型、位置、大小，保护、创建者、创建时间、最近修改时间、…</li></ul></li><li>﻿文件头：<ul><li>在存储元数据中保存了每个文件的信息</li><li>保存文件的属性</li><li>跟踪哪一块存储块属于逻辑上文件结构的哪个偏移</li></ul></li></ul><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><ul><li><p>需要元数据数据来管理打开文件：</p><ul><li>文件指针：<u>指向最近的一次读写位置</u>，每个打开了这个文件的进程都有这个指针</li><li>文件打开计数：记录文件打开的次数——当最后一个进程关闭了文件时，允许将其从打开文件表中移除</li><li>文件磁盘位置：缓存数据访问信息</li><li>访问权限：每个程序访问模式信息</li></ul></li><li><p>﻿用户怎么访问文件</p><ul><li>在系统层面需要知道用户的访问模式：</li><li>﻿顺序访问：按字节依次读取<ul><li>几乎所有的访问都是这种方式</li></ul></li><li>﻿随机访问：从中间读写<ul><li>不常用，但是仍然重要．例如，虚拟内存支持文件：内存页存储在文件中</li><li>更加快速 一 不希望获取文件中间的内容的时候也必须先获取块内所有字节。</li></ul></li><li>基于内容访问：通过特征<ul><li>许多系统不提供此种访问方式，相反，数据库是建立在索引内容的磁盘访问上（需要高效的随机访问)</li></ul></li></ul></li><li><p>﻿﻿多用户系统中的文件共享：</p><ul><li>﻿访问控制<ul><li>谁能够获得哪些文件的哪些访问权限</li><li>访问模式：读、写、执行、删除、列举等</li></ul></li><li>﻿文件访问控制列表 (ACL)<ul><li>&lt;文件实体，权限&gt;</li></ul></li><li>﻿Unix 模式<ul><li>〈用户|组|所有人，读|写|可执行〉</li><li>用户ID识别用户，表明每个用户所允许的权限及保护模式</li><li>组ID允许用户组成组，并指定了组访问权限</li></ul></li><li>﻿指定多用户&#x2F;客户如何同时访问共享文件<ul><li>和过程同步算法相似</li><li>因磁盘I&#x2F;0和网络延迟而设计简单</li></ul></li><li>﻿﻿Unix 文件系统(UFS) 语义<ul><li>对打开文件的写入内容立即对其他打开同一文件的其他用户可见</li><li>共享文件指针允许多用户同时读取和写入文件</li></ul></li><li>﻿会话语义<ul><li>写入内容只有当文件关闭时可见</li></ul></li><li>﻿锁<ul><li>一些操作系统和文件系统提供该功能</li></ul></li></ul></li></ul><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li><p>文件以目录的方式组织起来</p></li><li><p>目录是一类特殊的文件</p><ul><li>每个目录都包含了一张表&lt;name, pointer to file header&gt;</li></ul></li><li><p>目录和文件的树型结构</p><ul><li>早期的文件系统是扁平的 （只有一层目录）</li></ul></li><li><p>﻿典型操作</p><ul><li>搜索文件</li><li>创建文件</li><li>删除文件</li><li>枚举目录</li><li>重命名文件</li><li>在文件系统中遍历一个路径</li></ul></li><li><p>﻿操作系统应该只允许内核模式修改目录</p><ul><li>确保映射的完整性</li><li>应用程序能够读目录 （如1s)</li></ul></li><li><p>﻿名字解析：逻辑名字转换成物理资源（如文件）的过程</p><ul><li>在文件系统中：到实际文件的文件名（路径）</li><li>遍历文件目录直到找到目标文件</li></ul></li><li><p>﻿举例：解析 “&#x2F;bin&#x2F;ls”</p><ul><li>读取root的文件头（在磁盘固定位置）</li><li>读取root的数据块：搜索 “bin” 项</li><li>读取bin的文件头</li><li>读取bin的数据块：搜索 “ls” 项</li><li>读取ls的文件头</li></ul></li><li><p>﻿当前工作目录</p><ul><li>每个进程都会指向一个文件目录用于解析文件名</li><li>允许用户指定相对路径来代替绝对路径</li></ul></li></ul><h4 id="文件别名"><a href="#文件别名" class="headerlink" title="文件别名"></a>文件别名</h4><h5 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h5><ul><li><p>两个或多个文件名关联同一个文件</p></li><li><p>﻿硬链接：<strong>多个文件项指向一个文件</strong></p></li><li><p>﻿软链接：以“快捷方式”指向其他文件(**“<u>快捷方式文件的内容是另一个文件的路径名</u>**”)</p></li><li><p>﻿通过存储真实文件的逻辑名称来实现</p></li></ul><h4 id="文件系统种类"><a href="#文件系统种类" class="headerlink" title="文件系统种类"></a>文件系统种类</h4><ul><li><p>﻿磁盘文件系统</p><ul><li>文件存储在数据存储设备上，如磁盘。</li><li>例如：FAT, NTFS, ext2&#x2F;3， IS09660，等</li></ul></li><li><p>﻿数据库文件系统</p><ul><li>文件根据其特征是可被寻址（辨识）的</li><li>例如：winFS</li></ul></li><li><p>﻿日志文件系统</p><ul><li>记录文件系统的修改&#x2F;事件</li><li>例如：journaling file system</li></ul></li><li><p>﻿网络&#x2F;分布式文件系统</p><ul><li><p>﻿文件可以通过网络被共享</p><ul><li>文件位于远程服务器</li><li>客户端远程挂载服务器文件系统</li><li>标准系统文件访问被转换成远程访问</li><li>标准文件共享协议：NFS for Unix, CIFS for windows</li></ul></li><li><p>﻿分布式文件系统的问题</p><ul><li>客户端和客户端上的用户辨别起来很复杂</li><li>例如，NFS是不安全的</li><li><strong>一致性问题</strong></li><li>错误处理模式</li></ul></li><li><p>例如：NFS, SMB, AFS, GFS</p></li></ul></li><li><p>﻿特殊&#x2F;虚拟文件系统</p></li></ul><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><ul><li><p>分层结构</p><ul><li>上层：虚拟(逻辑)文件系统</li><li>底层：特定文件系统模块</li></ul></li><li><p>﻿目的</p><ul><li>对所有不同文件系统的抽象(让上层使用统一的接口对不同的文件系统进行统一管理)</li></ul></li><li><p>﻿功能</p><ul><li>提供相同的文件和文件系统接口</li><li>管理所有文件和文件系统关联的数据结构</li><li>高效查询例程，遍历文件系统</li><li>与特定文件系统模块的交互</li></ul></li><li><p>实现</p><ul><li>﻿卷控制块 (Unix: “superblock”）<ul><li>每个文件系统一个</li><li>文件系统详细信息</li><li>块、块大小，空余块、计数&#x2F;指针等</li></ul></li><li>﻿文件控制块 (Unix： ”vnode” or “inode”）<ul><li>每个文件一个</li><li>文件详细信息</li><li>许可、拥有者、大小、数据库位置等</li></ul></li><li>﻿目录节点 (Linux: ”dentry”）<ul><li>每个目录项一个（目录和文件）</li><li>将目录项数据结构及树型布局编码成树型数据结构</li><li>指向文件控制块、父节点、项目列表等</li></ul></li></ul></li><li><p>文件系统数据结构</p><ul><li>卷控制块（每个文件系统一个）</li><li>文件控制块（每个文件一个）</li><li>目录节点(每个目录项一个)</li></ul></li><li><p>﻿持续存储在二级存储中</p><ul><li>分配在存储设备中的数据块中</li></ul></li><li><p>﻿当需要时加载进内存</p><ul><li>卷控制模块 ：当文件系统挂载时进入内存</li><li>文件控制块：当文件被访问时进入内存</li><li>目录节点：在遍历一个文件路径时进入内存</li></ul></li></ul><h3 id="数据块缓存"><a href="#数据块缓存" class="headerlink" title="数据块缓存"></a>数据块缓存</h3><ul><li>﻿数据块按需读入内存<ul><li>提供 read() 操作</li><li>预读：预选读取后面的数据块</li></ul></li><li>﻿数据块使用后被缓存<ul><li>假设数据将会再次被使用</li><li>写操作可能被缓存和延迟写入</li></ul></li><li>﻿两种数据块缓存方式<ul><li>普通缓冲区缓存</li><li>页缓存：统一缓存数据块和内存页<ul><li>﻿分页要求<ul><li>当需要一个页时才格其载入内存</li></ul></li><li>﻿支持存储<ul><li>一个页（在虚拟地址空间中）可以被映射到一个本地文件中（在二级存储中）</li></ul></li><li>文件数据块的页缓存<ul><li>在虚拟内存中文件数据块被映射成页</li><li>文件的读&#x2F;写操作被转换成对内存的访问</li><li>可能导致缺页和&#x2F;或设置为脏页</li></ul></li></ul></li></ul></li></ul><h3 id="打开文件的数据结构"><a href="#打开文件的数据结构" class="headerlink" title="打开文件的数据结构"></a>打开文件的数据结构</h3><ul><li>﻿打开文件描述<ul><li>文件状态信息</li><li>目录项、当前文件指针、文件操作设置等</li></ul></li><li>﻿打开文件表<ul><li>一个进程一个</li><li>系统级</li><li>每个卷控制块也会保存一个列表</li><li>所以如果有文件被打开将不能被卸载</li></ul></li></ul><h3 id="文件分配"><a href="#文件分配" class="headerlink" title="文件分配"></a>文件分配</h3><ul><li><p>﻿大多数文件都很小</p><ul><li>需要对小文件提供强力的支持</li><li>块空间不能太大</li></ul></li><li><p>﻿﻿一些文件非常大</p><ul><li>必须支持大文件 （64-bit 文件偏移）</li><li>大文件访问需要相当高效</li></ul></li><li><p>﻿如何为一个文件分配数据块</p><ul><li>﻿分配方式<ul><li>连续分配<ul><li>优点：<ul><li>文件读取表现好</li><li>高效的顺序和随机访问</li></ul></li><li>缺点：<ul><li>碎片</li><li>如文件增大，则不好处理</li></ul></li></ul></li><li>链式分配<ul><li>文件以数据块链表的方式存储</li><li>文件头包含了从第一块到最后一块的指针</li><li>优点：<ul><li>创建、增大、缩小容易</li><li>没有碎片</li></ul></li><li>缺点：<ul><li>不可能进行真正的随机访问(链表，所以只能串型访问)</li><li>可靠性(中途断电，导致链表被破坏)</li></ul></li></ul></li><li>索引分配<ul><li>﻿为每个文件创建一个名为索引数据块的非数据数据块<ul><li>到文件数据块的指针列表</li></ul></li><li>﻿文件头包含了索引数据块</li><li>﻿优点：<ul><li>创建、增大、缩小很容易</li><li>没有碎片</li><li>支持直接访问</li></ul></li><li>缺点：<ul><li>当文件很小时，存储索引的开销</li><li>如何处理大文件？</li></ul></li></ul></li></ul></li><li>﻿指标<ul><li>高效：如存储利用 （外部碎片）</li><li>表现：如访问速度</li></ul></li></ul></li></ul><h3 id="空闲空间列表"><a href="#空闲空间列表" class="headerlink" title="空闲空间列表"></a>空闲空间列表</h3><p>……</p><h3 id="多磁盘管理-RAID"><a href="#多磁盘管理-RAID" class="headerlink" title="多磁盘管理 -RAID"></a>多磁盘管理 -RAID</h3><p>磁盘阵列（Redundant Arrays of Independent Disks，RAID），”数块独立磁盘构成具有冗余能力的阵列”</p><p>磁盘阵列是<strong>由很多块独立的磁盘，组合成一个容量巨大的磁盘组</strong>，<u>利用个别磁盘提供数据所产生加成效果提升整个磁盘系统效能</u>。利用这项技术，<strong>将数据切割成许多区段，分别存放在各个硬盘上</strong>。</p><ul><li><p>﻿分区：硬件磁盘的一种适合操作系统指定格式的划分</p></li><li><p>﻿卷：一个拥有一个文件系统实例的可访问的存储空间</p><ul><li>通常常驻在磁盘的单个分区上</li></ul></li><li><p>﻿使用多个并行磁盘来增加</p><ul><li>吞吐量（通过并行)</li><li>可靠性和可用性（通过冗余，多存几份，防备意外）</li></ul></li><li><p>﻿RAID 一 冗余磁盘阵列</p><ul><li>各种磁盘管理技术</li><li>RAID levels：不同RAID 分类（如，RATD-0， RAID-1, RATD-5)</li></ul></li><li><p>﻿实现</p><ul><li>在操作系统内核：存储&#x2F;卷管理</li><li>RAID硬件控制器 (I&#x2F;0)</li></ul></li></ul><h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><ul><li>﻿读取或写入时，磁头必须被定位在期望的磁道，并从所期望的扇区的开始</li><li>﻿寻道时间<ul><li>定位到期望的磁道所花费的时间</li></ul></li><li>﻿旋转延迟<ul><li>从扇区的开始处到到达目的处花费的时间</li></ul></li></ul><h4 id="SCAN"><a href="#SCAN" class="headerlink" title="SCAN"></a>SCAN</h4><p>对于扫描算法，磁臂从磁盘的一端开始，向另一端移动；在移过每个柱面时，处理请求。当到达磁盘的另一端时，磁头移动方向反转，并继续处理。磁头连续来回扫描磁盘。SCAN 算法有时称为电梯算法，因为磁头的行为就像大楼里面的电梯，先处理所有向上的请求，然后再处理相反方向的请求。</p><h4 id="C-LOOK"><a href="#C-LOOK" class="headerlink" title="C-LOOK"></a>C-LOOK</h4><p>基于SCAN算法，C-LOOK移动磁头从磁盘一端到磁盘另一端（磁臂只需移到一个方向的最远请求为止），并且处理行程上的请求，然而，当磁头到达另一端时，它立即返回到磁盘<strong>另一端</strong>最远的请求，而并不处理任何回程上的请求，然后从该最远的请求开始，继续往同一方向移动磁盘处理请求。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2023/06/02/Redis/"/>
      <url>/2023/06/02/Redis/</url>
      
        <content type="html"><![CDATA[<p>本博客参照了韩顺平老师的 Redis 课程讲义！</p><h1 id="1-Redis-基础知识"><a href="#1-Redis-基础知识" class="headerlink" title="1 Redis 基础知识"></a>1 Redis 基础知识</h1><h2 id="1-1-相关资料"><a href="#1-1-相关资料" class="headerlink" title="1.1 相关资料"></a>1.1 相关资料</h2><h3 id="1-1-1-官网-https-redis-io"><a href="#1-1-1-官网-https-redis-io" class="headerlink" title="1.1.1 官网: https://redis.io"></a>1.1.1 官网: <a href="https://redis.io/">https://redis.io</a></h3><h3 id="1-1-2下载地址-https-redis-io-docs-getting-started-installation-install-redis-on-mac-os"><a href="#1-1-2下载地址-https-redis-io-docs-getting-started-installation-install-redis-on-mac-os" class="headerlink" title="1.1.2下载地址: https://redis.io/docs/getting-started/installation/install-redis-on-mac-os/"></a>1.1.2下载地址: <a href="https://redis.io/docs/getting-started/installation/install-redis-on-mac-os/">https://redis.io/docs/getting-started/installation/install-redis-on-mac-os/</a></h3><h2 id="1-2-为什么需要-Redis"><a href="#1-2-为什么需要-Redis" class="headerlink" title="1.2 为什么需要 Redis"></a>1.2 为什么需要 Redis</h2><h3 id="1-2-1-企业需求"><a href="#1-2-1-企业需求" class="headerlink" title="1.2.1 企业需求"></a>1.2.1 企业需求</h3><ul><li>高并发</li><li>高可用</li><li>高性能</li><li>海量用户</li></ul><h3 id="1-2-2-关系型数据库-如-MySQL-问题"><a href="#1-2-2-关系型数据库-如-MySQL-问题" class="headerlink" title="1.2.2 关系型数据库(如 MySQL)-问题"></a>1.2.2 关系型数据库(如 MySQL)-问题</h3><ul><li>性能瓶颈： 磁盘 IO 性能低下</li><li>扩展瓶颈： 数据关系复杂， 扩展性差， 不便于大规模集群</li></ul><h3 id="1-2-3-Redis-的优势"><a href="#1-2-3-Redis-的优势" class="headerlink" title="1.2.3 Redis 的优势"></a>1.2.3 Redis 的优势</h3><ul><li>内存存储-降低磁盘 IO 次数</li><li>不存储关系， 仅存储数据-数据间关系， 越简单越好</li></ul><h2 id="1-3-Redis-简介"><a href="#1-3-Redis-简介" class="headerlink" title="1.3 Redis 简介"></a>1.3 Redis 简介</h2><h3 id="1-3-1-简述"><a href="#1-3-1-简述" class="headerlink" title="1.3.1 简述:"></a>1.3.1 简述:</h3><p>Redis (Remote DIctionary Server) 是用 C 语言开发的一个<strong>开源的高性能键值对（key-value） 数据库</strong></p><h3 id="1-3-2-特征"><a href="#1-3-2-特征" class="headerlink" title="1.3.2 特征"></a>1.3.2 特征</h3><ul><li>数据间没有必然的关联关系</li><li>高性能——官方提供测试数据， 50 个并发执行 100000 个请求,读的速度是 110000 次&#x2F;s,写的速度是 81000 次&#x2F;s</li><li>多种数据结构支持<ul><li><em>String</em> 字符串类型</li><li><em>Hash</em>  列表类型</li><li><em>List</em> 散列类型</li><li><em>Set</em> 集合类型</li><li><em>SortedSet</em> 有序集合模型</li></ul></li><li>持久化支持——可以进行数据灾难恢复</li></ul><p></p><h3 id="1-3-3-应用场景"><a href="#1-3-3-应用场景" class="headerlink" title="1.3.3 应用场景"></a>1.3.3 应用场景</h3><p>● 为热点数据加速查询， 如热点商品、 热点新闻、 热点资讯、 推广类等高访问量信息等</p><p>● 任务队列，如秒杀、抢购、购票排队等</p><p>● 即时信息查询，如排行榜、各类网站访问统计</p><p>● 时效性信息控制，如验证码控制、投票控制等</p><p>● 分布式数据共享，如分布式集群架构中的 session 分离</p><p>● 消息队列</p><p>● 分布式锁</p><h1 id="2-NoSQL-数据库"><a href="#2-NoSQL-数据库" class="headerlink" title="2 NoSQL 数据库"></a>2 NoSQL 数据库</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>​<strong>Not-Only SQL（ 泛指非关系型的数据库）， 作为关系型数据库的补充</strong></p><h2 id="2-2-作用："><a href="#2-2-作用：" class="headerlink" title="2.2 作用："></a>2.2 作用：</h2><p>​ 应对在海量用户和海量数据的情况下， 带来的数据处理问题</p><h2 id="2-3特点"><a href="#2-3特点" class="headerlink" title="2.3特点"></a>2.3特点</h2><ul><li>可扩容， 可伸缩</li><li>大数据量下高性能</li><li>灵活的数据模型</li><li>高可用</li></ul><h3 id="SQL-关系型数据库-🆚-NoSQL-非关系型数据库"><a href="#SQL-关系型数据库-🆚-NoSQL-非关系型数据库" class="headerlink" title="SQL(关系型数据库) 🆚 NoSQL(非关系型数据库)"></a>SQL(关系型数据库) 🆚 NoSQL(非关系型数据库)</h3><table><thead><tr><th></th><th>SQL</th><th>NoSQL</th></tr></thead><tbody><tr><td>数据结构</td><td>结构化(建了表就不方便再改变)</td><td>非结构化</td></tr><tr><td>数据关联</td><td>关联的</td><td>无关联的</td></tr><tr><td>查询方式</td><td>SQL语句查询</td><td>非SQL语句</td></tr><tr><td>事务特性</td><td>ACID</td><td>BASE</td></tr><tr><td>存储方式</td><td>磁盘</td><td>内存</td></tr><tr><td>扩展性</td><td>垂直</td><td>水平</td></tr><tr><td>使用场景</td><td>1）数据结构固定<br />2）相关业务对数据安全性、一致性要求较高</td><td>1）数据结构不稳定<br />2）对一致性、安全性要求不高<br />3）对性能要求高</td></tr></tbody></table><h2 id="2-4-常见-Nosql-数据库"><a href="#2-4-常见-Nosql-数据库" class="headerlink" title="2.4 常见 Nosql 数据库"></a>2.4 常见 Nosql 数据库</h2><ul><li>Redis</li><li>memcache</li><li>HBase</li><li>MongoDB</li></ul><h1 id="3-Redis-使用"><a href="#3-Redis-使用" class="headerlink" title="3 Redis 使用"></a>3 Redis 使用</h1><h2 id="关于本机的redis信息："><a href="#关于本机的redis信息：" class="headerlink" title="关于本机的redis信息："></a>关于本机的redis信息：</h2><ul><li><p>redis.conf 地址：&#x2F;opt&#x2F;homebrew&#x2F;etc&#x2F;redis.conf</p></li><li><p>redis-server地址： &#x2F;opt&#x2F;homebrew&#x2F;opt&#x2F;redis&#x2F;bin&#x2F;redis-server</p></li></ul><p>​运行redis：redis-server    或    &#x2F;opt&#x2F;homebrew&#x2F;opt&#x2F;redis&#x2F;bin&#x2F;redis-server</p><p>​<strong>停止redis：redis-cli shutdown</strong></p><p>​密码设置成了 root 想要知道改了什么配置文件，请到&#x2F;opt&#x2F;homebrew&#x2F;etc&#x2F;redis.conf寻找#donn changed 20230411注释</p><h2 id="基于配置文件运行redis："><a href="#基于配置文件运行redis：" class="headerlink" title="基于配置文件运行redis："></a>基于配置文件运行redis：</h2><p>​redis-server &#x2F;opt&#x2F;homebrew&#x2F;etc&#x2F;redis.conf</p><h2 id="查找redis启用的进程："><a href="#查找redis启用的进程：" class="headerlink" title="查找redis启用的进程："></a>查找redis启用的进程：</h2><pre><code> ps axu | grep redis          </code></pre><p>可以通过杀死进程来关闭redis服务 kill -9 进程号</p><h2 id="redis-cli-使用："><a href="#redis-cli-使用：" class="headerlink" title="redis-cli 使用："></a>redis-cli 使用：</h2><p>​redis-cli -h 127.0.0.1 -p 6379 -a root</p><p>​-h 指定要连接redis结点的ip地址，默认为 127.0.0.1</p><p>​-p 指定要连接的redis节点的端口，默认为 6379</p><p>​-a 指定redis的访问密码(不建议在连接前就输入密码「不安全」) </p><p>​—-&gt; 建议先不输入密码，建立连接后输入 AUTH  用户名(本机未设置)  密码</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/redis-cli.png" style="zoom:100%;" /><h2 id="mac设置redis开机自启动："><a href="#mac设置redis开机自启动：" class="headerlink" title="mac设置redis开机自启动："></a>mac设置redis开机自启动：</h2><p>​1.sudo vim &#x2F;Library&#x2F;LaunchDaemons&#x2F;redis-server.plist     创建plist文档，用于记录redis启动的配置的路径(怎么填去网上找找就行)</p><p>​2.运行以下命令实现开机自启动：</p><p>​sudo launchctl load &#x2F;Library&#x2F;LaunchDaemons&#x2F;redis-server.plist </p><p>​(貌似是执行⬆️这条语句后，mac开机就会自动执行redis-server.plist，即自动开启redis)</p><p>​3.运行指令，若redis启动了即配置成功</p><p>​sudo launchctl start redis-server (模拟重启) </p><h2 id="图形化客户端演示"><a href="#图形化客户端演示" class="headerlink" title="图形化客户端演示"></a>图形化客户端演示</h2><p>​在网站下载Mac版：<a href="https://redis.com/thank-you/redisinsight-the-best-redis-gui-35/">https://redis.com/thank-you/redisinsight-the-best-redis-gui-35/</a>      🌟简单好用</p><h1 id="4-Redis-指令"><a href="#4-Redis-指令" class="headerlink" title="4 Redis 指令"></a>4 Redis 指令</h1><h2 id="4-1-指令文档"><a href="#4-1-指令文档" class="headerlink" title="4.1 指令文档:"></a>4.1 指令文档:</h2><p><a href="http://redis.cn/commands.html">http://redis.cn/commands.html</a></p><p>命令十分丰富， 包括的命令组有 Cluster、 Connection、 Geo、 Hashes、 HyperLogLog、Keys、 Lists、 Pub&#x2F;Sub、 Scripting、 Server、 Sets、 Sorted Sets、 Strings、 Transactions 一共 14个 redis 命令组两百多个 redis 命令</p><h2 id="4-2-基础操作"><a href="#4-2-基础操作" class="headerlink" title="4.2 基础操作"></a>4.2 基础操作</h2><h3 id="4-2-1-通用命令"><a href="#4-2-1-通用命令" class="headerlink" title="4.2.1 通用命令"></a>4.2.1 通用命令</h3><ul><li>help 命令名称      ——&gt;        会返回该命令的用法描述</li></ul><table><thead><tr><th align="center">KEYS</th><th align="center">查看所有符合模板的key(效率低，因此不建议在生产环境设备上使用)</th></tr></thead><tbody><tr><td align="center"><strong>DEL</strong></td><td align="center"><strong>删除指定的key   可以一次删除多个key(用空格隔开即可)</strong></td></tr><tr><td align="center"><strong>EXISTS</strong></td><td align="center"><strong>判断KEY是否存在</strong></td></tr><tr><td align="center"><strong>EXPIRE</strong></td><td align="center"><strong>Set a key’s time to live in seconds</strong>—–<strong>给一个key设置有效期，有效期到期会自动删除key</strong></td></tr><tr><td align="center"><strong>TTL</strong></td><td align="center"><strong>Get the time to live for a key in seconds</strong> (一个key的TTL &#x3D; -1表示永久有效，-2表示已过期)</td></tr><tr><td align="center"><strong>type</strong></td><td align="center"><strong>获取key的类型</strong></td></tr><tr><td align="center"><strong>unlink</strong></td><td align="center"><strong>根据 value 选择<u>非阻塞</u>删除【 仅将 keys 从 keyspace 元数据中删除， 真正的删除会在后续异步操作】</strong></td></tr></tbody></table><h3 id="4-2-2对-DB-数据库-操作"><a href="#4-2-2对-DB-数据库-操作" class="headerlink" title="4.2.2对 DB(数据库)操作"></a>4.2.2对 DB(数据库)操作</h3><ul><li><p><strong>select： 命令切换数据库</strong></p><pre><code> 1. redis 安装后， 默认有 16 个库, 0-15</code></pre><ol start="2"><li>默认操作的是 redis 的 0 号库</li></ol></li><li><p><strong>dbsize： 查看当前数据库的 key 的数量</strong></p></li><li><p><strong>flushdb： 清空当前库</strong></p></li><li><p><strong>flushall： 清空全部库</strong></p></li></ul><h1 id="5-Redis-五大数据类型-x2F-结构"><a href="#5-Redis-五大数据类型-x2F-结构" class="headerlink" title="5 Redis 五大数据类型&#x2F;结构"></a>5 Redis 五大数据类型&#x2F;结构</h1><h2 id="5-1-操作文档"><a href="#5-1-操作文档" class="headerlink" title="5.1 操作文档"></a>5.1 操作文档</h2><h3 id="5-1-1-官方文档-https-redis-io-commands"><a href="#5-1-1-官方文档-https-redis-io-commands" class="headerlink" title="5.1.1 官方文档 : https://redis.io/commands"></a>5.1.1 官方文档 : <a href="https://redis.io/commands">https://redis.io/commands</a></h3><h3 id="5-1-2-中文文档-http-redisdoc-com"><a href="#5-1-2-中文文档-http-redisdoc-com" class="headerlink" title="5.1.2 中文文档: http://redisdoc.com/"></a>5.1.2 中文文档: <a href="http://redisdoc.com/">http://redisdoc.com/</a></h3><h2 id="5-2-Redis-数据存储格式"><a href="#5-2-Redis-数据存储格式" class="headerlink" title="5.2 Redis 数据存储格式"></a>5.2 Redis 数据存储格式</h2><h3 id="5-2-1-一句话-redis-自身是一个-Map，-其中所有的数据都是采用-key-value-的形式存储"><a href="#5-2-1-一句话-redis-自身是一个-Map，-其中所有的数据都是采用-key-value-的形式存储" class="headerlink" title="5.2.1 一句话: redis 自身是一个 Map， 其中所有的数据都是采用 key : value 的形式存储"></a>5.2.1 一句话: redis 自身是一个 Map， 其中所有的数据都是采用 key : value 的形式存储</h3><h3 id="5-2-2-key-是字符串，-value-是数据，-数据支持多种类型-x2F-结构"><a href="#5-2-2-key-是字符串，-value-是数据，-数据支持多种类型-x2F-结构" class="headerlink" title="5.2.2 key 是字符串， value 是数据， 数据支持多种类型&#x2F;结构"></a>5.2.2 key 是字符串， value 是数据， 数据支持多种类型&#x2F;结构</h3><h2 id="5-3-Redis-数据类型-5-种常用"><a href="#5-3-Redis-数据类型-5-种常用" class="headerlink" title="5.3 Redis 数据类型-5 种常用"></a>5.3 Redis 数据类型-5 种常用</h2><ul><li><strong>string</strong></li><li><strong>hash</strong></li><li><strong>list</strong></li><li><strong>set</strong></li><li><strong>sorted_set</strong></li></ul><h2 id="5-4-String类型"><a href="#5-4-String类型" class="headerlink" title="5.4 String类型"></a>5.4 String类型</h2><h3 id="5-4-1-说明"><a href="#5-4-1-说明" class="headerlink" title="5.4.1 说明"></a>5.4.1 说明</h3><ol><li>String 是 Redis 最基本的类型， 一个 key 对应一个 value。</li><li>String 类型是二进制安全的, Redis 的 string 可以包含任何数据。 比如 jpg 图片或者序列化的对象。</li><li>String 类型是 Redis 基本的数据类型， 一个 Redis 中字符串 value 最多可以是 512M</li></ol><p>​<strong>String又可以细分</strong>为：    string普通字符串</p><p>​  int 整数类型，可以自增、自减</p><p>​  float  浮点类型，可以自增、自减</p><p><u>底层都是由字节数组存储，区别在于编码方式不同</u></p><ul><li><h5 id="String常见命令："><a href="#String常见命令：" class="headerlink" title="String常见命令："></a>String常见命令：</h5><table><thead><tr><th align="left">SET</th><th align="center">SET key value</th></tr></thead><tbody><tr><td align="left"><strong>GET</strong></td><td align="center"><strong>GET</strong> key</td></tr><tr><td align="left"><strong>append</strong></td><td align="center"><strong>append</strong> key value <strong>将给定的 value 追加到原值的末尾</strong><br/>(key不存在就创建)</td></tr><tr><td align="left"><strong>setnx</strong></td><td align="center"><strong>setnx</strong> key value<br/>只有在 key 不存在时 设置 key 的值</td></tr><tr><td align="left"><strong>INCR</strong>(若value为int，value++)</td><td align="center"><strong>INCR</strong> key</td></tr><tr><td align="left"><strong>DECR</strong>(若value为int，value+&#x3D;-1)</td><td align="center"><strong>DECR</strong> key</td></tr><tr><td align="left"><strong>INCRBY</strong>(若value为int，value+&#x3D; step)</td><td align="center"><strong>INCRBY</strong> key step（step可为任意非0整数）</td></tr><tr><td align="left"><strong>INCRBYFLOAT</strong>(若value为float，value +&#x3D; step)</td><td align="center"><strong>INCRBYFLOAT</strong> key step ( float类型 )</td></tr><tr><td align="left"><strong>MSET</strong>(批量添加键值对)</td><td align="center"><strong>MSET</strong> key1 value1 key2 value2 …</td></tr><tr><td align="left"><strong>MGET</strong>(批量查询values)</td><td align="center"><strong>MGET</strong> key1 key2 key3 …</td></tr><tr><td align="left"><strong>msetnx</strong></td><td align="center"><strong>msetnx</strong> <key1><value1><key2><value2><br/> 同时设置一个或多个 key-value 对， 当且仅当所有给定 key 都不存在, 原子性， 有一个失败则都失败</td></tr><tr><td align="left"><strong>getrange</strong></td><td align="center">getrange <key>&lt;起始位置&gt;&lt;结束位置&gt;<br/> 获得值的范围， 类似 java 中的 substring<br/>两边都是闭区间，下标从0开始，负数表示从后往前数</td></tr><tr><td align="left"><strong>setrange</strong></td><td align="center"><strong>setrange</strong><key>&lt;起始位置&gt;<value>  <br/>覆写<key>所储存的字符串值， 从&lt;起始位置&gt;开始(索引从 0 开始)。</td></tr><tr><td align="left"><strong>SETEX</strong></td><td align="center"><strong>setex</strong> <key>&lt;过期时间&gt;<value> <br/>设置键值的同时， 设置过期时间， 单位秒</td></tr><tr><td align="left"><strong>getset</strong></td><td align="center"><strong>getset</strong> <key><value> ,<br/>以新换旧， 设置了新值同时获得旧值</td></tr></tbody></table><h5 id="思考：Redis中没有table的概念，那么该如何区别不同类型的key呢？-比如一个学生的id-x3D-1，一门课程的id也为1"><a href="#思考：Redis中没有table的概念，那么该如何区别不同类型的key呢？-比如一个学生的id-x3D-1，一门课程的id也为1" class="headerlink" title="思考：Redis中没有table的概念，那么该如何区别不同类型的key呢？(比如一个学生的id &#x3D; 1，一门课程的id也为1)"></a>思考：Redis中没有table的概念，那么该如何区别不同类型的key呢？(比如一个学生的id &#x3D; 1，一门课程的id也为1)</h5><p>​Redis中 key 允许有多个单词(用于平替表的概念)形成层级结构，多个单词间用 ：隔开</p><p>​格式举例—&gt;     项目名 ：业务名 ：类型 ：你给key起的名称</p></li></ul><h2 id="5-5-List类型-类似java-中的LinkedList"><a href="#5-5-List类型-类似java-中的LinkedList" class="headerlink" title="5.5 List类型(类似java 中的LinkedList)"></a>5.5 List类型(类似java 中的LinkedList)</h2><h3 id="5-5-1-概要"><a href="#5-5-1-概要" class="headerlink" title="5.5.1 概要"></a>5.5.1 概要</h3><p>list 类型, 保存多个数据， 底层使用双向链表存储结构实现——(支持正向、反向检索)</p><h3 id="5-5-2-list-存储结构示意图"><a href="#5-5-2-list-存储结构示意图" class="headerlink" title="5.5.2 list 存储结构示意图"></a>5.5.2 list 存储结构示意图</h3><p>​● 双向链表示意图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727194906350.png" alt="image-20230727194906350"></p><p>​<u>有序、元素可重复、增删操作快、查找速度一般</u></p><p>● 老韩解图</p><pre><code>1. Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部(左边)或者尾部(右边)。2. 底层是个双向链表，对两端的操作性能高，通过索引下标的操作中间的节点性能较差</code></pre><h3 id="5-5-3-List类型常见命令："><a href="#5-5-3-List类型常见命令：" class="headerlink" title="5.5.3 List类型常见命令："></a>5.5.3 List类型常见命令：</h3><table><thead><tr><th align="left"><strong>LPUSH <key><value1><value2><value3> …</strong></th><th><strong>向列表<u>左侧</u>插入一个或多个元素(一个一个push，第一个在最右边)</strong></th></tr></thead><tbody><tr><td align="left"><strong>LPOP <key></strong></td><td><strong>移除并返回列表左侧的第一个元素，没有则返回nil</strong></td></tr><tr><td align="left"><strong>RPUSH ** <key><value1><value2><value3> …</strong>**</td><td><strong>向列表<u>右侧</u>插入一个或多个元素</strong></td></tr><tr><td align="left"><strong>RPOP <key></strong></td><td><strong>移除并返回列表右侧的第一个元素，没有则返回nil</strong></td></tr><tr><td align="left"><strong>rpoplpush</strong> <key1> <key2></td><td><strong>从<key1>列表右边吐出一个值， 插到<key2>列表左边</strong></td></tr><tr><td align="left"><strong>lrange</strong> <key><start><stop></td><td><strong>按照索引下标获得索引范围内的所有元素(从左到右)</strong></td></tr><tr><td align="left"><strong>lrange mylist 0 -1</strong></td><td>0 左边第一个， -1 右边第一个， （0-1 表示获取所有）</td></tr><tr><td align="left"><strong>lindex <key><index></strong></td><td><strong>按照索引下标<u>获得</u>元素(从左到右)</strong></td></tr><tr><td align="left"><strong>llen</strong> <key></td><td><strong>获得列表长度</strong></td></tr><tr><td align="left"><strong>linsert <key> before <value><newvalue></strong></td><td><strong>在<value>的前面插入<newvalue>插入值</strong></td></tr><tr><td align="left"><strong>lrem</strong> <key><n><value></td><td><strong>从左边删除 n 个 value(从左到右)</strong></td></tr><tr><td align="left"><strong>lset<key><index><value></strong></td><td><strong>将列表 key 下标为 index 的值替换成 value</strong></td></tr><tr><td align="left"><strong>BLPOP&#x2F;BRPOP <key> <time></strong></td><td><strong>与LPOP和RPOP类似，<u>只不过在没有元素时等待指定时间</u>，而不是直接返回nil</strong><br /><strong>阻塞一段时间，在指定的时间内还没能搜索到List中对应的数据，才算是找不到</strong></td></tr></tbody></table><h3 id="5-5-4-list-最佳实践"><a href="#5-5-4-list-最佳实践" class="headerlink" title="5.5.4 list 最佳实践"></a>5.5.4 list 最佳实践</h3><h4 id="5-5-4-1-redis-应用于具有操作先后顺序的数据控制"><a href="#5-5-4-1-redis-应用于具有操作先后顺序的数据控制" class="headerlink" title="5.5.4.1 redis 应用于具有操作先后顺序的数据控制"></a>5.5.4.1 redis 应用于具有操作先后顺序的数据控制</h4><h4 id="5-5-4-2-应用场景"><a href="#5-5-4-2-应用场景" class="headerlink" title="5.5.4.2 应用场景"></a>5.5.4.2 应用场景</h4><p>​● 系统通知， 按照时间顺序展示， 将最近的通知列在前面</p><p>​可用于(如你发了朋友圈，记录为您点赞的用户及其点赞顺序)</p><h2 id="5-6-Set类型-类似java-中的HashSet"><a href="#5-6-Set类型-类似java-中的HashSet" class="headerlink" title="5.6 Set类型(类似java 中的HashSet)"></a>5.6 Set类型(类似java 中的HashSet)</h2><h3 id="5-6-1-概要"><a href="#5-6-1-概要" class="headerlink" title="5.6.1 概要:"></a>5.6.1 概要:</h3><p> set 提供的功能与 list 类似是一个列表的功能， 特殊之处在于 set 是可以自动排重的, 即值是不允许重复的</p><p>​——<u>无序、元素不可重复、查找快、支持交并等集合操作</u></p><p>​像是用哈希表存储的集合</p><h3 id="5-6-2-set-常用指令-amp-使用"><a href="#5-6-2-set-常用指令-amp-使用" class="headerlink" title="5.6.2 set 常用指令&amp;使用"></a>5.6.2 set 常用指令&amp;使用</h3><h4 id="5-6-2-1-set-指令操作示意图"><a href="#5-6-2-1-set-指令操作示意图" class="headerlink" title="5.6.2.1 set 指令操作示意图"></a>5.6.2.1 set 指令操作示意图</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727202023870.png" alt="image-20230727202023870" style="zoom:50%;" /><h4 id="5-6-2-2-Set类型的常见命令："><a href="#5-6-2-2-Set类型的常见命令：" class="headerlink" title="5.6.2.2 Set类型的常见命令："></a>5.6.2.2 Set类型的常见命令：</h4><table><thead><tr><th><strong>SADD <key><value1><value2> …..</strong></th><th><strong>向set中添加一个或多个元素(一个key，任意多个元素)，若已存在，则忽略</strong></th></tr></thead><tbody><tr><td><strong>SMEMBERS <key></strong></td><td><strong>获取set中的所有元素</strong></td></tr><tr><td><strong>SISMEMBER <key> <member></strong></td><td><strong>判断一个元素是否存在于set中</strong></td></tr><tr><td><strong>SCARD <key></strong></td><td><strong>返回set中元素的个数</strong></td></tr><tr><td><strong>SREM <key><value1><value2> ….</strong></td><td><strong>移除set中的指定元素</strong></td></tr><tr><td><strong>spop <key></strong></td><td><strong>随机从该集合中吐出一个值。</strong></td></tr><tr><td><strong>srandmember <key><n></strong></td><td><strong>随机从该集合中取出 n 个值。 不会从集合中删除</strong></td></tr><tr><td><strong>smove <source><destination>value</strong></td><td><strong>把集合中一个值从一个集合移动到另一个集合</strong></td></tr><tr><td>**SINTER <key1> <key2> ** <br /><strong>SDIFF、SUNION…</strong></td><td><strong>求key1与key2的交集</strong><br /><strong>差集、并集…</strong></td></tr></tbody></table><h2 id="5-7-Hash类型-类似java-中的Map"><a href="#5-7-Hash类型-类似java-中的Map" class="headerlink" title="5.7 Hash类型(类似java 中的Map)"></a>5.7 Hash类型(类似java 中的Map)</h2><h3 id="5-7-1-概要"><a href="#5-7-1-概要" class="headerlink" title="5.7.1 概要:"></a>5.7.1 概要:</h3><p> Redis hash 是一个键值对集合， hash 适合用于存储对象， 类似 Java 里面的Map&lt;String,Object&gt;</p><h3 id="5-7-2-一图胜千言：-Redis-hash-存储结构简单示意图"><a href="#5-7-2-一图胜千言：-Redis-hash-存储结构简单示意图" class="headerlink" title="5.7.2 一图胜千言： Redis hash 存储结构简单示意图"></a>5.7.2 一图胜千言： Redis hash 存储结构简单示意图</h3><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727205233999.png" alt="image-20230727205233999" style="zoom:50%;" /><p>​无序字典，可以对对象中的每个字段独立存储，可以针对单个字段CRUD</p><p>​一条hash类型的记录有： 一个 <strong>key</strong> 和一些 <strong>field value</strong> 对</p><h3 id="5-7-3-Hash类型常见命令："><a href="#5-7-3-Hash类型常见命令：" class="headerlink" title="5.7.3 Hash类型常见命令："></a>5.7.3 Hash类型常见命令：</h3><table><thead><tr><th><strong>hset <key1><field1><value1><field2><value2></strong></th><th><strong>批量添加或者修改hash类型key的<u>一个</u>field的值</strong></th></tr></thead><tbody><tr><td><strong>hget <key1><field></strong></td><td><strong>获取<u>一个</u>hash类型key的field的值</strong></td></tr><tr><td><strong>hmset <key1><field1><value1><field2><value2>…</strong></td><td><strong>批量添加、修改hash类型key的多个field与value</strong></td></tr><tr><td><strong>hmget <key1><field1> <field2>…</strong></td><td><strong>批量获取hash类型key的多个field的值</strong></td></tr><tr><td><strong>hexists<key1><field></strong></td><td><strong>查看哈希表 key 中， 给定域 field 是否存在</strong></td></tr><tr><td><strong>hkeys <key></strong></td><td><strong>列出该 hash 集合的所有 field</strong></td></tr><tr><td><strong>hvals <key></strong></td><td><strong>列出该 hash 集合的所有 value</strong></td></tr><tr><td><strong>hincrby <key><field><increment></strong></td><td><strong>为哈希表 key 中的域 field 的值加上增量 increment</strong></td></tr><tr><td><strong>hsetnx <key><field><value></strong></td><td><strong>将哈希表 key 中的域 field 的值设置为 value ， 当且仅当域 field 不存在</strong></td></tr><tr><td><strong>HGETALL key</strong></td><td><strong>获取一个hash类型的key中的所有的field和value</strong></td></tr><tr><td><strong>HINCRBY key field</strong></td><td><strong>让一个hash类型key的字段值自增并指定步长</strong></td></tr><tr><td><strong>HSETNX key field value</strong></td><td><strong>添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</strong></td></tr></tbody></table><h2 id="5-8-SortedSet-Zset类型-功能类似java-中的TreeSet"><a href="#5-8-SortedSet-Zset类型-功能类似java-中的TreeSet" class="headerlink" title="5.8 SortedSet-Zset类型(功能类似java 中的TreeSet)"></a>5.8 SortedSet-Zset类型(功能类似java 中的TreeSet)</h2><h3 id="5-8-1-简介"><a href="#5-8-1-简介" class="headerlink" title="5.8.1 简介"></a>5.8.1 简介</h3><ol><li>Redis 有序集合 zset 与普通集合 set 非常相似， 是一个<strong>没有重复元素的字符串集合</strong>。</li><li>不同之处是<strong>有序集合的每个成员都关联了一个评分(score),这个评分(score)被用来按照从最低分到最高分的方式排序集合中的成员</strong>。 集合的成员是唯一的， 但是评分可以是重复的 。</li><li>因为元素是有序的, 所以也可以很快的根据评分(score)或者次序(position)来获取一个范围的元素。</li><li>访问有序集合的中间元素也是非常快的, 你能够使用有序集合作为一个没有重复成员的列表。</li></ol><p></p><p>​——<u>可排序、元素不重复、查询速度快</u></p><p>​常用于实现<u>排行榜</u>这样的功能</p><h3 id="5-8-2-SortedSet类型的常用命令："><a href="#5-8-2-SortedSet类型的常用命令：" class="headerlink" title="5.8.2 SortedSet类型的常用命令："></a>5.8.2 Sorted<u>Set</u>类型的常用命令：</h3><table><thead><tr><th><strong>zadd <key><score1><value1><score2><value2>…</strong></th><th><strong>添加一个或多个元素到sorted set ，如果value已经存在则更新其score值</strong></th></tr></thead><tbody><tr><td><strong>z(rev)range <key><start><stop> [WITHSCORES]</strong></td><td><strong>返回有序集 key 中， <u>下标</u>在<start><stop>之间的元素，带 WITHSCORES， 可以让分数一起和值返回到结果集(默认升序、rev表示反转，即降序)</strong></td></tr><tr><td><strong>zscore <key><member></strong></td><td><strong>获取sorted set中的指定元素的score值</strong></td></tr><tr><td><strong>z(rev)rangebyscore key min max [withscores]</strong></td><td><strong>返回有序集 key 中， 所有 score 值介于min 和 max 之间(包括等于 min 或 max )的成员。 有序集成员按 score 值递增(从小到大)次序排列</strong></td></tr><tr><td><strong>zincrby <key><increment><value></strong></td><td><strong>为元素的 score 加上增量</strong></td></tr><tr><td><strong>zrem <key><value></strong></td><td><strong>删除该集合下， 指定值的元素</strong></td></tr><tr><td><strong>zcount <key><min><max></strong></td><td><strong>统计该集合， 分数区间内的元素个数</strong></td></tr><tr><td><strong>zrank <key><value></strong></td><td><strong>返回该值在集合中的排名， 从 0 开始</strong></td></tr><tr><td><strong>Z(REV)RANK <key><value></strong></td><td><strong>获取sorted set 中的指定元素的排名</strong>(从0开始，默认升序)</td></tr><tr><td><strong>ZCARD <key></strong></td><td><strong>获取sorted set中的元素个数</strong></td></tr><tr><td><strong>ZCOUNT key min max</strong></td><td><strong>统计<u>score</u>值在给定范围内的所有元素的个数</strong></td></tr><tr><td><strong>ZDIFF、ZINTER、ZUNION</strong></td><td><strong>求差集、交集、并集</strong></td></tr></tbody></table><ul><li>🌟注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可</li></ul><h1 id="6-Redis-配置"><a href="#6-Redis-配置" class="headerlink" title="6 Redis 配置"></a>6 Redis 配置</h1><h2 id="6-1-配置文档"><a href="#6-1-配置文档" class="headerlink" title="6.1 配置文档"></a>6.1 配置文档</h2><h3 id="6-1-1-参考文档"><a href="#6-1-1-参考文档" class="headerlink" title="6.1.1 参考文档 :"></a>6.1.1 参考文档 :</h3><p><a href="https://www.cnblogs.com/nhdlb/p/14048083.html#_label0">https://www.cnblogs.com/nhdlb/p/14048083.html#_label0</a></p><h2 id="6-2-常规配置"><a href="#6-2-常规配置" class="headerlink" title="6.2 常规配置"></a>6.2 常规配置</h2><h3 id="6-2-1-设置密码"><a href="#6-2-1-设置密码" class="headerlink" title="6.2.1 设置密码"></a>6.2.1 设置密码</h3><h3 id="6-2-2-daemonize"><a href="#6-2-2-daemonize" class="headerlink" title="6.2.2 daemonize"></a>6.2.2 daemonize</h3><h3 id="6-2-3-loglevel"><a href="#6-2-3-loglevel" class="headerlink" title="6.2.3 loglevel"></a>6.2.3 loglevel</h3><h3 id="6-2-4-logfile"><a href="#6-2-4-logfile" class="headerlink" title="6.2.4 logfile"></a>6.2.4 logfile</h3><h3 id="6-2-5-设定库的数量"><a href="#6-2-5-设定库的数量" class="headerlink" title="6.2.5 设定库的数量"></a>6.2.5 设定库的数量</h3><h2 id="6-3-Units-单位"><a href="#6-3-Units-单位" class="headerlink" title="6.3 Units 单位"></a>6.3 Units 单位</h2><p>如图:</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728083451434.png" alt="image-20230728083451434"></p><p>1、 配置大小单位,开头定义了一些基本的度量单位， 只支持 bytes， 不支持 bit</p><p>2、 不区分大小写</p><h2 id="6-4-INCLUDES"><a href="#6-4-INCLUDES" class="headerlink" title="6.4 #INCLUDES#"></a>6.4 #INCLUDES#</h2><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728083845886.png" alt="image-20230728083845886"></p><p><strong>多实例的情况可以把公用的配置文件提取出来, 然后 include</strong></p><h2 id="6-5-NETWORK"><a href="#6-5-NETWORK" class="headerlink" title="6.5 #NETWORK#"></a>6.5 #NETWORK#</h2><h3 id="6-5-1-bind"><a href="#6-5-1-bind" class="headerlink" title="6.5.1 bind"></a>6.5.1 bind</h3><p> 如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728084509521.png" alt="image-20230728084509521"></p><ul><li>默认情况 bind&#x3D;127.0.0.1 只能接受本机的访问请求</li><li>如果服务器是需要远程访问的， 需要将其注释掉</li></ul><h3 id="6-5-2-protected-mode"><a href="#6-5-2-protected-mode" class="headerlink" title="6.5.2 protected-mode"></a>6.5.2 protected-mode</h3><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728084720819.png" alt="image-20230728084720819"></p><ul><li>默认是保护模式</li><li>如果服务器是需要远程访问的, 需要将 yes 设置为 no</li></ul><h3 id="6-5-3-port"><a href="#6-5-3-port" class="headerlink" title="6.5.3 port"></a>6.5.3 port</h3><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728084841445.png" alt="image-20230728084841445"></p><ul><li>Redis 服务默认端口 6379</li></ul><h3 id="6-5-4-timeout"><a href="#6-5-4-timeout" class="headerlink" title="6.5.4 timeout"></a>6.5.4 timeout</h3><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728084955938.png" alt="image-20230728084955938"></p><ul><li>一个空闲的客户端维持多少秒会关闭， 0 表示关闭该功能, 即永不超时</li></ul><h3 id="6-5-5-tcp-keepalive"><a href="#6-5-5-tcp-keepalive" class="headerlink" title="6.5.5 tcp-keepalive"></a>6.5.5 tcp-keepalive</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728085057878.png" alt="image-20230728085057878"></p><ul><li>tcp-keepalive 是<strong>对访问客户端的一种心跳检测</strong>， 每隔 n 秒检测一次, 单位为秒</li><li>如果设置为 0， 则不会进行 Keepalive 检测， 建议设置成 60</li><li>老韩说明: 为什么需要心跳检测机制<ul><li>TCP 协议中有长连接和短连接之分。 短连接环境下， 数据交互完毕后， 主动释放连接；</li><li>长连接的环境下， 进行一次数据交互后， 很长一段时间内无数据交互时， 客户端可能意外断开， 这些 TCP 连接并未来得及正常释放， 那么， 连接的另一方并不知道对端的情况，它会一直维护这个连接， 长时间的积累会导致非常多的半打开连接， 造成端系统资源的消耗和浪费， 且有可能导致在一个无效的数据链路层面发送业务数据， 结果就是发送失败。所以服务器端要做到快速感知失败， 减少无效链接操作， 这就有了 TCP 的 Keepalive(保活探测)机制</li></ul></li></ul><h2 id="6-6-GENERAL-通用"><a href="#6-6-GENERAL-通用" class="headerlink" title="6.6 #GENERAL 通用#"></a>6.6 #GENERAL 通用#</h2><h3 id="6-6-1-daemonize"><a href="#6-6-1-daemonize" class="headerlink" title="6.6.1 daemonize"></a>6.6.1 daemonize</h3><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728085407475.png" alt="image-20230728085407475"></p><ul><li>是否为后台进程， 设置为 yes</li><li>设置为 yes 后, 表示守护进程, 后台启动</li></ul><h3 id="6-6-2-pidfile"><a href="#6-6-2-pidfile" class="headerlink" title="6.6.2 pidfile"></a>6.6.2 pidfile</h3><p>如图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728085518957.png" alt="image-20230728085518957"></p><ul><li>存放 pid 文件的位置， 每个实例会产生一个不同的 pid 文件, <strong>记录 redis 的进程号</strong></li></ul><h3 id="6-6-3-loglevel"><a href="#6-6-3-loglevel" class="headerlink" title="6.6.3 loglevel"></a>6.6.3 loglevel</h3><p>如图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728085914809.png" alt="image-20230728085914809"></p><ul><li><p>redis 日志分为 4 个级别， 默认的设置为 notice, <strong>开发测试阶段可以用 debug</strong>(日志内容较多,不建议生产环境使用)， 生产模式一般选用 notice</p></li><li><p>redis 日志分为 4 个级别说明</p><ul><li>debug： 会打印出很多信息， 适用于开发和测试阶段；</li><li>verbose（冗长的）： 包含很多不太有用的信息， 但比 debug 要清爽一些；</li><li>notice： 适用于生产模式；</li><li>warning : 警告信息；</li></ul></li></ul><h3 id="6-6-4-logfile"><a href="#6-6-4-logfile" class="headerlink" title="6.6.4 logfile"></a>6.6.4 logfile</h3><p>如图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728090613879.png" alt="image-20230728090613879"></p><ul><li>logfile “” 就是说， 默认为控制台打印， 并没有日志文件生成</li><li>可以为 redis.conf 的 logfile 指定配置项</li></ul><h3 id="6-6-5-databases-16"><a href="#6-6-5-databases-16" class="headerlink" title="6.6.5 databases 16"></a>6.6.5 databases 16</h3><p>如图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728090759061.png" alt="image-20230728090759061"></p><ul><li>设定库的数量 默认 16， 默认数据库为 0 号</li><li>可以使用 SELECT <dbid>命令在连接上指定数据库 id</li></ul><h2 id="6-7-SECURITY-安全"><a href="#6-7-SECURITY-安全" class="headerlink" title="6.7 #SECURITY 安全#"></a>6.7 #SECURITY 安全#</h2><h3 id="6-7-1-设置密码"><a href="#6-7-1-设置密码" class="headerlink" title="6.7.1 设置密码"></a>6.7.1 设置密码</h3><h4 id="6-7-1-1-redis-conf-中设置密码"><a href="#6-7-1-1-redis-conf-中设置密码" class="headerlink" title="6.7.1.1 redis.conf 中设置密码"></a>6.7.1.1 redis.conf 中设置密码</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728090958792.png" alt="image-20230728090958792"></p><h4 id="6-7-1-2-命令行设置密码-密码只在本次启动过程中生效"><a href="#6-7-1-2-命令行设置密码-密码只在本次启动过程中生效" class="headerlink" title="6.7.1.2 命令行设置密码(密码只在本次启动过程中生效)"></a>6.7.1.2 命令行设置密码(密码只在本次启动过程中生效)</h4><p>在redis服务中，   config set requirepass 密码</p><p><strong>在命令中设置密码， 是临时的, 重启 redis 服务器， 密码就还原了</strong></p><h2 id="6-8-LIMITS-限制"><a href="#6-8-LIMITS-限制" class="headerlink" title="6.8 #LIMITS 限制#"></a>6.8 #LIMITS 限制#</h2><h3 id="6-8-1-maxclients"><a href="#6-8-1-maxclients" class="headerlink" title="6.8.1 maxclients"></a>6.8.1 maxclients</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728091350586.png" alt="image-20230728091350586"></p><ul><li>设置 redis 同时可以与多少个客户端进行连接</li><li>默认情况下为 10000 个客户端</li><li>如果达到了此限制， redis会拒绝新的连接请求， 并且向这些连接请求方发出”max numberof clients reached”</li></ul><h3 id="6-8-2-maxmemory"><a href="#6-8-2-maxmemory" class="headerlink" title="6.8.2 maxmemory"></a>6.8.2 maxmemory</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728091506781.png" alt="image-20230728091506781"></p><ul><li>在默认情况下, 对 32 位 实例会限制在 3 GB, 因为 32 位的机器最大只支持 4GB 的内存， 而系统本身就需要一定的内存资源来支持运行， 所以 32 位机器限制最大 3 GB 的可用内存是非常合理的， 这样可以避免因为内存不足而导致 Redis 实例崩溃</li><li>在默认情况下, 对于 64 位实例是没有限制</li><li>当用户开启了 redis.conf 配置文件的 maxmemory 选项， 那么 Redis 将限制选项的值不能小于 1 MB</li></ul><p><u><strong>对 maxmemory 设置的建议</strong></u></p><ol><li><p>Redis 的 maxmemory 设置取决于使用情况, 有些网站只需要 32MB， 有些可能需要 12GB。</p></li><li><p>maxmemory 只能根据具体的生产环境来调试， 不要预设一个定值， 从小到大测试，基本标准是不干扰正常程序的运行。</p></li><li><p>Redis 的最大使用内存跟搭配方式有关， 如果只是用 Redis 做纯缓存, 64-128M 对一般小型网站就足够了</p></li><li><p>如果使用 Redis 做数据库的话， 设置到物理内存的 1&#x2F;2 到 3&#x2F;4 左右都可以</p></li><li><p>如果使用了快照功能的话， 最好用到 50%以下， 因为快照复制更新需要双倍内存空间，如果没有使用快照而设置 redis 缓存数据库， 可以用到内存的 80%左右， 只要能保证 Java、NGINX 等其它程序可以正常运行就行了</p></li></ol><h3 id="6-8-3-maxmemory-policy"><a href="#6-8-3-maxmemory-policy" class="headerlink" title="6.8.3 maxmemory-policy"></a>6.8.3 maxmemory-policy</h3><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728092049334.png" alt="image-20230728092049334" style="zoom:70%;" /><p>policy 一览:</p><ul><li>volatile-lru： 使用 LRU 算法移除 key， 只对设置了过期时间的键； (最近最少使用)</li><li>allkeys-lru： 在所有集合 key 中， 使用 LRU 算法移除 key</li><li>volatile-random： 在过期集合中移除随机的 key， 只对设置了过期时间的键</li><li>allkeys-random： 在所有集合 key 中， 移除随机的 key</li><li>volatile-ttl： 移除那些 TTL 值最小的 key， 即那些最近要过期的 key</li><li>noeviction： 不进行移除。 针对写操作， 只是返回错误信息</li></ul><h3 id="6-8-4-maxmemory-samples"><a href="#6-8-4-maxmemory-samples" class="headerlink" title="6.8.4 maxmemory-samples"></a>6.8.4 maxmemory-samples</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728091924891.png" alt="image-20230728091924891"></p><ul><li>设置样本数量， LRU 算法和最小 TTL 算法都并非是精确的算法， 而是估算值， 所以你可以设置样本的大小， redis 默认会检查这么多个 key 并选择其中 LRU 的那个</li><li>一般设置 3 到 7 的数字， 数值越小样本越不准确， 但性能消耗越小</li></ul><h1 id="7-发布和订阅"><a href="#7-发布和订阅" class="headerlink" title="7 发布和订阅"></a>7 发布和订阅</h1><h2 id="7-1-发布和订阅是什么"><a href="#7-1-发布和订阅是什么" class="headerlink" title="7.1 发布和订阅是什么"></a>7.1 发布和订阅是什么</h2><h3 id="7-1-1-概述："><a href="#7-1-1-概述：" class="headerlink" title="7.1.1 概述："></a>7.1.1 概述：</h3><p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式： 发送者 (pub) 发送消息，订阅者 (sub) 接收消息</p><h3 id="7-1-2-Redis-客户端可以订阅任意数量的频道"><a href="#7-1-2-Redis-客户端可以订阅任意数量的频道" class="headerlink" title="7.1.2 Redis 客户端可以订阅任意数量的频道"></a>7.1.2 Redis 客户端可以订阅任意数量的频道</h3><h3 id="7-1-3-一图胜千言"><a href="#7-1-3-一图胜千言" class="headerlink" title="7.1.3 一图胜千言"></a>7.1.3 一图胜千言</h3><p>1、 客户端订阅频道示意图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728092654620.png" alt="image-20230728092654620" style="zoom: 67%;" /><p>2、当给这个频道发布消息后，消息就会发送给订阅的客户端</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728093005557.png" alt="image-20230728093005557" style="zoom:60%;" /><h2 id="7-2-如何理解发布和订阅模式"><a href="#7-2-如何理解发布和订阅模式" class="headerlink" title="7.2 如何理解发布和订阅模式"></a>7.2 如何理解发布和订阅模式</h2><h3 id="7-2-1-任务队列"><a href="#7-2-1-任务队列" class="headerlink" title="7.2.1 任务队列"></a>7.2.1 任务队列</h3><p>1、 顾名思义， 就是”传递消息的队列”</p><p>2、 与任务队列进行交互的实体有两类， 一类是生产者（ producer）， 另一类则是消费者（consumer）。 <strong>生产者将需要处理的任务放入任务队列中， 而消费者则不断地从任务队列中读入任务信息并执行</strong></p><h3 id="7-2-2-如何理解"><a href="#7-2-2-如何理解" class="headerlink" title="7.2.2 如何理解"></a>7.2.2 如何理解</h3><p>​可以这么简单的理解：</p><ol><li>Subscriber： 收音机， 可以收到多个频道， 并以队列方式显示</li><li>Publisher： 电台， 可以往不同的 FM 频道中发消息</li><li>Channel： 不同频率的 FM 频道</li></ol><p>从 Pub&#x2F;Sub 的机制来看， 它更像是一个广播系统， 多个订阅者（Subscriber） 可以订阅多个频道（Channel）， 多个发布者（Publisher） 可以往多个频道（Channel） 中发布消息</p><h2 id="7-3-发布订阅模式分类"><a href="#7-3-发布订阅模式分类" class="headerlink" title="7.3 发布订阅模式分类"></a>7.3 发布订阅模式分类</h2><p>——-发布：提供数据的</p><p>——-订阅：接受、处理数据的</p><h3 id="7-3-1-一个发布者，-多个订阅者"><a href="#7-3-1-一个发布者，-多个订阅者" class="headerlink" title="7.3.1 一个发布者， 多个订阅者"></a>7.3.1 一个发布者， 多个订阅者</h3><p>​-主要应用： <strong>通知、 公告</strong></p><p>​-可以<strong>作为消息队列或者消息管道</strong></p><p>​-示意图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728093416754.png" alt="image-20230728093416754"></p><h3 id="7-3-2-多个发布者，-一个订阅者"><a href="#7-3-2-多个发布者，-一个订阅者" class="headerlink" title="7.3.2 多个发布者， 一个订阅者"></a>7.3.2 多个发布者， 一个订阅者</h3><p>​-各应用程序作为 Publisher 向 Channel 中发送消息， Subscriber 端收到消息后执行相应的业务逻辑， 比如写数据库， 显示..</p><p>​-主要应用：<strong>排行榜、投票、计数</strong></p><p>​-示意图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728093709916.png" alt="image-20230728093709916"></p><h3 id="7-3-3-多个发布者，-多个订阅者"><a href="#7-3-3-多个发布者，-多个订阅者" class="headerlink" title="7.3.3 多个发布者， 多个订阅者"></a>7.3.3 多个发布者， 多个订阅者</h3><p>-可以向不同的 Channel 中发送消息， 由不同的 Subscriber 接收。</p><p>-主要应用：<strong>群聊、聊天</strong></p><p>-示意图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728093939273.png" alt="image-20230728093939273"></p><h2 id="7-4-命令行实现发布和订阅"><a href="#7-4-命令行实现发布和订阅" class="headerlink" title="7.4 命令行实现发布和订阅"></a>7.4 命令行实现发布和订阅</h2><h3 id="7-4-1-发布、订阅操作"><a href="#7-4-1-发布、订阅操作" class="headerlink" title="7.4.1 发布、订阅操作"></a>7.4.1 发布、订阅操作</h3><p>1、 <strong>PUBLISH channel msg</strong></p><p>将信息 message 发送到指定的频道 channel</p><p>2、 <strong>SUBSCRIBE channel [channel …]</strong></p><p>订阅频道， 可以同时订阅多个频道</p><p>3、 <strong>UNSUBSCRIBE [channel …]</strong></p><p>取消订阅指定的频道, 如果不指定频道， 则会取消订阅所有频道</p><p>4、 <strong>PSUBSCRIBE pattern [pattern …]</strong></p><p>订阅一个或多个符合给定模式的频道， 每个模式以 * 作为匹配符， 比如 it* 匹配所 有以 it 开头的频道( it.news 、 it.blog 、 it.tweets 等等)， news.* 匹配所有 以 news. 开头的频道( news.it 、 news.global.today 等等)， 诸如此类</p><p>5、 <strong>PUNSUBSCRIBE [pattern [pattern …]]</strong></p><p>退订指定的规则, 如果没有参数则会退订所有规则</p><h3 id="7-4-2-快速入门"><a href="#7-4-2-快速入门" class="headerlink" title="7.4.2 快速入门"></a>7.4.2 快速入门</h3><p>1、 打开一个客户端订阅 channel1</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728094614049.png" alt="image-20230728094614049" style="zoom:50%;" /><p>2、打开另一个客户端，给 channel1 发布消息 hello</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728094636960.png" alt="image-20230728094636960" style="zoom:50%;" /><p>3、返回的 1, 是订阅者数量</p><p>4、发布的消息没有持久化(关闭redis后就没了)</p><p>5、订阅的客户端, 只能收到订阅后发布的消息</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728094704271.png" alt="image-20230728094704271" style="zoom:50%;" /><h1 id="8-Jedis"><a href="#8-Jedis" class="headerlink" title="8 Jedis"></a>8 Jedis</h1><h2 id="8-1-API-文档"><a href="#8-1-API-文档" class="headerlink" title="8.1 API 文档"></a>8.1 API 文档</h2><h3 id="8-1-1-在线文档-https-www-mklab-cn-onlineapi-jedis"><a href="#8-1-1-在线文档-https-www-mklab-cn-onlineapi-jedis" class="headerlink" title="8.1.1 在线文档 : https://www.mklab.cn/onlineapi/jedis/"></a>8.1.1 在线文档 : <a href="https://www.mklab.cn/onlineapi/jedis/">https://www.mklab.cn/onlineapi/jedis/</a></h3><h2 id="8-2-Jedis-介绍"><a href="#8-2-Jedis-介绍" class="headerlink" title="8.2 Jedis 介绍"></a>8.2 Jedis 介绍</h2><p>-Java 程序操作 Redis 的工具</p><h2 id="8-3-Jedis-操作-Redis-数据"><a href="#8-3-Jedis-操作-Redis-数据" class="headerlink" title="8.3 Jedis 操作 Redis 数据"></a>8.3 Jedis 操作 Redis 数据</h2><p>​<strong>(以redis命名作为方法名称，学习成本低，但是线程不安全，多线程环境下需要基于连接池来使用)</strong></p><h3 id="8-3-1-快速入门"><a href="#8-3-1-快速入门" class="headerlink" title="8.3.1 快速入门"></a>8.3.1 快速入门</h3><h5 id="step1-引入依赖"><a href="#step1-引入依赖" class="headerlink" title="step1:  引入依赖"></a>step1:  引入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="step2：建立连接"><a href="#step2：建立连接" class="headerlink" title="step2：建立连接"></a>step2：建立连接</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 老师解读</span></span><br><span class="line"><span class="comment">* 1. 确保 ip:6379 是连通的, 需要打开防火墙的端口</span></span><br><span class="line"><span class="comment">* 2. 如果 redis 你设置了密码, 需要执行 jedis.auth(&quot;hspedu&quot;);进行权限验证</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">con</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;172.20.10.4&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        jedis.auth(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> jedis.ping();</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功，返回结果：&quot;</span> + res);</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="step3：使用Redis"><a href="#step3：使用Redis" class="headerlink" title="step3：使用Redis"></a>step3：使用Redis</h5><p> (Jedis中的API和redis中的命令一模一样！)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">key</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;172.20.10.4&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">       jedis.auth(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">       jedis.set(<span class="string">&quot;q1&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">       jedis.set(<span class="string">&quot;q2&quot;</span>,<span class="string">&quot;234&quot;</span>);</span><br><span class="line">       jedis.set(<span class="string">&quot;q3&quot;</span>,<span class="string">&quot;345&quot;</span>);</span><br><span class="line"></span><br><span class="line">       Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;key--&gt;&quot;</span> + key);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(jedis.exists(<span class="string">&quot;q1&quot;</span>));</span><br><span class="line">       System.out.println(jedis.ttl(<span class="string">&quot;q2&quot;</span>));</span><br><span class="line">       System.out.println(jedis.get(<span class="string">&quot;q2&quot;</span>));</span><br><span class="line">       jedis.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="step4：释放资源"><a href="#step4：释放资源" class="headerlink" title="step4：释放资源"></a>step4：释放资源</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="literal">null</span>)&#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-2-连接-Redis-注意事项"><a href="#8-3-2-连接-Redis-注意事项" class="headerlink" title="8.3.2 连接 Redis 注意事项"></a>8.3.2 连接 Redis 注意事项</h3><p>1、 确保 ip:6379 是连通的, 注意打开防火墙的 6379 端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">● 设置开放的端口号</span><br><span class="line">firewall-cmd --add-port=6379/tcp --permanent</span><br><span class="line">● 重启防火墙</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">● 查看防火墙</span><br><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure><p>2、如果 redis 你设置了密码, 需要执行 jedis.auth(“密码”);进行权限验证</p><h1 id="9-Spring-Boot2-整合-Redis"><a href="#9-Spring-Boot2-整合-Redis" class="headerlink" title="9 Spring Boot2 整合 Redis"></a>9 Spring Boot2 整合 Redis</h1><h2 id="9-1-需求分析-x2F-图解"><a href="#9-1-需求分析-x2F-图解" class="headerlink" title="9.1 需求分析&#x2F;图解"></a>9.1 需求分析&#x2F;图解</h2><ol><li>在 springboot 中 , 整合 redis</li><li>可以通过 <strong>RedisTemplate</strong> 完成对 redis 的操作, 包括设置数据&#x2F;获取数据</li><li>比如添加和读取数据</li></ol><h2 id="9-2-具体整合实现"><a href="#9-2-具体整合实现" class="headerlink" title="9.2 具体整合实现"></a>9.2 具体整合实现</h2><h3 id="9-2-1-创建-Maven-项目"><a href="#9-2-1-创建-Maven-项目" class="headerlink" title="9.2.1 创建 Maven 项目"></a>9.2.1 创建 Maven 项目</h3><h3 id="9-2-2-修改-pom-xml-引入相关依赖"><a href="#9-2-2-修改-pom-xml-引入相关依赖" class="headerlink" title="9.2.2 修改 pom.xml - 引入相关依赖"></a>9.2.2 修改 pom.xml - 引入相关依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- redis依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- spring2.X集成redis所需common-pool--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--不要带版本号,防止冲突, 使用版本仲裁即可--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.13.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="9-2-3-配置"><a href="#9-2-3-配置" class="headerlink" title="9.2.3 配置"></a>9.2.3 配置</h3><h4 id="9-2-3-1-application-properties"><a href="#9-2-3-1-application-properties" class="headerlink" title="9.2.3.1 application.properties"></a>9.2.3.1 application.properties</h4><p>– 完成 redis 的基本配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Redis服务器地址</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">172.20.10.4</span></span><br><span class="line"><span class="comment">#Redis服务器连接端口</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment">#Redis密码</span></span><br><span class="line"><span class="attr">spring.redis.password</span>=<span class="string">root</span></span><br><span class="line"><span class="comment">#Redis数据库索引(默认为0</span></span><br><span class="line"><span class="attr">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#连接超时时间(毫秒</span></span><br><span class="line"><span class="attr">spring.redis.timeout</span>=<span class="string">1800000</span></span><br><span class="line"><span class="comment">#连接池最大连接数(使用负值表示没有限制</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="comment">#最大阻塞等待时间(使用负值表示没有限制</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment">#连接池中最大空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="comment">#连接池中最小空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure><h4 id="9-2-3-2-redis-配置类"><a href="#9-2-3-2-redis-配置类" class="headerlink" title="9.2.3.2 redis 配置类"></a>9.2.3.2 redis 配置类</h4><p>1、 是<strong>对要使用的 RedisTemplate bean 对象的配置</strong>, 可以理解成是一个常规配置.</p><p>2、 同学们想一想我们以前学习过一个 JdbcTemplate,设计理念类似</p><p>3、 如果不配置, springboot 会使用默认配置, 这个默认配置, 会出现一些问题, 比如:redisTemplate 的 key 序列化等, 问题所以通常我们需要配置</p><p>4、创 建 RedisConfig.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        System.out.println(<span class="string">&quot;template=&gt;&quot;</span> + template);<span class="comment">//这里可以验证..</span></span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.activateDefaultTyping(</span><br><span class="line">                LaissezFaireSubTypeValidator.instance,</span><br><span class="line">                ObjectMapper.DefaultTyping.NON_FINAL,</span><br><span class="line">                JsonTypeInfo.As.WRAPPER_ARRAY);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">//key序列化方式</span></span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line">        <span class="comment">//value序列化</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//value hashmap序列化</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="comment">//解决查询缓存转换异常的问题</span></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.activateDefaultTyping(</span><br><span class="line">                LaissezFaireSubTypeValidator.instance,</span><br><span class="line">                ObjectMapper.DefaultTyping.NON_FINAL,</span><br><span class="line">                JsonTypeInfo.As.WRAPPER_ARRAY);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span></span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        <span class="type">RedisCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-2-3-3-注意事项和细节"><a href="#9-2-3-3-注意事项和细节" class="headerlink" title="9.2.3.3 注意事项和细节"></a>9.2.3.3 注意事项和细节</h4><p>1、 如果没有提供 RedisConfig 配置类 , springboot 会使用默认配置, 也可以使用,但是会存在问题</p><p>2、🌟 Unrecognized token ‘beijing’: was expecting (‘true’, ‘false’ or ‘null’)看报错，是 jason 转换异常，实际上是因为 <strong>redisTemplate 在做数据存储的时候会把存储的内容序列化，所以，redisTemplate 读取的时候也会反序列化，</strong><u>而在 <strong>redis 客户端</strong>set 的时候并不会做序列化，因此 set 的进去的值在用 redisTemplate 读的时候就会报类型转换异常了</u></p><p>—-解决方案 : 最简单的就是<strong>用程序</strong>重新 set 一遍即可</p><h4 id="9-2-3-4编写控制层，接收前端消息后进行redis存取操作"><a href="#9-2-3-4编写控制层，接收前端消息后进行redis存取操作" class="headerlink" title="9.2.3.4编写控制层，接收前端消息后进行redis存取操作"></a>9.2.3.4编写控制层，接收前端消息后进行redis存取操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//装配RedisTemplate</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写方法,演示如何操作list,hash,set,zset</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/t2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">t2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//list-存</span></span><br><span class="line">    redisTemplate.opsForList().leftPush(<span class="string">&quot;books&quot;</span>, <span class="string">&quot;笑傲江湖&quot;</span>);</span><br><span class="line">    redisTemplate.opsForList().leftPush(<span class="string">&quot;books&quot;</span>, <span class="string">&quot;hello,java&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//list-取出</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">books</span> <span class="operator">=</span> redisTemplate.opsForList().range(<span class="string">&quot;books&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">booksList</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (Object book : books) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book--&gt;&quot;</span> + book.toString());</span><br><span class="line">        booksList += book.toString() + <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//hash</span></span><br><span class="line">    <span class="comment">//redisTemplate.opsForHash()</span></span><br><span class="line">    <span class="comment">//set</span></span><br><span class="line">    <span class="comment">//redisTemplate.opsForSet()</span></span><br><span class="line">    <span class="comment">//zset</span></span><br><span class="line">    <span class="comment">//redisTemplate.opsForZSet()</span></span><br><span class="line">    <span class="keyword">return</span> booksList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RedisTemplate工具类的使用：</p><table><thead><tr><th align="center"><strong>API</strong></th><th align="center"><strong>返回值类型</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"><strong>redisTemplate</strong>.opsForValue()</td><td align="center">ValueOperations</td><td align="center">操作String类型数据</td></tr><tr><td align="center"><strong>redisTemplate</strong>.opsForHash()</td><td align="center">HashOperations</td><td align="center">操作Hash类型数据</td></tr><tr><td align="center"><strong>redisTemplate</strong>.opsForList()</td><td align="center">ListOperations</td><td align="center">操作List类型数据</td></tr><tr><td align="center"><strong>redisTemplate</strong>.opsForSet()</td><td align="center">SetOperations</td><td align="center">操作Set类型数据</td></tr><tr><td align="center"><strong>redisTemplate</strong>.opsForZSet()</td><td align="center">ZSetOperations</td><td align="center">操作SortedSet类型数据</td></tr><tr><td align="center"><strong>redisTemplate</strong></td><td align="center"></td><td align="center">通用的命令</td></tr></tbody></table><h1 id="10-Redis-持久化-RDB-记录数据"><a href="#10-Redis-持久化-RDB-记录数据" class="headerlink" title="10 Redis 持久化-RDB(记录数据)"></a>10 Redis 持久化-RDB(记录数据)</h1><h2 id="10-1-官方资料"><a href="#10-1-官方资料" class="headerlink" title="10.1 官方资料"></a>10.1 官方资料</h2><h3 id="10-1-1-在线文档-https-redis-io-topics-persistence"><a href="#10-1-1-在线文档-https-redis-io-topics-persistence" class="headerlink" title="10.1.1 在线文档 : https://redis.io/topics/persistence"></a>10.1.1 在线文档 : <a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a></h3><h2 id="10-2-持久化方案"><a href="#10-2-持久化方案" class="headerlink" title="10.2 持久化方案"></a>10.2 持久化方案</h2><h3 id="10-2-1-RDB（Redis-DataBase）"><a href="#10-2-1-RDB（Redis-DataBase）" class="headerlink" title="10.2.1 RDB（Redis DataBase）"></a>10.2.1 RDB（Redis DataBase）</h3><h3 id="10-2-2-AOF（Append-Of-File）"><a href="#10-2-2-AOF（Append-Of-File）" class="headerlink" title="10.2.2 AOF（Append Of File）"></a>10.2.2 AOF（Append Of File）</h3><h2 id="10-3-RDB-是什么"><a href="#10-3-RDB-是什么" class="headerlink" title="10.3 RDB 是什么?"></a>10.3 RDB 是什么?</h2><h3 id="10-3-1-在指定的时间间隔内将内存中的数据集快照写入磁盘，-也就-Snapshot-快照，-恢复时将快照文件读到内存"><a href="#10-3-1-在指定的时间间隔内将内存中的数据集快照写入磁盘，-也就-Snapshot-快照，-恢复时将快照文件读到内存" class="headerlink" title="10.3.1 在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就 Snapshot 快照， 恢复时将快照文件读到内存"></a>10.3.1 在指定的时间间隔内<u>将内存中的数据集快照写入磁盘</u>， 也就 Snapshot 快照， 恢复时将快照文件读到内存</h3><h2 id="10-4-RDB-持久化流程"><a href="#10-4-RDB-持久化流程" class="headerlink" title="10.4 RDB 持久化流程"></a>10.4 RDB 持久化流程</h2><h3 id="10-4-1-RDB-及其执行流程"><a href="#10-4-1-RDB-及其执行流程" class="headerlink" title="10.4.1 RDB 及其执行流程"></a>10.4.1 RDB 及其执行流程</h3><h4 id="1、-一图胜千言"><a href="#1、-一图胜千言" class="headerlink" title="1、 一图胜千言"></a>1、 一图胜千言</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729092028338.png" alt="image-20230729092028338"></p><h4 id="2、对上图的解读"><a href="#2、对上图的解读" class="headerlink" title="2、对上图的解读"></a>2、对上图的解读</h4><p>​具体流程如下：</p><pre><code>1) redis 客户端执行 bgsave 命令或者自动触发 bgsave 命令；2) 主进程判断当前是否已经存在正在执行的子进程，如果存在，那么主进程直接返回；3) 如果不存在正在执行的子进程，那么就 **fork 一个新的子进程进行持久化数据**，fork 过程是阻塞的，fork 操作完成后主进程即可执行其他操作；4) 子进程先将数据写入到临时的 rdb 文件中，**待快照数据写入完成后再原子替换**旧的 rdb文件</code></pre><ol start="5"><li>同时发送信号给主进程，通知主进程 rdb 持久化完成，主进程更新相关的统计信息</li></ol><h4 id="3、老师小结"><a href="#3、老师小结" class="headerlink" title="3、老师小结"></a>3、老师小结</h4><ol><li>整个过程中，主进程是不进行任何 IO 操作的(交给子进程)，这就确保了极高的性能</li><li>如果需要进行大规模数据的恢复, 且对于数据恢复的完整性不是非常敏感，那 RDB 方式要比 AOF 方式更加的高效</li><li>RDB 的缺点是最后一次持久化后的数据可能丢失(最后一次持久化期间进来的数据不会被记录到rdb文件中)</li></ol><ul><li>如果你是正常关闭 Redis , 关闭时会再进行一次持久化, 不会造成数据丢失</li><li>如果是 Redis 异常终止&#x2F;宕机, 就可能造成数据丢失</li><li>后面在讲解快照配置 , 还会举例说明</li></ul><h3 id="10-4-2-Fork-amp-Copy-On-Write"><a href="#10-4-2-Fork-amp-Copy-On-Write" class="headerlink" title="10.4.2 Fork&amp;Copy-On-Write"></a>10.4.2 Fork&amp;Copy-On-Write</h3><p>1、 Fork 的作用是复制一个与当前进程一样的进程。 新进程的所有数据(变量、 环境变量、程序计数器等) 数值都和原进程一致， 但是是一个全新的进程， 并作为原进程的子进程</p><p>——对进程进行深拷贝，并将结果作为原进程的子进程</p><p>2、 在 Linux 程序中， fork()会产生一个和父进程完全相同的子进程， 但子进程在此后多会exec 系统调用， 出于效率考虑， Linux 中引入了”写时复制技术 即: copy-on-write” , 有兴趣的参考: <a href="https://blog.csdn.net/Code_beeps/article/details/92838520">https://blog.csdn.net/Code_beeps/article/details/92838520</a></p><p>3、 一般情况父进程和子进程会共用同一段物理内存， 只有进程空间的各段的内容要发生变化时， 才会将父进程的内容复制一份给子进程。</p><h2 id="10-5-RDB-配置"><a href="#10-5-RDB-配置" class="headerlink" title="10.5 RDB 配置"></a>10.5 RDB 配置</h2><h3 id="10-5-1-dump-rdb-文件"><a href="#10-5-1-dump-rdb-文件" class="headerlink" title="10.5.1 dump.rdb 文件"></a>10.5.1 dump.rdb 文件</h3><h4 id="10-5-1-1-介绍"><a href="#10-5-1-1-介绍" class="headerlink" title="10.5.1.1 介绍"></a>10.5.1.1 介绍</h4><p>​在 redis.conf 中配置文件名称, 默认为 dump.rdb</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729093257075.png" alt="image-20230729093257075" style="zoom:50%;" /><h4 id="10-5-1-2-如何配置"><a href="#10-5-1-2-如何配置" class="headerlink" title="10.5.1.2 如何配置"></a>10.5.1.2 如何配置</h4><h4 id="1、-默认为-Redis-启动时命令行所在的目录下"><a href="#1、-默认为-Redis-启动时命令行所在的目录下" class="headerlink" title="1、 默认为 Redis 启动时命令行所在的目录下"></a>1、 默认为 Redis 启动时命令行所在的目录下</h4><p>​1) 如图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729094325579.png" alt="image-20230729094325579"></p><p>说明：dump.rdb文件存放着redis中的数据，你每次启动，都会到你设定的路径下的 dump.rdb 中寻找数据，如果此处设置的<strong>不是绝对路径而是相对路径</strong>，那么你在不同的目录下启动redis时，就会去不同的地方寻找备份的数据，即在不同目录下启动得到的备份数据源不同！</p><h3 id="10-5-2-相关配置-amp-参数-amp-操作"><a href="#10-5-2-相关配置-amp-参数-amp-操作" class="headerlink" title="10.5.2 相关配置&amp;参数&amp;操作"></a>10.5.2 相关配置&amp;参数&amp;操作</h3><h4 id="10-5-2-1-默认快照配置"><a href="#10-5-2-1-默认快照配置" class="headerlink" title="10.5.2.1 默认快照配置"></a>10.5.2.1 默认快照配置</h4><h5 id="1、-配置如图"><a href="#1、-配置如图" class="headerlink" title="1、 配置如图"></a>1、 配置如图</h5><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729095330539.png" alt="image-20230729095330539"></p><h5 id="2、注意理解这个时间段的概念"><a href="#2、注意理解这个时间段的概念" class="headerlink" title="2、注意理解这个时间段的概念"></a>2、注意理解这个时间段的概念</h5><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729095537814.png" alt="image-20230729095537814"></p><h5 id="3、如果我们没有开启-save-的注释-那么在退出-Redis-时-也会进行备份-更新-dump-db"><a href="#3、如果我们没有开启-save-的注释-那么在退出-Redis-时-也会进行备份-更新-dump-db" class="headerlink" title="3、如果我们没有开启 save 的注释, 那么在退出 Redis 时, 也会进行备份, 更新 dump.db"></a>3、如果我们没有开启 save 的注释, 那么在退出 Redis 时, 也会进行备份, 更新 dump.db</h5><h4 id="10-5-2-2-save-VS-bgsave"><a href="#10-5-2-2-save-VS-bgsave" class="headerlink" title="10.5.2.2 save VS bgsave"></a>10.5.2.2 save VS bgsave</h4><p>1、 save ： save 时只管保存， 其它不管， 全部阻塞。 手动保存, <strong>不建议</strong>。</p><p>2、 bgsave： <u>Redis 会在后台异步进行快照操作， 快照同时还可以响应客户端请求。</u></p><p>3、 可以通过 lastsave 命令获取最后一次成功执行快照的时间(<strong>unix 时间戳</strong>) , 可以使用工具转换</p><p><a href="https://tool.lu/timestamp/">https://tool.lu/timestamp/</a></p><h4 id="10-5-2-3-flushall"><a href="#10-5-2-3-flushall" class="headerlink" title="10.5.2.3 flushall"></a>10.5.2.3 flushall</h4><p>1、执行 flushall 命令， 也会产生 dump.rdb 文件, 数据为空</p><p>2、Redis Flushall 命令用于<strong>清空整个 Redis 服务器的数据(删除所有数据库的所有 key)</strong></p><p>10.5.2.4 Save</p><p>1、 格式： save 秒钟 写操作次数, 如图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729100520528.png" alt="image-20230729100520528"></p><p>2、RDB 是整个内存的压缩过的 Snapshot，RDB 的数据结构，可以配置复合的快照触发条件(即配合save)</p><p>3、禁用: 给 save 传入空字符串, 可以看文档</p><h4 id="10-5-2-5-stop-writes-on-bgsave-error"><a href="#10-5-2-5-stop-writes-on-bgsave-error" class="headerlink" title="10.5.2.5 stop-writes-on-bgsave-error"></a>10.5.2.5 stop-writes-on-bgsave-error</h4><p>1、 配置如图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729100830128.png" alt="image-20230729100830128"></p><p>2、当 Redis 无法写入磁盘的话(比如磁盘满了), 直接关掉 Redis 的写操作。推荐 yes</p><h4 id="10-5-2-6-rdbcompression"><a href="#10-5-2-6-rdbcompression" class="headerlink" title="10.5.2.6 rdbcompression"></a>10.5.2.6 rdbcompression</h4><p>1、 配置如图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729100916375.png" alt="image-20230729100916375"></p><p>2、对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis 会采用LZF 算法进行压缩。</p><p>3、如果你不想消耗 CPU 来进行压缩的话，可以设置为关闭此功能, 默认 yes</p><h4 id="10-5-2-7-rdbchecksum"><a href="#10-5-2-7-rdbchecksum" class="headerlink" title="10.5.2.7 rdbchecksum"></a>10.5.2.7 rdbchecksum</h4><p>1、 配置如图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729101019969.png" alt="image-20230729101019969"></p><p>2、在存储快照后, 还可以让 redis 使用 CRC64 算法来进行数据校验，保证文件是完整的</p><p>3、但是这样做会增加大约 10%的性能消耗，如果<strong>希望获取到最大的性能提升，可以关闭此功能</strong>, 推荐 yes</p><h4 id="10-5-2-8-动态停止-RDB"><a href="#10-5-2-8-动态停止-RDB" class="headerlink" title="10.5.2.8 动态停止 RDB"></a>10.5.2.8 动态停止 RDB</h4><p>1、 动态停止 RDB： redis-cli <strong>config set save “”</strong></p><p>2、说明: <strong>save 后给空值，表示禁用保存策略</strong></p><h3 id="10-5-3-实例演示"><a href="#10-5-3-实例演示" class="headerlink" title="10.5.3 实例演示"></a>10.5.3 实例演示</h3><p>1、 需求: 如果 Redis 的 key 在 30 秒内, 有 5 个 key 变化, 就自动进行 RDB 备份</p><p>修改redis.conf中的 save 30 5</p><h2 id="10-6-RDB-备份-amp-恢复"><a href="#10-6-RDB-备份-amp-恢复" class="headerlink" title="10.6 RDB 备份&amp;恢复"></a>10.6 RDB 备份&amp;恢复</h2><p>1、 关于 RDB 备份&amp;恢复, 老韩要说的</p><ul><li>老韩先说明：Redis 可以充当缓存, 对项目进行优化, 因此<strong>重要&#x2F;敏感的数据建议在 Mysql要保存一份</strong></li><li>从设计层面来说, Redis 的内存数据, 都是可以重新获取的(可能来自程序, 也可能来自Mysql)</li><li>因此我们这里说的备份&amp;恢复主要是给大家说明一下 <strong>Redis 启动时, 初始化数据是从dump.rdb 来的, 这个机制</strong></li></ul><ol><li><p>config get dir 查询 rdb 文件的目录</p></li><li><p><strong>将 dump.rdb 进行备份</strong>, 如果有必要可以写 shell 脚本来定时备份 [参考 Linux 课程 定时备份 Mysql 数据库, 视频地址 <a href="https://www.bilibili.com/video/BV1Sv411r7vd?p=105">https://www.bilibili.com/video/BV1Sv411r7vd?p=105</a> ] , 这里老师简单处理</p></li></ol><h2 id="10-7-RDB-持久化小结"><a href="#10-7-RDB-持久化小结" class="headerlink" title="10.7 RDB 持久化小结"></a>10.7 RDB 持久化小结</h2><h3 id="10-7-1-优势"><a href="#10-7-1-优势" class="headerlink" title="10.7.1 优势"></a>10.7.1 优势</h3><p>1、 适合大规模的数据恢复</p><p>2、对数据完整性和一致性要求不高更适合使用</p><p>3、节省磁盘空间</p><p>4、恢复速度快</p><h3 id="10-7-2-劣势"><a href="#10-7-2-劣势" class="headerlink" title="10.7.2 劣势"></a>10.7.2 劣势</h3><ol><li><p>虽然 Redis 在 fork 时使用了写时拷贝技术(Copy-On-Write), 但是如果数据庞大时还是比较消耗性能。</p></li><li><p>在备份周期在一定间隔时间做一次备份， 所以如果 Redis 意外 down 掉的话(如果正常关闭 Redis, 仍然会进行 RDB 备份, 不会丢失数据), 就会丢失最后一次快照后的所有修改</p></li></ol><h1 id="11-Redis-持久化-AOF-记录操作"><a href="#11-Redis-持久化-AOF-记录操作" class="headerlink" title="11 Redis 持久化-AOF(记录操作)"></a>11 Redis 持久化-AOF(记录操作)</h1><h2 id="11-1-官方资料"><a href="#11-1-官方资料" class="headerlink" title="11.1 官方资料"></a>11.1 官方资料</h2><h3 id="11-1-1-在线文档-https-redis-io-topics-persistence"><a href="#11-1-1-在线文档-https-redis-io-topics-persistence" class="headerlink" title="11.1.1 在线文档 : https://redis.io/topics/persistence"></a>11.1.1 在线文档 : <a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a></h3><h2 id="11-2-AOF-是什么"><a href="#11-2-AOF-是什么" class="headerlink" title="11.2 AOF 是什么?"></a>11.2 AOF 是什么?</h2><p>1、 AOF(Append Only File)</p><p>2、 <u>以日志的形式来记录每个写操作(增量保存)</u>， 将 Redis 执行过的所有写指令记录下来(比如 set&#x2F;del 操作会记录, 读操作 get 不记录) [后面演示]</p><p>3、 <strong>只许追加文件但不可以改写文件</strong></p><p>4、 redis <strong>启动之初会读取该文件重新构建数据</strong></p><p>5、 redis 重启的话就根据日志文件的内容**<u>将写指令从前到后执行一次以完成数据的恢复工作</u>**</p><h2 id="11-3-AOF-持久化流程"><a href="#11-3-AOF-持久化流程" class="headerlink" title="11.3 AOF 持久化流程"></a>11.3 AOF 持久化流程</h2><p>1、 持久化流程示意图</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230729155117545.png" alt="image-20230729155117545" style="zoom:50%;" /><p>2、解读</p><ol><li>客户端的请求写命令会被 append <strong>追加到 AOF 缓冲区</strong>内</li><li>AOF 缓冲区根据 AOF 持久化策略[always,everysec,no]将操作 sync <strong>同步到磁盘的 AOF 文件</strong>中 </li><li>AOF 文件大小超过重写策略或手动重写时，会对 AOF 文件 <strong>rewrite</strong> 重写，压缩 AOF 文件容量 </li><li>Redis 服务<strong>重启时，会重新 load 加载 AOF 文件中的写操作达到数据恢复的目的</strong></li></ol><h2 id="11-4-AOF-开启"><a href="#11-4-AOF-开启" class="headerlink" title="11.4 AOF 开启"></a>11.4 AOF 开启</h2><p>1、 在 redis.conf 中配置文件名称， 默认为 appendonly.aof</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729155850603.png" alt="image-20230729155850603"></p><p>2、<u><strong>AOF 文件的保存路径，同 RDB 的路径一致。</strong></u></p><p>3、AOF 和 RDB 同时开启，<strong>系统默认取 AOF 的数据</strong>（默认AOF优先级高，可手动修改）</p><p>4、当开启 AOF 后, Redis 从 AOF 文件取数据.</p><h2 id="11-5-AOF-实例演示"><a href="#11-5-AOF-实例演示" class="headerlink" title="11.5 AOF 实例演示"></a>11.5 AOF 实例演示</h2><p>…………</p><h2 id="11-6-AOF-启动-x2F-修复-x2F-恢复"><a href="#11-6-AOF-启动-x2F-修复-x2F-恢复" class="headerlink" title="11.6 AOF 启动&#x2F;修复&#x2F;恢复"></a>11.6 AOF 启动&#x2F;修复&#x2F;恢复</h2><h3 id="11-6-1-基本说明"><a href="#11-6-1-基本说明" class="headerlink" title="11.6.1 基本说明"></a>11.6.1 基本说明</h3><p>​AOF 的备份机制和性能虽然和 RDB 不同, 但是备份和恢复的操作同 RDB 一样, <strong>都是拷贝备份文件, 需要恢复时再拷贝到 Redis 工作目录下， 启动系统即加载</strong></p><h3 id="11-6-2-正常恢复"><a href="#11-6-2-正常恢复" class="headerlink" title="11.6.2 正常恢复"></a>11.6.2 正常恢复</h3><p>1、 修改默认的 appendonly no， 改为 yes</p><p><strong>2、将有数据的 aof 文件定时备份, 需要恢复时, 复制一份保存到对应目录(查看目录：config get dir)</strong></p><p>3、恢复：重启 redis 然后重新加载</p><p>4、和前面 RDB 备份&#x2F;恢复机制类似</p><h3 id="11-6-3-异常恢复"><a href="#11-6-3-异常恢复" class="headerlink" title="11.6.3 异常恢复"></a>11.6.3 异常恢复</h3><p>1、 如遇到 AOF 文件损坏， 通过 [&#x2F;usr&#x2F;local&#x2F;bin]# .&#x2F;redis-check-aof –fix appendonly.aof 进行恢复</p><p>2、建议先: 备份被写坏的 AOF 文件</p><p>3、恢复：重启 redis，然后重新加载</p><h2 id="11-7-同步频率设置"><a href="#11-7-同步频率设置" class="headerlink" title="11.7 同步频率设置"></a>11.7 同步频率设置</h2><p>1、 配置位置</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729161749574.png" alt="image-20230729161749574" style="zoom:50%;" /><p>2、老韩解读上图</p><p>​1)appendfsync always</p><p>​始终同步，每次 Redis 的写入都会立刻记入日志；性能较差但数据完整性比较好</p><p>​2)appendfsync everysec</p><p>​每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</p><p>​3)appendfsync noredis </p><p>​不主动进行同步，把同步时机交给操作系统</p><p>​<a href="https://baijiahao.baidu.com/s?id=1740774723808931509&wfr=spider&for=pc">https://baijiahao.baidu.com/s?id=1740774723808931509&amp;wfr=spider&amp;for=pc</a></p><h2 id="11-8-Rewrite-压缩"><a href="#11-8-Rewrite-压缩" class="headerlink" title="11.8 Rewrite 压缩"></a>11.8 Rewrite 压缩</h2><h3 id="1、-rewrite-重写介绍"><a href="#1、-rewrite-重写介绍" class="headerlink" title="1、 rewrite 重写介绍"></a>1、 rewrite 重写介绍</h3><pre><code>1) AOF 文件越来越大，**需要定期对 AOF 文件进行重写达到压缩**1) 旧的 AOF 文件含有&lt;u&gt;无效命令会被忽略，保留最新的数据命令&lt;/u&gt; , 比如 set a a1 ; set a b1 ;set a c1; 保留最后一条指令就可以了1) &lt;u&gt;多条写命令可以合并为一个 , 比如 set a c1 b b1 c c1&lt;/u&gt;1) AOF 重写降低了文件占用空间1) 更小的 AOF 文件可以更快的被 redis 加载</code></pre><h3 id="2、重写触发配置"><a href="#2、重写触发配置" class="headerlink" title="2、重写触发配置"></a>2、重写触发配置</h3><p>​1) 手动触发直接调用 bgrewriteaof 命令</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729162232144.png" alt="image-20230729162232144" style="zoom:50%;" /><p>​2）自动触发</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729162701336.png" alt="image-20230729162701336"></p><ul><li><strong>auto-aof-rewrite-min-size: AOF 文件最小重写大小</strong>, 只有当 AOF 文件大小大于该值时候才能重写, 默认配置 64MB</li><li>auto-aof-rewrite-percentage: 当前 AOF 文件大小和最后一次重写后的大小之间的比率等于或者大于指定的增长百分比，如 100 代表当前 AOF 文件是上次重写的两倍时候才重写</li></ul><p>系统载入时或者上次重写完毕时，Redis 会记录此时 AOF 大小，设为base_size, 如果 Redis 的 AOF 当前大小&gt;&#x3D; base_size +base_size*100% (默认)且当前大小&gt;&#x3D;64mb(默认)的情况下，Redis 会对 AOF 进行重写</p><h2 id="11-9-AOF-持久化小结"><a href="#11-9-AOF-持久化小结" class="headerlink" title="11.9 AOF 持久化小结"></a>11.9 AOF 持久化小结</h2><h3 id="11-9-1-优势"><a href="#11-9-1-优势" class="headerlink" title="11.9.1 优势"></a>11.9.1 优势</h3><p>1、 备份机制更稳健， 丢失数据概率更低。</p><p>2、可读的日志文本，通过操作 AOF 稳健，可以处理误操作</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729175239380.png" alt="image-20230729175239380" style="zoom:50%;" /><h3 id="11-9-2-劣势"><a href="#11-9-2-劣势" class="headerlink" title="11.9.2 劣势"></a>11.9.2 劣势</h3><p>1、 比起 RDB 占用更多的磁盘空间</p><p>2、恢复备份速度要慢</p><p>3、每次读写都同步的话，有一定的性能压力</p><h2 id="11-10-RDB-还是-AOF"><a href="#11-10-RDB-还是-AOF" class="headerlink" title="11.10 RDB 还是 AOF?"></a>11.10 RDB 还是 AOF?</h2><p>1、 官方文档地址: <a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a></p><p>2、<strong>官方推荐两个都启用</strong></p><p>3、如果只做缓存：如果你只希望你的数据在服务器运行的时候存在, 你也可以不使用任何持久化方式</p><h1 id="12-Redis事务-锁机制-秒杀"><a href="#12-Redis事务-锁机制-秒杀" class="headerlink" title="12 Redis事务_ 锁机制 _秒杀"></a>12 Redis事务_ 锁机制 _秒杀</h1><h2 id="12-1-Redis-的事务是什么"><a href="#12-1-Redis-的事务是什么" class="headerlink" title="12.1 Redis 的事务是什么?"></a>12.1 Redis 的事务是什么?</h2><p>​1、 Redis 事务是一个单独的隔离操作： 事务中的所有命令都会序列化、 按顺序地执行</p><p>​2、事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</p><p>​3、Redis 事务的主要作用就是串联多个命令防止别的命令插队</p><h2 id="12-2-Redis-事务三特性"><a href="#12-2-Redis-事务三特性" class="headerlink" title="12.2 Redis 事务三特性"></a>12.2 Redis 事务三特性</h2><h3 id="12-2-1-单独的隔离操作"><a href="#12-2-1-单独的隔离操作" class="headerlink" title="12.2.1 单独的隔离操作"></a>12.2.1 单独的隔离操作</h3><p>​1、 事务中的所有命令都会<u>序列化、 按顺序地执行</u></p><p>​2、 事务在执行的过程中， <u>不会被其他客户端发送来的命令请求所打断</u></p><h3 id="12-2-2-没有隔离级别的概念"><a href="#12-2-2-没有隔离级别的概念" class="headerlink" title="12.2.2 没有隔离级别的概念"></a>12.2.2 没有隔离级别的概念</h3><p>​队列中的命令(指令), <strong>在没有提交前都不会实际被执行</strong></p><h3 id="12-2-3-不保证原子性"><a href="#12-2-3-不保证原子性" class="headerlink" title="12.2.3 不保证原子性"></a>12.2.3 不保证原子性</h3><p>​事务执行过程中, 如果有指令执行失败， 其它的指令仍然会被执行, 没有回滚</p><h2 id="12-3-事务相关指令-Multi、-Exec、-discard"><a href="#12-3-事务相关指令-Multi、-Exec、-discard" class="headerlink" title="12.3 事务相关指令 Multi、 Exec、 discard"></a>12.3 事务相关指令 Multi、 Exec、 discard</h2><h3 id="12-3-1-一图胜千言"><a href="#12-3-1-一图胜千言" class="headerlink" title="12.3.1 一图胜千言"></a>12.3.1 一图胜千言</h3><p>1、 Redis 事务指令示意图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729180534083.png" alt="image-20230729180534083" style="zoom:50%;" /><p>2、解读上图:</p><ol><li><strong>从输入 Multi 命令开始，输入的命令都会依次进入命令队列中，但不会执行</strong>(类似 Mysql的 start transaction 开启事务)</li><li><strong>输入 Exec 后，Redis 会将之前的命令队列中的命令依次执行</strong>(类似 Mysql 的 commit 提交事务)</li><li>组队的过程中可以<strong>通过 discard 来放弃组队</strong>(类似 Mysql 的 rollback 回顾事务)</li><li>⚠️： Redis 事务和 Mysql 事务本质是完全不同的, 这里只是用 Mysql 的做类似说明, 是为了让小伙伴好理解</li></ol><h3 id="12-3-2-快速入门"><a href="#12-3-2-快速入门" class="headerlink" title="12.3.2 快速入门"></a>12.3.2 快速入门</h3><p>……</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729181130039.png" alt="image-20230729181130039"></p><h3 id="12-3-3-注意事项和细节"><a href="#12-3-3-注意事项和细节" class="headerlink" title="12.3.3 注意事项和细节"></a>12.3.3 注意事项和细节</h3><p>​1、 组队的过程中, 可以通过 discard 来放弃组队</p><p>​<strong>2、如果在组队阶段报错, 会导致 exec 失败, 那么事务的所有指令都不会被执行</strong>(这时候是有原子性的)</p><p>​3、如果组队成功, 但是指令有不能正常执行的, 那么 exec 提交, 会出现有成功有失败情况,也就是事务得到部分执行, <strong>这种情况下, Redis 事务不具备原子性.</strong></p><h2 id="12-4-事务冲突及解决方案"><a href="#12-4-事务冲突及解决方案" class="headerlink" title="12.4 事务冲突及解决方案"></a>12.4 事务冲突及解决方案</h2><h3 id="12-4-1-先看一个问题"><a href="#12-4-1-先看一个问题" class="headerlink" title="12.4.1 先看一个问题"></a>12.4.1 先看一个问题</h3><p>1、 经典的抢票问题(总共十张票)</p><p>​1) 一个请求想购买 6</p><p>​2) 一个请求想购买 5</p><p>​    3) 一个请求想购买 1</p><p>——如果没有控制, 会造成超卖现象    ;  如果 3 个指令, 都得到执行, 最后剩余的票数是 -2</p><h3 id="12-4-2-悲观锁"><a href="#12-4-2-悲观锁" class="headerlink" title="12.4.2 悲观锁"></a>12.4.2 悲观锁</h3><p>1、 工作示意图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729182017365.png" alt="image-20230729182017365"></p><p>2、解读上图</p><ol><li>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，<strong>每次去拿数据的时候都认为别人会修改，所以每次在获取数据的时候都会上锁</strong></li><li>这样别人&#x2F;其它请求想拿这个数据就会 block，直到拿到锁。</li><li>悲观锁是锁设计理念, 传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁.</li></ol><h3 id="12-4-3-乐观锁"><a href="#12-4-3-乐观锁" class="headerlink" title="12.4.3 乐观锁"></a>12.4.3 乐观锁</h3><p>1、 工作示意图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729182519566.png" alt="image-20230729182519566"></p><p>2、解读上图：</p><pre><code>1) 乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁1) 但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，**可以使用版本号等机制。**1) 乐观锁&lt;u&gt;**适用于多读的应用类型，这样可以提高吞吐量**&lt;/u&gt;。Redis 就是利用这种 check-and-set机制实现事务的1) 乐观锁是锁设计理念(**不用担心在修改版本的瞬间，别人正好读到版本——因为版本修改阶段是原子性的！**)</code></pre><h3 id="12-4-4-watch-amp-unwatch"><a href="#12-4-4-watch-amp-unwatch" class="headerlink" title="12.4.4 watch &amp; unwatch"></a>12.4.4 watch &amp; unwatch</h3><h4 id="12-4-4-1-watch"><a href="#12-4-4-1-watch" class="headerlink" title="12.4.4.1 watch"></a>12.4.4.1 watch</h4><p>1、 基本语法: watch key [key …]</p><p>2、在执行 multi 之前，<strong>先执行 watch key1 [key2],可以监视一个(或多个) key ，如果在事务执行之前这个(或这些) key <u>被其他命令所改动</u>，那么事务将被打断.</strong></p><p>3、这里可以结合乐观锁机制进行理解</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729183535766.png" alt="image-20230729183535766"></p><h4 id="12-4-4-2-unwatch"><a href="#12-4-4-2-unwatch" class="headerlink" title="12.4.4.2 unwatch"></a>12.4.4.2 unwatch</h4><p>1、 基本语法unwatch</p><p>2、取消 watch 命令对所有 key 的监视。</p><p>3、如果在执行 watch 命令后，exec 命令或 discard 命令先被执行了的话，那么就不需要再执行 unwatch 了</p><h2 id="12-5-火车票-抢票"><a href="#12-5-火车票-抢票" class="headerlink" title="12.5 火车票-抢票"></a>12.5 火车票-抢票</h2><h3 id="12-5-1-需求分析-x2F-图解"><a href="#12-5-1-需求分析-x2F-图解" class="headerlink" title="12.5.1 需求分析&#x2F;图解"></a>12.5.1 需求分析&#x2F;图解</h3><p>……</p><h3 id="12-5-2-思路分析"><a href="#12-5-2-思路分析" class="headerlink" title="12.5.2 思路分析"></a>12.5.2 思路分析</h3><p>​– 思路分析</p><p>​1、一个 user 只能购买一张票, 即<u>不能复购</u></p><p>​2、<u>不能出现超购</u>,也是就多卖了.</p><p>​3、不能出现火车票遗留问题&#x2F;库存遗留, 即*<u>火车票不能留下</u>*</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730102256386.png" alt="image-20230730102256386" style="zoom: 67%;" /><h3 id="12-5-3-版本-1：-完成基本购票流程-暂不考虑事务和并发问题"><a href="#12-5-3-版本-1：-完成基本购票流程-暂不考虑事务和并发问题" class="headerlink" title="12.5.3 版本 1： 完成基本购票流程, 暂不考虑事务和并发问题"></a>12.5.3 版本 1： 完成基本购票流程, 暂不考虑事务和并发问题</h3><p>​1、 创建 Java Web 项目, 参照以前讲过搭建 Java Web 项目流程即可</p><p>​2、引入相关的 jar 包 和 jquery</p><p>​3、创建 index.jsp(买票界面)</p><p>​4、创建 SecKillRedis.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 秒杀类: 完成秒杀,抢购</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecKillRedis</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写一个测试方法-看看是否能够连通到指定的Redis</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRedis</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.198.135&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">//jedis.auth(&quot;foobared&quot;);//如果需要认证, 就使用auth</span></span><br><span class="line">        System.out.println(jedis.ping());</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 秒杀过程/方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid      用户id - 在后台生成</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ticketNo 票的编号, 比如北京-成都的ticketNo 就是bj_cd</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">doSecKill</span><span class="params">(String uid, String ticketNo)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- uid 和 ticketNo进行非空校验</span></span><br><span class="line">        <span class="keyword">if</span> (uid == <span class="literal">null</span> || ticketNo == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//- 连接到Redis, 得到jedis对象</span></span><br><span class="line">        <span class="comment">//Jedis jedis = new Jedis(&quot;192.168.198.135&quot;, 6379);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- 通过连接池获取到jedis对象/连接</span></span><br><span class="line">        <span class="type">JedisPool</span> <span class="variable">jedisPoolInstance</span> <span class="operator">=</span> JedisPoolUtil.getJedisPoolInstance();</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPoolInstance.getResource();</span><br><span class="line">        System.out.println(<span class="string">&quot;---使用的连接池技术----&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- 拼接票的库存key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">stockKey</span> <span class="operator">=</span> <span class="string">&quot;sk:&quot;</span> + ticketNo + <span class="string">&quot;:ticket&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- 拼接秒杀用户要存放到的set集合对应的key,这个set集合可以存放多个userId</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userKey</span> <span class="operator">=</span> <span class="string">&quot;sk:&quot;</span> + ticketNo + <span class="string">&quot;:user&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//🎃监控库存</span></span><br><span class="line">        jedis.watch(stockKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- 获取到对应的票的库存, 判断是否为null</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">stock</span> <span class="operator">=</span> jedis.get(stockKey);</span><br><span class="line">        <span class="keyword">if</span> (stock == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;秒杀还没有开始, 请等待..&quot;</span>);</span><br><span class="line">            jedis.close(); <span class="comment">//如果jedis是从连接池获取的,则这里的close就是将jedis对象/连接释放到连接池</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- 判断用户是否重复秒杀/复购</span></span><br><span class="line">        <span class="keyword">if</span> (jedis.sismember(userKey, uid)) &#123;</span><br><span class="line">            System.out.println(uid + <span class="string">&quot; 不能重复秒杀...&quot;</span>);</span><br><span class="line">            jedis.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//- 判断火车票，是否还有剩余</span></span><br><span class="line">        <span class="keyword">if</span> (Integer.parseInt(stock) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;票已经卖完了, 秒杀结束..&quot;</span>);</span><br><span class="line">            jedis.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">////- 可以购买</span></span><br><span class="line">        <span class="comment">////1. 将票的库存量-1</span></span><br><span class="line">        <span class="comment">//jedis.decr(stockKey);</span></span><br><span class="line">        <span class="comment">////2. 将该用户加入到抢购成功对应的set集合中</span></span><br><span class="line">        <span class="comment">//jedis.sadd(userKey, uid);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用事务,完成秒杀(防止超卖)</span></span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">multi</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//组队操作</span></span><br><span class="line">        multi.decr(stockKey);<span class="comment">//减去票的库存</span></span><br><span class="line">        multi.sadd(userKey, uid);<span class="comment">//将该用户加入到抢购成功对应的set集合中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行</span></span><br><span class="line">        List&lt;Object&gt; results = multi.exec();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(results == <span class="literal">null</span> || results.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;抢票失败...&quot;</span>);</span><br><span class="line">            jedis.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(uid + <span class="string">&quot; 秒杀成功..&quot;</span>);</span><br><span class="line">        jedis.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、创建SecKillServlet.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecKillServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1. 请求时,模拟生成一个userId</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10000</span>) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//2. 获取用户要购买的票的编号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ticketNo</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;ticketNo&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 调用秒杀的方法</span></span><br><span class="line">        <span class="comment">//boolean isOk = SecKillRedis.doSecKill(userId, ticketNo);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 调用lua脚本完成秒杀方法</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isOk</span> <span class="operator">=</span> SecKillRedisByLua.doSecKill(userId, ticketNo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 将结果返回给前端-这个地方可以根据业务需要调整</span></span><br><span class="line">        response.getWriter().print(isOk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-5-4-抢票并发模拟-出现超卖问题"><a href="#12-5-4-抢票并发模拟-出现超卖问题" class="headerlink" title="12.5.4 抢票并发模拟, 出现超卖问题"></a>12.5.4 抢票并发模拟, 出现超卖问题</h3><p>并发模拟</p><p>可以使用postman模拟</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730110008609.png" alt="image-20230730110008609" style="zoom:50%;" /><h3 id="12-5-5-连接池技术"><a href="#12-5-5-连接池技术" class="headerlink" title="12.5.5 连接池技术"></a>12.5.5 连接池技术</h3><h4 id="12-5-5-1-连接池介绍"><a href="#12-5-5-1-连接池介绍" class="headerlink" title="12.5.5.1 连接池介绍"></a>12.5.5.1 连接池介绍</h4><p>​1、 节省每次连接 redis 服务带来的消耗， <u><strong>把连接好的实例反复利用。</strong></u></p><p>​2、 链接池参数</p><pre><code>    - MaxTotal： 控制**一个 pool 可分配多少个 jedis 实例**， 通过 pool.getResource()来获取；如果赋值为-1， 则表示不限制    - maxIdle： 控制一个 pool 最多有**多少个状态为 idle(空闲)的 jedis 实例**</code></pre><ul><li><p>MaxWaitMillis： 表示当获取一个 jedis 实例时， 最大的等待毫秒数， 如果超过等待时间，则直接抛 JedisConnectionException</p></li><li><p>testOnBorrow： 获得一个 jedis 实例的时候是否检查连接可用性（ping()）； 如果为 true，则得到的 jedis 实例均是可用的</p></li></ul><h4 id="12-5-5-2-使用连接池-优化连接超时"><a href="#12-5-5-2-使用连接池-优化连接超时" class="headerlink" title="12.5.5.2 使用连接池, 优化连接超时"></a>12.5.5.2 使用连接池, 优化连接超时</h4><p>​1、 老师说明: 通过连接池， 可以指定连接超时时间, 这个连接超时时间， 也需要合理设置 ， 要考虑到用户的实际体验</p><p>​2 、 创 建 JedisPoolUtil.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用连接池的方式来获取Redis连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisPoolUtil</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//老师解读volatile作用</span></span><br><span class="line">    <span class="comment">//1. 线程的可见性: 当一个线程去修改一个共享变量时, 另外一个线程可以读取这个修改的值</span></span><br><span class="line">    <span class="comment">//2. 顺序的一致性: 禁止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">JedisPoolUtil</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保证每次调用返回的 jedisPool是单例-这里老师使用了双重校验</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JedisPool <span class="title function_">getJedisPoolInstance</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == jedisPool) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (JedisPoolUtil.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == jedisPool) &#123;</span><br><span class="line">                    <span class="type">JedisPoolConfig</span> <span class="variable">jedisPoolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">                    <span class="comment">//对连接池进行配置</span></span><br><span class="line">                    jedisPoolConfig.setMaxTotal(<span class="number">200</span>);</span><br><span class="line">                    jedisPoolConfig.setMaxIdle(<span class="number">32</span>);</span><br><span class="line">                    jedisPoolConfig.setMaxWaitMillis(<span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">                    jedisPoolConfig.setBlockWhenExhausted(<span class="literal">true</span>);</span><br><span class="line">                    jedisPoolConfig.setTestOnBorrow(<span class="literal">true</span>);</span><br><span class="line">                    jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jedisPoolConfig, <span class="string">&quot;192.168.198.135&quot;</span>, <span class="number">6379</span>, <span class="number">60000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jedisPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放连接资源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(Jedis jedis)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> != jedis) &#123;</span><br><span class="line">            jedis.close();<span class="comment">//如果这个jedis是从连接池获取的,这里jedis.close(),就是将jedis对象/连接，释放到连接池</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="🌟volatile："><a href="#🌟volatile：" class="headerlink" title="🌟volatile："></a>🌟volatile：</h4><p>这是因为 new 关键字创建对象不是原⼦操作，创建⼀个对象会经历下⾯<br>的步骤：</p><ol><li>在堆内存开辟内存空间</li><li>调⽤构造⽅法，初始化对象</li><li>引⽤变量指向堆内存空间</li></ol><p>​为了提⾼性能，编译器和处理器常常会对既定的代码执⾏顺序进⾏指令重排序，从源码到最终执⾏指令会经历如下流程：<br>源码编译器优化重排序指令级并⾏重排序内存系统重排序最终执⾏指令序列所以经过指令重排序之后，创建对象的执⾏顺序可能为 1 2 3 或者 1 3 2 ，因此当某个线程在乱序运⾏ 1 3 2 指令的时候，引⽤变量指向堆内存空间，这个对象不为 null，但是没有初始化，其他线程有可能这个时候进⼊了 getInstance 的第⼀个 if(instance &#x3D;&#x3D; null) 判断不为 nulll ，导致<strong>错误使⽤了没有初始化的⾮ null 实例</strong>，这样的话就会出现异常，这个就是著名的<br>DCL 失效问题。<br>当我们在引⽤变量上⾯添加 volatile 关键字以后，会通过在创建对象指令的前后添加内存屏障来禁⽌指令重排序，就可以避免这个问题，⽽且对volatile 修饰的变量的修改对其他任何线程都是可⻅的。</p><h3 id="12-5-6-利用-Reids-事务机制，-解决超卖"><a href="#12-5-6-利用-Reids-事务机制，-解决超卖" class="headerlink" title="12.5.6 利用 Reids 事务机制， 解决超卖"></a>12.5.6 利用 Reids 事务机制， 解决超卖</h3><p>1、 控制超卖-Redis 事务底层(乐观锁机制分析)</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730133348196.png" alt="image-20230730133348196"></p><p>2 、 修 改 SecKillRedis.java</p><p>😵‍💫见12.5.3 的完整代码</p><h3 id="12-5-7-抢票并发模拟-出现库存遗留问题"><a href="#12-5-7-抢票并发模拟-出现库存遗留问题" class="headerlink" title="12.5.7 抢票并发模拟,出现库存遗留问题"></a>12.5.7 抢票并发模拟,出现库存遗留问题</h3><h4 id="1、-先重置一下-redis-的数据，把库存量设的较大-为-600"><a href="#1、-先重置一下-redis-的数据，把库存量设的较大-为-600" class="headerlink" title="1、 先重置一下 redis 的数据，把库存量设的较大 , 为 600"></a>1、 先重置一下 redis 的数据，把库存量设的较大 , 为 600</h4><h4 id="2、执行指令"><a href="#2、执行指令" class="headerlink" title="2、执行指令"></a>2、执行指令</h4><p>​ab -n 1000 -c 300 -p ~&#x2F;postfile -T  application&#x2F;x-www-form-urlencoded<a href="http://ip:port/seckill/secKillServlet">http://ip:port/seckill/secKillServlet</a></p><p>​老韩解读:1) 这里我们并发数变大 -c 300</p><h4 id="3、执行结果"><a href="#3、执行结果" class="headerlink" title="3、执行结果"></a>3、执行结果</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730134144402.png" alt="image-20230730134144402" style="zoom:50%;" /><p>​可以看到, 剩余票数为 543, 并不是 0</p><h4 id="4、出现库存遗留问题的分析"><a href="#4、出现库存遗留问题的分析" class="headerlink" title="4、出现库存遗留问题的分析"></a>4、出现库存遗留问题的分析</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730134242569.png" alt="image-20230730134242569"></p><h3 id="12-5-8-LUA-脚本"><a href="#12-5-8-LUA-脚本" class="headerlink" title="12.5.8 LUA 脚本"></a>12.5.8 LUA 脚本</h3><h4 id="12-5-8-1-LUA-介绍"><a href="#12-5-8-1-LUA-介绍" class="headerlink" title="12.5.8.1 LUA 介绍"></a>12.5.8.1 LUA 介绍</h4><p>​1、 Lua 是一个小巧的脚本语言， Lua 脚本可以很容易的被 C&#x2F;C++ 代码调用， 也可以反过来调用 C&#x2F;C++的函数， Lua 并没有提供强大的库， 一个完整的 Lua 解释器不过 200k，所以 Lua 不适合作为开发独立应用程序的语言， 而是作为<strong>嵌入式脚本语言</strong>。</p><p>​2、很多应用程序、游戏使用 LUA 作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。</p><p>​3、将复杂的或者多步的 Redis 操作，写为一个脚本，一次提交给 redis 执行，减少反复连接 redis 的次数。提升性能。</p><p>​4、LUA 脚本是类似 Redis 事务，有一定的原子性，不会被其他命令插队，<strong>可以完成一些 redis 事务性的操作</strong></p><p>​5、Redis 的 lua 脚本功能，只有在 Redis 2.6 以上的版本才可以使用</p><p>​6、通过 lua 脚本解决争抢问题，实际上是 Redis 利用其单线程的特性，<strong>用任务队列的方式解决多任务并发问题</strong></p><h4 id="12-5-8-2-LUA-脚本-解决库存遗留-思路分析图"><a href="#12-5-8-2-LUA-脚本-解决库存遗留-思路分析图" class="headerlink" title="12.5.8.2 LUA 脚本, 解决库存遗留-思路分析图"></a>12.5.8.2 LUA 脚本, 解决库存遗留-思路分析图</h4><p>​一图胜千言</p><p>​<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730135547720.png" alt="image-20230730135547720"></p><p>对上图解读</p><pre><code>1) LUA 脚本是类似 Redis 事务，有一定的原子性，不会被其他命令插队，能完成 Redis事务性的操作 1) 通过 lua 脚本解决争抢问题，Redis 利用其单线程的特性，将请求形成任务队列, 从而解决多任务并发问题</code></pre><h4 id="12-5-8-3-LUA-脚本-解决库存遗留-代码实现"><a href="#12-5-8-3-LUA-脚本-解决库存遗留-代码实现" class="headerlink" title="12.5.8.3 LUA 脚本, 解决库存遗留-代码实现"></a>12.5.8.3 LUA 脚本, 解决库存遗留-代码实现</h4><p>1、 编写 lua 脚本文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Lua脚本完成秒杀</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecKillRedisByLua</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 老师说明</span></span><br><span class="line"><span class="comment">     * 1. 这个脚本字符串是在lua脚本上修改的, 但是要注意不完全是字符串处理</span></span><br><span class="line"><span class="comment">     * 2. 比如 : 这里我就使用了 \&quot; , 还有换行使用了 \r\n</span></span><br><span class="line"><span class="comment">     * 3. 这些都是细节，如果你直接把lua脚本粘贴过来，不好使,一定要注意细节</span></span><br><span class="line"><span class="comment">     * 4. 如果写的不成功，就在老师这个代码上修改即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">secKillScript</span> <span class="operator">=</span> <span class="string">&quot;local userid=KEYS[1];\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;local ticketno=KEYS[2];\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;local stockKey=&#x27;sk:&#x27;..ticketno..\&quot;:ticket\&quot;;\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;local usersKey=&#x27;sk:&#x27;..ticketno..\&quot;:user\&quot;;\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;local userExists=redis.call(\&quot;sismember\&quot;,usersKey,userid);\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;if tonumber(userExists)==1 then \r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;   return 2;\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;end\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;local num= redis.call(\&quot;get\&quot; ,stockKey);\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;if tonumber(num)&lt;=0 then \r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;   return 0;\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;else \r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;   redis.call(\&quot;decr\&quot;,stockKey);\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;   redis.call(\&quot;sadd\&quot;,usersKey,userid);\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;end\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;return 1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用lua脚本完成秒杀的核心方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">doSecKill</span><span class="params">(String uid,String ticketNo)</span> &#123;</span><br><span class="line">        <span class="comment">//先从redis连接池，获取连接</span></span><br><span class="line">        <span class="type">JedisPool</span> <span class="variable">jedisPoolInstance</span> <span class="operator">=</span> JedisPoolUtil.getJedisPoolInstance();</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPoolInstance.getResource();</span><br><span class="line">        <span class="comment">//就是将lua脚本进行加载</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sha1</span> <span class="operator">=</span> jedis.scriptLoad(secKillScript);</span><br><span class="line">        <span class="comment">//evalsha是根据指定的 sha1校验码, 执行缓存在服务器的脚本</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.evalsha(sha1, <span class="number">2</span>, uid, ticketNo);</span><br><span class="line">        <span class="type">String</span> <span class="variable">resString</span> <span class="operator">=</span> String.valueOf(result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据lua脚本执行返回的结果，做相应的处理</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;0&quot;</span>.equals(resString)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;票已经卖光了..&quot;</span>);</span><br><span class="line">            jedis.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;2&quot;</span>.equals(resString)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不能重复购买..&quot;</span>);</span><br><span class="line">            jedis.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(resString)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;抢购成功&quot;</span>);</span><br><span class="line">            jedis.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;购票失败..&quot;</span>);</span><br><span class="line">            jedis.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="13-主从复制"><a href="#13-主从复制" class="headerlink" title="13 主从复制"></a>13 主从复制</h1><h2 id="13-1-主从复制介绍"><a href="#13-1-主从复制介绍" class="headerlink" title="13.1 主从复制介绍"></a>13.1 主从复制介绍</h2><h3 id="13-1-1-分析单个-Redis-的问题"><a href="#13-1-1-分析单个-Redis-的问题" class="headerlink" title="13.1.1 分析单个 Redis 的问题"></a>13.1.1 分析单个 Redis 的问题</h3><h3 id="13-1-2-一图胜千言"><a href="#13-1-2-一图胜千言" class="headerlink" title="13.1.2 一图胜千言"></a>13.1.2 一图胜千言</h3><p>1、 Redis 主从复制的示意图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730230820880.png" alt="image-20230730230820880" style="zoom:67%;" /><p>2、对上图的解读</p><ol><li><p>上图描述了主机数据更新后, 自动同步到备机的 master&#x2F;slaver 机制</p></li><li><p>Master 以<strong>写</strong>为主，Slaver 以<strong>读</strong>为主</p></li><li><p>好处: 读写分离, 提升效率 (理解: 读写分离后, 将读和写操作分布到不同的 Reids, 减少单个 Redis 的压力, 提升效率)</p></li><li><p>好处: 容灾快速恢复 (理解: <u>如果某个 slaver , 不能正常工作, 可以切换到另一个 slaver</u>)</p></li><li><p>主从复制, 要求是 <strong>1 主多从</strong>, 不能有多个 Master( 理解: 如果有多个主服务器 Master,那么 slaver 不能确定和哪个 Master 进行同步, 出现数据紊乱)</p></li><li><p>要解决主服务器的高可用性, <u>可以使用 Redis 集群</u></p></li></ol><h2 id="13-2-搭建一主多从"><a href="#13-2-搭建一主多从" class="headerlink" title="13.2 搭建一主多从"></a>13.2 搭建一主多从</h2><p>1、 需求说明</p><ol><li>搭建主从复制结构</li><li>这里我们搭建 一主二从即可, 其它 slaver 可以依此完成</li><li>分析我搭建的思路&#x2F;认真理解</li></ol><p>把原来的redis.conf复制三份，分别进行配置，用它们来各自启动redis服务，再通过指令：「slaveof <master_ip> <master_port>」来设置主从关系，这样以后我们就搭建完毕了</p><p>注意：</p><ul><li>搭建完以后，在主服务中添加、修改数据，可以在从服务处读取</li><li>从服务无法添加、修改、删除数据，只能读取</li></ul><h2 id="13-3-主从复制-原理"><a href="#13-3-主从复制-原理" class="headerlink" title="13.3 主从复制-原理"></a>13.3 主从复制-原理</h2><p>1、 原理示意图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730233615428.png" alt="image-20230730233615428" style="zoom: 67%;" /><p>2、老师解读上图-主从复制流程</p><ul><li>Slave 启动成功连接到 master 后会发送一个 <strong>sync 命令</strong></li><li>Master 接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后, master 将传送整个数据文件到 slave,以完成一次完全同步</li><li>slave 服务在接收到数据库文件数据后，将其存盘并加载到内存中, 即 <strong>全量复制</strong></li><li>Master 数据变化了, 会将新的收集到的修改命令依次传给 slave, 完成同步, 即 <strong>增量复制</strong></li><li>但是只要是重新连接 master,一次完全同步（全量复制)将被自动执行</li></ul><p>总结：</p><p><strong><u>(第一次连 –&gt; 全量复制；连上后主服务数据变化 –&gt; 增量复制；断开后重新连上 –&gt; 全量复制)</u></strong></p><h2 id="13-4-一主二仆"><a href="#13-4-一主二仆" class="headerlink" title="13.4 一主二仆"></a>13.4 一主二仆</h2><p>1、 如果从服务器 down 了, 重新启动, 仍然可以获取 Master 的最新数据</p><p>2、如果主服务器 down 了, <u>从服务器并不会抢占为主服务器</u>, 当主服务器恢复后, 从服务器仍然指向原来的主服务器.</p><h2 id="13-5-薪火相传"><a href="#13-5-薪火相传" class="headerlink" title="13.5 薪火相传"></a>13.5 薪火相传</h2><p>1、 示意图</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230731082350913.png" alt="image-20230731082350913" style="zoom:50%;" /><p>2、老师解读上图</p><pre><code>1) 上一个 Slave 可以是下一个 slave 的 Master，Slave 同样可以接收其他 slaves 的连接和同步请求，那么该 &lt;u&gt;slave 作为了链条中下一个的 master, 可以有效减轻 master 的写压力,&lt;/u&gt;去中心化降低风险1) 用 **slaveof &lt;master_ip&gt;&lt;master_port&gt;     (从服务的ip、port)**</code></pre><ol start="3"><li>风险是一旦某个 slave 宕机，后面的 slave 都没法同步</li><li>主机挂了，从机还是从机，无法写数据了</li><li>作为别人master的从服务只是拥有了与其从服务同步数据的能力，并不能修改数据！</li></ol><h2 id="13-6-反客为主"><a href="#13-6-反客为主" class="headerlink" title="13.6 反客为主"></a>13.6 反客为主</h2><p>1、 在薪火相传的结构下, 当一个 master 宕机后, <u>指向 Master 的 slave 可以升为 master, 其后面的 slave 不用做任何修改</u></p><p>2、用 slaveof no one 将从机变为主机 (老韩说明: 后面可以使用哨兵模式, 自动完成切换.)</p><h2 id="13-7-哨兵模式-sentinel"><a href="#13-7-哨兵模式-sentinel" class="headerlink" title="13.7 哨兵模式(sentinel)"></a>13.7 哨兵模式(sentinel)</h2><h3 id="13-7-1-实例演示"><a href="#13-7-1-实例演示" class="headerlink" title="13.7.1 实例演示"></a>13.7.1 实例演示</h3><p>1、 工作示意图</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230731083436662.png" alt="image-20230731083436662" style="zoom:50%;" /><p>2、哨兵模式(如图): **<u>反客为主的自动版</u>**，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p><p>3、老韩实验</p><p>​1)调整为一主二仆模式，6379 带着 6380、6381 , 根据前面讲解的调整即可</p><p>​2)创建 sentinel.conf , 名字不能乱写, 按照指定的来</p><p>​<strong>写入</strong>：sentinel monitor redis_master 127.0.0.1 6379 1</p><p>​说明:</p><p>​<strong>redis_master</strong> 为监控对象起的服务器名称</p><p>​<strong>1</strong> 表示至少有多少个哨兵同意迁移的数量, 这里我配置1 表示只要有1个哨兵同意迁移就可以切换</p><p>​3) 启动哨兵, 注意看哨兵的端口是 26379</p><p>![image-20230731084427183](&#x2F;Users&#x2F;donn&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230731084427183.png)</p><p>​4) 当主机挂掉，从机选举中产生新的主机</p><p>​5) <strong><u>如果原来的主机重启, 会自动成为从机</u></strong></p><h3 id="13-7-2-注意事项和细节"><a href="#13-7-2-注意事项和细节" class="headerlink" title="13.7.2 注意事项和细节"></a>13.7.2 注意事项和细节</h3><p>1、 在哨兵模式下， 主机 down 后的执行流程分析</p><p>![image-20230731084948786](&#x2F;Users&#x2F;donn&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230731084948786.png)</p><p>2、解读上图 - 哨兵如何在从机中, 推选新的 Master 主机, 选择的条件依次为:</p><ol><li><strong>优先级</strong>在 redis.conf 中默认：replica-priority 100，值越小优先级越高</li><li><strong>偏移量</strong>是指获得原主机数据的量, 数据量最全的优先级高</li><li>每个 redis 实例启动后都会随机生成一个 40 位的 <strong>runid</strong>, 值越小优先级越高</li></ol><h1 id="14-集群"><a href="#14-集群" class="headerlink" title="14 集群"></a>14 集群</h1><h2 id="14-1-为什么需要集群-高可用性"><a href="#14-1-为什么需要集群-高可用性" class="headerlink" title="14.1 为什么需要集群-高可用性"></a>14.1 为什么需要集群-高可用性</h2><p>1、 生产环境的实际需求和问题</p><ul><li><strong>容量不够</strong>，redis 如何进行扩容？</li><li><strong>并发</strong>写操作， redis 如何分摊？</li><li>主从模式，薪火相传模式，<u>主机宕机，会导致 ip 地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息</u></li></ul><h3 id="2、传统解决方案-代理主机来解决"><a href="#2、传统解决方案-代理主机来解决" class="headerlink" title="2、传统解决方案-代理主机来解决"></a>2、传统解决方案-代理主机来解决</h3><p>![image-20230731090153302](&#x2F;Users&#x2F;donn&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230731090153302.png)</p><p>解读上图</p><ol><li><p>客户端请求先到代理服务器</p></li><li><p>由代理服务器进行<strong>请求转发</strong>到对应的业务处理服务器</p></li><li><p>为了高可用性, 代理服务、A 服务、B 服务、C 服务都需要搭建主从结构(至少是一主一从),这样就需求搭建至少 8 台服务器</p></li><li><p>这种方案的缺点是: <u>成本高，维护困难, 如果是一主多从, 成本就会更高</u></p></li></ol><h3 id="3、redis3-0-提供解决方案-无中心化集群配置"><a href="#3、redis3-0-提供解决方案-无中心化集群配置" class="headerlink" title="3、redis3.0 提供解决方案-无中心化集群配置"></a>3、redis3.0 提供解决方案-无中心化集群配置</h3><p>![image-20230731090351617](&#x2F;Users&#x2F;donn&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230731090351617.png)</p><p>解读上图</p><pre><code>1) 各个 Redis 服务仍然采用主从结构2) 各个 Redis 服务是连通的, **任何一台服务器, 都可以作为请求入口**3) 各个 Redis 服务器因为是连通的, 可以进行请求转发4) 这种方式, 就无中心化集群配置, 可以看到，只需要 6 台服务器即可搞定</code></pre><ol start="5"><li>无中心化集群配置, 还会根据 key 值, 计算 slot , 把数据分散到不同的主机, 从而缓解单个主机的存取压力.[后面老师会演示和再说明]</li><li>Redis 推荐使用无中心化集群配置</li><li>在实际生成环境 各个 Redis 服务器, <u>应当部署到不同的机器</u>(防止机器宕机, 主从复制失效)</li></ol><h2 id="14-2-集群介绍"><a href="#14-2-集群介绍" class="headerlink" title="14.2 集群介绍"></a>14.2 集群介绍</h2><p>1、 Redis 集群实现了对 Redis 的水平扩容， 即启动 N 个 redis 节点， 将整个数据库分布存储在这 N 个节点中， 每个节点存储总数据的 1&#x2F;N。</p><p>2、 Redis 集群通过分区（partition） 来提供一定程度的<strong>可用性</strong>（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求</p><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><h4 id="1、修改主服务的conf文件中的配置："><a href="#1、修改主服务的conf文件中的配置：" class="headerlink" title="1、修改主服务的conf文件中的配置："></a>1、修改主服务的conf文件中的配置：</h4><p>​cluster-enabled yes 打开集群模式</p><p>​cluster-config-file nodes-6379.conf </p><p>​设定节点配置文件名cluster-node-timeout 15000 设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换</p><h4 id="2、启动服务"><a href="#2、启动服务" class="headerlink" title="2、启动服务"></a>2、启动服务</h4><p>![image-20230731093504555](&#x2F;Users&#x2F;donn&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230731093504555.png)</p><p>![image-20230731093522619](&#x2F;Users&#x2F;donn&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230731093522619.png)</p><h4 id="3、将六个节点合成一个集群"><a href="#3、将六个节点合成一个集群" class="headerlink" title="3、将六个节点合成一个集群"></a>3、将六个节点合成一个集群</h4><p>![image-20230731093608968](&#x2F;Users&#x2F;donn&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230731093608968.png)</p><p>将六个节点合成一个集群 的指令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create --cluster-replicas 1 192.168.198.130:6379 192.168.198.130:6380 192.168.198.130:6381 192.168.198.130:6389192.168.198.130:6390 192.168.198.130:6391</span><br></pre></td></tr></table></figure><h5 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h5><ol><li>组合之前，请确保所有 redis 实例启动后，nodes-xxxx.conf 文件都生成正常</li><li>此处不要用 127.0.0.1, 请用真实 IP 地址, 在真实生产环境, IP 都是独立的.</li><li>replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组</li><li>搭建集群如果没有成功, 把 sentinel 进程 kill 掉, 再试一下</li><li>分析主从对应关系</li></ol><h4 id="4、集群方式登录"><a href="#4、集群方式登录" class="headerlink" title="4、集群方式登录"></a>4、集群方式登录</h4><p>指令: <strong>redis-cli -c -p 6379</strong></p><p>指令: <strong><u>cluster nodes</u></strong> 命令查看集群信息, 主从的对应关系</p><h3 id="14-3-2-注意事项和细节"><a href="#14-3-2-注意事项和细节" class="headerlink" title="14.3.2 注意事项和细节"></a>14.3.2 注意事项和细节</h3><p>1、 一个集群至少要有三个主节点</p><p>2、 选项 <strong>–cluster-replicas 1</strong> 表示我们希望为集群中的<u>每个主节点创建一个从节点</u>。</p><p>3、 分配原则： <u><strong>尽量保证主服务器和从服务器各自运行在不同的 IP 地址(机器), 防止机器故障导致主从机制失效, 高可用性得不到保障</strong></u></p><h2 id="14-4-Redis-集群使用"><a href="#14-4-Redis-集群使用" class="headerlink" title="14.4 Redis 集群使用"></a>14.4 Redis 集群使用</h2><p>1、 什么是 slots</p><p>1）Redis 集群启动后, 你会看到如下提示</p><p>![image-20230731094714287](&#x2F;Users&#x2F;donn&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230731094714287.png)</p><p>![image-20230731094732477](&#x2F;Users&#x2F;donn&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230731094732477.png)</p><p>2）一个 Redis 集群包含 16384 个插槽（hash slot），编号从 0-16383, <u>Reids 中的每个键都属于这 16384 个插槽的其中一个</u></p><p>3）集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和</p><p>![image-20230731094808015](&#x2F;Users&#x2F;donn&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230731094808015.png)</p><p>4)<u><strong>集群中的每个节点负责处理一部分插槽</strong></u>。 举个例子， 如果一个集群可以有主节点， 其中：</p><ul><li>节点 A 负责处理 0 号至 5460 号插槽</li><li>节点 B 负责处理 5461 号至 10922 号插槽</li><li>节点 C 负责处理 10923 号至 16383 号插槽</li></ul><p>2、在集群中录入值</p><p>1）在 redis 每次录入、查询键值，redis 都会计算出该 key 应该送往的插槽，<u>如果不是该客户端对应服务器的插槽，redis 会告知应前往的 redis 实例地址和端口</u>。(因为你可以在集群的任意端启用redis服务)</p><p>2）redis-cli 客户端提供了 –c 参数实现<strong>自动重定向</strong>。</p><p>3）如 redis-cli -c –p 6379 登入后，再录入、查询键值对可以自动重定向</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230731095430316.png" alt="image-20230731095430316" style="zoom: 50%;" /><p>4）**<u>不在一个 slot 下的键值</u>，是不能使用 mget,mset 等多键操作**</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230731095522774.png" alt="image-20230731095522774" style="zoom:50%;" /><p>5）<strong>可以通过{}来定义组的概念，从而<u>使 key 中{}内相同内容的键值对放到一个 slot 中</u>去</strong>，可以对一个组的数据进行mget等多键操作</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230731095552328.png" alt="image-20230731095552328" style="zoom:50%;" /><p>3、<u>查询集群中的值</u></p><p>1）指令: CLUSTER KEYSLOT <key> <strong>返回 key 对应的 slot 值</strong></p><p>2）指令: CLUSTER COUNTKEYSINSLOT <slot> <strong>返回 slot 有多少个 key</strong></p><p>3）指令: CLUSTER GETKEYSINSLOT <slot><count> <strong>返回 count 个 slot 槽中的键</strong></p><p> ![image-20230731100125306](&#x2F;Users&#x2F;donn&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230731100125306.png)</p><h2 id="14-5-Redis-集群故障恢复"><a href="#14-5-Redis-集群故障恢复" class="headerlink" title="14.5 Redis 集群故障恢复"></a>14.5 Redis 集群故障恢复</h2><p>1、 如果主节点下线, <u>从节点会自动升为主节点</u>(注意 15 秒超时, 再观察比较准确)</p><p>—是该主节点的从节点提生成master，而不是其他节点替代这个节点</p><p>2、主节点恢复后，主节点回来变成从机</p><p>3、如果所有某一段插槽的主从节点都宕掉，Redis 服务是否还能继续, 要根据不同的配置而言</p><p>​1）如果某一段插槽的主从都挂掉，而 <strong>cluster-require-full-coverage</strong> 为 yes ，那么 ，整个集群都挂掉</p><p>​2）如果某一段插槽的主从都挂掉，而 <strong>cluster-require-full-coverage</strong> 为 no , 那么, 只是该插槽数据不能使用，也无法存储</p><p>​3）redis.conf 中的参数 cluster-require-full-coverage</p><p>![image-20230731100749215](&#x2F;Users&#x2F;donn&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230731100749215.png)</p><h2 id="14-6-集群的-Jedis-开发"><a href="#14-6-集群的-Jedis-开发" class="headerlink" title="14.6 集群的 Jedis 开发"></a>14.6 集群的 Jedis 开发</h2><p>1、 即使连接的不是主机， 集群会自动切换主机存储。 主机写， 从机读。</p><p>2、无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据</p><p>3、老韩实验</p><p>​1）将 Redis 相关的端口都打开(防火墙设置), 否则会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作Redis集群</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisCluster_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 这里的set可以加入多个入口</span></span><br><span class="line"><span class="comment">         * 2. 因为我们没有做日志配置，输出时，有些提示,但是不影响使用</span></span><br><span class="line"><span class="comment">         * 3. 如果我们使用的是集群，需要把相关的端口都打开，否则会报错</span></span><br><span class="line"><span class="comment">         * 4. JedisCluster的构造器有多个，也可以直接传入HostAndPort 代码如下</span></span><br><span class="line"><span class="comment">         * public JedisCluster(HostAndPort node) &#123;</span></span><br><span class="line"><span class="comment">         *         this(Collections.singleton(node));</span></span><br><span class="line"><span class="comment">         *     &#125;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Set&lt;HostAndPort&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;HostAndPort&gt;();</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.198.135&quot;</span>,<span class="number">6379</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">JedisCluster</span> <span class="variable">jedisCluster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisCluster</span>(set);</span><br><span class="line">        jedisCluster.set(<span class="string">&quot;address&quot;</span>,<span class="string">&quot;bj~北京&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> jedisCluster.get(<span class="string">&quot;address&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;address--&gt;&quot;</span> + address);</span><br><span class="line">        jedisCluster.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-7-Redis-集群的优缺点"><a href="#14-7-Redis-集群的优缺点" class="headerlink" title="14.7 Redis 集群的优缺点"></a>14.7 Redis 集群的优缺点</h2><h3 id="14-7-1-优点"><a href="#14-7-1-优点" class="headerlink" title="14.7.1 优点"></a>14.7.1 优点</h3><p>​1、 实现扩容</p><p>​2、分摊压力</p><p>​3、无中心配置相对简单</p><h3 id="14-7-2-缺点"><a href="#14-7-2-缺点" class="headerlink" title="14.7.2 缺点"></a>14.7.2 缺点</h3><p>​1、 多键操作是不被支持的</p><p>​2、 多键的 Redis 事务是不被支持的。 lua 脚本不被支持</p><p>​3、 由于集群方案出现较晚， 很多公司已经采用了其他的集群方案， 而其它方案想要迁移至 redis cluster， 需要整体迁移而不是逐步过渡， 复杂度较大</p><h4 id="3-2-Jedis连接池"><a href="#3-2-Jedis连接池" class="headerlink" title="3.2.Jedis连接池"></a>3.2.Jedis连接池</h4><h5 id="——为了解决Jedis的线程不安全的问题"><a href="#——为了解决Jedis的线程不安全的问题" class="headerlink" title="——为了解决Jedis的线程不安全的问题"></a>——为了解决Jedis的线程不安全的问题</h5><p>Jedis官方提供JedisPool类，我们通过它创建连接池，从连接池中获取jedis对象，实现并发</p><p>我们写一个工具类，用于生成Jedis的连接池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.jedis.util;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原poo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">0</span>);</span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//创建连接池对象</span></span><br><span class="line">      <span class="comment">//172.30.10.68为你的IP地址 1000(毫秒)为连接存活时间  “root”为密码</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig,<span class="string">&quot;172.30.10.68&quot;</span>,<span class="number">6379</span>, <span class="number">1000</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//因此建立Jeris连接的方式为：</span></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//通过连接池建立连接</span></span><br><span class="line">        jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">        <span class="comment">//选择数据库</span></span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-SpringDataRedis快速入门"><a href="#3-3-SpringDataRedis快速入门" class="headerlink" title="3.3.SpringDataRedis快速入门"></a>3.3.SpringDataRedis快速入门</h4><ul><li><strong>提供了对不同Redis客户端的整合</strong></li><li><strong>提供了 <u>RedisTemplate</u> 统一API来操作Redis</strong></li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><h5 id="RedisTemplate工具类的使用："><a href="#RedisTemplate工具类的使用：" class="headerlink" title="RedisTemplate工具类的使用："></a>RedisTemplate工具类的使用：</h5><table><thead><tr><th align="center"><strong>API</strong></th><th align="center"><strong>返回值类型</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"><strong>redisTemplate</strong>.opsForValue()</td><td align="center">ValueOperations</td><td align="center">操作String类型数据</td></tr><tr><td align="center"><strong>redisTemplate</strong>.opsForHash()</td><td align="center">HashOperations</td><td align="center">操作Hash类型数据</td></tr><tr><td align="center"><strong>redisTemplate</strong>.opsForList()</td><td align="center">ListOperations</td><td align="center">操作List类型数据</td></tr><tr><td align="center"><strong>redisTemplate</strong>.opsForSet()</td><td align="center">SetOperations</td><td align="center">操作Set类型数据</td></tr><tr><td align="center"><strong>redisTemplate</strong>.opsForZSet()</td><td align="center">ZSetOperations</td><td align="center">操作SortedSet类型数据</td></tr><tr><td align="center"><strong>redisTemplate</strong></td><td align="center"></td><td align="center">通用的命令</td></tr></tbody></table><h5 id="SpringDataRedis的环境配置："><a href="#SpringDataRedis的环境配置：" class="headerlink" title="SpringDataRedis的环境配置："></a>SpringDataRedis的环境配置：</h5><h6 id="Step1-引入依赖"><a href="#Step1-引入依赖" class="headerlink" title="Step1: 引入依赖"></a>Step1: 引入依赖</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="Step2-配置文件-在application-yaml中添加redis的配置-使用了lettuce提供的API"><a href="#Step2-配置文件-在application-yaml中添加redis的配置-使用了lettuce提供的API" class="headerlink" title="Step2: 配置文件(在application.yaml中添加redis的配置 使用了lettuce提供的API )"></a>Step2: 配置文件(在application.yaml中添加redis的配置 使用了lettuce提供的API )</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">172.30</span><span class="number">.10</span><span class="number">.68</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span></span><br></pre></td></tr></table></figure><h6 id="Step3-注入RedisTemplate"><a href="#Step3-注入RedisTemplate" class="headerlink" title="Step3: 注入RedisTemplate"></a>Step3: 注入RedisTemplate</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br></pre></td></tr></table></figure><h6 id="Step4-开始使用"><a href="#Step4-开始使用" class="headerlink" title="Step4:开始使用"></a>Step4:开始使用</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;hobby&quot;</span>,<span class="string">&quot;吃&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">hobby</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;hobby&quot;</span>);</span><br><span class="line">        System.out.println(hobby);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化,序列化后，会以字节的形式存储在redis数据库中</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230414091141449.png" alt="image-20230414091141449" style="zoom: 60%;" /><ul><li><p>可读性差</p></li><li><p>内存占用较大</p></li></ul><h4 id="3-4-RedisSerializer配置"><a href="#3-4-RedisSerializer配置" class="headerlink" title="3.4.RedisSerializer配置"></a>3.4.RedisSerializer配置</h4><p>​方案一：配置RedisTemplate的序列化方式：(白学，方案有缺陷)</p><p>​1.自定义RedisTemplate</p><p>​2.修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂   </span></span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">// 设置序列化工具   </span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// key和 hashKey采用 string序列化  </span></span><br><span class="line">        redisTemplate.setKeySerializer(RedisSerializer.string()); </span><br><span class="line">        redisTemplate.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// value和 hashValue采用 JSON序列化</span></span><br><span class="line">        redisTemplate.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--##################引入jackson依赖：###############--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>「缺陷」</strong>:为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会<strong>带来额外的内存开销</strong>。</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230414093507462.png" alt="image-20230414093507462" style="zoom: 50%;" /><h4 id="3-5-StringRedisTemplate"><a href="#3-5-StringRedisTemplate" class="headerlink" title="3.5.StringRedisTemplate"></a>3.5.StringRedisTemplate</h4><p>方案二(缺点是存取对象时都需要自行手动序列化&#x2F;反序列化)：</p><p>​1.使用StringRedisTemplate</p><p>​2.写入Redis时，手动把对象序列化为JSON</p><p>​3.读取Redis时，手动把读取到的JSON反序列化为对象</p><p>Spring默认提供了一个<strong>StringRedisTemplate</strong>类，它的<strong>key和value的序列化方式默认就是String方式</strong>。省去了我们自定义RedisTemplate的过程：</p><h5 id="StringRedisTemplate类的使用："><a href="#StringRedisTemplate类的使用：" class="headerlink" title="StringRedisTemplate类的使用："></a>StringRedisTemplate类的使用：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"><span class="comment">// JSON工具</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testStringTemplate</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">  <span class="comment">// 准备对象</span></span><br><span class="line">  <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;虎哥&quot;</span>, <span class="number">18</span>);</span><br><span class="line">  <span class="comment">// 手动序列化</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">  <span class="comment">// 写入一条数据到redis</span></span><br><span class="line">  stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:200&quot;</span>, json); </span><br><span class="line">  <span class="comment">// 读取数据</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:200&quot;</span>);</span><br><span class="line">  <span class="comment">// 反序列化</span></span><br><span class="line">  <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(val, User.class);</span><br><span class="line">  System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在redis中存放的json数据将不含类路径信息：{“name”:”虎哥”,”age”:18} </p><h2 id="实战篇"><a href="#实战篇" class="headerlink" title="实战篇"></a>实战篇</h2><h3 id="1-短信验证码的登录注册功能"><a href="#1-短信验证码的登录注册功能" class="headerlink" title="1.短信验证码的登录注册功能"></a>1.短信验证码的登录注册功能</h3><h4 id="搭建黑马点评项目"><a href="#搭建黑马点评项目" class="headerlink" title="搭建黑马点评项目"></a>搭建黑马点评项目</h4><ul><li><h5 id="前端部署在nginx服务器，后端部署在tomcat服务器"><a href="#前端部署在nginx服务器，后端部署在tomcat服务器" class="headerlink" title="前端部署在nginx服务器，后端部署在tomcat服务器"></a>前端部署在nginx服务器，后端部署在tomcat服务器</h5></li><li><p>查看nginx的安装信息：brew info nginx</p><p>mac 中 nginx的常用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx 启动服务</span><br><span class="line">sudo nginx -s reload  重新加载</span><br><span class="line">sudo nginx -s reopen 重新启动</span><br><span class="line">sudo nginx -s quit 退出（处理完事情走）</span><br><span class="line">open /opt/homebrew/etc/nginx/ 查看nginx安装目录</span><br><span class="line">nginx -V 查看nginx版本及安装的本地位置</span><br><span class="line">ngxin -v 查看nginx版本（此方法依然可以检测是否安装某一软件，如git,hg等）</span><br></pre></td></tr></table></figure></li></ul><h4 id="基于session的短信登录"><a href="#基于session的短信登录" class="headerlink" title="基于session的短信登录"></a>基于session的短信登录</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230415105822095.png" alt="image-20230415105822095"></p><h5 id="功能1-输入手机号点击发送验证码"><a href="#功能1-输入手机号点击发送验证码" class="headerlink" title="功能1:输入手机号点击发送验证码"></a>功能1:输入手机号点击发送验证码</h5><p>​查看得：请求网址为 <a href="http://localhost:8080/api/user/code?phone=13612345678%EF%BC%8C%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E4%B8%BAPOST">http://localhost:8080/api/user/code?phone=13612345678，请求方式为POST</a></p><table><thead><tr><th>有效信息表：</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>POST</td></tr><tr><td>请求路径</td><td>&#x2F;user&#x2F;code</td></tr><tr><td>请求参数</td><td>phone,电话号码</td></tr><tr><td>返回值</td><td>无</td></tr></tbody></table><p>对应在controller中编写响应函数即可:</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230415110937034.png" alt="image-20230415110937034"></p><p>虽然还没写发送验证码的逻辑，总之功能交给service层就行啦</p><h5 id="功能2-通过手机号和短信验证码登录"><a href="#功能2-通过手机号和短信验证码登录" class="headerlink" title="功能2:通过手机号和短信验证码登录"></a>功能2:通过手机号和短信验证码登录</h5><p>请求网址: <a href="http://localhost:8080/api/user/login">http://localhost:8080/api/user/login</a></p><table><thead><tr><th>有效信息表：</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>POST</td></tr><tr><td>请求路径</td><td>&#x2F;user&#x2F;login</td></tr><tr><td>请求参数</td><td>json形式 phone : 电话号码 ; code : 验证码</td></tr><tr><td>返回值</td><td>无</td></tr></tbody></table><p>由于数据以json形式放在payload中，因此需要@RequestBody注解获取</p><h4 id="集群下的session共享问题"><a href="#集群下的session共享问题" class="headerlink" title="集群下的session共享问题"></a>集群下的session共享问题</h4><p><strong>多台Tomcat并不共享session存储空间，当请求切换(负载均衡)到不同tomcat服务时导致数据丢失的问题</strong></p><p>​如何让tomcat实现session共享？</p><p>——使用redis集群！</p><h5 id="Redis实现共享session登录"><a href="#Redis实现共享session登录" class="headerlink" title="Redis实现共享session登录"></a>Redis实现共享session登录</h5><p>这时，我们可以将数据保存在redis中</p><p>redis设计：<br>    由于一个设备可能登录多个账号，如果仅仅将”code”作为key，将会造成验证码的覆盖<br>    因此我们可以使用用户的唯一标识——手机号作为验证码记录的key！</p><p>​  <strong>「key的设计：唯一性(防止数据覆盖)；用户在请求时会携带的信息」</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230415152700699.png" alt="image-20230415152700699"></p><h4 id="Redis实现session的刷新问题"><a href="#Redis实现session的刷新问题" class="headerlink" title="Redis实现session的刷新问题"></a>Redis实现session的刷新问题</h4><p>​使用拦截器，对所有页面的请求进行拦截，若有请求，则将token的有效期刷新！</p><h3 id="缓存学习："><a href="#缓存学习：" class="headerlink" title="缓存学习："></a>缓存学习：</h3><h4 id="什么是缓存？"><a href="#什么是缓存？" class="headerlink" title="什么是缓存？"></a>什么是缓存？</h4><h5 id="——数据交换的缓冲区"><a href="#——数据交换的缓冲区" class="headerlink" title="——数据交换的缓冲区"></a>——数据交换的缓冲区</h5><table><thead><tr><th>缓存的优点</th><th>缓存的成本</th></tr></thead><tbody><tr><td>降低后端负载</td><td>数据一致性成本</td></tr><tr><td>提高读写效率，降低响应时间</td><td>代码维护成本</td></tr><tr><td></td><td>运维成本</td></tr></tbody></table><h4 id="添加Redis缓存"><a href="#添加Redis缓存" class="headerlink" title="添加Redis缓存"></a>添加Redis缓存</h4><h5 id="应用场景：查询商铺信息"><a href="#应用场景：查询商铺信息" class="headerlink" title="应用场景：查询商铺信息"></a>应用场景：查询商铺信息</h5><p>​                     </p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230416110937099.png" alt="image-20230416110937099" style="zoom:50%;" /><p>​自己实现其中的逻辑</p><h4 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h4><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230416113050539.png" alt="image-20230416113050539" style="zoom: 33%;" /><p>​数据更新-&gt;缓存中的对应记录会被删除</p><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>​—-&gt;是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><h5 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h5><h6 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h6><p>​优点：实现简单，维护方便</p><p>​缺点：额外的内存消耗、       可能造成短期的不一致</p><h6 id="布隆过滤"><a href="#布隆过滤" class="headerlink" title="布隆过滤"></a>布隆过滤</h6><p>​优点：内存占用较少，没有多余key</p><p>​缺点：实现复杂、                  存在误判可能(hash冲突)</p><p>​         <strong>使用缓存空对象方式解决：</strong></p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230416215655097.png" alt="image-20230416215655097" style="zoom:50%;" /><p>缓存穿透的解决方案有哪些？</p><p>​•缓存null值</p><p>​•布隆过滤</p><p>​•增强id的复杂度，避免被猜测id规律</p><p>​•做好数据的基础格式校验</p><p>​•加强用户权限校验</p><p>​•做好热点参数的限流</p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><h4 id="缓存工具类封装"><a href="#缓存工具类封装" class="headerlink" title="缓存工具类封装"></a>缓存工具类封装</h4>]]></content>
      
      
      <categories>
          
          <category> 后端开发组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发组件 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列</title>
      <link href="/2023/06/02/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2023/06/02/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="1-MQ的相关概念-message-queue"><a href="#1-MQ的相关概念-message-queue" class="headerlink" title="1.MQ的相关概念(message queue)"></a>1.MQ的相关概念(message queue)</h2><h3 id="1-1什么是MQ："><a href="#1-1什么是MQ：" class="headerlink" title="1.1什么是MQ："></a>1.1什么是MQ：</h3><ul><li><p>​本质是个队列，只不过队列中的内容是message而已！</p></li><li><p>​用于上下游传递消息</p></li></ul><h3 id="1-2为什么要使用MQ"><a href="#1-2为什么要使用MQ" class="headerlink" title="1.2为什么要使用MQ"></a>1.2为什么要使用MQ</h3><h4 id="1-流量消峰："><a href="#1-流量消峰：" class="headerlink" title="1.流量消峰："></a>1.流量消峰：</h4><p>​在用户访问系统前添加MQ，对访问的消息进行排队，虽然排队会消耗时间但不会出现流量过大导致服务器宕机的情况。</p><h4 id="2-应用解耦："><a href="#2-应用解耦：" class="headerlink" title="2.应用解耦："></a>2.应用解耦：</h4><p>​如果没有MQ，比如用户在订单系统下单后，订单系统会立即调用物流系统，如果物流系统暂时出故障了，那么下单操作就会异常。</p><p>​如果使用了MQ，用户在订单系统下单后，如果物流系统暂时出故障了，物流系统需要处理的消息会被缓存在MQ中，等到物流系统故障修复完成，就可以从MQ中取出待处理的信息。这个过程中，用户不会感受到物流系统的故障，因此提升了系统的可用性。</p><h4 id="3-异步处理："><a href="#3-异步处理：" class="headerlink" title="3.异步处理："></a>3.异步处理：</h4><p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完。</p><p>以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api，B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅。</p><p>使用消息队列可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不用做这些操作，A 服务还能及时的得到异步处理成功的消息。</p><h2 id="2-RabbitMQ"><a href="#2-RabbitMQ" class="headerlink" title="2.RabbitMQ"></a>2.RabbitMQ</h2><h3 id="2-1-RabbitMQ概念："><a href="#2-1-RabbitMQ概念：" class="headerlink" title="2.1 RabbitMQ概念："></a>2.1 RabbitMQ概念：</h3><p>​RabbitMQ是一个消息中间件，能够接收、存储并转发消息</p><h3 id="2-2-四大核心概念："><a href="#2-2-四大核心概念：" class="headerlink" title="2.2 四大核心概念："></a>2.2 四大核心概念：</h3><h4 id="生产者："><a href="#生产者：" class="headerlink" title="生产者："></a>生产者：</h4><p>​产生数据，发送消息的程序成为生产者</p><h4 id="交换机："><a href="#交换机：" class="headerlink" title="交换机："></a>交换机：</h4><p>​接收来自生产者的消息，并将消息推送到队列中</p><p>​一个交换机可以与多个独立产生绑定关系binding(交换机需要知道将消息推送给特定队列、多个队列或是丢弃—由交换机类型决定)</p><h4 id="队列："><a href="#队列：" class="headerlink" title="队列："></a>队列：</h4><p>​队列  —–&gt;  一个大的消息缓冲区</p><p>​多个生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据</p><h4 id="消费者："><a href="#消费者：" class="headerlink" title="消费者："></a>消费者：</h4><p>​等待接收消息的程序</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230426204426849.png" alt="image-20230426204426849"></p><h3 id="rebbitmq服务的使用："><a href="#rebbitmq服务的使用：" class="headerlink" title="rebbitmq服务的使用："></a>rebbitmq服务的使用：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">brew services start rabbitmq<span class="comment">//开启服务</span></span><br><span class="line">brew services restart rabbitmq<span class="comment">//重启服务</span></span><br><span class="line">rabbitmqctl list_users<span class="comment">//查看用户</span></span><br><span class="line">rabbitmqctl add_user admin <span class="number">123</span><span class="comment">//添加用户用户名:admin 密码:123</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator<span class="comment">//将 admin 用户 设置为 administrator --&gt; 超级管理员</span></span><br><span class="line">rabbitmqctl set_permissions -p <span class="string">&quot;/&quot;</span> admin <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span><span class="comment">//为admin用户设置权限</span></span><br><span class="line"></span><br><span class="line">rabbitMQ可视化管理界面，即后台管理界面地址：localhost:<span class="number">15672</span>        ip:<span class="number">15672</span></span><br></pre></td></tr></table></figure><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><h2 id="引入依赖："><a href="#引入依赖：" class="headerlink" title="引入依赖："></a>引入依赖：</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>消息生产者发送消息到队列，消费者从队列中取出消息</p><h1 id="Work-Queues"><a href="#Work-Queues" class="headerlink" title="Work Queues"></a>Work Queues</h1><p>使用场景：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230427223442104.png" alt="image-20230427223442104"></p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2023/06/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/06/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="尚硅谷视频看到P43"><a href="#尚硅谷视频看到P43" class="headerlink" title="尚硅谷视频看到P43"></a>尚硅谷视频看到P43</h1><h1 id="设计模式七大原则："><a href="#设计模式七大原则：" class="headerlink" title="设计模式七大原则："></a>设计模式七大原则：</h1><h3 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h3><p>1） 代码重用性（即：相同功能的代码，不用多次编写）</p><p>2）可读性（即：编程规划性，便于其他程序员的阅读和理解）</p><p>3）可扩展性（即：当需要增加新的功能时，非常的方便，称为可维护)</p><p>4） 可靠性（即：当我们增加新的功能后，对原来的功能没有影响）</p><p>5） 使程序呈现高内聚，低耦合的特性</p><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>​「一个类只负责一项职责」</p><p>单一职责原则注意事项和细节：</p><p>​1. 降低类的复杂度，一个类只负责一项职责。</p><p>​2.提高类的可读性、可维护性。</p><p>​3.降低变更引起的风险。</p><p>​4.通常情况下，我们应该遵守单一职责原则。</p><p>​ ——只有<strong>逻辑足够简单</strong>时，才可以在<strong>代码级</strong>违反单一职责原则；</p><p>​ ——只有类型的<strong>方法数量足够少</strong>时，才可以才<strong>方法级别</strong>保持单一职责原则。</p><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>客户端不应该依赖它不需要的接口，<strong>一个类对另一个类的依赖应建立在最小的接口上</strong>。</p><p>​因为如果不是建立在最小的接口上，那么就说明有几个接口白白被实现了(实现但是没有被用)，违背了接口隔离原则！</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230523160645384.png" alt="image-20230523160645384" style="zoom:50%;" /><p>改进后：⬇️</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230523160702347.png" alt="image-20230523160702347" style="zoom:50%;" /><h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><ol><li><p>高层模块不应该依赖低层模块，二者都应该<strong>依赖其抽象</strong></p></li><li><p>抽象不应该依赖细节，细节应该依赖抽象</p></li><li><p>依赖倒转(倒置)的中心思想是<strong>「面向接口编程」</strong></p></li><li><p>依赖倒转原则是基于这样的设计理念：<u>相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多</u>。在java 中，抽象指的是接口或抽象类，细节就是具体的实现类</p></li><li><p>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</p></li></ol><p>依赖关系传递的三种方式：你通过什么方式把接口的实现类传给你要使用的类</p><ul><li>接口传递(直接将对象作为方法的形参)</li><li>构造方法传递(将对象在构造时存入待使用的类)</li><li>setter传递(set进去)</li></ul><p>注意事项：</p><ol><li>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好.</li><li>变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化</li><li>继承时遵循里氏替换原则</li></ol><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><ol><li>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，<strong>但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏</strong>。</li></ol><ol start="2"><li><strong>继承</strong>在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，<strong>增加对象间的耦合性</strong>，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障</li><li>问题提出：在编程中，如何正确的使用继承？&#x3D;＞里氏替换原则</li></ol><p>里氏替换原则的含义：所有引用基类的地方都能透明地使用其子类</p><p>​——子类尽量不重写父类的方法(重写后无法满足里氏替换原则)</p><p>​——如果你继承了然后还重写，那你何必继承呢？（除非迫不得已，不要重写父类方法）</p><p>在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性比较差。特别是运行多态比较频繁的时候。</p><p>通用的做法是：<strong>原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉</strong>，采用依赖，聚合，组合等</p><p>关系代替.</p><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><ul><li><p>是编程中最基础、最重要的设计原则</p></li><li><p>一个软件实体如类，模块和函数应该<u><strong>对扩展开放(对提供方)<strong>，</strong>对修改关闭(对使用方)</strong></u>。用抽象构建框架，用实现扩展细节。</p></li><li><p>当软件需要变化时，尽量通过<u><em><strong>扩展</strong></em></u>软件实体的行为来实现变化，而<strong>不是</strong>通过<strong>修改</strong>已有的代码来实现变化。</p></li><li><p><u>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</u></p></li></ul><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>​基本介绍</p><ol><li><p>一个对象应该<strong>对其他对象保持最少的了解</strong></p></li><li><p>类与类关系越密切，耦合度越大</p></li><li><p>迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息</p></li><li><p>迪米特法则还有个更简单的定义：只与直接的朋友通信</p></li><li><p>直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间</p></li></ol><p>是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现<strong>成员变量，方法参数，方法返</strong></p><p><strong>回值</strong>中的类为<u>直接的朋友</u>，而出现在<strong>局部变量中的类</strong>不是直接的朋友。也就是说，**<u>「陌生的类最好不要以局部变</u>**</p><p>**<u>量的形式出现在类的内部」</u>**。</p><h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>​<strong>原则是尽量使用合成&#x2F;聚合的方式，而不是使用继承</strong>(因为继承会增加耦合性)</p><p>场景：想让B使用A中的方法：</p><p>​我们当然可以让B继承A，但是这样会让A与B的耦合性增强</p><p>​我们可以采用以下方法：</p><ul><li>依赖：在B中添加以A为形参的方法，在该方法中使用A</li><li>聚合：将A作为B类中的一个成员变量(构造函数&#x2F;set方法)，在B的任意方法中使用A</li><li>组合：将A作为B类中的一个成员变量，在创建B的时候直接new A(), new一个</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>​设计原则的核心思想：</p><ul><li>找出应用中的<strong>可能需要变化之处</strong>，把他们<strong>独立</strong>出来，不要和那些不需要变化的代码混在一起</li><li><strong>针对接口编程</strong>，而不是针对实现编程</li><li>为了交互对象之间的<strong>松耦合设计</strong>而努力</li></ul><p></p><p>​</p><h1 id="UML图："><a href="#UML图：" class="headerlink" title="UML图："></a>UML图：</h1><ul><li><p>UML—Unified modeling language UML(统一建模语言)，是一种<strong>用于软件系统分析和设计的语言工具</strong>，它用于帮助软件开发人员进行思考和记录思路的结果</p></li><li><p>UML 本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如<strong>类、接口、实现、泛化、依赖、组合、聚合</strong>等</p></li></ul><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230524002012376.png" alt="image-20230524002012376" style="zoom:50%;" /><ol><li>用例图(use case)</li><li>静态结构图：<strong>类图</strong>、对象图、包图、组件图、部署图</li><li>动态行为图：交互图(时序图与协作图）、状态图、活动图</li></ol><p>类图用于描述类与类之间的关系，是UML图中的核心</p><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p>1） 用于描述系统中的<strong>类(对象)本身的组成</strong>和<strong>类(对象)之间的各种静态关系</strong>。</p><p>2） 类之间的关系：依赖、泛化(继承)、实现、关联、聚合与组合。</p><h3 id="依赖关系："><a href="#依赖关系：" class="headerlink" title="依赖关系："></a>依赖关系：</h3><p>​如果A类用到了B，则A与B存在依赖关系（如果没有对方，就无法编译通过）</p><ul><li>作为A的成员属性</li><li>是A中方法的返回类型</li><li>是A中方法的接收类型(形参类型)</li><li>在A的方法中使用到(作为局部变量)</li></ul><p>​<u>用<strong>虚线箭头</strong>描述关系</u></p><h3 id="泛化关系："><a href="#泛化关系：" class="headerlink" title="泛化关系："></a>泛化关系：</h3><p>​即继承关系，是依赖关系的特例</p><p><u>用<strong>实线+空心三角形</strong>描述</u></p><h3 id="实现关系："><a href="#实现关系：" class="headerlink" title="实现关系："></a>实现关系：</h3><p>​即接口的实现关系，也是依赖关系的特例<br><u>用<strong>虚线+空心三角形</strong>描述</u></p><h3 id="关联关系："><a href="#关联关系：" class="headerlink" title="关联关系："></a>关联关系：</h3><p>​指类与类之间的联系，是依赖关系的特例</p><p>用于描述两个类之间的关系是<strong>单向</strong>还是<strong>双向</strong>的</p><h3 id="聚合关系："><a href="#聚合关系：" class="headerlink" title="聚合关系："></a>聚合关系：</h3><p>​表示整体与部分的关系，***<u>整体和部分可以分开</u><em><strong>，是</strong>关联关系的特例</em>*</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>&#123;<span class="comment">//Computer中的Mouse可以为null</span></span><br><span class="line">Mouse mouse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>用<strong>实线+空心菱形</strong>描述</u></p><h3 id="组合关系："><a href="#组合关系：" class="headerlink" title="组合关系："></a>组合关系：</h3><p>​表示整体与部分的关系，***<u>整体和部分不可以分开</u>***，则是组合关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>&#123;<span class="comment">//Computer与Mouse 共创建、共销毁</span></span><br><span class="line"><span class="type">Mouse</span> <span class="variable">mouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mouse</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用实线+黑菱形描述</p><h1 id="设计模式概述："><a href="#设计模式概述：" class="headerlink" title="设计模式概述："></a>设计模式概述：</h1><h2 id="掌握设计模式的层次："><a href="#掌握设计模式的层次：" class="headerlink" title="掌握设计模式的层次："></a>掌握设计模式的层次：</h2><ul><li>第1层：刚开始学编程不久，听说过什么是设计模式</li><li>第2层：有很长时间的编程经验，自己写了很多代码，其中用到了设计模式，但是自己却不知道</li><li>第3层：学习过了设计模式，发现自己己经在使用了，并且发现了一些新的模式挺好用的</li><li>第4层：阅读了很多别人写的源码和框架，在其中看到别人设计模式，并且能够领会设计模式的精妙和带来的好处。</li><li>第5层：代码写着写着，自己都没有意识到使用了设计模式，并且熟练的写了出来。</li></ul><h2 id="设计模式介绍："><a href="#设计模式介绍：" class="headerlink" title="设计模式介绍："></a>设计模式介绍：</h2><ul><li>设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是某类问题的通用解決方案，设计模式 (Design pattern）代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</li><li>设计模式的本质提高 软件的维护性，通用性和扩展性，并降低软件的复杂度。</li><li>＜&lt;设计模式&gt;＞是经典的书，作者是 Erich Gamma、 Richard Helmn、 Ralph Johnson 和 John Vlissides Design （俗称“四人组 GOF”)</li><li>设计模式并不局限于某种语言，java，php，c++ 都有设计模式.</li></ul><h1 id="设计模式详解："><a href="#设计模式详解：" class="headerlink" title="设计模式详解："></a>设计模式详解：</h1><h2 id="创建型模式："><a href="#创建型模式：" class="headerlink" title="创建型模式："></a>创建型模式：</h2><p><strong>创建型： 在创建对象的同时隐藏创建逻辑，不使⽤ new 直接实例化对象，程序在判断需要创建哪些对象时更灵活。包括⼯⼚&#x2F;抽象⼯⼚&#x2F;单例&#x2F;建造者&#x2F;原型模式。</strong></p><h3 id="单例模式："><a href="#单例模式：" class="headerlink" title="单例模式："></a>单例模式：</h3><ol><li><p><strong>饿汉式(静态常量)</strong></p><ul><li><p>构造器私有化保证外部不能new</p></li><li><p>类的内部创建<strong>静态对象</strong>        在类的内部创建该类的静态对象，在类加载时自动生成</p></li><li><p>向外暴露一个静态的公共方法——getInstance</p><p>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</p><p>缺点：在<strong>类装载的时候就完成实例化</strong>，没有达到Lazy Loading 的效果。<u>如果从始至终从未使用过这个实例，则会造成内存的浪费</u>；正因为是在类加载时就会创建对象，我们可能在别的地方无意导致该类加载而不去使用，造成内存浪费。</p></li></ul></li><li><p><strong>饿汉式(静态代码块)</strong></p><ul><li><p>在类中定义该类的静态变量</p></li><li><p>在静态代码块中完成该类的静态变量的初始化</p><p>优缺点分析：</p><p>​这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点与上面方法一样</p><p>结论：这种单例模式可用，但是可能造成内存浪费</p></li></ul></li><li><p>懒汉式(线程不安全)</p><ul><li><p>构造器私有化 保证外部不能new</p></li><li><p>类的内部定义<strong>静态对象</strong>          创建对象，但是不创建(不 new)</p></li><li><p>向外暴露一个静态的公共方法——getInstance  在调用该方法时，才对该类的静态对象进行创建</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230524105503814.png" alt="image-20230524105503814" style="zoom:45%;" /><p>优缺点分析：</p><p>​起到了 Lazy Loading 的效果，但是只能在单线程下使用。</p><p>​如果在多线程下，一个线程进入了**if(singleton&#x3D;&#x3D; null)**判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。</p><p><strong>结论</strong>：在实际开发中，不要使用这种方式.</p></li></ul></li><li><p>懒汉式(线程安全，同步方法)</p><p>给 getInstance 添加 synchronize 修饰，保证同步</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230524112254631.png" alt="image-20230524112254631" style="zoom:40%;" /><p>优缺点分析：</p><p>​解决了线程安全问题</p><p>​<strong>效率太低了</strong>，<u>每个线程在想获得类的实例时候，执行 getinstance()方法都要进行同步</u>。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。方法进行同步效率太低</p><p><strong>结论</strong>：在实际开发中，<strong>不推荐</strong>使用这种方式</p></li><li><p>懒汉式(线程安全，同步代码块)</p><p>不可使用，因为不能保证单例</p></li><li><p><strong>双重检查</strong></p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230524114249721.png" alt="image-20230524114249721" style="zoom:50%;" /><p>​Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次if(singleton&#x3D;&#x3D; null)检查，这样就可以保证线程安全了。</p><p>​这样，实例化代码只用执行一次，后面再次访问时，判断if(singleton&#x3D;&#x3D;null)，直接 return 实例化对象，也避免的反复进行方法同步.</p><p>​线程安全；延迟加载；效率较高</p><p>结论：在实际开发中，<strong>推荐使用这种单例设计模式</strong></p><h4 id="🌟这⾥为什么要使⽤-volatile-？"><a href="#🌟这⾥为什么要使⽤-volatile-？" class="headerlink" title="🌟这⾥为什么要使⽤ volatile ？"></a>🌟这⾥为什么要使⽤ volatile ？</h4><p>这是因为 new 关键字创建对象不是原⼦操作，创建⼀个对象会经历下⾯<br>的步骤：</p><ol><li>在堆内存开辟内存空间</li><li>调⽤构造⽅法，初始化对象</li><li>引⽤变量指向堆内存空间<br>为了提⾼性能，编译器和处理器常常会对既定的代码执⾏顺序进⾏指令重排序，从源码到最终执⾏指令会经历如下流程：<br>源码编译器优化重排序指令级并⾏重排序内存系统重排序最终执⾏指令序列所以经过指令重排序之后，创建对象的执⾏顺序可能为 1 2 3 或者 1 3 2 ，因此当某个线程在乱序运⾏ 1 3 2 指令的时候，引⽤变量指向堆内存空间，这个对象不为 null，但是没有初始化，其他线程有可能这个时候进⼊了 getInstance 的第⼀个 if(instance &#x3D;&#x3D; null) 判断不为 nulll ，导致<strong>错误使⽤了没有初始化的⾮ null 实例</strong>，这样的话就会出现异常，这个就是著名的<br>DCL 失效问题。<br>当我们在引⽤变量上⾯添加 volatile 关键字以后，会通过在创建对象指令的前后添加内存屏障来禁⽌指令重排序，就可以避免这个问题，⽽且对volatile 修饰的变量的修改对其他任何线程都是可⻅的。</li></ol></li><li><p><strong>静态内部类</strong></p><ul><li><p>构造器私有化 保证外部不能new</p></li><li><p>构建一个静态内部类，内部类中有一个静态属性，如果加载了静态类，该属性也会创建对象</p></li><li><p>向外暴露一个静态的公共方法——getInstance  在调用该方法时，对静态内部类进行初始化，返回静态内部类属性</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230524115554993.png" alt="image-20230524115554993" style="zoom:50%;" /></li></ul><p>优缺点分析：</p><ul><li><p>这种方式采用了类装载的机制来保证初始化实例时只有一个线程。</p></li><li><p>静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用getinstance 方法，才会装载 Singletoninstance 类，从而完成 Singleton 的实例化。</p></li><li><p>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</p></li><li><p>优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</p></li><li><p>缺点：getInstance 还是被synchronized修饰了</p></li></ul><p><strong>结论</strong>：推荐使用．</p></li><li><p><strong>枚举</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过 Singleton.INSTANCE 来获取单例，获取的对象可以使用Singleton中的方法</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">  INSTANCE;<span class="comment">//属性</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>这借助 JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步 问题，而且还能防止反序列化重新创建</p></li><li><p>新的对象。</p></li><li><p>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式</p></li><li><p><strong>结论</strong>：推荐使用</p></li></ul><h4 id="单例模式注意事项："><a href="#单例模式注意事项：" class="headerlink" title="单例模式注意事项："></a>单例模式注意事项：</h4><ul><li><p>单例模式保证了 系统内存中该类只存在一个对象，<u>节省了系统资源</u>，<strong>对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</strong></p></li><li><p>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new</p></li><li><p>单例模式使用的场景：**<u><em>需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多（即：重量级对象），但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、session 工厂等）</em></u>**</p></li></ul></li></ol><h3 id="工厂模式："><a href="#工厂模式：" class="headerlink" title="工厂模式："></a>工厂模式：</h3><h4 id="简单工厂模式："><a href="#简单工厂模式：" class="headerlink" title="简单工厂模式："></a>简单工厂模式：</h4><p>「针对每种产品」</p><p><u>简单⼯⼚模式指由⼀个⼯⼚对象来创建实例，客户端不需要关注创建逻辑，只需提供传⼊⼯⼚的参数。</u></p><ul><li><p>简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式</p></li><li><p>简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为</p></li><li><p>在软件开发中，当我们<strong>用到大量的创建某种、某类或者某批对象</strong>时，就会使用到工厂模式.</p></li></ul><h4 id="工厂方法模式："><a href="#工厂方法模式：" class="headerlink" title="工厂方法模式："></a>工厂方法模式：</h4><p>「针对一类产品」</p><p>和简单⼯⼚模式中⼯⼚负责⽣产所有产品相⽐，⼯⼚⽅法模式将⽣成具体产品的任务分发给具体的产品⼯⼚。</p><p>其实就是在工厂这边再分层 逻辑为：总工厂&lt;–&gt;子工厂1&#x2F;2&#x2F;3…</p><p>​其中，总工厂定义了产品的生产接口，而生产接口由不同的子工厂进行实现。从而对工厂进行了进一步划分。</p><h4 id="抽象工厂模式："><a href="#抽象工厂模式：" class="headerlink" title="抽象工厂模式："></a>抽象工厂模式：</h4><p>「针对多类产品，每个类中还有多种产品！」</p><p>总工厂、子工厂都是抽象的。要生产某种产品，我们首先找到模版类似的子类，再对子类进行实现，从而进行创建。</p><h2 id="结构型模式："><a href="#结构型模式：" class="headerlink" title="结构型模式："></a>结构型模式：</h2><h3 id="适配器模式："><a href="#适配器模式：" class="headerlink" title="适配器模式："></a>适配器模式：</h3><p>概述：在我们的应⽤程序中我们可能需要将两个不同接⼝的类来进⾏通信，在不修改这两个的前提下我们可能会需要某个中间件来完成这个衔接的过程。这个中间件就是适配器。所谓适配器模式就是<strong>将⼀个类的接⼝，转换成客户期望的另⼀个接⼝</strong>。它<u>可以让原本两个不兼容的接⼝能够⽆缝完成对接</u>。</p><p>作为中间件的适配器将⽬标类和适配者解耦，增加了类的透明性和可复⽤性。</p><p>⽬标类和适配者不必有很大关联，可以通过适配器建立联系，从而实现解耦。</p><h5 id="类适配器："><a href="#类适配器：" class="headerlink" title="类适配器："></a>类适配器：</h5><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230524201128653.png" alt="image-20230524201128653" style="zoom:50%;" /><p><strong>对象适配器：</strong></p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230524201140631.png" alt="image-20230524201140631" style="zoom:50%;" /><ul><li><p>Target: 定义 Client 真正需要使⽤的接⼝。</p></li><li><p>Adaptee: 其中定义了⼀个已经存在的接⼝，也是我们需要进⾏适配的接⼝。</p></li><li><p>Adapter: 对 Adaptee 和 Target 的接⼝进⾏适配，保证对 target 中接⼝的调⽤可以间接转换为对 Adaptee 中接⼝进⾏调⽤。</p><ul><li>优点：</li></ul><ol><li>提⾼了类的复⽤；</li><li>组合若⼲关联对象形成对外提供统⼀服务的接⼝；</li><li>扩展性、灵活性好。</li></ol><ul><li>缺点：</li></ul><ol><li>过多使⽤适配模式容易造成代码功能和逻辑意义的混淆。</li><li>部分语⾔对继承的限制，可能⾄多只能适配⼀个适配者类，⽽且⽬标类必须是抽象类。</li></ol></li></ul><h3 id="装饰模式："><a href="#装饰模式：" class="headerlink" title="装饰模式："></a>装饰模式：</h3><p>装饰器模式主要对现有的类对象进⾏包裹和封装，以期望在不改变类对象及其类定义的情况下，为对象添加额外功能。是⼀种对象结构型模式。需要注意的是，该过程是通过调⽤被包裹之后的对象完成功能添加的，⽽不是直接修改现有对象的⾏为，相当于增加了中间层。(AOP???)</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230524204945734.png" alt="image-20230524204945734" style="zoom:50%;" /><p><strong>Component</strong>: 对象的接⼝类，定义装饰对象和被装饰对象的共同接⼝；<br><strong>ConcreteComponent</strong>: 被装饰对象的类定义；<br><strong>Decorator</strong>: 装饰对象的抽象类，<u><strong>持有⼀个具体的被修饰对象</strong></u>，并实现接⼝类继承的公共接⼝；<br><strong>ConcreteDecorator</strong>:具体的装饰器，负责往被装饰对象添加额外的功能；</p><h4 id="讲讲装饰器模式的应⽤场景"><a href="#讲讲装饰器模式的应⽤场景" class="headerlink" title="讲讲装饰器模式的应⽤场景"></a>讲讲装饰器模式的应⽤场景</h4><p>如果你希望在<u>⽆需修改代码的</u>情况下即可使⽤对象， 且希望在运⾏时<u>为对象新增额外的⾏为</u>， 可以使⽤装饰模式。装饰能将业务逻辑组织为层次结构， 你可为各层创建⼀个装饰， 在运⾏时<br>将各种不同逻辑组合成对象。 由于这些对象都遵循通⽤接⼝， 客户端代码能以相同的⽅式使⽤这些对象。如果⽤继承来扩展对象⾏为的⽅案难以实现或者根本不可⾏， 你可以使⽤该模式。许多编程语⾔使⽤ final 最终关键字来限制对某个类的进⼀步扩展。 复⽤最终类已有⾏为的唯⼀⽅法是使⽤装饰模式： ⽤封装器对其进⾏封装。</p><h3 id="代理模式："><a href="#代理模式：" class="headerlink" title="代理模式："></a>代理模式：</h3><p>代理模式的本质是⼀个中间件，主要⽬的是解耦合服务提供者和使⽤者。<strong>使⽤者通过代理间接地访问服务提供者</strong>，<u>便于后者的封装和控制</u>。是⼀种结构性模式。</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230524202229926.png" alt="image-20230524202229926" style="zoom:60%;" /><p>Subject: 定义 RealSubject 对外的接⼝，且这些接⼝必须被 Proxy 实现，这样外部调⽤ proxy 的接⼝最终都被转化为对 realsubject 的调⽤。<br>RealSubject: 真正的⽬标对象。<br>Proxy: ⽬标对象的代理，负责控制和管理⽬标对象，并间接地传递外部对⽬标对象的访问。</p><p>Remote Proxy: 对本地的请求以及参数进⾏序列化，向远程对象发送请求，并对响应结果进⾏反序列化，将最终结果反馈给调⽤者；<br>Virtual Proxy: 当⽬标对象的创建开销⽐较⼤的时候，可以使⽤延迟或者异步的⽅式创建⽬标对象；<br>Protection Proxy: 细化对⽬标对象访问权限的控制；</p><h4 id="静态代理和动态代理的区别"><a href="#静态代理和动态代理的区别" class="headerlink" title="静态代理和动态代理的区别:"></a>静态代理和动态代理的区别:</h4><ol><li>灵活性 ：动态代理更加灵活，不需要必须实现接⼝，可以直接代理实现类，并且可以不需要针对每个⽬标类都创建⼀个代理类。另外，静态代理中，接⼝⼀旦新增加⽅法，⽬标对象和代理对象都要进⾏修改，这是⾮常麻烦的！</li><li>JVM 层⾯ ：<u>静态代理在编译时就将接⼝、实现类、代理类这些都变成了⼀个个实际的 class ⽂件</u>。⽽动态代理是在运⾏时动态⽣成类字节码，并加载到 JVM 中的。</li></ol><h2 id="行为型模式："><a href="#行为型模式：" class="headerlink" title="行为型模式："></a>行为型模式：</h2><h3 id="观察者模式："><a href="#观察者模式：" class="headerlink" title="观察者模式："></a>观察者模式：</h3><p>观察者模式主要⽤于<u>处理对象间的⼀对多的关系</u>，是⼀种对象⾏为模式。</p><p>该模式的实际应⽤场景⽐较容易确认，当⼀个对象状态发⽣变化时，所有该对象的关注者均能收到状态变化通知，以进⾏相应的处理。(怎么这么像websocket啊)</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230524203754928.png" alt="image-20230524203754928" style="zoom:50%;" /><p><strong>Subject</strong>: 抽象被观察者，仅提供注册和删除观察者对象的接⼝声明。<br><strong>ConcreteSubject</strong>: 具体被观察者对象，该对象中收集了所有需要被通知的观察者，并可以动态的增删集合中的观察者。当其状态发⽣变化时会通知所有观察者对象。<br><strong>Observer</strong>: 抽象观察者，为所有观察者定义获得通知的统⼀接⼝；<br><strong>ConcreteObserver</strong>: 观察者对象，其关注对象为 Subject，能接受 Subject变化时发出的通知并更新⾃身状态。</p><ul><li>优点：</li></ul><ol><li>被观察者和观察者之间是抽象耦合的；</li><li>耦合度较低，两者之间的关联仅仅在于消息的通知；</li><li>被观察者⽆需关⼼他的观察者；</li><li>⽀持⼴播通信；</li></ol><ul><li>缺点：</li></ul><ol><li>观察者只知道被观察对象发⽣了变化，但<strong>不知变化的过程和缘由</strong>；</li><li><strong>观察者同时也可能是被观察者，消息传递的链路可能会过⻓，完成所有</strong><br><strong>通知花费时间较多</strong></li><li>如果观察者和被观察者之间产⽣循环依赖，或者消息传递链路形成闭<br>环，会<u>导致⽆限循环</u>；</li></ol><h4 id="你的项⽬是怎么⽤的观察者模式？"><a href="#你的项⽬是怎么⽤的观察者模式？" class="headerlink" title="你的项⽬是怎么⽤的观察者模式？"></a>你的项⽬是怎么⽤的观察者模式？</h4><p>在⽀付场景下，⽤户购买⼀件商品，当⽀付成功之后三⽅会回调⾃身，在这个时候系统可能会有很多需要执⾏的逻辑（如：更新订单状态，发送邮件通知，赠送礼品…），这些逻辑之间并没有强耦合，因此天然适合使⽤观察者模式去实现这些功能，当有更多的操作时，只需要添加新的观察者就能实现，完美实现了对修改关闭，对扩展开放的开闭原则。</p><h3 id="责任链模式："><a href="#责任链模式：" class="headerlink" title="责任链模式："></a>责任链模式：</h3><p>⼀个请求沿着⼀条“链”传递，直到该“链”上的某个处理者处理它为⽌。</p><h4 id="讲讲责任链模式的应⽤场景"><a href="#讲讲责任链模式的应⽤场景" class="headerlink" title="讲讲责任链模式的应⽤场景"></a>讲讲责任链模式的应⽤场景</h4><ul><li><p>当程序需要使⽤不同⽅式处理不同种类请求， ⽽且请求类型和顺序预先未知时， 可以使⽤责任链模式。该模式能将多个处理者连接成⼀条链。 接收到请求后， 它会 “询问” 每个处理者是否能够对其进⾏处理。这样所有处理者都有机会来处理请求。</p></li><li><p>当必须按顺序执⾏多个处理者时， 可以使⽤该模式。 ⽆论你以何种顺序将处理者连接成⼀条链， 所有请求都会严格按照顺序通过链上的处理者。</p></li></ul><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><h4 id="什么是策略模式？"><a href="#什么是策略模式？" class="headerlink" title="什么是策略模式？"></a>什么是策略模式？</h4><p>策略模式（Strategy Pattern）属于对象的⾏为模式。其⽤意是针对⼀组算法，将每⼀个算法封装到具有共同接⼝的独⽴的类中，从⽽使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发⽣变化。其主要⽬的是通过定义相似的算法，替换 if else 语句写法，并且可以随时相互替换。</p><h4 id="策略模式有什么好处？"><a href="#策略模式有什么好处？" class="headerlink" title="策略模式有什么好处？"></a>策略模式有什么好处？</h4><p>定义了⼀系列封装了算法、⾏为的对象，他们可以相互替换。举例： Java.util.List 就是定义了⼀个增（ add ）、删（ remove ）、改（ set ）、查（ indexOf ）策略，⾄于实现这个策略的ArrayList 、 LinkedList 等类，只是在具体实现时采⽤了不同的算法。但因为它们策略⼀样，不考虑速度的情况下，使⽤时完全可以互相替换使⽤。</p><h1 id="设计模式实例："><a href="#设计模式实例：" class="headerlink" title="设计模式实例："></a>设计模式实例：</h1><h2 id="Spring-使⽤了哪些设计模式？"><a href="#Spring-使⽤了哪些设计模式？" class="headerlink" title="Spring 使⽤了哪些设计模式？"></a>Spring 使⽤了哪些设计模式？</h2><ul><li>⼯⼚设计模式 : Spring 使⽤⼯⼚模式通过BeanFactory 、 ApplicationContext 创建 bean 对象。</li><li>代理设计模式 : Spring AOP 功能的实现(<strong>动态代理</strong>)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件开发基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/2023/06/02/SpringBoot/"/>
      <url>/2023/06/02/SpringBoot/</url>
      
        <content type="html"><![CDATA[<p>本博客是根据韩顺平老师的SpingBoot课程进行的知识总结！</p><h3 id="SpringBoot快速入门"><a href="#SpringBoot快速入门" class="headerlink" title="SpringBoot快速入门"></a>SpringBoot快速入门</h3><ul><li>简化了传统的SSM开发，简化整合步骤，提高开发效率</li><li>简化了Maven项目的pom.xml依赖导入，可以说是一键导入</li></ul><p>@SpringBootApplication:用于表示这是一个springboot应用&#x2F;项目</p><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>​pom.xml中</p><p>​导入了父工程</p><p>​1.spring-boot-starter-parent中还有父项目，声明了开发中常用的依赖的版本号</p><p>​2.会自行进行版本仲裁(程序员没有指定某个jar依赖的版本，则以父项目指定的版本为准)</p><p>​想要修改自动仲裁的版本：（依赖就近优先原则）</p><p>​方式1：在pom.xml自行显式引入依赖<dependency></p><p>​方式2：在pom.xml文件中的<properties>标签中执行版本号</p><h4 id="场景启动器"><a href="#场景启动器" class="headerlink" title="场景启动器"></a>场景启动器</h4><p>​<strong>官方</strong>给的starter形式为：spring-boot-starter-xxx</p><p>​场景启动器能够帮你把使用xxx时所需要的配置全都配好，比如web、redis、jdbc等</p><p>​<strong>第三方</strong>的starter形式为：xxx-spring-boot-starter</p><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><h4 id="自动配置了什么？"><a href="#自动配置了什么？" class="headerlink" title="自动配置了什么？"></a>自动配置了什么？</h4><p>​–Tomcat</p><p>​–SpringMVC</p><p>​–自动配置了Web常用功能如字符过滤器，并注入到容器中</p><p>​–🌟自动配置了默认扫描包结构：默认扫描 <strong>springboot主程序目录下及其子目录中</strong>的包包(可以自行配置)</p><h4 id="如何修改默认配置？"><a href="#如何修改默认配置？" class="headerlink" title="如何修改默认配置？"></a>如何修改默认配置？</h4><h5 id="修改默认扫描包结构-可以传入一个String数组，表示需要扫描多个不同的包"><a href="#修改默认扫描包结构-可以传入一个String数组，表示需要扫描多个不同的包" class="headerlink" title="修改默认扫描包结构(可以传入一个String数组，表示需要扫描多个不同的包)"></a>修改默认扫描包结构(可以传入一个String数组，表示需要扫描多个不同的包)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//scanBasePackages = &#123;&quot;com.study&quot;&#125;指定springboot要扫描的包及其子包</span></span><br><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages = &#123;&quot;com.study&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApp</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><h5 id="也可以在resources-x2F-application-properties文件中定义更多的-自定义配置"><a href="#也可以在resources-x2F-application-properties文件中定义更多的-自定义配置" class="headerlink" title="也可以在resources&#x2F;application.properties文件中定义更多的  自定义配置"></a>也可以在resources&#x2F;application.properties文件中定义更多的  <u>自定义配置</u></h5><pre><code> ⚠️我们在resources/application.properties中自定义了配置，那么springboot在哪读取这些配置的呢？</code></pre><p>​我们在application.properties中配置的信息会映射到该属性对应的某个类中(默认配置最终都会映射到对应的类中)，这个类会被注册进IOC容器中，因此配置才会生效！</p><p>​还可以自定义配置，类似于定义一个常量</p><p>配置的关系：application.properties  xxxProperties  xxxAutoConfiguration</p><p>xxxAutoConfiguration类中含有一个xxxProperties对象，xxxProperties对象中保存了默认配置的值，如果程序员在application.properties中进行了自定义的配置，会被反映到xxxProperties中，覆盖其中的默认值。于是xxxAutoConfiguration中携带的配置就是application.properties与xxxProperties中的信息了，xxxAutoConfiguration再被注册到IOC容器中，于是配置完成！</p><h3 id="SpringBoot容器功能"><a href="#SpringBoot容器功能" class="headerlink" title="SpringBoot容器功能"></a>SpringBoot容器功能</h3><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h4><p>​在SpringBoot中使用@Configuration添加&#x2F;注入组件</p><p>​配置类(被@Configuration修饰的类) 配置类也会注入到容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>      <span class="comment">//表示这是一个配置类</span></span><br><span class="line"><span class="comment">//在@Configuration注解的类中，程序员可以通过@Bean注解来注入bean对象到容器</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span><span class="comment">//默认为单例，可以在scope注解中设置为多例</span></span><br></pre></td></tr></table></figure><h5 id="proxyBeanMethods-代理bean的方法"><a href="#proxyBeanMethods-代理bean的方法" class="headerlink" title="proxyBeanMethods:代理bean的方法"></a>proxyBeanMethods:代理bean的方法</h5><p>​@Configuration(proxyBeanMethods &#x3D; false)&#x2F;&#x2F;表示每个@Bean方法被调用返回的组件<strong>都是新创建的</strong>，多例，代理方式 Lite模式</p><p>​@Configuration(proxyBeanMethods &#x3D; true) &#x2F;&#x2F;表示每个@Bean方法被调用返回的组件<strong>都是单实例的</strong>，单例，非代理方式 Full模式</p><p>​⬆️以上配置要生效，需要先获取BeanConfig组件，再调用方法</p><p>​如果直接通过容器获取，则以上设置无效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接通过容器获取：        </span></span><br><span class="line"><span class="type">Monster</span> <span class="variable">monster01</span> <span class="operator">=</span> ioc.getBean(<span class="string">&quot;monster01&quot;</span>, Monster.class);</span><br><span class="line">        <span class="type">Monster</span> <span class="variable">monster02</span> <span class="operator">=</span> ioc.getBean(<span class="string">&quot;monster01&quot;</span>, Monster.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;01---&quot;</span> + monster01 + <span class="string">&quot; &quot;</span> + monster01.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;02---&quot;</span> + monster02 + <span class="string">&quot; &quot;</span> + monster02.hashCode());</span><br><span class="line"><span class="comment">//获取BeanConfig组件，再调用方法：</span></span><br><span class="line">        <span class="type">BeanConfig</span> <span class="variable">beanConfig</span> <span class="operator">=</span> ioc.getBean(BeanConfig.class);</span><br><span class="line">        <span class="type">Monster</span> <span class="variable">monster01</span> <span class="operator">=</span> beanConfig.monster01();</span><br><span class="line">        <span class="type">Monster</span> <span class="variable">monster02</span> <span class="operator">=</span> beanConfig.monster01();</span><br><span class="line">        System.out.println(<span class="string">&quot;01---&quot;</span> + monster01 + <span class="string">&quot; &quot;</span> + monster01.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;02---&quot;</span> + monster02 + <span class="string">&quot; &quot;</span> + monster02.hashCode());</span><br></pre></td></tr></table></figure><h5 id="配置类——config文件可以有多个"><a href="#配置类——config文件可以有多个" class="headerlink" title="配置类——config文件可以有多个"></a>配置类——config文件可以有多个</h5><p>​每个类可以有多种Bean，给@Bean修饰的方法起不同的名字( id )即可</p><p>&#x2F;&#x2F;monster02为你为该bean设置的id，如果你没有为其在@bean的name属性中设置名称，那么默认为你修饰的构造<strong>方法名</strong><br>通过此步骤：ioc.getBean(“monster02”, Monster.class);</p><h4 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h4><p>修饰配置类，可以通过 .class的数组，来注入指定类型的Bean</p><p>​可以用于注入组件，例：@Import( {Dog.class, Cat.class} ) &#x2F;&#x2F;<strong><u><em>默认bean的ID为该类的全类名</em></u></strong></p><h4 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h4><p>​条件装配：满足Conditional指定的条件，则进行组件注入</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当容器中有一个bean，它的名字是 monster_nmw ,就注入这个bean；没有则不注入//只要名字ok就行，对类型不做要求</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(name = &quot;monster_nmw&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Dog <span class="title function_">dog01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果@Conditional修饰类，那么这个配置类中的所有组件<strong>都</strong>需要满足该条件</p><h4 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h4><p><strong>用于配置传统方式(xml文件)的bean</strong></p><p>​修饰某个配置类，将 .xml 文件中的配置导入到配置类中，并测试是否可以获得 .xml 文件中的组件</p><p>resources目录下的xml文件用 @ImportResource( locations &#x3D; “classpath:xxx.xml” )</p><h4 id="配置绑定："><a href="#配置绑定：" class="headerlink" title="配置绑定："></a>配置绑定：</h4><p>​将application.properties中指定的k-v值 与 JavaBean进行绑定！</p><p>​功能：获取JavaBean时，一些数据自动从application.properties获取</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置Furn的属性 k-v</span></span><br><span class="line"><span class="comment">#其中 furn01 用于指定/区分不同的绑定对象，这样可以在绑定不同的Furn bean属性值时</span></span><br><span class="line"><span class="comment">#通过furn01前缀进行区分</span></span><br><span class="line"><span class="comment">#furn01.id中的id是Furn bean的属性名</span></span><br><span class="line"><span class="attr">furn01.id</span>=<span class="string">100</span></span><br><span class="line"><span class="attr">furn01.name</span>=<span class="string">TV</span></span><br><span class="line"><span class="attr">furn01.price</span>=<span class="string">1000.9</span></span><br></pre></td></tr></table></figure><p>在对应的<strong>bean</strong>中添加注解：@ConfigurationProperties(prefix &#x3D; “furn01”)</p><h4 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h4><p>​修饰bean，直接将bean注册入容器</p><h3 id="SpringBoot底层机制分析"><a href="#SpringBoot底层机制分析" class="headerlink" title="SpringBoot底层机制分析"></a>SpringBoot底层机制分析</h3><h3 id="P32开始"><a href="#P32开始" class="headerlink" title="P32开始"></a>P32开始</h3><h3 id="跳到了P47"><a href="#跳到了P47" class="headerlink" title="跳到了P47"></a>跳到了P47</h3><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><p>简化Javabean的开发，javabean中的getter、setter、tostring均可通过Lombok实现</p><p>@Data 注解在类上，提供所有属性的getter、setter方法</p><p>@Getter</p><p>@Setter</p><p>@ToString</p><p>@NoargsConstructor</p><p>@AllargsConstructor</p><h3 id="Spring-Initializr"><a href="#Spring-Initializr" class="headerlink" title="Spring Initializr"></a>Spring Initializr</h3><p>程序员使用Maven Archetype 来生成Maven项目，项目原型相对简陋，需要手动配置</p><p>我们可以通过Spring Initialzr来构建Maven项目</p><h3 id="53-60跳了！"><a href="#53-60跳了！" class="headerlink" title="53-60跳了！"></a>53-60跳了！</h3><h3 id="yaml："><a href="#yaml：" class="headerlink" title="yaml："></a>yaml：</h3><h4 id="基本规则："><a href="#基本规则：" class="headerlink" title="基本规则："></a>基本规则：</h4><h5 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h5><p>​        key： value        (key + : + 一个空格 + value)<br>​大小写敏感<br>​使用缩进表示层级关系<br>​    缩进不允许使用Tab，只能使用空格<br>​    缩进的格数不重要，只要相同层级的元素左对齐即可<br>​    ‘#’ 表示注释<br>​字符串无需加引号：<br>​单引号会将 \n 作为字符串输出<br>​双引号会将 \n 作为换行输出</p><h5 id="表示对象："><a href="#表示对象：" class="headerlink" title="表示对象："></a>表示对象：</h5><p>​    k: {k1: v1,k2: v2,….}<br>或<br>​    k:<br>​      k1: v1<br>​      k2:v2<br>​      k3:v3<br>​      …</p><h5 id="表示数组："><a href="#表示数组：" class="headerlink" title="表示数组："></a>表示数组：</h5><p>​    k: [v1,v2,v3,…]<br>或<br>​    k:<br>​&#x2F;- v1<br>​&#x2F;-v2<br>​&#x2F;-v3<br>​……</p><!--    在yml文件中，输入自定javabean时需要提示，只需引入如下依赖    --><dependency>    <groupId>org.springframework.boot</groupId>    <artifactId>spring-boot-configuration-processor</artifactId>    <optional>true</optional></dependency><p>properties文件与yaml文件会被**逐个解析(按文件顺序)**，若定义了同样的东西，那么谁先定义就按谁的来</p><h3 id="WEB开发-静态资源访问"><a href="#WEB开发-静态资源访问" class="headerlink" title="WEB开发-静态资源访问"></a>WEB开发-静态资源访问</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><h5 id="默认静态资源目录："><a href="#默认静态资源目录：" class="headerlink" title="默认静态资源目录："></a>默认静态资源目录：</h5><p>​放在resource目录下的四种目录中，会被认为是静态资源：<br>​    1.&#x2F;static<br>​    2.&#x2F;public<br>​    3.&#x2F;resources<br>​    4.&#x2F;META-INF&#x2F;resources</p><p>​可自行更改成别的包，但没必要</p><p>🌟为什么是这几个包呢？因为在Spring容器中，WebProperties.java在IOC容器中被加载，而在其中定义了默认的静态资源路径！</p><h5 id="常见静态资源："><a href="#常见静态资源：" class="headerlink" title="常见静态资源："></a>常见静态资源：</h5><p>​.js .css 图片 字体文件等等</p><h5 id="访问方式："><a href="#访问方式：" class="headerlink" title="访问方式："></a>访问方式：</h5><p>​项目根路径&#x2F; + 静态资源名 (无需中间的路径，直接资源名即可)</p><p>​原因：在 WebProperties.java 中，帮你做了映射。当然，不满意的话也可以自定配置定义。</p><h5 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h5><h6 id="静态资源访问原理："><a href="#静态资源访问原理：" class="headerlink" title="静态资源访问原理："></a>静态资源访问原理：</h6><p>​静态映射是 &#x2F;**  也就是对所有请求拦截，当收到请求时，<strong>先看Controller能不能处理</strong>，若不能，再将请求交给<strong>静态资源处理器</strong>，如果静态资源中也无法匹配，则返回404错误   </p><p>​（即：<u>先看Controller中有无匹配，没有再看静态资源中有没有</u>）</p><p><strong>⚠️因此Controller中的请求可能和静态资源重名，导致意外的错误，因此我们有时需要将静态资源的默认访问前缀进行修改，从而避免冲突</strong></p><h6 id="修改静态资源访问前缀："><a href="#修改静态资源访问前缀：" class="headerlink" title="修改静态资源访问前缀："></a>修改静态资源访问前缀：</h6><p>​在 application.yaml 中配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改静态资源访问的路径/ 前缀</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/study/**</span></span><br></pre></td></tr></table></figure><h6 id="增加一个静态资源目录："><a href="#增加一个静态资源目录：" class="headerlink" title="增加一个静态资源目录："></a>增加一个静态资源目录：</h6><p>​…</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">static-locations:</span> [<span class="string">新的路径</span>]<span class="comment"># 如果原来的还想用，那么要把原来的也填进新的路径中</span></span><br></pre></td></tr></table></figure><h3 id="Rest风格请求处理"><a href="#Rest风格请求处理" class="headerlink" title="Rest风格请求处理"></a>Rest风格请求处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonsterController</span> &#123;</span><br><span class="line"><span class="comment">//    @RequestMapping(value = &quot;/monster&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/monster&quot;)</span><span class="comment">//两种写法作用相同！</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMonster</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GET-查询&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/monster&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">saveMonster</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;POST-保存&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/monster&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">putMonster</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PUT-修改&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/monster&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteMonster</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DELETE-删除&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>客户端是 PostMan 可以直接发送Put、Delete 请求，可以不设置Filter</p><p>如果要springboot支持<strong>页面表单</strong>的Rest功能，需要注意：</p><ul><li>Rest风格请求 核心Filter——HiddenHttpMethodFilter，表单请求会被其拦截，获取表单的 _method值，再判断是PUT&#x2F;DELETE&#x2F;PATCH</li><li>需要在application.yml中启动filter功能</li><li>修改application.yml，启用filter功能</li></ul><p>@RestController 与 @Controller：</p><p>​@Controller：会将方法返回的String交给视图解析器，再跳转到页面</p><p>​1.如果没有配置视图解析器，看有没有对应返回String的其他Controller，有，进入其他controller</p><p>​2.如果配置了视图解析器，则直接寻找有无对应视图解析器，有则使用视图解析器</p><p>​3.找不到则返回404</p><p>​@RestController：会直接返回String，不会寻找视图解析器进行跳转</p><h2 id="参数接收相关注解"><a href="#参数接收相关注解" class="headerlink" title="参数接收相关注解"></a>参数接收相关注解</h2><h3 id="Springboot接收参数注解介绍："><a href="#Springboot接收参数注解介绍：" class="headerlink" title="Springboot接收参数注解介绍："></a>Springboot接收参数注解介绍：</h3><h4 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h4><p>​接收url路径中的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParameterController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/monster/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pathVariable</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id,</span></span><br><span class="line"><span class="params">                               <span class="meta">@PathVariable(&quot;name&quot;)</span>String name,</span></span><br><span class="line"><span class="params">                               <span class="meta">@PathVariable</span> Map&lt;String, String&gt; map)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id:&quot;</span> + id);</span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;map:&quot;</span> + map);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h4><p>​获取http请求头中的全部或部分信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取http请求头中的host信息</span></span><br><span class="line"><span class="comment">//获取http请求头中的所有信息</span></span><br><span class="line"><span class="meta">@GetMapping</span> (<span class="string">&quot;/requestHeader&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestHeader</span><span class="params">(<span class="meta">@RequestHeader(&quot;Host&quot;)</span>String host,</span></span><br><span class="line"><span class="params">                            <span class="meta">@RequestHeader</span> Map&lt;String, String&gt;header)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;host-&quot;</span> + host);</span><br><span class="line">    System.out.println(<span class="string">&quot;header-&quot;</span> + header);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h4><h5 id="RequestAttribute"><a href="#RequestAttribute" class="headerlink" title="@RequestAttribute"></a>@RequestAttribute</h5><p>​获取request域属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/ok&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">ok</span><span class="params">(<span class="meta">@RequestAttribute(value = &quot;user&quot;,required = false)</span>String user)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user:&quot;</span> + user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="SessionAttribute"><a href="#SessionAttribute" class="headerlink" title="@SessionAttribute"></a>@SessionAttribute</h5><p>​获取session域属性，使用方法与@RequestAttribute相同</p><h4 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h4><p>​获取请求参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求信息：</span></span><br><span class="line">&lt;a href=<span class="string">&quot;/hi?name=xiaowoniu&amp;fruit=pear&amp;fruit=apple&quot;</span>&gt;<span class="meta">@RequestParam</span>-获取请求参数&lt;/a&gt;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@GetMapping(&quot;/hi&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hi</span><span class="params">(<span class="meta">@RequestParam(value=&quot;name&quot;)</span>String username,</span></span><br><span class="line"><span class="params">                 <span class="meta">@RequestParam(value = &quot;fruit&quot;)</span>List&lt;String&gt; fruits)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username-&quot;</span> + username);</span><br><span class="line">    System.out.println(<span class="string">&quot;fruits-&quot;</span> + fruits);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h4><p>​获取cookie中的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/cookie&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">cookie</span><span class="params">(<span class="meta">@CookieValue(value = &quot;cookie_key&quot;,required = false)</span>String cookie_value,        <span class="meta">@CookieValue(value = &quot;username&quot;,required = false)</span> Cookie cookie)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;cookie_value:&quot;</span> + cookie_value);</span><br><span class="line">    <span class="keyword">if</span> (cookie != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;username:&quot;</span> + cookie.getName() + <span class="string">&quot; - &quot;</span> + cookie.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h4><p>​获取  <strong>POST请求体</strong>  ，可以直接封装到javabean中(<strong>在自定义参数对象章节中teach</strong>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">postMethod</span><span class="params">(<span class="meta">@RequestBody</span> String content)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;content:&quot;</span> + content);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂参数"><a href="#复杂参数" class="headerlink" title="复杂参数"></a>复杂参数</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>controller中，如果有map、model形参，如果在方法过程中向其中放入了数据，那么request域中会保存map、model中的所有数据</p><h4 id="复杂参数应用实例"><a href="#复杂参数应用实例" class="headerlink" title="复杂参数应用实例"></a>复杂参数应用实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//响应一个复杂请求（注册请求</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/register&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">register</span><span class="params">(Map&lt;String, String&gt; map,</span></span><br><span class="line"><span class="params">                       Model model,</span></span><br><span class="line"><span class="params">                       HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="comment">//如果一个注册请求来了，我们会将注册的数据封装到map或者model中</span></span><br><span class="line">    <span class="comment">//map与model中的数据会被放入request中</span></span><br><span class="line">    map.put(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;tjy&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;job&quot;</span>, <span class="string">&quot;java engineer&quot;</span>);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;sal&quot;</span>, <span class="number">80000</span>);</span><br><span class="line">    <span class="comment">//一会再测试response的使用</span></span><br><span class="line">    <span class="comment">//演示创建 cookie，并通过response添加到浏览器</span></span><br><span class="line">    <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;123@qq.com&quot;</span>);</span><br><span class="line">    response.addCookie(cookie);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/registerOk&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/registerOk&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">registerOk</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user:&quot;</span> + request.getAttribute(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;job:&quot;</span> + request.getAttribute(<span class="string">&quot;job&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;sal:&quot;</span> + request.getAttribute(<span class="string">&quot;sal&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义对象参数-自动封装"><a href="#自定义对象参数-自动封装" class="headerlink" title="自定义对象参数-自动封装"></a>自定义对象参数-自动封装</h3><p>​SpringBoot在响应请求时，也支持自定义对象参数</p><p>​完成自动类型转换与格式化</p><p>​支持级联封装</p><p>​</p><h2 id="自定义转换器"><a href="#自定义转换器" class="headerlink" title="自定义转换器"></a>自定义转换器</h2><p>Convert</p><p>​SpringBoot在响应客户端请求时，<strong>将提交的数据封装成对象</strong>时，使用了<strong>内置的转化器</strong></p><p>​也支持自定义转换器</p><p>(用于将接收到的数据封装到javabean中时，自定义的类型转换——如：接收到了tom,123可以转换为Employee对象，tom -&gt; Employee.name; 123 -&gt; Employee.salary)  </p><p>SpringBoot在接受数据时 会对<strong>接收到的数据类型</strong>以及<strong>将要转换的数据类型</strong>寻找对应的转换器，所以如果没有自定义转换器，我们不能将目标数据类型设为自定义类型，除非你写了对应的自定义类型转换器</p><p>​<strong>写在Config包中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.springboot.config;</span><br><span class="line"><span class="keyword">import</span> com.study.springboot.bean.Car;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.convert.converter.Converter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.format.FormatterRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.ObjectUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/5/16</span></span><br><span class="line"><span class="comment"> * 11:05</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//自定义配置类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//表示WebConfig是一个配置类，启用了Lite模式</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于注入bean WebMvcConfigurer</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebMvcConfigurer <span class="title function_">webMvcConfigurer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFormatters</span><span class="params">(FormatterRegistry registry)</span> &#123;</span><br><span class="line">                <span class="comment">//1. 在这个方法中，我们添加一个自定义的转换器</span></span><br><span class="line">                <span class="comment">//2. String ——&gt; Car</span></span><br><span class="line">                <span class="comment">//3. 增加的自定义转换器会注册到Converters容器中</span></span><br><span class="line">                <span class="comment">//4. converter 底层结构是 ConcurrentHashMap 内置默认有124个转换器</span></span><br><span class="line">                registry.addConverter(<span class="keyword">new</span> <span class="title class_">Converter</span>&lt;String, Car&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Car <span class="title function_">convert</span><span class="params">(String source)</span> &#123;</span><br><span class="line">                        <span class="comment">//在此加入自定义的转换业务代码</span></span><br><span class="line">                        <span class="keyword">if</span>(!ObjectUtils.isEmpty(source))&#123;</span><br><span class="line">                            <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">                            String[] split = source.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                            car.setName(split[<span class="number">0</span>]);</span><br><span class="line">                            car.setPrice(Double.parseDouble(split[<span class="number">1</span>]));</span><br><span class="line">                            <span class="keyword">return</span> car;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Springboot使用HashMap存储所有转换器，其中 key由<strong>convert的原数据类型与目的数据类型组成</strong>，问题来了，如果对于一组数据类型，注册了多个转换器，怎么办呢？——————后来写的会把前面写的<u><strong>覆盖</strong></u>！</p><p>@Controller</p><p>对于return的String，在静态资源中寻找响应的页面</p><p>@ResponseBody</p><p>可以以json格式返回一个自定义对象</p><p>也可以直接在页面上返回String，而不会进行视图解析(可以修饰类，也可以修饰方法)</p><p>@RestController &#x3D; @Controller + @ResponseBody</p><h2 id="处理JSON格式数据"><a href="#处理JSON格式数据" class="headerlink" title="处理JSON格式数据"></a>处理JSON格式数据</h2><h2 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h2><p>​客户端发送器请求，请求中会携带一个ACCEPT字段，告诉服务端应该返回什么类型的数据</p><p>​在AbstractJackson2HttpMessageConverter.java 中， contentType字段会获取请求中的信息，从而知道应当返回什么类型的数据</p><p>🌟我们还可以对请求Header中的ACCEPT字段添加多种可以接受的数据类型，并赋予权重，这样就更加体现了内容协商的思想！</p><p>⬆️问题：postman中可以随意改变accept中的信息，那浏览器中不能修改，又该怎么办呢？</p><p>——开启 <strong>基于请求参数的内容协商功能</strong>⬇️</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">contentnegotiation:</span></span><br><span class="line">      <span class="attr">favor-parameter:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h2><p>​一种服务器渲染技术</p><p>thymeleaf页面无需服务器渲染也可以被浏览器运行，页面简洁</p><p>缺点：并不是一个高性能的引擎，适用于单体应用</p>]]></content>
      
      
      <categories>
          
          <category> Spring开发框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud</title>
      <link href="/2023/06/02/SpringCloud/"/>
      <url>/2023/06/02/SpringCloud/</url>
      
        <content type="html"><![CDATA[<p> 本博客参照了韩顺平老师的 Sping Cloud 课程讲义！</p><h1 id="1-Spring-Cloud-基本介绍"><a href="#1-Spring-Cloud-基本介绍" class="headerlink" title="1 Spring Cloud 基本介绍"></a><strong>1 Spring Cloud</strong> 基本介绍</h1><h2 id="1-1-官方文档"><a href="#1-1-官方文档" class="headerlink" title="1.1 官方文档"></a>1.1 官方文档</h2><h3 id="1-1-1"><a href="#1-1-1" class="headerlink" title="1.1.1"></a>1.1.1</h3><h3 id="地址-https-spring-io-projects-spring-cloud"><a href="#地址-https-spring-io-projects-spring-cloud" class="headerlink" title="地址**: https://spring.io/projects/spring-cloud**"></a>地址**: <a href="https://spring.io/projects/spring-cloud">https://spring.io/projects/spring-cloud</a>**</h3><h2 id="1-2-微服务引出"><a href="#1-2-微服务引出" class="headerlink" title="1.2 微服务引出"></a>1.2 微服务引出</h2><h3 id="1-没有微服务技术-是不是程序员就不能开发大型项目"><a href="#1-没有微服务技术-是不是程序员就不能开发大型项目" class="headerlink" title="1.没有微服务技术**,是不是程序员就不能开发大型项目?**"></a>1.没有微服务技术**,<strong>是不是程序员就不能开发大型项目</strong>?**</h3><p>​<strong>是可以的, 对大型项目进行模块划分,对各个模块进行实现, 模块之间更多的是以API调用完成,耦合度较高, 不利于扩展和维护。</strong></p><h3 id="2-标准的微服务解决方案-springcloud-和cloud-alibaba-出现原因和价值是什么"><a href="#2-标准的微服务解决方案-springcloud-和cloud-alibaba-出现原因和价值是什么" class="headerlink" title="2.标准的微服务解决方案(springcloud 和cloud alibaba)出现原因和价值是什么?"></a>2.标准的微服务解决方案(springcloud 和cloud alibaba)出现原因和价值是什么?</h3><p>​<strong>(1)</strong> **微服务可以根据业务不同，将一个大项目 , 分解成不同的服务(微服务，比如搜 索服务&#x2F;网关服务&#x2F;配置服务&#x2F;存储服务&#x2F;发现服务等等) **</p><p>​<strong>(2)各个服务通过分布式方式进行工 作，从而可以高效，快速，稳定的完成复杂的功能</strong></p><p>​<strong>(3) 如果小伙伴还不理解, 你也可以理解成就 将原来大项目的某些模块-&gt;抽出形成微服务-&gt;配合分布式工作方式-&gt;从而高效，快速，稳定的完成复杂业务功能。</strong></p><h3 id="3-一图胜千言"><a href="#3-一图胜千言" class="headerlink" title="3. 一图胜千言"></a>3. 一图胜千言</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519160836110.png" alt="image-20230519160836110"></p><h2 id="1-3-系统架构的演变过程"><a href="#1-3-系统架构的演变过程" class="headerlink" title="1.3 系统架构的演变过程"></a>1.3 系统架构的演变过程</h2><h3 id="1-3-1单体架构："><a href="#1-3-1单体架构：" class="headerlink" title="1.3.1单体架构："></a>1.3.1单体架构：</h3><p>​<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519161225897.png" alt="image-20230519161225897"></p><p>仅适合少量用户的情况</p><p>如果用户量大，server无法响应大量请求；大量操作数据库的语句冲垮DB</p><h3 id="1-3-2动静分离架构："><a href="#1-3-2动静分离架构：" class="headerlink" title="1.3.2动静分离架构："></a>1.3.2动静分离架构：</h3><p>​<u>静态缓存+文件存储</u></p><p>动静分离：</p><p>1.对静态资源、动态资源的请求进行分离过滤，对于静态资源的请求，直接找资源服务器响应；对于动态服务器的请求才找到应用服务器进行响应。</p><p>2.对请求的数据进行缓存，使用redis等，降低数据库等负荷。</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519162426761.png" alt="image-20230519162426761"></p><h3 id="1-3-3分布式架构："><a href="#1-3-3分布式架构：" class="headerlink" title="1.3.3分布式架构："></a>1.3.3分布式架构：</h3><p>​<u>业务拆分+负载均衡</u></p><p>​<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519163644982.png" alt="image-20230519163644982"></p><h3 id="1-3-4微服务架构："><a href="#1-3-4微服务架构：" class="headerlink" title="1.3.4微服务架构："></a>1.3.4微服务架构：</h3><p>​<u>使用Spring Cloud</u></p><p><img src="https://mp.processon.com/chart_image/id/5c77d08ae4b0628e8208c507.png" alt="点击查看图片来源"></p><ul><li><p><strong>“微服务” 一词源于 Martin Fowler 的名为Microservices 的博文，简单地说， 微服 务是系统架构上的一种设计风格，它的主旨是<u>将一个原本独立的系统拆分成多个小型服务，这些小型服务都在各自独立的进程中运行</u>，服务之间通过基于HTTP 的 RESTful API 进行通信协作。</strong></p></li><li><p><strong>被拆分成的每一个小型服务都国绕着系统中的某一项或一些耦合度较高的业务功能进行构建， 并且每个服务都维护着自身的数据存储、业务开发、自动化测试案例以及独立部署机制。 由于有轻量级的通信协作基础，所以这些微服务可以使用不同的语言来编写，这里我们使用 java。</strong></p></li></ul><h2 id="1-4-Spring-Colud全面说明"><a href="#1-4-Spring-Colud全面说明" class="headerlink" title="1.4 Spring Colud全面说明"></a>1.4 Spring Colud全面说明</h2><h4 id="1-Springcloud-来源于-Spring，是更高层次的、-架构视角的综合性大型项目，-目标旨在构建一套标准化的微服务解决方案，让架构师在使用微服务理念构建系统的时，-面对各环节的问题都可以找到相应的组件来处理"><a href="#1-Springcloud-来源于-Spring，是更高层次的、-架构视角的综合性大型项目，-目标旨在构建一套标准化的微服务解决方案，让架构师在使用微服务理念构建系统的时，-面对各环节的问题都可以找到相应的组件来处理" class="headerlink" title="1.Springcloud 来源于 Spring，是更高层次的、 架构视角的综合性大型项目， 目标旨在构建一套标准化的微服务解决方案，让架构师在使用微服务理念构建系统的时， 面对各环节的问题都可以找到相应的组件来处理"></a>1.Springcloud 来源于 Spring，是更高层次的、 架构视角的综合性大型项目， 目标旨在构建一套标准化的微服务解决方案，让架构师在使用微服务理念构建系统的时， 面对各环节的问题都可以找到相应的组件来处理</h4><h4 id="2-Spring-Cloud-是Spring-社区为微服务架构提供的一个-“全家桶”-套餐。套餐中各个组件之间的配合，可以减少在组件的选型和整合上花费的精力，可以快速构建起基础的微服务架构系统，是微服务架构的最佳落地方案"><a href="#2-Spring-Cloud-是Spring-社区为微服务架构提供的一个-“全家桶”-套餐。套餐中各个组件之间的配合，可以减少在组件的选型和整合上花费的精力，可以快速构建起基础的微服务架构系统，是微服务架构的最佳落地方案" class="headerlink" title="2.Spring Cloud 是Spring 社区为微服务架构提供的一个 “全家桶” 套餐。套餐中各个组件之间的配合，可以减少在组件的选型和整合上花费的精力，可以快速构建起基础的微服务架构系统，是微服务架构的最佳落地方案"></a>2.Spring Cloud 是Spring 社区为微服务架构提供的一个 “全家桶” 套餐。套餐中各个组件之间的配合，可以减少在组件的选型和整合上花费的精力，可以快速构建起基础的微服务架构系统，是微服务架构的最佳落地方案</h4><h4 id="3-Spirng-Cloud-天然支持-spring-Boot-有版本对应要求-，使用门槛较低"><a href="#3-Spirng-Cloud-天然支持-spring-Boot-有版本对应要求-，使用门槛较低" class="headerlink" title="3.Spirng Cloud 天然支持 spring Boot(有版本对应要求)，使用门槛较低"></a>3.Spirng Cloud 天然支持 spring Boot(有版本对应要求)，使用门槛较低</h4><h4 id="4-解决与分布式系统相关的复杂性-一网络问题，延迟开销，带宽向题，安全问题"><a href="#4-解决与分布式系统相关的复杂性-一网络问题，延迟开销，带宽向题，安全问题" class="headerlink" title="4.解决与分布式系统相关的复杂性 一网络问题，延迟开销，带宽向题，安全问题"></a>4.解决与分布式系统相关的复杂性 一网络问题，延迟开销，带宽向题，安全问题</h4><h4 id="5-处理服务发现的能力-一-服务发现允许集群中的进程和服务找到彼此并进行通信"><a href="#5-处理服务发现的能力-一-服务发现允许集群中的进程和服务找到彼此并进行通信" class="headerlink" title="5.处理服务发现的能力 一 服务发现允许集群中的进程和服务找到彼此并进行通信"></a>5.处理服务发现的能力 一 服务发现允许集群中的进程和服务找到彼此并进行通信</h4><h4 id="6-解決冗余问题-一-元余问题经常发生在分布式系统中"><a href="#6-解決冗余问题-一-元余问题经常发生在分布式系统中" class="headerlink" title="6.解決冗余问题 一 元余问题经常发生在分布式系统中"></a>6.解決冗余问题 一 元余问题经常发生在分布式系统中</h4><h4 id="7-解决负载均衡-一-改进跨多个计算资源（例如计算机集群，网络链接，中央处理单元）的工作负载分布"><a href="#7-解决负载均衡-一-改进跨多个计算资源（例如计算机集群，网络链接，中央处理单元）的工作负载分布" class="headerlink" title="7.解决负载均衡 一 改进跨多个计算资源（例如计算机集群，网络链接，中央处理单元）的工作负载分布"></a>7.解决负载均衡 一 改进跨多个计算资源（例如计算机集群，网络链接，中央处理单元）的工作负载分布</h4><h2 id="1-5-Spring-Cloud-核心组件图"><a href="#1-5-Spring-Cloud-核心组件图" class="headerlink" title="1.5 Spring Cloud 核心组件图"></a>1.5 Spring Cloud 核心组件图</h2><h3 id="1-5-1-文档-https-spring-io-projects-spring-cloud"><a href="#1-5-1-文档-https-spring-io-projects-spring-cloud" class="headerlink" title="1.5.1 文档 : https://spring.io/projects/spring-cloud"></a><strong>1.5.1</strong> 文档 <strong>: <a href="https://spring.io/projects/spring-cloud">https://spring.io/projects/spring-cloud</a></strong></h3><h3 id="1-5-2一图胜千言"><a href="#1-5-2一图胜千言" class="headerlink" title="1.5.2一图胜千言"></a>1.5.2一图胜千言</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519184405128.png" alt="image-20230519184405128"></p><h2 id="1-6-Spring-Cloud-分布式示意图"><a href="#1-6-Spring-Cloud-分布式示意图" class="headerlink" title="1.6 Spring Cloud 分布式示意图"></a>1.6 Spring Cloud 分布式示意图</h2><h3 id="1-6-1-文档-https-spring-io-microservices"><a href="#1-6-1-文档-https-spring-io-microservices" class="headerlink" title="1.6.1 文档 : https://spring.io/microservices"></a><strong>1.6.1</strong> 文档 <strong>: <a href="https://spring.io/microservices">https://spring.io/microservices</a></strong></h3><h3 id="1-6-2-一图胜千言"><a href="#1-6-2-一图胜千言" class="headerlink" title="1.6.2 一图胜千言"></a><strong>1.6.2</strong> 一图胜千言</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519185237018.png" alt="image-20230519185237018"></p><ol><li><p>Spring cloud 是微服务的落地</p></li><li><p>Spring cloud 体现了微服务的弹性设计</p></li><li><p>微服务的工作方式一般是基于分布式的。</p></li><li><p>Spring Cloud 仍然是 Spring 家族一员，可以解决微服务的分布式工作方式带来的各种问题</p></li><li><p>Spring Cloud 提供很多组件，比如 服务发现，负载均街，链路中断，分布式追踪和监控，甚至提供 API gateway 功能.</p></li></ol><h3 id="1-6-3-SpringCloud和SpringBoot版本对应关系"><a href="#1-6-3-SpringCloud和SpringBoot版本对应关系" class="headerlink" title="1.6.3 SpringCloud和SpringBoot版本对应关系"></a><strong>1.6.3 SpringCloud</strong>和<strong>SpringBoot</strong>版本对应关系</h3><p>![image-20230519190708371](&#x2F;Users&#x2F;donn&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230519190708371.png)</p><h2 id="1-7-Spring-Cloud-组件选型"><a href="#1-7-Spring-Cloud-组件选型" class="headerlink" title="1.7 Spring Cloud 组件选型"></a>1.7 Spring Cloud 组件选型</h2><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519190901580.png" alt="image-20230519190901580"></p><h1 id="2-Spring-Cloud-Alibaba-基本介绍"><a href="#2-Spring-Cloud-Alibaba-基本介绍" class="headerlink" title="2 Spring Cloud Alibaba 基本介绍"></a><strong>2 Spring Cloud Alibaba</strong> 基本介绍</h1><h2 id="2-1-官方文档"><a href="#2-1-官方文档" class="headerlink" title="2.1 官方文档"></a>2.1 官方文档</h2><h3 id="2-1-1-英文地址-https-github-com-alibaba-spring-cloud-alibaba"><a href="#2-1-1-英文地址-https-github-com-alibaba-spring-cloud-alibaba" class="headerlink" title="2.1.1 英文地址**: https://github.com/alibaba/spring-cloud-alibaba**"></a><strong>2.1.1</strong> 英文地址**: <a href="https://github.com/alibaba/spring-cloud-alibaba">https://github.com/alibaba/spring-cloud-alibaba</a>**</h3><h3 id="2-1-2英-文-地-址-中-文-文-档-https-github-com-alibaba-spring-cloud-alibaba-blob-master-README-zh-md"><a href="#2-1-2英-文-地-址-中-文-文-档-https-github-com-alibaba-spring-cloud-alibaba-blob-master-README-zh-md" class="headerlink" title="2.1.2英 文 地 址 : 中 文 文 档 : https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md"></a><strong>2.1.2</strong>英 文 地 址 <strong>:</strong> 中 文 文 档 <strong>: <a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md">https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md</a></strong></h3><h2 id="2-2-SpringCloudAlibaba是什么"><a href="#2-2-SpringCloudAlibaba是什么" class="headerlink" title="2.2 SpringCloudAlibaba是什么"></a>2.2 SpringCloudAlibaba是什么</h2><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519192136898.png" alt="image-20230519192136898"></p><h2 id="2-3-主要功能一览"><a href="#2-3-主要功能一览" class="headerlink" title="2.3 主要功能一览"></a>2.3 主要功能一览</h2><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519192150299.png" alt="image-20230519192150299"></p><h2 id="2-4-Spring-Cloud-Alibaba-核心组件"><a href="#2-4-Spring-Cloud-Alibaba-核心组件" class="headerlink" title="2.4 Spring Cloud Alibaba 核心组件"></a>2.4 Spring Cloud Alibaba 核心组件</h2><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519192202912.png" alt="image-20230519192202912"></p><h2 id="2-5-分布式微服务技术选型"><a href="#2-5-分布式微服务技术选型" class="headerlink" title="2.5: 分布式微服务技术选型"></a>2.5: 分布式微服务技术选型</h2><h3 id="•Spring-Cloud-原生组件的几大痛点"><a href="#•Spring-Cloud-原生组件的几大痛点" class="headerlink" title="•Spring Cloud 原生组件的几大痛点"></a>•Spring Cloud 原生组件的几大痛点</h3><p>1.Spring Cloud 部分组件停止维护和更新，给开发带来不便</p><p>2.Spring cioud 部分环境搭建复杂，没有完善的可视化界面，我们需要大量的二次开发和定制</p><p>3.Spring Cloud 配置复杂，难以上手</p><h3 id="•Spring-Cloud-Alibaba-的优势"><a href="#•Spring-Cloud-Alibaba-的优势" class="headerlink" title="•Spring Cloud Alibaba 的优势"></a>•Spring Cloud Alibaba 的优势</h3><ol><li>阿里使用过的组件经历了考验（高并发，高性能，高可用，性能强悍，设计合理，现在开源</li></ol><p>出来供大家使用。</p><ol start="2"><li>搭配完善的可视化界面，给开发运维带来极大的便利搭建简单，学习曲线低。</li></ol><ul><li><h3 id="分布式微服务技术选型建议"><a href="#分布式微服务技术选型建议" class="headerlink" title="分布式微服务技术选型建议"></a><strong>分布式微服务技术选型建议</strong></h3></li></ul><p>以Spring Cloud Alibaba为主，以Spring Cloud 原生组件为辅。</p><h1 id="3-微服务基础环境搭建"><a href="#3-微服务基础环境搭建" class="headerlink" title="3 微服务基础环境搭建"></a>3 微服务基础环境搭建</h1><h2 id="3-1-创建父工程-，用于聚合其它微服务模块"><a href="#3-1-创建父工程-，用于聚合其它微服务模块" class="headerlink" title="3.1 创建父工程 ，用于聚合其它微服务模块"></a>3.1 创建父工程 ，用于聚合其它微服务模块</h2><h3 id="3-1-1-需求说明-x2F-图解"><a href="#3-1-1-需求说明-x2F-图解" class="headerlink" title="3.1.1 需求说明**&#x2F;**图解"></a><strong>3.1.1</strong> 需求说明**&#x2F;**图解</h3><h3 id="3-1-2-实现步骤"><a href="#3-1-2-实现步骤" class="headerlink" title="3.1.2 实现步骤"></a><strong>3.1.2</strong> 实现步骤</h3><h4 id="3-1-2-1-创建父项目-作为聚合其它微服务模块"><a href="#3-1-2-1-创建父项目-作为聚合其它微服务模块" class="headerlink" title="3.1.2.1 创建父项目, 作为聚合其它微服务模块"></a>3.1.2.1 创建父项目, 作为聚合其它微服务模块</h4><p>###我们先创建一个父项目**,** 该父项目会去管理多个微服务模块(module)</p><p>Maven创建项目 使用webapp Maven工件</p><h4 id="3-1-2-2-项目设置"><a href="#3-1-2-2-项目设置" class="headerlink" title="3.1.2.2 项目设置"></a>3.1.2.2 项目设置</h4><ol><li></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519194056058.png" alt="image-20230519194056058"></p><ol start="2"><li></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519194231324.png" alt="image-20230519194231324"></p><p>3.父项目本身不写代码，是用来进行管理的</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519194329079.png" alt="image-20230519194329079"></p><h4 id="3-1-2-4-配置父工程-pom-xml-作为聚合其它模块"><a href="#3-1-2-4-配置父工程-pom-xml-作为聚合其它模块" class="headerlink" title="3.1.2.4 配置父工程 pom.xml, 作为聚合其它模块"></a>3.1.2.4 配置父工程 pom.xml, 作为聚合其它模块</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.study.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>e-commerce-center<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--  表明是一个父工程，用于聚合管理其他模块--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>e-commerce-center Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      老师说明: 使用最新版本的 log4j , 防止安全漏洞</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>2.17.2<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span>1.18.20<span class="tag">&lt;/<span class="name">lombok.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>8.0.31<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">druid.version</span>&gt;</span>1.1.17<span class="tag">&lt;/<span class="name">druid.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis.spring.boot.version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">mybatis.spring.boot.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  1. dependencyManagement 作用: 子模块继承后, 锁定版本,</span></span><br><span class="line"><span class="comment">  子模块不用再写 version --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      老师解读:</span></span><br><span class="line"><span class="comment">      1. type: pom 和 scope import 配合使用</span></span><br><span class="line"><span class="comment">      2. 表示 父项目的子模块, 在引入 springboot 相关依赖时 锁定版本为</span></span><br><span class="line"><span class="comment">      3. 通过 pom + import 解决 maven 单继承机制</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;druid.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-1-3-注意事项和细节"><a href="#3-1-3-注意事项和细节" class="headerlink" title="3.1.3 注意事项和细节"></a><strong>3.1.3</strong> 注意事项和细节</h3><h4 id="3-1-3-1-Maven的dependencyManagement说明"><a href="#3-1-3-1-Maven的dependencyManagement说明" class="headerlink" title="3.1.3.1 Maven的dependencyManagement说明"></a>3.1.3.1 Maven的dependencyManagement说明</h4><p>1、Maven 使用 dependencyManagement 元素来提供了一种管理依赖版本号的方式。通常在项目</p><p>packaging 为 POM，中使用dependencvManadement 元素。</p><p>2、使用pom.xml 中的dependencyManagement 元素能让所有在子项目中引用一个依赖， Maven 会沿着父子层次向上走，直到找到一个拥有dependencyManagement 元素的项目，然后它就会使用这个dependencyManagement 元素中指定的版本号。</p><p>3、好处：如果有多个子项目都号1用同一样依赖，则可以避免在每个使用的子项目里都声明一个版本号，当开级或切换到另一个版本时，只需要在顶层父容器里更新，而不需要分别在子项目的修改;另外如果某个子项目需要另外的一个版本，只需要声明version 就可。</p><p>4、dependency Management 里只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。</p><p>5、如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version 和 scope 都读取自父 pom</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230519202427190.png" alt="image-20230519202427190" style="zoom:50%;" /><p>6、如果子项目中指定了版本号，那么会使用子项目中指定的 jar 版本</p><h2 id="3-2-创建会员中心微服务模块-service-provider"><a href="#3-2-创建会员中心微服务模块-service-provider" class="headerlink" title="3.2 创建会员中心微服务模块 -service provider"></a>3.2 创建会员中心微服务模块 -service provider</h2><h3 id="3-2-1-需求说明"><a href="#3-2-1-需求说明" class="headerlink" title="3.2.1 需求说明"></a><strong>3.2.1</strong> 需求说明</h3><h4 id="1、通过浏览器可以获取会员信息-通过会员中心微服务模块"><a href="#1、通过浏览器可以获取会员信息-通过会员中心微服务模块" class="headerlink" title="1、通过浏览器可以获取会员信息**(通过会员中心微服务模块)**"></a><strong>1</strong>、通过浏览器可以获取会员信息**(<strong>通过会员中心微服务模块</strong>)**</h4><h3 id="3-2-2-思路分析"><a href="#3-2-2-思路分析" class="headerlink" title="3.2.2 思路分析"></a><strong>3.2.2</strong> 思路分析</h3><p>1、创建 Moduel &amp; 完成配置</p><p>2、创建数据库&#x2F;表</p><p>3、创建 entity-dao&#x2F;Mapper.xml-service-controller</p><p>4、完成测试</p><h3 id="3-2-3-实现步骤"><a href="#3-2-3-实现步骤" class="headerlink" title="3.2.3 实现步骤"></a><strong>3.2.3</strong> 实现步骤</h3><p>​application.yml:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">member-service-provider-10000</span><span class="comment">#名称，可以自己指定</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/booking?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">QWEASDzxc123</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span> <span class="comment">#后面 mapper 文件的位置</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.study.springcloud.entity</span>  <span class="comment">#实体类的包路径</span></span><br></pre></td></tr></table></figure><p>MemberMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.study.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>e-commerce-center<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>member-service-provider-10000<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;packaging&gt;war&lt;/packaging&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>member-service-provider-10000 Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        使用版本仲裁，从父项目中获取版本--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        springboot程序的监控系统，实现系统健康检测</span></span><br><span class="line"><span class="comment">            可以通过 http://localhost:10000/actuator 看到相关连接</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>member-service-provider-10000<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-4-🌟注意事项和细节"><a href="#3-2-4-🌟注意事项和细节" class="headerlink" title="3.2.4 🌟注意事项和细节"></a><strong>3.2.4</strong> 🌟注意事项和细节</h3><p><strong>传输javabean时</strong></p><p>1、我们的前端如果是以 <strong>json 格式</strong>来发送添加信息Member，那么我们<strong>需要使用@RequestBody</strong>,</p><p>才能将数据封裝到对应的 bean，同时保证 http 的请求头的 content-type 是对应的</p><p>2、如果前端是以 <strong>表单</strong> 或者 <strong>parameters</strong> 形式提交， 则一定不能使用@RequestBody， 才</p><p>会进行对象参数封装，同时保证http 的请求头的 content-type 是对应</p><p>3、在进行 SpringBoot 应用程序测试时，引入的 jUnit 是ore.junit.jupiter.api.Test</p><p>4、 在运行程序时，一定要确保你的 XxxxMapper.xml 文件被自动放到的 target 目录的</p><p>classes 指定目录。</p><h2 id="3-3-创建使用会员微服务模块-service-consumer"><a href="#3-3-创建使用会员微服务模块-service-consumer" class="headerlink" title="3.3 创建使用会员微服务模块 -service consumer"></a>3.3 创建使用会员微服务模块 -service consumer</h2><h3 id="3-3-1-需求说明-x2F-图解"><a href="#3-3-1-需求说明-x2F-图解" class="headerlink" title="3.3.1 需求说明**&#x2F;**图解"></a><strong>3.3.1</strong> 需求说明**&#x2F;**图解</h3><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230520114632421.png" alt="image-20230520114632421" style="zoom:30%;" /><p>-浏览器: <a href="http://localhost/member/consumer/get/1">http://localhost/member/consumer/get/1</a></p><p>-测试添加会员 : <a href="http://localhost/member/consumer/save">http://localhost/member/consumer/save</a></p><h3 id="3-3-2-思路分析-x2F-图解"><a href="#3-3-2-思路分析-x2F-图解" class="headerlink" title="3.3.2 思路分析**&#x2F;**图解"></a><strong>3.3.2</strong> 思路分析**&#x2F;**图解</h3><p>1、创建 Moduel(member-service-consumer-80) ＆ 完成配罝</p><p>2、创建 controller</p><p>3、完成测试</p><h3 id="3-3-3-实现步骤"><a href="#3-3-3-实现步骤" class="headerlink" title="3.3.3 实现步骤"></a><strong>3.3.3</strong> 实现步骤</h3><h4 id="3-3-3-1-创建-Moduel-amp-完成配置"><a href="#3-3-3-1-创建-Moduel-amp-完成配置" class="headerlink" title="3.3.3.1 创建 Moduel &amp; 完成配置"></a>3.3.3.1 创建 Moduel &amp; 完成配置</h4><h5 id="创建Moduel："><a href="#创建Moduel：" class="headerlink" title="创建Moduel："></a>创建Moduel：</h5><p>在创建Moduel后，其父工程的 pom.xml 会做相应变化，在<modules>标签中增加管理member-service-consumer-80微服务模块</p><h5 id="完成配置："><a href="#完成配置：" class="headerlink" title="完成配置："></a>完成配置：</h5><p>pom.xml &#x2F; application.yaml 可参考之前写的，取自己需要的即可。</p><h5 id="注入-RestTemplate："><a href="#注入-RestTemplate：" class="headerlink" title="注入 RestTemplate："></a>注入 RestTemplate：</h5><h6 id="RestTemplate基本介绍："><a href="#RestTemplate基本介绍：" class="headerlink" title="RestTemplate基本介绍："></a>RestTemplate基本介绍：</h6><p>​1、<strong>RestTemplate</strong> 是Spring 提供的用于访问 Rest 服务的模板类</p><p>​2、RestTerplate 提供了多种<strong>便捷访问远程 Http 服务</strong>的方法</p><p>​3、说明：可以这样理解，通过 RestTemplate，我们可以发出 http 请求(支持Restful 风格)，去调用Controller 提供的 API 接口，就像我们使用浏览器发出http 请求调用该 API接口一样。</p><p>​4、使用简单便捷</p><h6 id="官网地址："><a href="#官网地址：" class="headerlink" title="官网地址："></a>官网地址：</h6><p><a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html">https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html</a></p><h6 id="创建配置类-com-x2F-hspedu-x2F-springcloud-x2F-config-x2F-CustomizationBean-java"><a href="#创建配置类-com-x2F-hspedu-x2F-springcloud-x2F-config-x2F-CustomizationBean-java" class="headerlink" title="创建配置类: com&#x2F;hspedu&#x2F;springcloud&#x2F;config&#x2F;CustomizationBean.java"></a>创建配置类: com&#x2F;hspedu&#x2F;springcloud&#x2F;config&#x2F;CustomizationBean.java</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomizationBean</span> &#123;</span><br><span class="line">    <span class="comment">//配置注入RestTemplate bean 对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="创建-com-x2F-hspedu-x2F-springcloud-x2F-controller-x2F-MemberConsumerController-java"><a href="#创建-com-x2F-hspedu-x2F-springcloud-x2F-controller-x2F-MemberConsumerController-java" class="headerlink" title="创建:com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;MemberConsumerController.java"></a>创建:com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;MemberConsumerController.java</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberConsumerController</span> &#123;</span><br><span class="line">    <span class="comment">//url由（ip：端口）+（请求名称）两部分组成</span></span><br><span class="line">    <span class="comment">//定义member_service_provider_url</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MEMBER_SERVICE_PROVIDER_URL</span> <span class="operator">=</span></span><br><span class="line">            <span class="string">&quot;http://localhost:10000&quot;</span>;</span><br><span class="line">    <span class="comment">//方法/接口，添加member对象到数据库/表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//装配RestController</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;member/consumer/save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Member&gt; <span class="title function_">save</span><span class="params">(Member member)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;service-consumer member=&#123;&#125;&quot;</span>,member);</span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(</span><br><span class="line">                MEMBER_SERVICE_PROVIDER_URL+<span class="string">&quot;/member/save&quot;</span>,member, Result.class);</span><br><span class="line">        <span class="comment">//url,要save的对象，返回值的类型</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据id 调用服务接口，返回member对象信息</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/member/consumer/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Member&gt; <span class="title function_">getMemberById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(</span><br><span class="line">                MEMBER_SERVICE_PROVIDER_URL+<span class="string">&quot;/member/get/&quot;</span> + id,Result.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3-2-注意事项和使用细节"><a href="#3-3-3-2-注意事项和使用细节" class="headerlink" title="3.3.3.2 注意事项和使用细节"></a>3.3.3.2 注意事项和使用细节</h4><h5 id="添加会员数据库中为-null-的解决方案"><a href="#添加会员数据库中为-null-的解决方案" class="headerlink" title="添加会员数据库中为 null 的解决方案"></a>添加会员数据库中为 <strong>null</strong> 的解决方案</h5><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230520171355467.png" alt="image-20230520171355467" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230520171418620.png" alt="image-20230520171418620" style="zoom:50%;" /><h5 id="开启-Run-DashBoard"><a href="#开启-Run-DashBoard" class="headerlink" title="开启 Run DashBoard"></a>开启 <strong>Run DashBoard</strong></h5><p>​当springcloud 的服务有多个时，管理多个服务的启动使用run会不好管理，这样我们就可以使用 </p><p>RunDashboard.</p><p>找到 你的项目&#x2F;.idea&#x2F;workspace.xml 文件在其中添加下面的代码即可</p><p>添加在：原本第二行<project version="4">的下一行即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">&quot;RunDashboard&quot;</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">&quot;configurationTypes&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;SpringBootApplicationConfigurationType&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">&quot;ruleStates&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">RuleState</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ConfigurationTypeDashboardGroupingRule&quot;</span> /&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">RuleState</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">RuleState</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;StatusDashboardGroupingRule&quot;</span> /&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">RuleState</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">option</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重启项目 </p><p>​<strong>视图-工具窗口-服务</strong> 即可方便管理各个主程序！</p><h2 id="3-4-创建共用模块-供其它模块使用"><a href="#3-4-创建共用模块-供其它模块使用" class="headerlink" title="3.4 创建共用模块-供其它模块使用"></a>3.4 创建共用模块-供其它模块使用</h2><h3 id="3-4-1-需求说明-x2F-图解"><a href="#3-4-1-需求说明-x2F-图解" class="headerlink" title="3.4.1 需求说明**&#x2F;**图解"></a><strong>3.4.1</strong> 需求说明**&#x2F;**图解</h3><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230520185154382.png" alt="image-20230520185154382" style="zoom:50%;" /><h3 id="3-4-2-思路分析-x2F-图解"><a href="#3-4-2-思路分析-x2F-图解" class="headerlink" title="3.4.2 思路分析**&#x2F;**图解"></a><strong>3.4.2</strong> 思路分析**&#x2F;**图解</h3><p>1、创建 Moduel &amp; 完成配置</p><p>2、创建entity，把共用的实体类放到对应的包下</p><p>3、完成测试</p><h3 id="3-4-3-实现步骤"><a href="#3-4-3-实现步骤" class="headerlink" title="3.4.3 实现步骤"></a><strong>3.4.3</strong> 实现步骤</h3><h4 id="3-4-3-1-创建-Moduel-amp-完成配置"><a href="#3-4-3-1-创建-Moduel-amp-完成配置" class="headerlink" title="3.4.3.1 创建 Moduel &amp; 完成配置"></a>3.4.3.1 创建 Moduel &amp; 完成配置</h4><h5 id="3-4-3-1-1-创建-e-commerce-center-common-api"><a href="#3-4-3-1-1-创建-e-commerce-center-common-api" class="headerlink" title="3.4.3.1.1 创建 e_commerce_center-common-api"></a><strong>3.4.3.1.1</strong> 创建 <strong>e_commerce_center-common-api</strong></h5><h6 id="在pom-xml中提取公共依赖"><a href="#在pom-xml中提取公共依赖" class="headerlink" title="在pom.xml中提取公共依赖"></a>在pom.xml中提取公共依赖</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--老师解读&lt;optional&gt;true&lt;/optional&gt;:</span></span><br><span class="line"><span class="comment">    1. true 表示两个项目之间依赖不传递</span></span><br><span class="line"><span class="comment">    2. 小伙伴可以这里理解&lt;optional&gt;true&lt;/optional&gt;: 防止将该依赖传递到其他模块中</span></span><br><span class="line"><span class="comment">    说的再具体一点，比如 member-service-consumer-80 模块依赖了本项目,</span></span><br><span class="line"><span class="comment">    那么本项目不会把 lombok 传递给 member-service-consumer-80</span></span><br><span class="line"><span class="comment">    3. 不设置 optional 或者 optional 是 false，表示传递依赖</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="抽取共用-API-x2F-类"><a href="#抽取共用-API-x2F-类" class="headerlink" title="抽取共用 API&#x2F;类"></a>抽取共用 API&#x2F;类</h6><p>​写入公共的entity</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230520191145475.png" alt="image-20230520191145475" style="zoom:55%;" /><h6 id="使用-Maven-打包成-jar"><a href="#使用-Maven-打包成-jar" class="headerlink" title="使用 Maven 打包成 jar"></a>使用 Maven 打包成 jar</h6><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230520192050410.png" alt="image-20230520192050410" style="zoom:50%;" /><p>会在test目录中生成对应jar包</p><h6 id="工程重构"><a href="#工程重构" class="headerlink" title="工程重构"></a>工程重构</h6><p>​1.在 <strong>member-service-consumer-80</strong> 引入 <strong>e_commerce_center-common-api-1.0-SNAPSHOT.jar</strong></p><p>​删除原来的 <strong>entity</strong> 包</p><p>​修改 <strong>pom.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入 e_commerce_center-common-api --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hspedu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>e_commerce_center-common-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样就完成了！</p><h1 id="4-SpringCloud-Eureka-服务注册中心"><a href="#4-SpringCloud-Eureka-服务注册中心" class="headerlink" title="4 SpringCloud Eureka 服务注册中心"></a>4 SpringCloud Eureka 服务注册中心</h1><h2 id="4-1-Eureka介绍"><a href="#4-1-Eureka介绍" class="headerlink" title="4.1 Eureka介绍"></a>4.1 Eureka介绍</h2><h3 id="4-1-1-学-Eureka-前的说明"><a href="#4-1-1-学-Eureka-前的说明" class="headerlink" title="4.1.1 学 Eureka 前的说明"></a><strong>4.1.1</strong> 学 <strong>Eureka</strong> 前的说明</h3><h4 id="1、Spring-Cloud-组件选型图"><a href="#1、Spring-Cloud-组件选型图" class="headerlink" title="1、Spring Cloud 组件选型图"></a><strong>1</strong>、Spring Cloud 组件选型图</h4><p>![image-20230519190901580](&#x2F;Users&#x2F;donn&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230519190901580.png)</p><h4 id="2、从上图可以看出，目前主流的服务注册-amp-发现的组件是-Nacos，-但是-Eureka-作为一个老牌经典的-服务注册-amp-发现技术还是有必要学习一下，原因："><a href="#2、从上图可以看出，目前主流的服务注册-amp-发现的组件是-Nacos，-但是-Eureka-作为一个老牌经典的-服务注册-amp-发现技术还是有必要学习一下，原因：" class="headerlink" title="2、从上图可以看出，目前主流的服务注册&amp;发现的组件是 Nacos， 但是 Eureka 作为一个老牌经典的 服务注册&amp;发现技术还是有必要学习一下，原因："></a>2、从上图可以看出，目前主流的服务注册&amp;发现的组件是 Nacos， 但是 Eureka 作为一个老牌经典的 服务注册&amp;发现技术还是有必要学习一下，原因：</h4><p>（1） 一些早期的分布式 微服务项目使用的是 Eureka， 小伙伴在工作中，完全有可能遇到这种情况。</p><p>（2） 后期的服务注册&amp;发现组件&#x2F;技术，都参考了 Eureka 设计和理念，学习了Eureka 后，我们上手Nacos容易很多，而且理解的更深刻。</p><h3 id="4-1-2-当前项目架构问题分析-引出-Eureka"><a href="#4-1-2-当前项目架构问题分析-引出-Eureka" class="headerlink" title="4.1.2 当前项目架构问题分析 **-**引出 Eureka"></a><strong>4.1.2</strong> 当前项目架构问题分析 **-**引出 Eureka</h3><p>一图胜千言</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230521192330770.png" alt="image-20230521192330770"></p><p>1.在企业级项目中，服务消费访问请求会存在高并发 (一个服务提供模块可能无法承受)</p><p>2.如果只有一个会员中心-提供服务模块，可用性差 (如果只有一个服务提供模块，如果故障，系统将无法使用，可用性差)</p><p>3.所以，会员中心提供服务往往是一个集群，也就是说会有<strong>多个会员中心提供服务微服务模块</strong> ( 高可用 )  </p><p>4.那么这个时候，就存在一个问题：服务消费方，怎么去发现可以使用的服务 </p><p>5,当服务消费方，发现了可以使用的服务后(可能是多个，又存在一个问题：到底调用 A服务，还是B服务？ 这就引出了服务注册和负载均衡)</p><p>6.Eureka 就可以解决上述问题</p><h3 id="4-1-3-引入-Eureka-项目架构"><a href="#4-1-3-引入-Eureka-项目架构" class="headerlink" title="4.1.3 引入 Eureka 项目架构"></a><strong>4.1.3</strong> 引入 <strong>Eureka</strong> 项目架构</h3><h4 id="一图胜千言"><a href="#一图胜千言" class="headerlink" title="一图胜千言"></a>一图胜千言</h4><p>​<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230521193144050.png" alt="image-20230521193144050"></p><ol><li><p>会员中心-是提供服务的模块，在项目中，会做成集群，提供高可用</p></li><li><p>Eureka Server 有必要的话，也可以做成集群</p></li><li><p>Eureka 包含两个组件：Eureka Server和 Eureka Client</p></li><li><p>Eureka Server 提供注册服务，各个微服务节点通过配置启动后，会在 Eureka Server中迸行注册，这样 EurekaServer 中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。</p></li><li><p>Euretka Client 通过注册中心进行访问，是一个Java 客户端，用于简化 Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin） 负载算法的负载均衡器。在应用启动后，将会向 Eureka Server 发送心跳（默认周期为 30秒)。如果 Eureka Server 在多个心跳周期内没有接收到某个节点的心跳，EurekaServer 将会从服务注册表中把这个服务节点移除(默认90秒)</p></li></ol><h3 id="4-1-4-服务治理介绍"><a href="#4-1-4-服务治理介绍" class="headerlink" title="4.1.4 服务治理介绍"></a><strong>4.1.4</strong> 服务治理介绍</h3><h4 id="4-1-4-1-Eureka实现服务治理"><a href="#4-1-4-1-Eureka实现服务治理" class="headerlink" title="4.1.4.1 Eureka实现服务治理"></a>4.1.4.1 Eureka实现服务治理</h4><h4 id="4-1-4-2-在传统的-rpc-远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理困难，所以-需要治理服务之间依赖关系"><a href="#4-1-4-2-在传统的-rpc-远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理困难，所以-需要治理服务之间依赖关系" class="headerlink" title="4.1.4.2 在传统的 rpc 远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理困难，所以 需要治理服务之间依赖关系"></a>4.1.4.2 在传统的 rpc 远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理困难，所以 需要治理服务之间依赖关系</h4><h4 id="4-1-4-3-服务治理实现服务调用、负载均衡、容错等，实现服务发现与注册。"><a href="#4-1-4-3-服务治理实现服务调用、负载均衡、容错等，实现服务发现与注册。" class="headerlink" title="4.1.4.3 服务治理实现服务调用、负载均衡、容错等，实现服务发现与注册。"></a>4.1.4.3 服务治理实现服务调用、负载均衡、容错等，实现服务发现与注册。</h4><h4 id="4-1-4-4-二说分布式开发-https-jingyan-baidu-com-article-46650658def479f549e5f83e-html"><a href="#4-1-4-4-二说分布式开发-https-jingyan-baidu-com-article-46650658def479f549e5f83e-html" class="headerlink" title="4.1.4.4 二说分布式开发: https://jingyan.baidu.com/article/46650658def479f549e5f83e.html"></a>4.1.4.4 二说分布式开发: <a href="https://jingyan.baidu.com/article/46650658def479f549e5f83e.html">https://jingyan.baidu.com/article/46650658def479f549e5f83e.html</a></h4><h3 id="4-1-5-服务注册和发现"><a href="#4-1-5-服务注册和发现" class="headerlink" title="4.1.5 服务注册和发现"></a><strong>4.1.5</strong> 服务注册和发现</h3><p>Eureka采用了CS [client-server-java基础我们讲过一个多人聊天项目] 的设计架构，Eureka Server 作为服务注册功能的服务器，它是服务注册中心。</p><p>系统中的其他微服务，<strong>使用 Eureka的客户端连接到 Eureka Server</strong>并维持心跳连接，通过 Eureka Server 来监控系统中各个微服务是否正常运行。</p><p>在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息 比如 服务地址通讯地址等以别名方式注册到注册中心上。</p><p>服务消费者或者服务提供者，以服务别名的方式去注册中心上获取到实际的服务提供者通讯地址，然后通过RPC调用服务。</p><h2 id="4-2-创建单机-Eureka-Server-注册中心"><a href="#4-2-创建单机-Eureka-Server-注册中心" class="headerlink" title="4.2 创建单机 Eureka Server-注册中心"></a>4.2 创建单机 Eureka Server-注册中心</h2><h3 id="4-2-1-需求说明-x2F-图解"><a href="#4-2-1-需求说明-x2F-图解" class="headerlink" title="4.2.1 需求说明**&#x2F;**图解"></a><strong>4.2.1</strong> 需求说明**&#x2F;**图解</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230522104534270.png" alt="image-20230522104534270"></p><h3 id="4-2-2-实现步骤"><a href="#4-2-2-实现步骤" class="headerlink" title="4.2.2 实现步骤"></a><strong>4.2.2</strong> 实现步骤</h3><h4 id="4-2-2-1-创建-Moduel-amp-完成配置"><a href="#4-2-2-1-创建-Moduel-amp-完成配置" class="headerlink" title="4.2.2.1 创建 Moduel &amp; 完成配置"></a>4.2.2.1 创建 Moduel &amp; 完成配置</h4><h5 id="4-2-2-1-1-创建-e-commerce-eureka-server-9001-微服务模块-作为注册中心"><a href="#4-2-2-1-1-创建-e-commerce-eureka-server-9001-微服务模块-作为注册中心" class="headerlink" title="4.2.2.1.1 创建 e-commerce-eureka-server-9001 微服务模块**[**作为注册中心]"></a>4.2.2.1.1 创建 <strong>e-commerce-eureka-server-9001</strong> 微服务模块**[**作为注册中心]</h5><h6 id="创建-module"><a href="#创建-module" class="headerlink" title="创建 module"></a>创建 <strong>module</strong></h6><h6 id="4-2-2-1-2-修改-e-commerce-eureka-server-9001-的-pom-xml-加入依赖"><a href="#4-2-2-1-2-修改-e-commerce-eureka-server-9001-的-pom-xml-加入依赖" class="headerlink" title="4.2.2.1.2 修改 e-commerce-eureka-server-9001 的 pom.xml , 加入依赖"></a>4.2.2.1.2 修改 <strong>e-commerce-eureka-server-9001</strong> 的 <strong>pom.xml ,</strong> 加入依赖</h6><h6 id="4-2-2-1-3-创建-resources-x2F-application-yml"><a href="#4-2-2-1-3-创建-resources-x2F-application-yml" class="headerlink" title="4.2.2.1.3 创建 resources&#x2F;application.yml"></a><strong>4.2.2.1.3</strong> 创建 <strong>resources&#x2F;application.yml</strong></h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9001</span></span><br><span class="line"><span class="comment"># 配置eureka-server</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span> <span class="comment">#服务实例名</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">#表示自己就是注册中心，作用是维护注册服务实例，不需要去检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><h6 id="4-2-2-1-4-创建主启动类-com-x2F-hspedu-x2F-springcloud-x2F-EurekaApplication-java"><a href="#4-2-2-1-4-创建主启动类-com-x2F-hspedu-x2F-springcloud-x2F-EurekaApplication-java" class="headerlink" title="4.2.2.1.4 创建主启动类 com&#x2F;hspedu&#x2F;springcloud&#x2F;EurekaApplication.java"></a><strong>4.2.2.1.4</strong> 创建主启动类 <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;EurekaApplication.java</strong></h6><p>记得添加@EnableEurekaServer，表示该程序作为EurekaServer</p><h3 id="4-2-3-将-member-service-provider-10000-作-为-EurekaClient-注-册-到-e-commerce-eureka-server-9001-成为服务提供者"><a href="#4-2-3-将-member-service-provider-10000-作-为-EurekaClient-注-册-到-e-commerce-eureka-server-9001-成为服务提供者" class="headerlink" title="4.2.3 将 member-service-provider-10000 作 为 EurekaClient 注 册 到 e-commerce-eureka-server-9001 成为服务提供者"></a><strong>4.2.3</strong> 将 <strong>member-service-provider-10000</strong> 作 为 <strong>EurekaClient</strong> 注 册 到 <strong>e-commerce-eureka-server-9001</strong> 成为服务提供者</h3><h4 id="4-2-3-1-架构示意图"><a href="#4-2-3-1-架构示意图" class="headerlink" title="4.2.3.1 架构示意图"></a>4.2.3.1 架构示意图</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230522124755649.png" alt="image-20230522124755649" style="zoom:50%;" /><h4 id="4-2-3-2-修改-member-service-provider-10000-的-pom-xml"><a href="#4-2-3-2-修改-member-service-provider-10000-的-pom-xml" class="headerlink" title="4.2.3.2 修改 member-service-provider-10000 的 pom.xml"></a>4.2.3.2 修改 member-service-provider-10000 的 pom.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--       引入eureka-client场景启动器starter--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-2-3-3-修改-member-service-provider-10000-的-resources-x2F-application-yml"><a href="#4-2-3-3-修改-member-service-provider-10000-的-resources-x2F-application-yml" class="headerlink" title="4.2.3.3 修改 member-service-provider-10000 的 resources&#x2F;application.yml"></a>4.2.3.3 修改 member-service-provider-10000 的 resources&#x2F;application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">member-service-provider-10000</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/e_commerce_center_db?serverTimezone=GMT%2B8&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">QWEASDzxc123</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.study.springcloud.entity</span></span><br><span class="line"><span class="comment">#配置eureka-client</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span> <span class="comment">#将自己注册到Eureka-server</span></span><br><span class="line">    <span class="comment">#表示从Eureka-server抓取注册信息</span></span><br><span class="line">    <span class="comment">#如果是单节点，可以不配置；</span></span><br><span class="line">    <span class="comment">#但是provider是一个集群，则必须将此项配置为true，这样才能配合Ribbon使用负载均衡功能</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 表示将自己注册到哪个eureka-server</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:9001/eureka</span></span><br></pre></td></tr></table></figure><h4 id="4-2-3-4-修改-member-service-provider-10000-的-com-x2F-hspedu-x2F-springcloud-x2F-MemberApplication-java"><a href="#4-2-3-4-修改-member-service-provider-10000-的-com-x2F-hspedu-x2F-springcloud-x2F-MemberApplication-java" class="headerlink" title="4.2.3.4 修改 member-service-provider-10000 的 com&#x2F;hspedu&#x2F;springcloud&#x2F;MemberApplication.java"></a>4.2.3.4 修改 member-service-provider-10000 的 com&#x2F;hspedu&#x2F;springcloud&#x2F;MemberApplication.java</h4><p>添加注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@EnableEurekaClient,将该程序标识为Eureka-client</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br></pre></td></tr></table></figure><h4 id="4-2-3-5-完成测试"><a href="#4-2-3-5-完成测试" class="headerlink" title="4.2.3.5 完成测试"></a>4.2.3.5 完成测试</h4><h5 id="4-2-3-5-1-启动-e-commerce-eureka-server-9001"><a href="#4-2-3-5-1-启动-e-commerce-eureka-server-9001" class="headerlink" title="4.2.3.5.1 启动 **e-commerce-eureka-server-9001 **"></a><strong>4.2.3.5.1</strong> 启动 **e-commerce-eureka-server-9001 **</h5><h5 id="4-2-3-5-2-启动-member-service-provider-10000"><a href="#4-2-3-5-2-启动-member-service-provider-10000" class="headerlink" title="4.2.3.5.2 启动 **member-service-provider-10000 **"></a><strong>4.2.3.5.2</strong> 启动 **member-service-provider-10000 **</h5><h5 id="4-2-3-5-3-浏览器-http-localhost-9001"><a href="#4-2-3-5-3-浏览器-http-localhost-9001" class="headerlink" title="4.2.3.5.3 浏览器**: http://localhost:9001**"></a><strong>4.2.3.5.3</strong> 浏览器**: <a href="http://localhost:9001/">http://localhost:9001</a>**</h5><h5 id="4-2-3-5-4-微服务注册名配置说明"><a href="#4-2-3-5-4-微服务注册名配置说明" class="headerlink" title="4.2.3.5.4 微服务注册名配置说明"></a><strong>4.2.3.5.4</strong> 微服务注册名配置说明</h5><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230522130616526.png" alt="image-20230522130616526"></p><h3 id="4-2-4-配-置-member-service-consumer-80-作-为-EurekaClient，-可-以-拉取-x2F-获-取e-commerce-eureka-server-9001-提供的服务信息"><a href="#4-2-4-配-置-member-service-consumer-80-作-为-EurekaClient，-可-以-拉取-x2F-获-取e-commerce-eureka-server-9001-提供的服务信息" class="headerlink" title="4.2.4 配 置 member-service-consumer-80 作 为 EurekaClient， 可 以 拉取 &#x2F; 获 取e-commerce-eureka-server-9001 提供的服务信息"></a><strong>4.2.4</strong> 配 置 <strong>member-service-consumer-80</strong> 作 为 <strong>EurekaClient</strong>， 可 以 拉取 <strong>&#x2F;</strong> 获 取e-commerce-eureka-server-9001 提供的服务信息</h3><h4 id="4-2-4-1-架构示意图"><a href="#4-2-4-1-架构示意图" class="headerlink" title="4.2.4.1 架构示意图"></a>4.2.4.1 架构示意图</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230522202407897.png" alt="image-20230522202407897"></p><h4 id="4-2-4-2-修改-pom-xml"><a href="#4-2-4-2-修改-pom-xml" class="headerlink" title="4.2.4.2 修改 pom.xml"></a>4.2.4.2 修改 pom.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--       引入eureka-client场景启动器starter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-2-4-3-修改-application-yml"><a href="#4-2-4-3-修改-application-yml" class="headerlink" title="4.2.4.3 修改 application.yml"></a>4.2.4.3 修改 application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">在原本的配置在增加：</span></span><br><span class="line"><span class="comment">#配置eureka-client</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span> <span class="comment">#将自己注册到Eureka-server</span></span><br><span class="line">    <span class="comment">#表示从Eureka-server抓取注册信息</span></span><br><span class="line">    <span class="comment">#如果是单节点，可以不配置；</span></span><br><span class="line">    <span class="comment">#但是provider是一个集群，则必须将此项配置为true，这样才能配合Ribbon使用负载均衡功能</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 表示将自己注册到哪个eureka-server</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:9001/eureka</span></span><br></pre></td></tr></table></figure><h4 id="4-2-4-4-修改-MemberConsumerApplication-java"><a href="#4-2-4-4-修改-MemberConsumerApplication-java" class="headerlink" title="4.2.4.4 修改 MemberConsumerApplication.java"></a>4.2.4.4 修改 MemberConsumerApplication.java</h4><p>添加注解：@EnableEurekaClient             将该程序标识为Eureka-client</p><h4 id="4-2-4-5-完成测试"><a href="#4-2-4-5-完成测试" class="headerlink" title="4.2.4.5 完成测试"></a>4.2.4.5 完成测试</h4><h5 id="4-2-4-5-1-启动-e-commerce-eureka-server-9001"><a href="#4-2-4-5-1-启动-e-commerce-eureka-server-9001" class="headerlink" title="4.2.4.5.1 启动 **e-commerce-eureka-server-9001 **"></a><strong>4.2.4.5.1</strong> 启动 **e-commerce-eureka-server-9001 **</h5><h5 id="4-2-4-5-2-启动-member-service-consumer-80"><a href="#4-2-4-5-2-启动-member-service-consumer-80" class="headerlink" title="4.2.4.5.2 启动 **member-service-consumer-80 **"></a><strong>4.2.4.5.2</strong> 启动 **member-service-consumer-80 **</h5><h5 id="4-2-4-5-3-浏览器-http-localhost-9001"><a href="#4-2-4-5-3-浏览器-http-localhost-9001" class="headerlink" title="4.2.4.5.3 浏览器**: http://localhost:9001**"></a><strong>4.2.4.5.3</strong> 浏览器**: <a href="http://localhost:9001/">http://localhost:9001</a>**</h5><h3 id="4-2-5-Service-Consumer-、Service-Provider-、EurekaServer-的维护机制"><a href="#4-2-5-Service-Consumer-、Service-Provider-、EurekaServer-的维护机制" class="headerlink" title="4.2.5 Service Consumer 、Service Provider 、EurekaServer 的维护机制"></a><strong>4.2.5 Service Consumer</strong> 、<strong>Service Provider</strong> 、<strong>EurekaServer</strong> 的维护机制</h3><p>EurekaServer中维护了服务信息——一个键值对：key是<strong>服务名</strong>，value是 <strong>调用服务的地址</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230526170804321.png" alt="image-20230526170804321"></p><h3 id="4-2-6-Eureka自我保护模式"><a href="#4-2-6-Eureka自我保护模式" class="headerlink" title="4.2.6 Eureka自我保护模式"></a><strong>4.2.6 Eureka</strong>自我保护模式</h3><h4 id="4-2-6-1-自我保护模式理论"><a href="#4-2-6-1-自我保护模式理论" class="headerlink" title="4.2.6.1 自我保护模式理论"></a>4.2.6.1 自我保护模式理论</h4><ol><li><p>在默认情况下， <strong>Eureka 启动了自我保护模式</strong></p></li><li><p>自我保证机制&#x2F;模式说明</p><ul><li><p>默认情況下Eurekaclient定时向EurekaServer端发送心跳包。</p></li><li><p>如果Eureka在server端在一定时间内（默认90秒）没有收到Eurekaclient发送心跳包，便会直接从服务注册列表中剔除该服务。</p></li><li><p>如果Eureka 开启了自我保护模式&#x2F;机制，那么在短时间 (90秒中）内丢失了大量的服务实例心跳，这时候EurekaServer会开启自我保护机制，不会剔除该服务（该现象可能出现在如果网络不通或者阻鑫) 因为客户端还能正常发送心跳，只是网络延迟问题，而保护机制是为了解决此问题而产生的。</p></li></ul></li><li><p>自我保护是属于 <strong>CAP</strong> 里面的 AP 分支， 保证高可用和分区容错性。(cap解读：<a href="https://blog.csdn.net/wangliangluang/article/details/120626014">https://blog.csdn.net/wangliangluang/article/details/120626014</a>)</p></li><li><p>自我保护模式是—种<strong>应对网络异常的安全保护措施</strong>。它的架构哲学是宁可同时保留所有微服务(健康的微服务和不健康的微服务都会保留)也不盲目注销任何健康的微服 务。使用自我保护模式，可以让 Eureka 集群更加的健壮、稳定。</p></li><li><p>测试：</p><p>……</p></li></ol><h2 id="4-3-搭建-EurekaServer-集群-实现负载均衡-amp-故障容错"><a href="#4-3-搭建-EurekaServer-集群-实现负载均衡-amp-故障容错" class="headerlink" title="4.3 搭建 EurekaServer 集群- 实现负载均衡&amp;故障容错"></a>4.3 搭建 EurekaServer 集群- 实现负载均衡&amp;故障容错</h2><h3 id="4-3-1-为什么需要集群-Eureka-Server"><a href="#4-3-1-为什么需要集群-Eureka-Server" class="headerlink" title="4.3.1 为什么需要集群 Eureka Server"></a><strong>4.3.1</strong> 为什么需要集群 Eureka Server</h3><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230528115636389.png" alt="image-20230528115636389" style="zoom:50%;" /><ol><li><p>微服务 RPC 远程服务调用最核心的是实现高可用</p></li><li><p>如果注册中心只有1个，它出故障，会导致整个服务环境不可用</p></li><li><p>解决办法：搭建 <strong>Eureka 注册中心集群</strong>，<strong>实现负载均衡+故障容错</strong></p></li></ol><h3 id="4-3-2需求分析-x2F-图解"><a href="#4-3-2需求分析-x2F-图解" class="headerlink" title="4.3.2需求分析**&#x2F;**图解"></a>4.3.2需求分析**&#x2F;**图解</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230528120007909.png" alt="image-20230528120007909"></p><h3 id="4-3-3-搭建-Eureka-Server-集群"><a href="#4-3-3-搭建-Eureka-Server-集群" class="headerlink" title="4.3.3 搭建 Eureka Server 集群"></a><strong>4.3.3</strong> 搭建 <strong>Eureka Server</strong> 集群</h3><h4 id="4-3-3-1-创建-e-commerce-eureka-server-9002-微服务模块-作为注册中心"><a href="#4-3-3-1-创建-e-commerce-eureka-server-9002-微服务模块-作为注册中心" class="headerlink" title="4.3.3.1 创建 e-commerce-eureka-server-9002 微服务模块[作为注册中心]"></a>4.3.3.1 创建 e-commerce-eureka-server-9002 微服务模块[作为注册中心]</h4><h5 id="4-3-3-1-1-创建步骤参考-e-commerce-eureka-server-9001"><a href="#4-3-3-1-1-创建步骤参考-e-commerce-eureka-server-9001" class="headerlink" title="4.3.3.1.1 创建步骤参考 e-commerce-eureka-server-9001"></a><strong>4.3.3.1.1</strong> 创建步骤参考 <strong>e-commerce-eureka-server-9001</strong></h5><h5 id="4-3-3-1-2-修改-pom-xml-加入依赖"><a href="#4-3-3-1-2-修改-pom-xml-加入依赖" class="headerlink" title="4.3.3.1.2 修改 pom.xml , 加入依赖"></a><strong>4.3.3.1.2</strong> 修改 <strong>pom.xml ,</strong> 加入依赖</h5><h5 id="4-3-3-1-3-创建-resources-x2F-application-yml"><a href="#4-3-3-1-3-创建-resources-x2F-application-yml" class="headerlink" title="4.3.3.1.3 创建 resources&#x2F;application.yml"></a><strong>4.3.3.1.3</strong> 创建 <strong>resources&#x2F;application.yml</strong></h5><h5 id="4-3-3-1-4-创建主启动类-EurekaApplication9002-java"><a href="#4-3-3-1-4-创建主启动类-EurekaApplication9002-java" class="headerlink" title="4.3.3.1.4 创建主启动类 EurekaApplication9002.java"></a><strong>4.3.3.1.4</strong> 创建主启动类 <strong>EurekaApplication9002.java</strong></h5><h4 id="4-3-3-2-修改-e-commerce-eureka-server-9001-微服务模块"><a href="#4-3-3-2-修改-e-commerce-eureka-server-9001-微服务模块" class="headerlink" title="4.3.3.2 修改 e-commerce-eureka-server-9001 微服务模块"></a>4.3.3.2 修改 e-commerce-eureka-server-9001 微服务模块</h4><h5 id="4-3-3-2-1-修改-resources-x2F-application-yml"><a href="#4-3-3-2-1-修改-resources-x2F-application-yml" class="headerlink" title="4.3.3.2.1 修改 resources&#x2F;application.yml"></a><strong>4.3.3.2.1</strong> 修改 <strong>resources&#x2F;application.yml</strong></h5><h5 id="4-3-3-2-2-修改主启动类名为-EurekaApplication9001-java"><a href="#4-3-3-2-2-修改主启动类名为-EurekaApplication9001-java" class="headerlink" title="4.3.3.2.2 修改主启动类名为 EurekaApplication9001.java"></a><strong>4.3.3.2.2</strong> 修改主启动类名为 <strong>EurekaApplication9001.java</strong></h5><h4 id="4-3-3-3-修改-hosts-文件"><a href="#4-3-3-3-修改-hosts-文件" class="headerlink" title="4.3.3.3 修改 hosts 文件"></a>4.3.3.3 修改 hosts 文件</h4><p>​域名转ip地址：先找本机的host文件，hosts文件中没有才去DNS服务器寻找，</p><p>​现在我们需要访问eureka9001.com这样的形式，就需要自行在本机的hosts文件添加键值对实现域名-&gt;ip</p><p>&#x2F;private&#x2F;etc&#x2F;hosts复制出来，修改，覆盖原来的文件即可完成修改</p><p>​在hosts文件中添加内容：</p><p>​<strong>#eureka</strong> 主机名和 <strong>ip</strong> 映射 </p><p>​**127.0.0.1 eureka9001.com **</p><p>​<strong>127.0.0.1 eureka9002.com</strong></p><h4 id="4-3-3-4-完成测试"><a href="#4-3-3-4-完成测试" class="headerlink" title="4.3.3.4 完成测试"></a>4.3.3.4 完成测试</h4><h5 id="4-3-3-4-1-启动-e-commerce-eureka-server-9001"><a href="#4-3-3-4-1-启动-e-commerce-eureka-server-9001" class="headerlink" title="4.3.3.4.1 启动 **e-commerce-eureka-server-9001"></a><strong>4.3.3.4.1</strong> 启动 **e-commerce-eureka-server-9001</h5><h5 id="4-3-3-4-2-启动-e-commerce-eureka-server-9002"><a href="#4-3-3-4-2-启动-e-commerce-eureka-server-9002" class="headerlink" title="4.3.3.4.2** 启动 **e-commerce-eureka-server-9002"></a>4.3.3.4.2** 启动 **e-commerce-eureka-server-9002</h5><h5 id="4-3-3-4-3-浏览器-http-eureka9001-com-9001-浏览器-http-eureka9002-com-9002"><a href="#4-3-3-4-3-浏览器-http-eureka9001-com-9001-浏览器-http-eureka9002-com-9002" class="headerlink" title="4.3.3.4.3** 浏览器**: http://eureka9001.com:9001** 浏览器**: http://eureka9002.com:9002**"></a>4.3.3.4.3** 浏览器**: <a href="http://eureka9001.com:9001/">http://eureka9001.com:9001</a>** 浏览器**: <a href="http://eureka9002.com:9002/">http://eureka9002.com:9002</a>**</h5><h4 id="4-3-3-5-将-member-service-provider-10000-注册到-EurekaServer-集群-目前-2-台"><a href="#4-3-3-5-将-member-service-provider-10000-注册到-EurekaServer-集群-目前-2-台" class="headerlink" title="4.3.3.5 将 member-service-provider-10000 注册到 EurekaServer 集群(目前 2 台)"></a>4.3.3.5 将 member-service-provider-10000 注册到 EurekaServer 集群(目前 2 台)</h4><h5 id="4-3-3-5-1-修改-resources-x2F-application-yml"><a href="#4-3-3-5-1-修改-resources-x2F-application-yml" class="headerlink" title="4.3.3.5.1 修改 resources&#x2F;application.yml"></a><strong>4.3.3.5.1</strong> 修改 <strong>resources&#x2F;application.yml</strong></h5><p>‘’’</p><p>defaultZone: <a href="http://eureka9001.com:9001/eureka">http://eureka9001.com:9001/eureka</a>, <a href="http://eureka9002.com:9002/eureka">http://eureka9002.com:9002/eureka</a></p><p>*#*表示将自己注册到哪个 <em>eurekaServer</em></p><p>将本微服务注册到多个 <em>eurekaServer,</em> 使用逗号隔开</p><p>‘’’</p><h5 id="4-3-3-5-2-完成测试"><a href="#4-3-3-5-2-完成测试" class="headerlink" title="4.3.3.5.2 完成测试"></a><strong>4.3.3.5.2</strong> 完成测试</h5><p><strong>1.</strong> <strong>启动</strong> <strong>e-commerce-eureka-server-9001</strong> <strong>和</strong> <strong>e-commerce-eureka-server-9002</strong></p><p><strong>2. 启动</strong> <strong>member-service-provider-10000<br>3.</strong> <strong>观察</strong> <strong>member-service-provider-10000</strong> <strong>是否注册到</strong> <strong>Eureka</strong> <strong>集群</strong>前 <strong>2</strong> <strong>台</strong>)</p><h4 id="4-3-3-6-将-member-service-consumer-80-注册到-EurekaServer-集群-目前-2-台"><a href="#4-3-3-6-将-member-service-consumer-80-注册到-EurekaServer-集群-目前-2-台" class="headerlink" title="4.3.3.6 将 member-service-consumer-80 注册到 EurekaServer 集群(目前 2 台)"></a>4.3.3.6 将 member-service-consumer-80 注册到 EurekaServer 集群(目前 2 台)</h4><h5 id="4-3-3-6-1-修改-resources-x2F-application-yml"><a href="#4-3-3-6-1-修改-resources-x2F-application-yml" class="headerlink" title="4.3.3.6.1 修改 resources&#x2F;application.yml"></a><strong>4.3.3.6.1</strong> 修改 <strong>resources&#x2F;application.yml</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaultZone: http://eureka9001.com:9001/eureka,http://eureka9002.com:9002/eureka</span><br></pre></td></tr></table></figure><h5 id="4-3-3-6-2-完成测试"><a href="#4-3-3-6-2-完成测试" class="headerlink" title="4.3.3.6.2 完成测试"></a><strong>4.3.3.6.2</strong> 完成测试</h5><p><strong>1.</strong> <strong>启动</strong> <strong>e-commerce-eureka-server-9001</strong> <strong>和</strong> <strong>e-commerce-eureka-server-9002</strong><br><strong>2.</strong> <strong>启动</strong> <strong>member-service-consumer-80<br>3.</strong> <strong>观察</strong> <strong>member-service-consumer-80</strong> <strong>是否注册到</strong> <strong>Eureka</strong> <strong>集群</strong>(<strong>目前</strong> <strong>2</strong> <strong>台</strong>)</p><h3 id="4-3-4-搭建会员中心服务提供方-集群"><a href="#4-3-4-搭建会员中心服务提供方-集群" class="headerlink" title="4.3.4 搭建会员中心服务提供方**-**集群"></a><strong>4.3.4</strong> 搭建会员中心服务提供方**-**集群</h3><h4 id="4-3-4-1-架构示意图"><a href="#4-3-4-1-架构示意图" class="headerlink" title="4.3.4.1 架构示意图"></a>4.3.4.1 架构示意图</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230528140357541.png" alt="image-20230528140357541"></p><h4 id="4-3-4-2-创建member-service-provider-10002"><a href="#4-3-4-2-创建member-service-provider-10002" class="headerlink" title="4.3.4.2 创建member-service-provider-10002"></a>4.3.4.2 创建member-service-provider-10002</h4><p>1.参考member-service-provider-10000 来创建 member-service-provider-10002 即可</p><p>2.创建好后，使用memberservice-provider-10000 的源 码和配置替換member-service-provider-10002 生成的代码（不要到磁盘整体拷贝，会出现关联到 member-service-provider-10000 的问题，很麻烦，可以创建好新项目的包，然后再拷贝对应包下的文件，就不会出向题）</p><p>3.提醒，拷贝时不要忘记拷贝 resources&#x2F;mapper&#x2F;Mem berMapper:xml 这些xaos.xml 文件</p><h4 id="4-3-4-3-创建-resources-x2F-application-yml"><a href="#4-3-4-3-创建-resources-x2F-application-yml" class="headerlink" title="4.3.4.3 创建 resources&#x2F;application.yml"></a>4.3.4.3 创建 resources&#x2F;application.yml</h4><p><strong>1.</strong> 创建好 <strong>application.yml</strong></p><p><strong>2.</strong> 从 <strong>member-service-provider-10000</strong> 拷贝 <strong>application.yml</strong> 的内容</p><p><strong>3.</strong> 修改端口号即可</p><h4 id="4-3-4-4-修改主启动类名"><a href="#4-3-4-4-修改主启动类名" class="headerlink" title="4.3.4.4 修改主启动类名"></a>4.3.4.4 修改主启动类名</h4><p><strong>1.</strong> 修改 <strong>member-service-provider-10000</strong> 的主启动类为 <strong>MemberProviderApplication10000</strong></p><p><strong>2.</strong> <strong>修改</strong> <strong>member-service-provider-10002</strong> <strong>的主启动类为</strong> <strong>MemberProviderApplication10002</strong></p><h4 id="4-3-4-5-完成测试"><a href="#4-3-4-5-完成测试" class="headerlink" title="4.3.4.5 完成测试"></a>4.3.4.5 完成测试</h4><p>……</p><h4 id="4-3-4-6-注意事项和细节"><a href="#4-3-4-6-注意事项和细节" class="headerlink" title="4.3.4.6 注意事项和细节"></a>4.3.4.6 注意事项和细节</h4><ol><li>因为 member-service-provider-10000 和 mem ber-service-provider-10002 作为一个集群提供服务，因此需要將 spring.application.name 进行统一。</li><li>这样消费方通过统一的别名进行负载均衡调用。</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230528142117680.png" alt="image-20230528142117680" style="zoom:33%;" /><p>将相同服务的提供方对外暴露的名称设置为相同的，这样就方便管理了。</p><h3 id="4-3-5-配置服务消费端-member-service-consumer-80-使用会员中心服务集群"><a href="#4-3-5-配置服务消费端-member-service-consumer-80-使用会员中心服务集群" class="headerlink" title="4.3.5 配置服务消费端 member-service-consumer-80 使用会员中心服务集群"></a><strong>4.3.5</strong> 配置服务消费端 <strong>member-service-consumer-80</strong> 使用会员中心服务集群</h3><h4 id="4-3-5-1-架构图"><a href="#4-3-5-1-架构图" class="headerlink" title="4.3.5.1 架构图"></a>4.3.5.1 架构图</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230528143413873.png" alt="image-20230528143413873"></p><h4 id="4-3-5-2-修改-MemberConsumerController-java"><a href="#4-3-5-2-修改-MemberConsumerController-java" class="headerlink" title="4.3.5.2 修改 MemberConsumerController.java"></a>4.3.5.2 修改 MemberConsumerController.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MEMBER_SERVICE_PROVIDER_URL</span> <span class="operator">=</span> <span class="string">&quot;http://member-service-provider&quot;</span>;</span><br><span class="line"><span class="comment">//member-service-provider为服务提供集群对外暴露的统一名称</span></span><br></pre></td></tr></table></figure><h4 id="4-3-5-3-修改-CustomizationBean-java"><a href="#4-3-5-3-修改-CustomizationBean-java" class="headerlink" title="4.3.5.3 修改 CustomizationBean.java"></a>4.3.5.3 修改 CustomizationBean.java</h4><p>​给 RestTemplate添加注解：**@LoadBalanced**</p><p>​目的是：赋予 <em>RestTemplate</em> 负载均衡的能力</p><h4 id="4-3-5-5-完成测试"><a href="#4-3-5-5-完成测试" class="headerlink" title="4.3.5.5 完成测试"></a>4.3.5.5 完成测试</h4><h5 id="4-3-5-5-1-启动-eureka-server-集群-目前-2-台"><a href="#4-3-5-5-1-启动-eureka-server-集群-目前-2-台" class="headerlink" title="4.3.5.5.1 启动 eureka server 集群**(目前 2 台)**"></a>4.3.5.5.1 启动 <strong>eureka server</strong> 集群**(<strong>目前 <strong>2</strong> 台</strong>)**</h5><h5 id="4-3-5-5-2-启动-member-service-provider-10000"><a href="#4-3-5-5-2-启动-member-service-provider-10000" class="headerlink" title="4.3.5.5.2 启动 member-service-provider-10000"></a>4.3.5.5.2 启动 <strong>member-service-provider-10000</strong></h5><h5 id="4-3-5-5-3-启动-member-service-provider-10002"><a href="#4-3-5-5-3-启动-member-service-provider-10002" class="headerlink" title="4.3.5.5.3 启动 member-service-provider-10002"></a>4.3.5.5.3 启动 <strong>member-service-provider-10002</strong></h5><h5 id="4-3-5-5-4不急，先测试-http-localhost-10000-member-get-1-和-http-localhost-10002-member-get-1"><a href="#4-3-5-5-4不急，先测试-http-localhost-10000-member-get-1-和-http-localhost-10002-member-get-1" class="headerlink" title="4.3.5.5.4不急，先测试 : http://localhost:10000/member/get/1 和 http://localhost:10002/member/get/1"></a><strong>4.3.5.5.4</strong>不急，先测试 <strong>: <a href="http://localhost:10000/member/get/1">http://localhost:10000/member/get/1</a></strong> 和 <strong><a href="http://localhost:10002/member/get/1">http://localhost:10002/member/get/1</a></strong></h5><p>先看看直接使用服务提供方时有没有问题，没问题再进行下一步测试(方便排错！)</p><h5 id="4-3-5-5-5-启动-member-service-consumer-80"><a href="#4-3-5-5-5-启动-member-service-consumer-80" class="headerlink" title="4.3.5.5.5 启动 member-service-consumer-80"></a><strong>4.3.5.5.5</strong> 启动 <strong>member-service-consumer-80</strong></h5><h5 id="4-3-5-5-6-浏览器访问-http-localhost-member-consumer-get-1"><a href="#4-3-5-5-6-浏览器访问-http-localhost-member-consumer-get-1" class="headerlink" title="4.3.5.5.6 浏览器访问**: http://localhost/member/consumer/get/1**"></a><strong>4.3.5.5.6</strong> 浏览器访问**: <a href="http://localhost/member/consumer/get/1">http://localhost/member/consumer/get/1</a>**</h5><h4 id="4-3-5-6-交替访问member服务说明"><a href="#4-3-5-6-交替访问member服务说明" class="headerlink" title="4.3.5.6 交替访问member服务说明:"></a>4.3.5.6 交替访问member服务说明:</h4><ol><li>注解@LoadBalanced 底层是Ribbon支持算法</li><li>2.Ribbon和Eureka 整合后consumer 直接调用服务而不用再关心地址和端口号，且该服务还有负载功能</li></ol><h3 id="4-3-6-获取-Eureka-Server-服务注册信息-DiscoveryClient"><a href="#4-3-6-获取-Eureka-Server-服务注册信息-DiscoveryClient" class="headerlink" title="4.3.6 获取 Eureka Server 服务注册信息 -DiscoveryClient"></a><strong>4.3.6</strong> 获取 <strong>Eureka Server</strong> 服务注册信息 <strong>-DiscoveryClient</strong></h3><h4 id="4-3-6-1-需求分析-x2F-图解"><a href="#4-3-6-1-需求分析-x2F-图解" class="headerlink" title="4.3.6.1 需求分析&#x2F;图解"></a>4.3.6.1 需求分析&#x2F;图解</h4><p><strong>1.</strong> 需求分析示意图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230528150507261.png" alt="image-20230528150507261"></p><p><strong>2.</strong> <strong>这里我们以服务消费方</strong>， <strong>去获取</strong> <strong>Eureka Server</strong> <strong>的服务注册信息为例讲解</strong></p><p><strong>3.</strong> <strong>当然也可以在服务提供方获取</strong> <strong>Eureka Server</strong> <strong>的服务注册信息</strong></p><h4 id="4-3-6-2-代码实现"><a href="#4-3-6-2-代码实现" class="headerlink" title="4.3.6.2 代码实现"></a>4.3.6.2 代码实现</h4><ol><li><strong>所在模块  member-service-consumer-80</strong></li><li><strong>修改</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;MemberConsumerController.java</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//装配DiscoveryClient</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/member/consumer/discovery&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">discovery</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;String&gt; services = discoveryClient.getServices();</span><br><span class="line">    <span class="keyword">for</span> (String service : services)&#123;</span><br><span class="line">        log.info(<span class="string">&quot;服务名=&#123;&#125;&quot;</span>,service);</span><br><span class="line">        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(service);</span><br><span class="line">        <span class="keyword">for</span> (ServiceInstance instance : instances)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;id=&#123;&#125;,host=&#123;&#125;,port=&#123;&#125;,uri=&#123;&#125;&quot;</span>,instance.getServiceId(),instance.getHost(),instance.getPort(),instance.getUri());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> discoveryClient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.</strong> <strong>这里修改主启动类</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;MemberConsumerApplication.java</strong></p><p>添加注解：@EnableDiscoveryClient</p><h4 id="4-3-6-3-测试"><a href="#4-3-6-3-测试" class="headerlink" title="4.3.6.3 测试"></a>4.3.6.3 测试</h4><p><strong>1.</strong> <strong>重启</strong> <strong>member-service-consumer-80</strong></p><p><strong>2.</strong> <strong>浏览器输出</strong> <strong><a href="http://localhost/member/consumer/discovery">http://localhost/member/consumer/discovery</a></strong></p><h4 id="4-3-6-4-注意事项和细节说明"><a href="#4-3-6-4-注意事项和细节说明" class="headerlink" title="4.3.6.4 注意事项和细节说明"></a>4.3.6.4 注意事项和细节说明</h4><ol><li><p>在引入 <strong>DiscoveryClient</strong> 时，不要引入错误的包：</p><p>正确的包**:** <strong>import</strong> <strong>org.springframework.cloud.client.discovery.DiscoveryClient</strong>;</p><p>错误的包**:** <strong>import</strong> <strong>com.netflix.discovery.DiscoveryClient</strong>;</p></li></ol><h2 id="4-4-Eureka后续说明"><a href="#4-4-Eureka后续说明" class="headerlink" title="4.4 Eureka后续说明"></a>4.4 Eureka后续说明</h2><p><strong>1. Eureka</strong> 停更说明**: <a href="https://github.com/Netflix/eureka/wiki">https://github.com/Netflix/eureka/wiki</a>**</p><p><strong>2.</strong> <strong>对于一些早期使用</strong> <strong>Eureka</strong> <strong>项目，掌握老师讲解技术基本可以应付了</strong>(<strong>这也是老师为什么还 要讲</strong> <strong>Eureka</strong> <strong>的原因</strong>)</p><p><strong>3.目前替代 Eureka 做服务注册和发现，均衡负载的 最佳组件是 spring Cloud Alibaba Nacos，后面老师会重点讲解。</strong></p><p><strong>4.虽然Eureka 停更，目前用的不多，但是它的服务注册和发现，均衡负载的思想是优先的，有了Eureka 的基础，我们学习 Spring Cloud Alibaba Nacos 会轻松很多</strong></p><h1 id="5-SpringCloudRibbon服务负载均衡"><a href="#5-SpringCloudRibbon服务负载均衡" class="headerlink" title="5 SpringCloudRibbon服务负载均衡"></a><strong>5 SpringCloudRibbon</strong>服务负载均衡</h1><h2 id="5-1-Ribbon介绍"><a href="#5-1-Ribbon介绍" class="headerlink" title="5.1 Ribbon介绍"></a>5.1 Ribbon介绍</h2><h3 id="5-1-1-Ribbon是什么"><a href="#5-1-1-Ribbon是什么" class="headerlink" title="5.1.1 Ribbon是什么"></a><strong>5.1.1 Ribbon</strong>是什么</h3><ol><li><p>Spring Cloud Ribbon 是<strong>基于 Netflix Ribbon</strong> 实现的一套**<u>客户端负载均衡</u>**的工具。</p></li><li><p>Ribbon 主要功能是<strong>提供客户端负载均衡算法和服务调用</strong></p></li><li><p>Ribbon 客户端组件提供一系列完善的配置项如连接超时，重试等。</p></li><li><p>Ribbon 会基于某种规则（如简单轮询，随机连接等）去连接指定服务</p></li><li><p>程序员很容易使用 Ribbon 的负载均衡算法实现负载均衡</p></li><li><p>一句话：Ribbon： <strong>负载均衡+RestTemplate调用</strong></p></li></ol><h3 id="5-1-2-官网"><a href="#5-1-2-官网" class="headerlink" title="5.1.2 官网"></a><strong>5.1.2</strong> 官网</h3><h4 id="5-1-2-1-https-github-com-Netflix-ribbon"><a href="#5-1-2-1-https-github-com-Netflix-ribbon" class="headerlink" title="5.1.2.1 https://github.com/Netflix/ribbon"></a>5.1.2.1 <a href="https://github.com/Netflix/ribbon">https://github.com/Netflix/ribbon</a></h4><h3 id="5-1-3-Ribbon进入维护状态"><a href="#5-1-3-Ribbon进入维护状态" class="headerlink" title="5.1.3 Ribbon进入维护状态"></a><strong>5.1.3 Ribbon</strong>进入维护状态</h3><p><strong>Ribbon 目前进入维护模式, 未来替换方案 是 <u>Spring Cloud LoadBalancer</u></strong></p><h3 id="5-1-4-LB-Load-Balance"><a href="#5-1-4-LB-Load-Balance" class="headerlink" title="5.1.4 LB(Load Balance)"></a>5.1.4 LB(Load Balance)</h3><h4 id="5-1-4-1-LB分类"><a href="#5-1-4-1-LB分类" class="headerlink" title="5.1.4.1 LB分类"></a>5.1.4.1 LB分类</h4><h5 id="集中式-LB"><a href="#集中式-LB" class="headerlink" title="集中式 LB"></a>集中式 LB</h5><ul><li><p>即在服务的消费方和提供方之间使用独立的LB设施（可以是硬件，如F5，也可以是软件，如Nginx)，由该设施负责把访向请求通过某种策略转发至服务的提供方：</p></li><li><p>LB(Load Balance 负载均衡）</p></li></ul><h5 id="进程内-LB"><a href="#进程内-LB" class="headerlink" title="进程内 LB"></a>进程内 LB</h5><ul><li><p>将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些服务地址可用，然后再从这些地址中选择出一个合适的服务地址。</p></li><li><p>Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。</p></li></ul><h4 id="5-1-4-2-实例-前面-member-consumer-轮询负载访问-10000-x2F-10002-底层就是-Ribbon-默认的轮询负载算法"><a href="#5-1-4-2-实例-前面-member-consumer-轮询负载访问-10000-x2F-10002-底层就是-Ribbon-默认的轮询负载算法" class="headerlink" title="5.1.4.2 实例-前面 member-consumer 轮询负载访问 10000&#x2F;10002 底层就是 Ribbon 默认的轮询负载算法"></a>5.1.4.2 实例-前面 member-consumer 轮询负载访问 10000&#x2F;10002 底层就是 Ribbon 默认的轮询负载算法</h4><h2 id="5-2-Ribbon原理"><a href="#5-2-Ribbon原理" class="headerlink" title="5.2 Ribbon原理"></a>5.2 Ribbon原理</h2><h3 id="5-2-1-Ribbon架构图-amp-机制"><a href="#5-2-1-Ribbon架构图-amp-机制" class="headerlink" title="5.2.1 Ribbon架构图**&amp;**机制"></a><strong>5.2.1 Ribbon</strong>架构图**&amp;**机制</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230529203201726.png" alt="image-20230529203201726">Ribbon 机制</p><ol><li><strong>先选择 EurekaServer</strong>，它<u>优先选择在同一个区域内负载较少的 serve</u>r</li><li><strong>再根据用户指定的策略</strong>，在<u>从 server取到的服务注册列表中选择一个地址</u></li><li>Ribbon 提供了多种策略：比如轮询、随机和根据响应时间加权。</li></ol><h3 id="5-2-2-Ribbon常见负载算法"><a href="#5-2-2-Ribbon常见负载算法" class="headerlink" title="5.2.2 Ribbon常见负载算法"></a><strong>5.2.2 Ribbon</strong>常见负载算法</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230529203353777.png" alt="image-20230529203353777"></p><h2 id="5-3-替换负载均衡算法-应用实例"><a href="#5-3-替换负载均衡算法-应用实例" class="headerlink" title="5.3 替换负载均衡算法-应用实例"></a>5.3 替换负载均衡算法-应用实例</h2><h3 id="5-3-1-需求分析-x2F-图解"><a href="#5-3-1-需求分析-x2F-图解" class="headerlink" title="5.3.1 需求分析**&#x2F;**图解"></a><strong>5.3.1</strong> 需求分析**&#x2F;**图解</h3><ol><li>需求：将默认的轮询算法改成随机算法 RandomRule</li><li>浏览器输入：htp:&#x2F;&#x2F;ocalhost&#x2F;member&#x2F;consuimer&#x2F;get&#x2F;1</li><li>要求 彷问的 10000&#x2F;10002 端口的服务是随机的</li></ol><h3 id="5-3-2代码实现"><a href="#5-3-2代码实现" class="headerlink" title="5.3.2代码实现"></a>5.3.2代码实现</h3><ol><li>创建 member-service-consumer-80com&#x2F;hspedu&#x2F;springcloud&#x2F;config&#x2F;RibbonRule.java</li></ol><h3 id="5-3-3-测试"><a href="#5-3-3-测试" class="headerlink" title="5.3.3 测试"></a><strong>5.3.3</strong> 测试</h3><p><strong>1.</strong> 浏览器输入 **: <a href="http://localhost/member/consumer/get/1">http://localhost/member/consumer/get/1</a> **</p><p><strong>2.</strong> <strong>观察访问的</strong> <strong>10000&#x2F;10002</strong> <strong>端口的服务是随机的</strong></p><h1 id="6-SpringCloud-Open-Feign服务调用"><a href="#6-SpringCloud-Open-Feign服务调用" class="headerlink" title="6 SpringCloud Open Feign服务调用"></a>6 SpringCloud Open Feign服务调用</h1><h2 id="6-1-OpenFeign介绍"><a href="#6-1-OpenFeign介绍" class="headerlink" title="6.1 OpenFeign介绍"></a>6.1 OpenFeign介绍</h2><h3 id="6-1-1-OpenFeign是什么"><a href="#6-1-1-OpenFeign是什么" class="headerlink" title="6.1.1 OpenFeign是什么"></a><strong>6.1.1 OpenFeign</strong>是什么</h3><ol><li><p>0penFeign 是个声明式 Webservice 客户端，使用 OpenFeign 让编写 web Service 客户端更简单</p></li><li><p>它的使用方法是定义一个服务接口然后在上面添加注解</p></li><li><p>0penFeign 也支持可拔插式的编码器和解码器。</p></li><li><p>Spring cloud 对 OpenFeign 进行了封装使其支持了 Spring Mvc 标准注解和HttpMessageConverters</p></li><li><p>0penFeign 可以与Eureka 和 Ribbon 组合使用以支持负载均衡</p></li></ol><h3 id="6-1-2-官网"><a href="#6-1-2-官网" class="headerlink" title="6.1.2 官网"></a><strong>6.1.2</strong> 官网</h3><h4 id="6-1-2-1-https-github-com-spring-cloud-spring-cloud-openfeign"><a href="#6-1-2-1-https-github-com-spring-cloud-spring-cloud-openfeign" class="headerlink" title="6.1.2.1 https://github.com/spring-cloud/spring-cloud-openfeign"></a>6.1.2.1 <a href="https://github.com/spring-cloud/spring-cloud-openfeign">https://github.com/spring-cloud/spring-cloud-openfeign</a></h4><h3 id="6-1-3-Feign和OpenFeign区别"><a href="#6-1-3-Feign和OpenFeign区别" class="headerlink" title="6.1.3 Feign和OpenFeign区别"></a><strong>6.1.3 Feign</strong>和<strong>OpenFeign</strong>区别</h3><p>​Feign(不好用，没人用了)：</p><ul><li><p>Feign是Spring Cioud组件中的一个轻量级RESTful的HTTP服务客户端</p></li><li><p>Feign内置了Ribbon，用来做客户端免载均衡， 去调用服务注册中心的服务。</p></li><li><p>Feign的使用方式是：使用Feign的注解定义接口，调用服务注册中心的服务</p></li><li><p>Feign支持的注解和用法请参考官方文档：<a href="https://githulb.com/OpenFeign/feign">https://githulb.com/OpenFeign/feign</a></p></li><li><p>Feign本身不支持Spring MvC的注解，它有一套自己的注解</p></li></ul><p>​</p><p>​OpenFeign：</p><ul><li><p>openFeign是Spring Cloud **<u>在Feign的基础上支持了Spring MvC的注解</u>**，如@Requesapping等等。</p></li><li><p>OpenFeign的@FeignClient可以解析SpringvC的@RequestMapping注解下的接口</p></li><li><p>OpenFeign通过动态代理的方式产生实现类，实现<strong>类中做负载均衡并调用其他服务</strong></p></li></ul><p>精简一句话 : <strong>OpenFeign 就是在 Feign 基础上做了加强</strong> , 有些程序员为了方便，说 <u>Feign 就是指的 OpenFeign</u></p><h2 id="6-2-OpenFeign-应用实例"><a href="#6-2-OpenFeign-应用实例" class="headerlink" title="6.2 OpenFeign-应用实例"></a>6.2 OpenFeign-应用实例</h2><h3 id="6-2-1-需求分析-x2F-图解"><a href="#6-2-1-需求分析-x2F-图解" class="headerlink" title="6.2.1 需求分析**&#x2F;**图解"></a><strong>6.2.1</strong> 需求分析**&#x2F;**图解</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230529210545959.png" alt="image-20230529210545959"></p><p>(Eureka实现获取服务、Ribbon实现自定义负载均衡算法、RestTemplate实现远程调用)</p><p>(Eureka实现获取服务、OpenFeign实现负载均衡+远程调用)</p><h3 id="6-2-2-创建服务消费模块-通过-OpenFeigen-实现远程调用"><a href="#6-2-2-创建服务消费模块-通过-OpenFeigen-实现远程调用" class="headerlink" title="6.2.2 创建服务消费模块 **-**通过 OpenFeigen 实现远程调用"></a><strong>6.2.2</strong> 创建服务消费模块 **-**通过 <strong>OpenFeigen</strong> 实现远程调用</h3><p><strong>1.</strong> 参考 <strong>member-service-consumer-80</strong> 创建 **member-service-consumer-openfeign-80(**具体步骤参考以前)</p><p><strong>2.</strong> <strong>修改</strong> <strong>pom.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    引入openfeign-start，即场景启动器    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>**3.创建 application.yml 内容如下:**、</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">e-commerce-consumer-openfeign</span></span><br><span class="line"><span class="comment">#配置eureka-client</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span> <span class="comment">#将自己注册到Eureka-server</span></span><br><span class="line">    <span class="comment">#表示从Eureka-server抓取注册信息</span></span><br><span class="line">    <span class="comment">#如果是单节点，可以不配置；</span></span><br><span class="line">    <span class="comment">#但是provider是一个集群，则必须将此项配置为true，这样才能配合Ribbon使用负载均衡功能</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 表示将自己注册到哪个eureka-server</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka9001.com:9001/eureka,http://eureka9002.com:9002/eureka</span></span><br></pre></td></tr></table></figure><p>4.创建主启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span> <span class="comment">//启动openFeignClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberConsumerOpenfeignApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MemberConsumerOpenfeignApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>创建 com&#x2F;study&#x2F;springcloud&#x2F;service&#x2F;MemberFeignService.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;MEMBER-SERVICE-PROVIDER&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MemberFeignService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在这里定义方法——远程调用服务提供方给的接口</span></span><br><span class="line">    <span class="comment">//原来是使用RestController实现功能的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.远程调用的方式是get</span></span><br><span class="line">    <span class="comment">//2.远程调用的url http:MEMBER-SERVICE-PROVIDER/member/get/&#123;id&#125;</span></span><br><span class="line">    <span class="comment">//3.MEMBER-SERVICE-PROVIDER是服务提供方在Eureka Server注册的服务</span></span><br><span class="line">    <span class="comment">//4.openfeign会根据负载均衡来决定调用哪个服务-默认是轮询</span></span><br><span class="line">    <span class="comment">//5.优点：openfeign支持了springMVC注解 + 接口 --&gt;解耦</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/member/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getMemberById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Long id)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>创建 com&#x2F;study&#x2F;springcloud&#x2F;controller&#x2F;MemberConsumerFeignController.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span> <span class="comment">//结果以json格式返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberConsumerFeignController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//装配MemberFeignService</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MemberFeignService memberFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/member/consumer/openfeign/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getMemberById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memberFeignService.getMemberById(id);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-3-测试"><a href="#6-2-3-测试" class="headerlink" title="6.2.3 测试"></a><strong>6.2.3</strong> 测试</h3><p>​浏览器输入 <strong>: <a href="http://localhost/member/consumer/openfeign/get/1">http://localhost/member/consumer/openfeign/get/1</a></strong></p><h3 id="6-2-4-注意事项和细节"><a href="#6-2-4-注意事项和细节" class="headerlink" title="6.2.4 注意事项和细节"></a><strong>6.2.4</strong> 注意事项和细节</h3><ul><li><p>配Openfeign的使用特点是 微服务调用接口+@Feignclient，使用接口进行<strong>解耦</strong></p></li><li><p>@FeignClient(value &#x3D; “MEMBER-SERVICE-PROVIDER”)，这里MEMBER-SERVICE-PROVIDER就是Eureka Server服务提供方注册的名称，不要写错了</p></li><li><p>接口方法上： value是不能乱写，远程调用的url 为<a href="http://member-service-provider/member/get/%7Bid%7D">http://MEMBER-SERVICE-PROVIDER/member/get/{id}</a></p></li></ul><p>​@GetMapping(“&#x2F;member&#x2F;get&#x2F;{id}”)<br>​    public Result getMemberById(@PathVariable(“id”)Long id);</p><h2 id="6-3-日志配置"><a href="#6-3-日志配置" class="headerlink" title="6.3 日志配置"></a>6.3 日志配置</h2><h3 id="6-3-1-基本介绍"><a href="#6-3-1-基本介绍" class="headerlink" title="6.3.1 基本介绍"></a><strong>6.3.1</strong> 基本介绍</h3><p>1．说明：Feign 提供了日志打印功能，可以通过配罝来调整日志级别，从而对 Feign 接口的调用情况进行监控和输出</p><p>2.日志级别</p><ul><li><p><strong>NONE</strong> ：默认的，不显示任何日志</p></li><li><p><strong>BASIC</strong>：仅记录请求方法、URL、响应状态码及执行时间;</p></li><li><p><strong>HEADERS</strong> ： 除了 BASIC中定义的信息之外，还有请求和响应的头信息;</p></li><li><p><strong>FULL</strong>：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。</p></li></ul><h3 id="6-3-2-配置日志-应用实例"><a href="#6-3-2-配置日志-应用实例" class="headerlink" title="6.3.2 配置日志**-**应用实例"></a><strong>6.3.2</strong> 配置日志**-**应用实例</h3><p><strong>1.</strong> 在 <strong>member-service-consumer-openfeign-80</strong> 创 建</p><p><strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;config&#x2F;OpenFeignConfig.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenFeignConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">loggerLevel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 在 <strong>member-service-consumer-openfeign-80</strong> 修改 <strong>application.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对MemberFeignService接口调用过程打印信息-debug</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.study.springcloud.service.MemberFeignService:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230530125632781.png" alt="image-20230530125632781" style="zoom:50%;" /><h3 id="6-3-3-测试"><a href="#6-3-3-测试" class="headerlink" title="6.3.3 测试"></a><strong>6.3.3</strong> 测试</h3><p>……</p><h2 id="6-4-OpenFeign超时"><a href="#6-4-OpenFeign超时" class="headerlink" title="6.4 OpenFeign超时"></a>6.4 OpenFeign超时</h2><p>若服务提供方(可能由于各种原因，比如操作数据库时间过长)响应超过OpenFeign的等待时间(默认1秒)，会返回超时错误(time out)</p><p>……</p><h3 id="6-4-3-设置OpenFeign超时时间"><a href="#6-4-3-设置OpenFeign超时时间" class="headerlink" title="6.4.3 设置OpenFeign超时时间"></a><strong>6.4.3</strong> 设置OpenFeign超时时间</h3><p>在服务消费方的配置文件中进行响应配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置feign客户端超时时间</span></span><br><span class="line"><span class="comment"># read-timeout 建立连接：从服务提供方获取可用资源的全部时间</span></span><br><span class="line"><span class="comment"># connect-timeout 两端连接所用时间</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">connect-timeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">read-timeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><h3 id="6-4-4-测试"><a href="#6-4-4-测试" class="headerlink" title="6.4.4 测试"></a><strong>6.4.4</strong> 测试</h3><p>……</p><h1 id="7-🌟SpringCloudGateway-服务网关"><a href="#7-🌟SpringCloudGateway-服务网关" class="headerlink" title="7 🌟SpringCloudGateway 服务网关"></a>7 🌟SpringCloudGateway 服务网关</h1><h2 id="7-1-Gateway介绍"><a href="#7-1-Gateway介绍" class="headerlink" title="7.1 Gateway介绍"></a>7.1 Gateway介绍</h2><h3 id="7-1-1-看一个需求，引出网关服务"><a href="#7-1-1-看一个需求，引出网关服务" class="headerlink" title="7.1.1 看一个需求，引出网关服务"></a><strong>7.1.1</strong> 看一个需求，引出网关服务</h3><p><strong>1</strong>、有一个前后端分离项目**,** 分析如图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230530144204835.png" alt="image-20230530144204835"></p><p>2、使用网关服务, 重构项目架构</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230530144645171.png" alt="image-20230530144645171"></p><h3 id="7-1-2-🌟Gateway-网络拓扑图"><a href="#7-1-2-🌟Gateway-网络拓扑图" class="headerlink" title="7.1.2 🌟Gateway 网络拓扑图"></a><strong>7.1.2 🌟Gateway</strong> 网络拓扑图</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230530151559362.png" alt="image-20230530151559362"></p><h3 id="7-1-3-Gateway是什么"><a href="#7-1-3-Gateway是什么" class="headerlink" title="7.1.3 Gateway是什么"></a><strong>7.1.3 Gateway</strong>是什么</h3><ol><li><p>Gateway 是在 Spring 生态系统之上构建的 API 网关服务，基于 spring , Spring Boot 和 Project Reactor 等技术。</p></li><li><p>Gateway 旨在提供一种简单而有效的方式来对 API 进行路由，以及提供一些强大的过滤器功能，例如 ：熔断、限流、重试等。</p></li></ol><h3 id="7-1-4-官网"><a href="#7-1-4-官网" class="headerlink" title="7.1.4 官网"></a>7.1.4 官网</h3><h4 id="7-1-4-1-https-cloud-spring-io-spring-cloud-static-spring-cloud-gateway-2-2-1-RELEASE-reference-html"><a href="#7-1-4-1-https-cloud-spring-io-spring-cloud-static-spring-cloud-gateway-2-2-1-RELEASE-reference-html" class="headerlink" title="7.1.4.1 https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/"></a>7.1.4.1 <a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/</a></h4><h3 id="7-1-5-Gateway-核心功能"><a href="#7-1-5-Gateway-核心功能" class="headerlink" title="7.1.5 Gateway 核心功能"></a><strong>7.1.5 Gateway</strong> 核心功能</h3><h4 id="7-1-5-1-鉴权"><a href="#7-1-5-1-鉴权" class="headerlink" title="7.1.5.1 鉴权"></a>7.1.5.1 鉴权</h4><h4 id="7-1-5-2-流量控制"><a href="#7-1-5-2-流量控制" class="headerlink" title="7.1.5.2 流量控制"></a>7.1.5.2 流量控制</h4><h4 id="7-1-5-3-熔断"><a href="#7-1-5-3-熔断" class="headerlink" title="7.1.5.3 熔断"></a>7.1.5.3 熔断</h4><h4 id="7-1-5-4-日志监控"><a href="#7-1-5-4-日志监控" class="headerlink" title="7.1.5.4 日志监控"></a>7.1.5.4 日志监控</h4><h4 id="7-1-5-5-反向代理"><a href="#7-1-5-5-反向代理" class="headerlink" title="7.1.5.5 反向代理"></a>7.1.5.5 反向代理</h4><h3 id="7-1-6-Gateway-vs-Zuul"><a href="#7-1-6-Gateway-vs-Zuul" class="headerlink" title="7.1.6 Gateway vs Zuul"></a><strong>7.1.6 Gateway vs Zuul</strong></h3><h4 id="7-1-6-1-Gateway-和-Zuul-区别"><a href="#7-1-6-1-Gateway-和-Zuul-区别" class="headerlink" title="7.1.6.1 Gateway 和 Zuul 区别"></a>7.1.6.1 Gateway 和 Zuul 区别</h4><ol><li><p>SpringCloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Zuul</p></li><li><p>SpringCloud Gateway 是基于 Spring WebFlux框架实现的</p></li><li><p>Spring WebFlux 框架底层则使用了高性能的 Reactor 模式通信框架 Netty，提升了网关性能</p></li></ol><h4 id="7-1-6-2-Gateway-特性"><a href="#7-1-6-2-Gateway-特性" class="headerlink" title="7.1.6.2 Gateway 特性"></a>7.1.6.2 Gateway 特性</h4><p>​Spring Cloud Gateway 基 于 Spring Framework(支 特 Spring WebFlux)， project Reactor 和 spring Boot 进行构建，具有如下特性：</p><ul><li>动态路由</li><li>可以对路由指定 predicate(断言)和Filter(过滤器）</li><li>集成Hystrix的断路器功能</li><li>集成 Spring Cloud 服务发现功能</li><li>请求限流功能</li><li>支持路径重写</li></ul><h2 id="7-2-Gateway基本原理"><a href="#7-2-Gateway基本原理" class="headerlink" title="7.2 Gateway基本原理"></a>7.2 Gateway基本原理</h2><h3 id="7-2-1-Gateway核心组件"><a href="#7-2-1-Gateway核心组件" class="headerlink" title="7.2.1 Gateway核心组件"></a><strong>7.2.1 Gateway</strong>核心组件</h3><h4 id="7-2-1-1-一张图"><a href="#7-2-1-1-一张图" class="headerlink" title="7.2.1.1 一张图"></a>7.2.1.1 一张图</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230530152704594.png" alt="image-20230530152704594" style="zoom:50%;" /><ol><li><p>web 请求通过一些匹配条件，定位到真正的服务节点&#x2F;微服务模块，在这个转发过程的前后，进行一些精细化控制。</p></li><li><p>predicate：就是匹配条件(请求是否能被接受使用)</p></li><li><p>filter：可以理解为是网关的过滤机制。</p><p>有了predicate 和filter，再加上目标 URL,就可以实现一个具体的路由</p></li></ol><h4 id="7-2-1-2-Route-路由"><a href="#7-2-1-2-Route-路由" class="headerlink" title="7.2.1.2 Route(路由)"></a>7.2.1.2 Route(路由)</h4><p>一句话：路由是构建网关的基本模块，它由 <strong>ID</strong>，<strong>目标 URL</strong>，<strong>一系列的断言和过滤器</strong>组成，如果断言为 true 则匹配该路由。</p><h4 id="7-2-1-3-Predicate-断言"><a href="#7-2-1-3-Predicate-断言" class="headerlink" title="7.2.1.3 Predicate(断言)"></a>7.2.1.3 Predicate(断言)</h4><ol><li><p>一句话：对 HTTP 请求中的所有内容（例如请求头或请求参数）进行匹配，如果请求与断言相匹配则进行路由</p></li><li><p>简单举例，比如配置路径，- Path&#x3D;&#x2F;member&#x2F;get&#x2F;**             断言,路经相匹配的进行路由转发，如果Http 请求的路径不匹配，则不进行路由转发。</p></li></ol><h4 id="7-2-1-4-Filter-过滤"><a href="#7-2-1-4-Filter-过滤" class="headerlink" title="7.2.1.4 Filter(过滤)"></a>7.2.1.4 Filter(过滤)</h4><p>1、一句话：使用过滤器，可以在<strong>请求被路由前或者之后</strong>对请求进行处理</p><p>2、你可以理解成，在对 Http 请求断言匹配成功后，可以通过网关的过滤机制，对Http 请求处理</p><h3 id="7-2-2-HowItWorks工作机制"><a href="#7-2-2-HowItWorks工作机制" class="headerlink" title="7.2.2 HowItWorks工作机制"></a><strong>7.2.2 HowItWorks</strong>工作机制</h3><h4 id="7-2-2-1-一图胜千言"><a href="#7-2-2-1-一图胜千言" class="headerlink" title="7.2.2.1 一图胜千言"></a>7.2.2.1 一图胜千言</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230530163559159.png" alt="image-20230530163559159" style="zoom:50%;" /><ol><li><p>客户端向 Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，將其发送到 Gateway Web Handler。</p></li><li><p>Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。</p></li><li><p>过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（”pre”）或之后(“post”）执行业务逻辑。</p></li><li><p>Filter 在”pre”类型的过滤器可以做<strong>参数校验、权限校验、流量监控、日志输出、协议转换</strong>等，</p></li><li><p>在”post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。</p></li></ol><p>一句话说：路由转发＋执行过滤器链</p><h2 id="7-3-搭建-Gateway-微服务"><a href="#7-3-搭建-Gateway-微服务" class="headerlink" title="7.3 搭建 Gateway 微服务"></a>7.3 搭建 Gateway 微服务</h2><h3 id="7-3-1-搭建-Gateway-应用实例"><a href="#7-3-1-搭建-Gateway-应用实例" class="headerlink" title="7.3.1 搭建 **Gateway-**应用实例"></a><strong>7.3.1</strong> 搭建 **Gateway-**应用实例</h3><h4 id="7-3-1-1-需求分析-x2F-图解"><a href="#7-3-1-1-需求分析-x2F-图解" class="headerlink" title="7.3.1.1 需求分析&#x2F;图解"></a>7.3.1.1 需求分析&#x2F;图解</h4><p>– 引入 <strong>Gateway</strong> 项目架构</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230531095247037.png" alt="image-20230531095247037"></p><p><strong>1.</strong> <strong>通过网关暴露的接口，实现调用真正的服务</strong> </p><p><strong>2.</strong> <strong>网关本身也是一个微服务模块</strong></p><h4 id="7-3-1-2-代码实现"><a href="#7-3-1-2-代码实现" class="headerlink" title="7.3.1.2 代码实现"></a>7.3.1.2 代码实现</h4><p><strong>1.</strong> 参考 <strong>member-service-consumer-80</strong> 创建 **e-commerce-gateway-20000(**具体步骤参考以前)<br><strong>2.</strong> 修改 <strong>pom.xml,</strong> 部分内容可以从 <strong>member-service-consumer-80</strong> 的 <strong>pom.xml</strong> 拷贝</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.study.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>e-commerce-center<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>e-commerce-gateway-20000<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--       引入gateway start， 网关场景启动器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--       引入eureka-client场景启动器starter--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--老师特别说明：</span></span><br><span class="line"><span class="comment">    不要引入：spring-boot-starter-web、spring-boot-starter-actuator</span></span><br><span class="line"><span class="comment">    否则会出现冲突</span></span><br><span class="line"><span class="comment">    因为gateway是一个服务网关，不需要web</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引入 e_commerce_center-common-api --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.study.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>e_commerce_center-common-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3.<strong>创建 <strong>application.yml(<strong>重点核心</strong>)</strong> 内容如下</strong>:</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">20000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">e-commerce-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment">#配置路由，可以配置多个 List&lt;RouteDefinition&gt; routes</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">member_route01</span> <span class="comment">#路由的id，程序员自行配置</span></span><br><span class="line">          <span class="comment">#gateway 最终访问的url 是 uri + path</span></span><br><span class="line">          <span class="comment">#匹配后提供服务的路由地址：也可以是外网 如www.baidu.com</span></span><br><span class="line">          <span class="comment">#比如：客户端/浏览器请求url：http:localhost:20000/member/get/1</span></span><br><span class="line">          <span class="comment">#网关对请求url中的path进行匹配，如果匹配失败，返回404</span></span><br><span class="line">          <span class="comment">#如果匹配成功，最终访问的url=http://localhost:10000/member/get/1</span></span><br><span class="line">          <span class="comment">#                     即 uri + path</span></span><br><span class="line">          <span class="comment">#这里⬇️的uri是固定不变的，在当前这种情况下是可以不使用Eureka Server 的</span></span><br><span class="line">          <span class="comment">#后面会使用灵活uri配置，会用到Eureka Server</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:10000</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 断言，可以有多种形式</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/member/get/**</span></span><br><span class="line"><span class="comment"># 配置Eureka Client</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">e-commerce-service</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span> <span class="comment">#将自己注册到Eureka-server</span></span><br><span class="line">    <span class="comment">#表示从Eureka-server抓取注册信息</span></span><br><span class="line">    <span class="comment">#如果是单节点，可以不配置；</span></span><br><span class="line">    <span class="comment">#但是provider是一个集群，则必须将此项配置为true，这样才能配合Ribbon使用负载均衡功能</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 表示将自己注册到哪个eureka-server</span></span><br><span class="line">      <span class="comment">#这里为了方便，就使用9001端口一个server</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka9001.com:9001/eureka</span></span><br></pre></td></tr></table></figure><p>**4.**创建主启动类 <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;GateWayApplication20000.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GateWayApplication20000</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(GateWayApplication20000.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-1-3-测试"><a href="#7-3-1-3-测试" class="headerlink" title="7.3.1.3 测试"></a>7.3.1.3 测试</h4><p>……</p><h4 id="7-3-1-4-注意事项和细节"><a href="#7-3-1-4-注意事项和细节" class="headerlink" title="7.3.1.4 注意事项和细节"></a>7.3.1.4 注意事项和细节</h4><p>因为我们的 member 的 controller 的方法参数使用了@RequestBody ,所以在使用 postman时，需要使用 json 格式发送数据, 否则会报400错误。</p><h3 id="7-3-2-二说-Gateway-路由配置"><a href="#7-3-2-二说-Gateway-路由配置" class="headerlink" title="7.3.2 二说 Gateway 路由配置"></a><strong>7.3.2</strong> 二说 <strong>Gateway</strong> 路由配置</h3><h4 id="7-3-2-1-方式-1-application-yml-中配置-前面讲过"><a href="#7-3-2-1-方式-1-application-yml-中配置-前面讲过" class="headerlink" title="7.3.2.1 方式 1: application.yml 中配置-前面讲过"></a>7.3.2.1 方式 1: application.yml 中配置-前面讲过</h4><h4 id="7-3-2-2-方式-2-编写配置类注入【了解】"><a href="#7-3-2-2-方式-2-编写配置类注入【了解】" class="headerlink" title="7.3.2.2 方式 2: 编写配置类注入【了解】"></a>7.3.2.2 方式 2: 编写配置类注入【了解】</h4><p>​<strong>1.</strong> 先注销 <strong>application.yml</strong> 对网关路由部分注销</p><p>​<strong>2.</strong> <strong>重启</strong> <strong>e-commerce-gateway-20000,</strong> <strong>再次测试，网关路由失效</strong></p><p><strong>3.</strong> 参考官方文档:<a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#spring-cloud-circuitbreaker-filter-factory">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#spring-cloud-circuitbreaker-filter-factory</a> ， 创 建com&#x2F;hspedu&#x2F;springcloud&#x2F;config&#x2F;GateWayRoutesConfig.java</p><h4 id="7-3-2-3-测试"><a href="#7-3-2-3-测试" class="headerlink" title="7.3.2.3 测试"></a>7.3.2.3 测试</h4><p>……</p><h3 id="7-3-3-动态路由"><a href="#7-3-3-动态路由" class="headerlink" title="7.3.3 动态路由"></a><strong>7.3.3</strong> 动态路由</h3><h4 id="7-3-3-1-需求分析-x2F-图"><a href="#7-3-3-1-需求分析-x2F-图" class="headerlink" title="7.3.3.1 需求分析&#x2F;图"></a>7.3.3.1 需求分析&#x2F;图</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230531150741007.png" alt="image-20230531150741007"></p><h4 id="7-3-3-2-代码实现"><a href="#7-3-3-2-代码实现" class="headerlink" title="7.3.3.2 代码实现"></a>7.3.3.2 代码实现</h4><p><strong>1.</strong> 修改 <strong>e-commerce-gateway-20000</strong> 的 <strong>application.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">20000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">e-commerce-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="comment"># 启用 DiscoveryClient 服务发现</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment">#配置路由，可以配置多个 List&lt;RouteDefinition&gt; routes</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">member_route01</span> <span class="comment">#路由的id，程序员自行配置</span></span><br><span class="line">          <span class="comment"># 1. lb:负载均衡协议名称</span></span><br><span class="line">          <span class="comment">#    member-service-provider：注册到eureka server的服务名(小写)</span></span><br><span class="line">          <span class="comment"># 2. 默认情况下，负载均衡算法为轮询</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://member-service-provider</span></span><br><span class="line">          <span class="attr">predicates:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/member/get/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">member_route02</span> </span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://member-service-provider</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/member/save</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">member_route03</span> </span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://member-service-provider</span></span><br><span class="line">          <span class="attr">predicates:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/</span></span><br><span class="line"><span class="comment"># 配置Eureka Client</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">e-commerce-service</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span> <span class="comment">#将自己注册到Eureka-server</span></span><br><span class="line">    <span class="comment">#表示从Eureka-server抓取注册信息</span></span><br><span class="line">    <span class="comment">#如果是单节点，可以不配置；</span></span><br><span class="line">    <span class="comment">#但是provider是一个集群，则必须将此项配置为true，这样才能配合Ribbon使用负载均衡功能</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 表示将自己注册到哪个eureka-server</span></span><br><span class="line">      <span class="comment">#这里为了方便，就使用9001端口一个server</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka9001.com:9001/eureka</span></span><br></pre></td></tr></table></figure><h4 id="7-3-3-3-测试"><a href="#7-3-3-3-测试" class="headerlink" title="7.3.3.3 测试"></a>7.3.3.3 测试</h4><h5 id="7-3-3-3-1-启动-e-commerce-eureka-server-9001"><a href="#7-3-3-3-1-启动-e-commerce-eureka-server-9001" class="headerlink" title="7.3.3.3.1 启动 e-commerce-eureka-server-9001"></a>7.3.3.3.1 启动 e-commerce-eureka-server-9001</h5><h5 id="7-3-3-3-2-启动-member-service-provider-10000"><a href="#7-3-3-3-2-启动-member-service-provider-10000" class="headerlink" title="7.3.3.3.2 启动 member-service-provider-10000"></a>7.3.3.3.2 启动 member-service-provider-10000</h5><h5 id="7-3-3-3-3-启动-member-service-provider-10002"><a href="#7-3-3-3-3-启动-member-service-provider-10002" class="headerlink" title="7.3.3.3.3 启动 member-service-provider-10002"></a>7.3.3.3.3 启动 member-service-provider-10002</h5><h5 id="7-3-3-3-4-启动-e-commerce-gateway-20000"><a href="#7-3-3-3-4-启动-e-commerce-gateway-20000" class="headerlink" title="7.3.3.3.4 启动 e-commerce-gateway-20000"></a>7.3.3.3.4 启动 e-commerce-gateway-20000</h5><h5 id="7-3-3-3-5-浏览器-通过网关访问-http-localhost-20000-member-get-1"><a href="#7-3-3-3-5-浏览器-通过网关访问-http-localhost-20000-member-get-1" class="headerlink" title="7.3.3.3.5 浏览器**:(通过网关访问) http://localhost:20000/member/get/1**"></a>7.3.3.3.5 浏览器**:(<strong>通过网关访问</strong>) <a href="http://localhost:20000/member/get/1">http://localhost:20000/member/get/1</a>**</h5><p>​浏览器输入**: <a href="http://localhost:20000/member/get/1">http://localhost:20000/member/get/1</a>**</p><h4 id="7-3-3-4-注意事项和细节"><a href="#7-3-3-4-注意事项和细节" class="headerlink" title="7.3.3.4 注意事项和细节"></a>7.3.3.4 注意事项和细节</h4><h5 id="7-3-3-4-1-配置好动态路由后-Gateway-会根据注册中心上微服务名，为请求创建动态路由，实现-动态路由-功能"><a href="#7-3-3-4-1-配置好动态路由后-Gateway-会根据注册中心上微服务名，为请求创建动态路由，实现-动态路由-功能" class="headerlink" title="7.3.3.4.1 配置好动态路由后 Gateway 会根据注册中心上微服务名，为请求创建动态路由，实现 动态路由 功能"></a><strong>7.3.3.4.1</strong> 配置好动态路由后 <strong>Gateway</strong> 会根据注册中心上微服务名，为请求创建动态路由，实现 动态路由 功能</h5><h5 id="7-3-3-4-2-使用的-lb-协议支持负载均衡-轮询算法"><a href="#7-3-3-4-2-使用的-lb-协议支持负载均衡-轮询算法" class="headerlink" title="7.3.3.4.2 使用的 lb 协议支持负载均衡**-**轮询算法"></a><strong>7.3.3.4.2</strong> 使用的 <strong>lb</strong> 协议支持负载均衡**-**轮询算法</h5><h5 id="7-3-3-4-3-配置自己的负载均衡算法，-测试完毕恢复成原来的轮询算法"><a href="#7-3-3-4-3-配置自己的负载均衡算法，-测试完毕恢复成原来的轮询算法" class="headerlink" title="7.3.3.4.3 配置自己的负载均衡算法， 测试完毕恢复成原来的轮询算法"></a><strong>7.3.3.4.3</strong> 配置自己的负载均衡算法， 测试完毕恢复成原来的轮询算法</h5><h2 id="7-4-Predicate-x2F-断言"><a href="#7-4-Predicate-x2F-断言" class="headerlink" title="7.4 Predicate&#x2F;断言"></a>7.4 Predicate&#x2F;断言</h2><h3 id="7-4-1-基本介绍"><a href="#7-4-1-基本介绍" class="headerlink" title="7.4.1 基本介绍"></a><strong>7.4.1</strong> 基本介绍</h3><h4 id="7-4-1-1-一句话-Predicate-就是一组匹配规则，当请求匹配成功，就执行对应Route-匹配失败，放弃-处理-x2F-转发"><a href="#7-4-1-1-一句话-Predicate-就是一组匹配规则，当请求匹配成功，就执行对应Route-匹配失败，放弃-处理-x2F-转发" class="headerlink" title="7.4.1.1 一句话: Predicate 就是一组匹配规则，当请求匹配成功，就执行对应Route, 匹配失败，放弃 处理&#x2F;转发"></a>7.4.1.1 一句话: Predicate 就是一组匹配规则，当请求匹配成功，就执行对应Route, 匹配失败，放弃 处理&#x2F;转发</h4><h4 id="7-4-1-2-RoutePredicateFactories"><a href="#7-4-1-2-RoutePredicateFactories" class="headerlink" title="7.4.1.2 RoutePredicateFactories"></a>7.4.1.2 RoutePredicateFactories</h4><p><strong>文档地址</strong>: <a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories</a></p><ul><li>Spring Cloud Gateway包括许多内置的Route Predicate工厂，所有这些Predicate都与HTTP请求的不同属性匹配，可以组合使用．</li><li>Spring Cloud Gateway 创建 Route 对象时，使用RoutePredicateFactory 创建Predicate对象，Predicate 对象可以赋值给Route。</li><li>所有这些谓词都匹配HTTP请求的不同属性。多种谓词工厂可以组合</li></ul><p>其实就是利用工厂中的api进行断言</p><h3 id="7-4-2-RoutePredicate实例-根据上述文档进行操作演示"><a href="#7-4-2-RoutePredicate实例-根据上述文档进行操作演示" class="headerlink" title="7.4.2 RoutePredicate实例(根据上述文档进行操作演示)"></a>7.4.2 RoutePredicate实例(根据上述文档进行操作演示)</h3><h4 id="7-4-2-1-AfterRoutePredicate"><a href="#7-4-2-1-AfterRoutePredicate" class="headerlink" title="7.4.2.1 AfterRoutePredicate"></a>7.4.2.1 AfterRoutePredicate</h4><h5 id="7-4-2-1-1-需求分析-x2F-图解"><a href="#7-4-2-1-1-需求分析-x2F-图解" class="headerlink" title="7.4.2.1.1 需求分析**&#x2F;**图解"></a><strong>7.4.2.1.1</strong> 需求分析**&#x2F;**图解</h5><p><strong>1.</strong> 需求分析**&#x2F;**图解</p><p>​需求**:** 只有 2022-11-18 12:35:50 <u><strong>之后</strong></u>的请求才进行匹配**&#x2F;<strong>转发</strong>,** 不满足该条件的，不处理</p><h5 id="7-4-2-1-2-代码实现"><a href="#7-4-2-1-2-代码实现" class="headerlink" title="7.4.2.1.2 代码实现"></a><strong>7.4.2.1.2</strong> 代码实现</h5><h5 id="1-参考文档-https-cloud-spring-io-spring-cloud-static-spring-cloud-gateway-2-2-1-RELEASE-reference-html-gateway-request-predicates-factories"><a href="#1-参考文档-https-cloud-spring-io-spring-cloud-static-spring-cloud-gateway-2-2-1-RELEASE-reference-html-gateway-request-predicates-factories" class="headerlink" title="1. 参考文档 : https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories"></a><strong>1.</strong> 参考文档 <strong>: <a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories</a></strong></h5><p><strong>2.</strong> <strong>修改</strong> <strong>e-commerce-gateway-20000</strong> <strong>的</strong> <strong>application.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">after_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">After=2017-01-20T17:42:47.789-07:00[America/Denver]</span></span><br></pre></td></tr></table></figure><h4 id="7-4-2-2-BeforeRoutePredicate"><a href="#7-4-2-2-BeforeRoutePredicate" class="headerlink" title="7.4.2.2 BeforeRoutePredicate"></a>7.4.2.2 BeforeRoutePredicate</h4><p><strong>1.</strong> 需求分析**&#x2F;**图解</p><p>需求**:** 只有 2022-11-18 12:35:50 <u><strong>之前</strong></u>的请求才进行匹配**&#x2F;<strong>转发</strong>,** 不满足该条件的，不处理</p><h5 id="7-4-2-2-2-代码实现"><a href="#7-4-2-2-2-代码实现" class="headerlink" title="7.4.2.2.2 代码实现"></a><strong>7.4.2.2.2</strong> 代码实现</h5><p><strong>1.</strong> 参考文档 <strong>: <a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories</a></strong></p><p><strong>2.</strong> <strong>修改</strong> <strong>e-commerce-gateway-20000</strong> <strong>的</strong> <strong>application.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">before_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Before=2017-01-20T17:42:47.789-07:00[America/Denver]</span></span><br></pre></td></tr></table></figure><h4 id="7-4-2-3-BetweenRoutePredicate"><a href="#7-4-2-3-BetweenRoutePredicate" class="headerlink" title="7.4.2.3 BetweenRoutePredicate"></a>7.4.2.3 BetweenRoutePredicate</h4><p><strong>1.</strong> 需求分析**&#x2F;**图解</p><p>需求**:** 只有 <strong>2020-11-18 12:35:50</strong> 和 <strong>2022-11-18 12:35:50</strong> <u><em>之间</em></u> 的请求才进行匹配**&#x2F;<strong>转 发</strong>,** 不满足该条件的，不处理</p><h5 id="7-4-2-3-2-代码实现"><a href="#7-4-2-3-2-代码实现" class="headerlink" title="7.4.2.3.2 代码实现"></a><strong>7.4.2.3.2</strong> 代码实现</h5><p><strong>1.</strong> 参考文档 <strong>: <a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories</a></strong></p><p><strong>2.</strong> <strong>修改</strong> <strong>e-commerce-gateway-20000</strong> <strong>的</strong> <strong>application.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">between_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Between=2017-01-20T17:42:47.789-07:00[America/Denver],</span> <span class="number">2017-01-21T17:42:47.789-07:00</span>[<span class="string">America/Denver</span>]</span><br></pre></td></tr></table></figure><h4 id="7-4-2-4-CookieRoutePredicate"><a href="#7-4-2-4-CookieRoutePredicate" class="headerlink" title="7.4.2.4 CookieRoutePredicate"></a>7.4.2.4 CookieRoutePredicate</h4><h5 id="7-4-2-4-1-需求分析-x2F-图解"><a href="#7-4-2-4-1-需求分析-x2F-图解" class="headerlink" title="7.4.2.4.1 需求分析**&#x2F;**图解"></a><strong>7.4.2.4.1</strong> 需求分析**&#x2F;**图解</h5><p>​需求**:** 请求带有 <strong>cookie</strong> 键**: user** 值**: hsp** 才匹配**&#x2F;**断言成功</p><p><strong>1.4.2.4.2</strong> 代码实现</p><p><strong>1.</strong> 参考文档 <strong>: <a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories</a></strong></p><p><strong>2.</strong> <strong>修改</strong> <strong>e-commerce-gateway-20000</strong> <strong>的</strong> <strong>application.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">cookie_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Cookie=chocolate,</span> <span class="string">ch.p</span></span><br><span class="line">        <span class="comment"># chocolate 是 cookie 名字 ch.p 是 cookie 的值，是按照正则表达式来匹配的</span></span><br></pre></td></tr></table></figure><h4 id="7-4-2-5-HeaderRoutePredicate"><a href="#7-4-2-5-HeaderRoutePredicate" class="headerlink" title="7.4.2.5 HeaderRoutePredicate"></a>7.4.2.5 HeaderRoutePredicate</h4><h5 id="7-4-2-5-1-需求分析-x2F-图解"><a href="#7-4-2-5-1-需求分析-x2F-图解" class="headerlink" title="7.4.2.5.1 需求分析**&#x2F;**图解"></a><strong>7.4.2.5.1</strong> 需求分析**&#x2F;**图解</h5><p><strong>1.</strong> 需求分析**&#x2F;**图解</p><p><strong>需求</strong>: <strong>请求头</strong> <strong>Header</strong> <strong>有</strong> <strong>X-Request-Id</strong>， 并且值为xxxxx 才匹配&#x2F;断言成功</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">header_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br><span class="line">        <span class="comment"># X-Request-Id 是 header 的名称, \d+ 是一个正则表达式</span></span><br></pre></td></tr></table></figure><h4 id="7-4-2-6-HostRoutePredicate"><a href="#7-4-2-6-HostRoutePredicate" class="headerlink" title="7.4.2.6 HostRoutePredicate"></a>7.4.2.6 HostRoutePredicate</h4><h5 id="7-4-2-6-1-需求分析-x2F-图解"><a href="#7-4-2-6-1-需求分析-x2F-图解" class="headerlink" title="7.4.2.6.1 需求分析**&#x2F;**图解"></a><strong>7.4.2.6.1</strong> 需求分析**&#x2F;**图解</h5><p><strong>1.</strong> 需求分析**&#x2F;**图解</p><p>需求： <strong>请求</strong> <strong>Host</strong> <strong>是</strong><em><strong>*.hspedu.*</strong></em> 才匹配&#x2F;断言成功 <strong>,</strong> <strong>比如</strong> <strong>Host： <a href="http://www.hspedu.com/">www.hspedu.com</a></strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">host_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Host=**.somehost.org,**.anotherhost.org</span></span><br><span class="line">        <span class="comment">#Host 可以有多个, 使用逗号间隔</span></span><br></pre></td></tr></table></figure><h4 id="7-4-2-7-MethodRoutePredicate"><a href="#7-4-2-7-MethodRoutePredicate" class="headerlink" title="7.4.2.7 MethodRoutePredicate"></a>7.4.2.7 MethodRoutePredicate</h4><p><strong>1.4.2.7.1</strong> 需求分析**&#x2F;**图解</p><p><strong>需求</strong>: <strong>请求是</strong> <strong>XXXXXX</strong> <strong>方式才匹配</strong>&#x2F;<strong>断言成功</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Method=GET,POST</span></span><br><span class="line">        <span class="comment"># 请求方式可以有多个, 使用逗号间隔</span></span><br></pre></td></tr></table></figure><h4 id="7-4-2-8-PathRoutePredicate"><a href="#7-4-2-8-PathRoutePredicate" class="headerlink" title="7.4.2.8 PathRoutePredicate"></a>7.4.2.8 PathRoutePredicate</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">host_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/red/&#123;segment&#125;,/blue/&#123;segment&#125;</span></span><br><span class="line">        <span class="comment"># Path 可以有多个, 使用逗号间隔</span></span><br></pre></td></tr></table></figure><h4 id="7-4-2-9-QueryRoutePredicate"><a href="#7-4-2-9-QueryRoutePredicate" class="headerlink" title="7.4.2.9 QueryRoutePredicate"></a>7.4.2.9 QueryRoutePredicate</h4><h5 id="1-4-2-9-1-需求分析-x2F-图解"><a href="#1-4-2-9-1-需求分析-x2F-图解" class="headerlink" title="1.4.2.9.1 需求分析**&#x2F;**图解"></a><strong>1.4.2.9.1</strong> 需求分析**&#x2F;**图解</h5><p>需求**:** 请求有参数 <strong>email ,<strong>并且满足电子邮件的基本格式</strong>,</strong> 才能匹配**&#x2F;**断言成功</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">query_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Query=red,</span> <span class="string">gree.</span></span><br><span class="line">        <span class="comment">#red 是参数名 gree. 是值, 支持正则表达式.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#对应邮箱：</span></span><br><span class="line">      <span class="comment"># - Query=email, [\w-]+@([a-zA-Z]+\.)+[a-zA-Z]+</span></span><br></pre></td></tr></table></figure><h4 id="7-4-2-10-RemoteAddr-Route-Predicate"><a href="#7-4-2-10-RemoteAddr-Route-Predicate" class="headerlink" title="7.4.2.10 RemoteAddr Route Predicate"></a>7.4.2.10 RemoteAddr Route Predicate</h4><h5 id="7-4-2-10-1-需求分析-x2F-图解"><a href="#7-4-2-10-1-需求分析-x2F-图解" class="headerlink" title="7.4.2.10.1 需求分析**&#x2F;**图解"></a><strong>7.4.2.10.1</strong> 需求分析**&#x2F;**图解</h5><p><strong>需求</strong>: <strong>请求的</strong> <strong>IP</strong> <strong>是</strong> <strong>127.0.0.1,</strong> <strong>才能匹配</strong>&#x2F;断言成功</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">remoteaddr_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">RemoteAddr=192.168.1.1/24</span></span><br></pre></td></tr></table></figure><h2 id="7-5-Filter-x2F-过滤器"><a href="#7-5-Filter-x2F-过滤器" class="headerlink" title="7.5 Filter&#x2F;过滤器"></a>7.5 Filter&#x2F;过滤器</h2><h3 id="7-5-1-基本介绍"><a href="#7-5-1-基本介绍" class="headerlink" title="7.5.1 基本介绍"></a><strong>7.5.1</strong> 基本介绍</h3><p><strong>1.</strong> 文档地址 <strong>: <a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gatewayfilter-factories">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gatewayfilter-factories</a></strong></p><p> <strong>路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应</strong></p><p><strong>Spring Cloud Gateway 内置了多种路由过滤器，他们都由GatewayFilter的工厂类来产生</strong></p><h3 id="7-5-2-类型"><a href="#7-5-2-类型" class="headerlink" title="7.5.2 类型"></a><strong>7.5.2</strong> 类型</h3><h4 id="7-5-2-1-GatewayFilter"><a href="#7-5-2-1-GatewayFilter" class="headerlink" title="7.5.2.1 GatewayFilter"></a>7.5.2.1 GatewayFilter</h4><h4 id="7-5-2-2-GlobalFilter"><a href="#7-5-2-2-GlobalFilter" class="headerlink" title="7.5.2.2 GlobalFilter"></a>7.5.2.2 GlobalFilter</h4><p>一般很少使用官方的filter，都是自定义满足需求，因此只介绍一个官方filter</p><h3 id="7-5-3-GatewayFilter使用"><a href="#7-5-3-GatewayFilter使用" class="headerlink" title="7.5.3 GatewayFilter使用"></a><strong>7.5.3 GatewayFilter</strong>使用</h3><h4 id="7-5-3-1-开发直接使用-GatewayFilter-较少，一般是自定义过滤器"><a href="#7-5-3-1-开发直接使用-GatewayFilter-较少，一般是自定义过滤器" class="headerlink" title="7.5.3.1 开发直接使用 GatewayFilter 较少，一般是自定义过滤器"></a>7.5.3.1 开发直接使用 GatewayFilter 较少，一般是自定义过滤器</h4><p>​演示：The AddRequestParameter GatewayFilter Factory</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">add_request_parameter_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestParameter=color,</span> <span class="string">blue</span></span><br></pre></td></tr></table></figure><h3 id="7-5-4-自定义-GlobalFilter"><a href="#7-5-4-自定义-GlobalFilter" class="headerlink" title="7.5.4 自定义 GlobalFilter"></a><strong>7.5.4</strong> 自定义 <strong>GlobalFilter</strong></h3><h4 id="7-5-4-1-需求分析-x2F-图解"><a href="#7-5-4-1-需求分析-x2F-图解" class="headerlink" title="7.5.4.1 需求分析&#x2F;图解"></a>7.5.4.1 需求分析&#x2F;图解</h4><p><strong>1.</strong> 自定义全局 <strong>GlobalFilter</strong> 过滤器<br><strong>2.</strong> 如果请求参数 <strong>user&#x3D;hspedu , pwd&#x3D;123456</strong> 则放行**,** 否则不能通过验证</p><h4 id="7-5-4-2-代码实现"><a href="#7-5-4-2-代码实现" class="headerlink" title="7.5.4.2 代码实现"></a>7.5.4.2 代码实现</h4><p><strong>1.</strong> 在 <strong>e-commerce-gateway-20000</strong> 创建<strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;filter&#x2F;CustomGateWayFilter.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.springcloud.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/6/1</span></span><br><span class="line"><span class="comment"> * 11:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomGateWayFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//filter是核心的方法，将我们的过滤业务写在该方法中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">//先获取到对应的参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span></span><br><span class="line">                exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span></span><br><span class="line">                exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!(<span class="string">&quot;hspedu&quot;</span>.equals(user) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(pwd)))&#123;</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示过滤器执行的顺序，数字越小，优先级越高</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-5-4-3-测试"><a href="#7-5-4-3-测试" class="headerlink" title="7.5.4.3 测试"></a>7.5.4.3 测试</h4><h5 id="7-5-4-3-1-启动-e-commerce-eureka-server-9001"><a href="#7-5-4-3-1-启动-e-commerce-eureka-server-9001" class="headerlink" title="7.5.4.3.1 启动 e-commerce-eureka-server-9001"></a><strong>7.5.4.3.1</strong> 启动 e-commerce-eureka-server-9001</h5><h5 id="7-5-4-3-2-启动-member-service-provider-10000-x2F-10002"><a href="#7-5-4-3-2-启动-member-service-provider-10000-x2F-10002" class="headerlink" title="7.5.4.3.2 启动 member-service-provider-10000&#x2F;10002"></a>7.5.4.3.2 启动 member-service-provider-10000&#x2F;10002</h5><h5 id="7-5-4-3-3-启动-e-commerce-gateway-20000"><a href="#7-5-4-3-3-启动-e-commerce-gateway-20000" class="headerlink" title="7.5.4.3.3 启动 e-commerce-gateway-20000"></a>7.5.4.3.3 启动 e-commerce-gateway-20000</h5><h5 id="7-5-4-3-4-浏览器-通过网关访问-http-localhost-20000-member-get-1-user-hspedu-amp-pwd-123456-输入-http-localhost-20000-member-get-1-user-hspedu-amp-pwd-123456"><a href="#7-5-4-3-4-浏览器-通过网关访问-http-localhost-20000-member-get-1-user-hspedu-amp-pwd-123456-输入-http-localhost-20000-member-get-1-user-hspedu-amp-pwd-123456" class="headerlink" title="7.5.4.3.4 浏览器**:(通过网关访问) http://localhost:20000/member/get/1?user=hspedu&amp;pwd=123456** 输入**: http://localhost:20000/member/get/1?user=hspedu&amp;pwd=123456**"></a>7.5.4.3.4 浏览器**:(<strong>通过网关访问</strong>) <a href="http://localhost:20000/member/get/1?user=hspedu&pwd=123456">http://localhost:20000/member/get/1?user=hspedu&amp;pwd=123456</a>** 输入**: <a href="http://localhost:20000/member/get/1?user=hspedu&pwd=123456">http://localhost:20000/member/get/1?user=hspedu&amp;pwd=123456</a>**</h5><h4 id="7-5-4-4-测试完毕，记得代码恢复到测试前"><a href="#7-5-4-4-测试完毕，记得代码恢复到测试前" class="headerlink" title="7.5.4.4 测试完毕，记得代码恢复到测试前"></a>7.5.4.4 测试完毕，记得代码恢复到测试前</h4><h1 id="8-SpringCloud-Sleuth-Zipkin-服务跟踪"><a href="#8-SpringCloud-Sleuth-Zipkin-服务跟踪" class="headerlink" title="8 SpringCloud Sleuth+Zipkin 服务跟踪"></a>8 SpringCloud Sleuth+Zipkin 服务跟踪</h1><h2 id="8-1-Sleuth-x2F-ZipKin基础"><a href="#8-1-Sleuth-x2F-ZipKin基础" class="headerlink" title="8.1 Sleuth&#x2F;ZipKin基础"></a>8.1 Sleuth&#x2F;ZipKin基础</h2><h3 id="8-1-1-官网"><a href="#8-1-1-官网" class="headerlink" title="8.1.1 官网"></a><strong>8.1.1</strong> 官网</h3><h4 id="8-1-1-1-https-github-com-spring-cloud-spring-cloud-sleuth"><a href="#8-1-1-1-https-github-com-spring-cloud-spring-cloud-sleuth" class="headerlink" title="8.1.1.1 https://github.com/spring-cloud/spring-cloud-sleuth"></a>8.1.1.1 <a href="https://github.com/spring-cloud/spring-cloud-sleuth">https://github.com/spring-cloud/spring-cloud-sleuth</a></h4><h3 id="8-1-2-Sleuth-x2F-Zipkin是什么"><a href="#8-1-2-Sleuth-x2F-Zipkin是什么" class="headerlink" title="8.1.2 Sleuth&#x2F;Zipkin是什么?"></a><strong>8.1.2 Sleuth&#x2F;Zipkin</strong>是什么?</h3><h4 id="8-1-2-1-概述-两张图"><a href="#8-1-2-1-概述-两张图" class="headerlink" title="8.1.2.1 概述(两张图)"></a>8.1.2.1 概述(两张图)</h4><ol><li><p>在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的服务节点调用**,** 来协同产生最后的请求结果，每一个请求都会形成一条复杂的分布式服务调用链路</p></li><li><p>链路中的任何一环出现高延时或错误都会引起整个请求最后的失败,因此<u>对整个服务的调用进行链路追踪和分析</u>就非常的重要</p></li><li><p>Sleuth 和 Zipkin简单关系图</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230601125136474.png" alt="image-20230601125136474"></p><h4 id="8-1-2-2-一句话-Sleuth-提供了一套完整的服务跟踪的解决方案-并兼容-Zipkin"><a href="#8-1-2-2-一句话-Sleuth-提供了一套完整的服务跟踪的解决方案-并兼容-Zipkin" class="headerlink" title="8.1.2.2 一句话: Sleuth 提供了一套完整的服务跟踪的解决方案 并兼容 Zipkin"></a>8.1.2.2 一句话: Sleuth 提供了一套完整的服务跟踪的解决方案 并兼容 Zipkin</h4><h4 id="8-1-2-3-梳理-🌟Sleuth-做链路追踪-Zipkin-做数据搜集-x2F-存储-x2F-可视化"><a href="#8-1-2-3-梳理-🌟Sleuth-做链路追踪-Zipkin-做数据搜集-x2F-存储-x2F-可视化" class="headerlink" title="8.1.2.3 梳理: 🌟Sleuth 做链路追踪 , Zipkin 做数据搜集&#x2F;存储&#x2F;可视化"></a>8.1.2.3 梳理: 🌟<u>Sleuth 做链路追踪 , Zipkin 做数据搜集&#x2F;存储&#x2F;可视化</u></h4><h3 id="8-1-3-Sleuth工作原理"><a href="#8-1-3-Sleuth工作原理" class="headerlink" title="8.1.3 Sleuth工作原理"></a><strong>8.1.3 Sleuth</strong>工作原理</h3><p><strong>1. Span</strong> 和 <strong>Trace</strong> 在一个系统中使用 <strong>Zipkin</strong> 的过程**-**图形化</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230603152155135.png" alt="image-20230603152155135"></p><ul><li><p>表示一请求链路，一条链路通过Trace id唯一标识，span标识发起的请求信息，各span通过parent id关联起来</p></li><li><p>Trace：类似于树结构的Span集合，表示一条调用链路，存在唯一标识 (一条请求链路只有唯一一个Trace id)</p></li><li><p>Span：基本工作单元，表示调用链路来源，通俗的理解span就是一次请求信息</p></li></ul><p><strong>2. spans</strong> <strong>的</strong> <strong>parent&#x2F;child</strong> <strong>关系图形化</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230603152459615.png" alt="image-20230603152459615"></p><ul><li><p>小伙伴注意看老师标识的红线，后一个span节点的parentid 指向&#x2F;记录 了上一个Span结点</p></li><li><p>span就是一次请求信息</p></li><li><p>多个Span集合就构成<u>一条调用链路</u></p></li><li><p>在span&#x3D;C 这个节点存在分支</p></li></ul><h2 id="8-2-Sleuth-x2F-ZipKin-搭建链路监控实例"><a href="#8-2-Sleuth-x2F-ZipKin-搭建链路监控实例" class="headerlink" title="8.2 Sleuth&#x2F;ZipKin-搭建链路监控实例"></a>8.2 Sleuth&#x2F;ZipKin-搭建链路监控实例</h2><h3 id="8-2-1-需求说明-x2F-图解"><a href="#8-2-1-需求说明-x2F-图解" class="headerlink" title="8.2.1 需求说明**&#x2F;**图解"></a><strong>8.2.1</strong> 需求说明**&#x2F;**图解</h3><p><strong>要求</strong>: <strong>通过</strong> <strong>Sleuth</strong> <strong>和</strong> <strong>Zipkin</strong> <strong>可以对</strong>服务调用链路<strong>进行监控</strong>, <strong>并在</strong> <strong>Zipkin</strong> <strong>进行显示</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230603152942262.png" alt="image-20230603152942262"></p><h3 id="8-2-2-安装-x2F-使用-Zipkin"><a href="#8-2-2-安装-x2F-使用-Zipkin" class="headerlink" title="8.2.2 安装**&#x2F;**使用 Zipkin"></a><strong>8.2.2</strong> 安装**&#x2F;**使用 <strong>Zipkin</strong></h3><h4 id="8-2-2-1-下载"><a href="#8-2-2-1-下载" class="headerlink" title="8.2.2.1 下载"></a>8.2.2.1 下载</h4><ol><li><p>下载地址：<a href="https://repo1.maven.org/maven2/io/zipkin/zipkin-server/">https://repo1.maven.org/maven2/io/zipkin/zipkin-server/</a></p></li><li><p>得到 zipkin-server-2.14.1-exec.jar</p></li></ol><h4 id="8-2-2-2-运行"><a href="#8-2-2-2-运行" class="headerlink" title="8.2.2.2 运行"></a>8.2.2.2 运行</h4><ol><li>进入 zipkin-server-2.14.1-exec.jar 所在目录的终端</li><li>执行命令  java -jar zipkin-server-2.14.1-exec.jar    开启zipkin服务</li></ol><h4 id="8-2-2-3-访问"><a href="#8-2-2-3-访问" class="headerlink" title="8.2.2.3 访问"></a>8.2.2.3 访问</h4><p>​浏览器输入**:<a href="http://localhost:9411/zipkin/">http://localhost:9411/zipkin/</a>**</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230603225430611.png" alt="image-20230603225430611"></p><h3 id="8-2-3-服务提供方集成-Sleuth-x2F-Zipkin"><a href="#8-2-3-服务提供方集成-Sleuth-x2F-Zipkin" class="headerlink" title="8.2.3 服务提供方集成 Sleuth&#x2F;Zipkin"></a><strong>8.2.3</strong> 服务提供方集成 <strong>Sleuth&#x2F;Zipkin</strong></h3><p><strong>1.</strong> 修改 <strong>member-service-provider-10000</strong> 的 <strong>pom.xml ,</strong> 增加引入 <strong>sleuth+zipkin</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    引入sleuth与zipkin相关依赖    --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--包含了 sleuth+zipkin--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230603230040079.png" alt="image-20230603230040079" style="zoom:50%;" /><p><strong>2.</strong> <strong>修改</strong> <strong>member-service-provider-10000</strong> <strong>的</strong> <strong>appliaction.xml ,</strong> <strong>指定</strong> <strong>Zipkin</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">member-service-provider</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/e_commerce_center_db?serverTimezone=GMT%2B8&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">QWEASDzxc123</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="comment">#配置sleuth和zipkin</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://localhost:9411</span></span><br><span class="line">  <span class="attr">sleuth:</span></span><br><span class="line">    <span class="attr">sampler:</span></span><br><span class="line">      <span class="comment"># 采样率 在0～1之间，1表示全部采集</span></span><br><span class="line">      <span class="attr">probability:</span> <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.study.springcloud.entity</span></span><br><span class="line"><span class="comment">#配置eureka-client</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span> <span class="comment">#将自己注册到Eureka-server</span></span><br><span class="line">    <span class="comment">#表示从Eureka-server抓取注册信息</span></span><br><span class="line">    <span class="comment">#如果是单节点，可以不配置；</span></span><br><span class="line">    <span class="comment">#但是provider是一个集群，则必须将此项配置为true，这样才能配合Ribbon使用负载均衡功能</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 表示将自己注册到哪个eureka-</span></span><br><span class="line">      <span class="comment"># 将本服务注册到多个eureka-server，使用逗号间隔即可</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka9001.com:9001/eureka,http://eureka9002.com:9002/eureka</span></span><br><span class="line"><span class="comment">#  instance:</span></span><br><span class="line">    <span class="comment">#1秒发送一次心跳(默认是90秒</span></span><br><span class="line"><span class="comment">#    lease-renewal-interval-in-seconds: 1</span></span><br><span class="line">    <span class="comment">#服务端收到最后一次心跳后的等待时间上限</span></span><br><span class="line"><span class="comment">#    lease-expiration-duration-in-seconds: 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-2-4-服务消费方集成-Sleuth-x2F-Zipkin"><a href="#8-2-4-服务消费方集成-Sleuth-x2F-Zipkin" class="headerlink" title="8.2.4 服务消费方集成 Sleuth&#x2F;Zipkin"></a>8.2.4 服务消费方集成 Sleuth&#x2F;Zipkin</h3><p><strong>1.</strong> 修改 <strong>member-service-consumer-80</strong> 的 <strong>pom.xml ,</strong> 增加引入 <strong>sleuth+zipkin</strong></p><p><strong>2.</strong> 修改 <strong>member-service-consumer-80</strong> 的 <strong>appliaction.xml ,</strong> 指定 <strong>Zipkin</strong></p><h3 id="8-2-5-测试"><a href="#8-2-5-测试" class="headerlink" title="8.2.5 测试"></a><strong>8.2.5</strong> 测试</h3><h4 id="8-2-5-1-启动-e-commerce-eureka-server-9001"><a href="#8-2-5-1-启动-e-commerce-eureka-server-9001" class="headerlink" title="8.2.5.1 启动 e-commerce-eureka-server-9001"></a>8.2.5.1 启动 e-commerce-eureka-server-9001</h4><h4 id="8-2-5-2-启动-member-service-provider-10000"><a href="#8-2-5-2-启动-member-service-provider-10000" class="headerlink" title="8.2.5.2 启动 member-service-provider-10000"></a>8.2.5.2 启动 member-service-provider-10000</h4><h4 id="8-2-5-3-启动-member-service-consumer-80"><a href="#8-2-5-3-启动-member-service-consumer-80" class="headerlink" title="8.2.5.3 启动 member-service-consumer-80"></a>8.2.5.3 启动 member-service-consumer-80</h4><h4 id="8-2-5-4-浏览器-浏览器输入-http-localhost-member-consumer-get-1"><a href="#8-2-5-4-浏览器-浏览器输入-http-localhost-member-consumer-get-1" class="headerlink" title="8.2.5.4 浏览器: 浏览器输入: http://localhost/member/consumer/get/1"></a>8.2.5.4 浏览器: 浏览器输入: <a href="http://localhost/member/consumer/get/1">http://localhost/member/consumer/get/1</a></h4><h3 id="8-2-6-查看监控-amp-分析结果"><a href="#8-2-6-查看监控-amp-分析结果" class="headerlink" title="8.2.6 查看监控**&amp;**分析结果"></a>8.2.6 查看监控**&amp;**分析结果</h3><h4 id="8-2-6-1-查看监控-amp-分析结果"><a href="#8-2-6-1-查看监控-amp-分析结果" class="headerlink" title="8.2.6.1 查看监控&amp;分析结果"></a>8.2.6.1 查看监控&amp;分析结果</h4><p><strong>1.</strong> 查看 **Zipkin : <a href="http://localhost:9411/zipkin/">http://localhost:9411/zipkin/</a> **</p><p><strong>2.</strong> <strong>选择某个服务，看结果</strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230604102426067.png" alt="image-20230604102426067" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230604102442418.png" alt="image-20230604102442418" style="zoom:50%;" /><p><strong>3.</strong> 查看一次调用链路的深度，以及该链路包含请求,各个请求耗时，**<u><em>找到请求瓶颈，为优化提供依据</em></u>**(重要)</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230604102455803.png" alt="image-20230604102455803" style="zoom:50%;" /><p><strong>4.</strong> <strong>查看服务调用的依赖关系</strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230604102509066.png" alt="image-20230604102509066" style="zoom:50%;" /><h1 id="9-🌟SpringCloudAlibabaNacos-服务注册中心-服务配置"><a href="#9-🌟SpringCloudAlibabaNacos-服务注册中心-服务配置" class="headerlink" title="9 🌟SpringCloudAlibabaNacos 服务注册中心+服务配置"></a>9 🌟SpringCloudAlibabaNacos 服务注册中心+服务配置</h1><h2 id="9-1-Nacos基础"><a href="#9-1-Nacos基础" class="headerlink" title="9.1 Nacos基础"></a>9.1 Nacos基础</h2><h3 id="9-1-1-官网"><a href="#9-1-1-官网" class="headerlink" title="9.1.1 官网"></a>9.1.1 官网</h3><h4 id="9-1-1-1-https-github-com-alibaba-Nacos"><a href="#9-1-1-1-https-github-com-alibaba-Nacos" class="headerlink" title="9.1.1.1 https://github.com/alibaba/Nacos"></a>9.1.1.1 <a href="https://github.com/alibaba/Nacos">https://github.com/alibaba/Nacos</a></h4><h3 id="9-1-2-Nacos是什么"><a href="#9-1-2-Nacos是什么" class="headerlink" title="9.1.2 Nacos是什么?"></a>9.1.2 Nacos是什么?</h3><h4 id="9-1-2-1-一句话-Nacos-就是注册中心-替代-Eureka-配置中心-替代-Config"><a href="#9-1-2-1-一句话-Nacos-就是注册中心-替代-Eureka-配置中心-替代-Config" class="headerlink" title="9.1.2.1 一句话: Nacos 就是注册中心[替代 Eureka]+配置中心[替代 Config]"></a>9.1.2.1 一句话: <u>Nacos 就是注册中心[替代 Eureka]+配置中心[替代 Config]</u></h4><h4 id="9-1-2-2-Nacos-Dynamic-Naming-and-Configuration-Service"><a href="#9-1-2-2-Nacos-Dynamic-Naming-and-Configuration-Service" class="headerlink" title="9.1.2.2 Nacos:Dynamic Naming and Configuration Service"></a>9.1.2.2 Nacos:Dynamic Naming and Configuration Service</h4><h4 id="9-1-2-3-Nacos-架构理论基础-CAP-理论-支持-AP-和-CP-可以切换"><a href="#9-1-2-3-Nacos-架构理论基础-CAP-理论-支持-AP-和-CP-可以切换" class="headerlink" title="9.1.2.3 Nacos:架构理论基础: CAP 理论 (支持 AP 和 CP, 可以切换)"></a>9.1.2.3 Nacos:架构理论基础: CAP 理论 (支持 AP 和 CP, 可以切换)</h4><p>CAP理论：</p><p>​一个分布式系统最多只能同时满足<strong>一致性</strong>（Consistency）、<strong>可用性</strong>（Availability）和<strong>分区容错性</strong>（Partition tolerance）这三项中的两项。</p><ul><li><strong>一致性</strong>指 “all nodes see the same data at the same time”，即所有节点在同一时间的数据完全一致。即多副本（Replications）问题中的数据一致性</li><li><strong>可用性</strong>指“<code>Reads and writes always succeed</code>”，即服务在正常响应时间内一直可用。好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。</li><li><strong>分区容错性</strong>指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务。</li></ul><p>比如对于两个结点如果它们之间的网络断开了，我们假设需要满足分区容错性，那么一定要在一致性和可用性之间进行取舍(分区容错性满足的情况下，如果满足一致性那就必须等待网络恢复后数据进行同步后才能提供服务——放弃了可用性；反之，如果选择了可用性，那么两个结点提供的数据一定不能保证一致性——牺牲了一致性)</p><h3 id="9-1-3-Nacos下载-amp-运行"><a href="#9-1-3-Nacos下载-amp-运行" class="headerlink" title="9.1.3 Nacos下载&amp;运行"></a>9.1.3 Nacos下载&amp;运行</h3><h4 id="9-1-3-1-下载-https-github-com-alibaba-nacos-releases-tag-1-2-1"><a href="#9-1-3-1-下载-https-github-com-alibaba-nacos-releases-tag-1-2-1" class="headerlink" title="9.1.3.1 下载: https://github.com/alibaba/nacos/releases/tag/1.2.1"></a>9.1.3.1 下载: <a href="https://github.com/alibaba/nacos/releases/tag/1.2.1">https://github.com/alibaba/nacos/releases/tag/1.2.1</a></h4><h4 id="9-1-3-2-环境要求-Java8-x2F-Maven-3-2-x"><a href="#9-1-3-2-环境要求-Java8-x2F-Maven-3-2-x" class="headerlink" title="9.1.3.2 环境要求: Java8&#x2F;Maven 3.2.x+"></a>9.1.3.2 环境要求: Java8&#x2F;Maven 3.2.x+</h4><h4 id="9-1-3-3-解压"><a href="#9-1-3-3-解压" class="headerlink" title="9.1.3.3 解压"></a>9.1.3.3 解压</h4><p>在我的mac中执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /Applications/nacos/bin//因为我把nacos放在了/Applications目录下</span><br><span class="line">sh startup.sh -m standalone//在nacos/bin目录下执行该语句即可成功启动nacos服务</span><br><span class="line">sh shutdown.sh//关闭nacos</span><br></pre></td></tr></table></figure><h4 id="9-1-3-4-浏览器-http-localhost-8848-nacos"><a href="#9-1-3-4-浏览器-http-localhost-8848-nacos" class="headerlink" title="9.1.3.4 浏览器 http://localhost:8848/nacos"></a>9.1.3.4 浏览器 <a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a></h4><h4 id="9-1-3-5-用户名-x2F-密码-为-nacos"><a href="#9-1-3-5-用户名-x2F-密码-为-nacos" class="headerlink" title="9.1.3.5 用户名&#x2F;密码 为 nacos"></a>9.1.3.5 用户名&#x2F;密码 为 nacos</h4><h2 id="9-2-创建-Nacos-服务提供者"><a href="#9-2-创建-Nacos-服务提供者" class="headerlink" title="9.2 创建 Nacos 服务提供者"></a>9.2 创建 Nacos 服务提供者</h2><h3 id="9-2-1-需求说明-x2F-图解"><a href="#9-2-1-需求说明-x2F-图解" class="headerlink" title="9.2.1 需求说明&#x2F;图解"></a>9.2.1 需求说明&#x2F;图解</h3><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230604111207532.png" alt="image-20230604111207532" style="zoom:50%;" /><h3 id="9-2-2-创建-member-service-nacos-provider-10004-并注册到-NacosServer8848"><a href="#9-2-2-创建-member-service-nacos-provider-10004-并注册到-NacosServer8848" class="headerlink" title="9.2.2 创建 member-service-nacos-provider-10004 并注册到 NacosServer8848"></a><strong>9.2.2</strong> 创建 member-service-nacos-provider-10004 并注册到 NacosServer8848</h3><h4 id="9-2-2-1-创建-member-service-nacos-provider-10004"><a href="#9-2-2-1-创建-member-service-nacos-provider-10004" class="headerlink" title="9.2.2.1 创建 member-service-nacos-provider-10004"></a>9.2.2.1 创建 member-service-nacos-provider-10004</h4><ol><li><p>参考<strong>member-service-provider-10000</strong> 来创建 <strong>member-service-nacos-provider-10004</strong> 即可</p></li><li><p>创建好后，使用member-service-provider-10000 的源码和配置替换member-service-nacos-provider-10004 生成的代码</p></li><li><p>提醒，拷贝时不要忘记拷贝 resources&#x2F;mapper&#x2F;MernberrVapper.xml 这些xeox.xrl 文件</p></li></ol><h4 id="9-2-2-2-修改父项目-pom-xml"><a href="#9-2-2-2-修改父项目-pom-xml" class="headerlink" title="9.2.2.2 修改父项目 pom.xml"></a>9.2.2.2 修改父项目 pom.xml</h4><p><strong>1.</strong> 参考官方文档 <strong><a href="https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_nacos_discovery">https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_nacos_discovery</a></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="9-2-2-3-修改本模块-pom-xml"><a href="#9-2-2-3-修改本模块-pom-xml" class="headerlink" title="9.2.2.3 修改本模块 pom.xml"></a>9.2.2.3 修改本模块 pom.xml</h4><p><strong>1.</strong> 将 <strong>member-service-provider-10000</strong> 的 <strong>pom.xml</strong> 的<dependencies>…</dependencies></p><p>拷贝过来，修改即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.study.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>e-commerce-center<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>member-service-nacos-provider-10004<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入nacos-start nacos场景启动器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--        使用版本仲裁，从父项目中获取版本--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        springboot程序的监控系统，实现系统健康检测</span></span><br><span class="line"><span class="comment">                    可以通过 http://localhost:10000/actuator 看到相关连接</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 引入 e_commerce_center-common-api --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.study.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>e_commerce_center-common-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="9-2-2-4-创建-application-yml"><a href="#9-2-2-4-创建-application-yml" class="headerlink" title="9.2.2.4 创建 application.yml"></a>9.2.2.4 创建 application.yml</h4><p><strong>1.</strong> 将 <strong>member-service-provider-10000</strong> 的 <strong>application.xml</strong> 拷贝过来，修改即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10004</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">member-service-nacos-provider</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/e_commerce_center_db?serverTimezone=GMT%2B8&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">QWEASDzxc123</span></span><br><span class="line"><span class="comment">#  配置nacos</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#配置nacos server的地址</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.study.springcloud.entity</span></span><br><span class="line"><span class="comment">#配置暴露所有的监控点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="9-2-2-5-创建主启动类"><a href="#9-2-2-5-创建主启动类" class="headerlink" title="9.2.2.5 创建主启动类"></a>9.2.2.5 创建主启动类</h4><p><strong>1.</strong> 创建主启动类 MemberNacosProviderApplication10004</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.springcloud;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入nacos发现的注解</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberNacosProviderApplication10004</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MemberNacosProviderApplication10004.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-2-2-6-为看到更好提示，修改-Controller"><a href="#9-2-2-6-为看到更好提示，修改-Controller" class="headerlink" title="9.2.2.6 为看到更好提示，修改 Controller"></a>9.2.2.6 为看到更好提示，修改 Controller</h4><p>……</p><h4 id="9-2-2-7-测试"><a href="#9-2-2-7-测试" class="headerlink" title="9.2.2.7 测试"></a>9.2.2.7 测试</h4><h5 id="9-2-2-7-1-启动-Nacos-Server-8848"><a href="#9-2-2-7-1-启动-Nacos-Server-8848" class="headerlink" title="9.2.2.7.1 启动 Nacos Server 8848"></a><strong>9.2.2.7.1</strong> 启动 Nacos Server 8848</h5><h5 id="9-2-2-7-2-启动-member-service-nacos-provider-10004"><a href="#9-2-2-7-2-启动-member-service-nacos-provider-10004" class="headerlink" title="9.2.2.7.2 启动 member-service-nacos-provider-10004"></a>9.2.2.7.2 启动 <strong>member-service-nacos-provider-10004</strong></h5><h5 id="9-2-2-7-3-观察-nacos-服务是否注册成功"><a href="#9-2-2-7-3-观察-nacos-服务是否注册成功" class="headerlink" title="9.2.2.7.3 观察 nacos 服务是否注册成功"></a><strong>9.2.2.7.3</strong> 观察 <strong>nacos</strong> 服务是否注册成功</h5><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230604130757230.png" alt="image-20230604130757230"></p><h3 id="9-2-3-创建-member-service-nacos-provider-10006-并注册到-NacosServer8848"><a href="#9-2-3-创建-member-service-nacos-provider-10006-并注册到-NacosServer8848" class="headerlink" title="9.2.3 创建 member-service-nacos-provider-10006 并注册到 NacosServer8848"></a>9.2.3 创建 member-service-nacos-provider-10006 并注册到 NacosServer8848</h3><h4 id="9-2-3-1-创建-member-service-nacos-provider-10006"><a href="#9-2-3-1-创建-member-service-nacos-provider-10006" class="headerlink" title="9.2.3.1 创建 member-service-nacos-provider-10006"></a>9.2.3.1 创建 member-service-nacos-provider-10006</h4><ol><li><p>参考member-service-nacos-provider-10004 来创建 member-service-nacos-provider-10006 即可</p></li><li><p>创建好后，使用member-service-nacos-provider-10004 的源码和配罝替换member-service-nacos-provider-10006 生成的代码</p></li><li><p>提醒，拷贝时不要忘记拷贝 resources&#x2F;mapper&#x2F;MemberMapper.xml 这些xoxx.xml文件</p></li></ol><h4 id="9-2-3-2-修改本模块-pom-xml"><a href="#9-2-3-2-修改本模块-pom-xml" class="headerlink" title="9.2.3.2 修改本模块 pom.xml"></a>9.2.3.2 修改本模块 pom.xml</h4><p><strong>1.</strong> 将 <strong>member-service-provider-10000</strong> 的 <strong>pom.xml</strong> 的<dependencies>…</dependencies></p><p>拷贝过来，修改即可</p><h4 id="9-2-3-3-创建-application-yml"><a href="#9-2-3-3-创建-application-yml" class="headerlink" title="9.2.3.3 创建 application.yml"></a>9.2.3.3 创建 application.yml</h4><p><strong>1.</strong> 将 <strong>member-service-nacos-provider-10004</strong> 的 <strong>application.xml</strong> 拷贝过来，修改端口即可</p><h4 id="9-2-3-4-创建主启动类"><a href="#9-2-3-4-创建主启动类" class="headerlink" title="9.2.3.4 创建主启动类"></a>9.2.3.4 创建主启动类</h4><p><strong>1.</strong> 创建主启动类 MemberNacosProviderApplication10006 (也复制过来，改个名称即可)</p><h4 id="9-2-3-5-为看到更好提示，修改-Controller"><a href="#9-2-3-5-为看到更好提示，修改-Controller" class="headerlink" title="9.2.3.5 为看到更好提示，修改 Controller"></a>9.2.3.5 为看到更好提示，修改 Controller</h4><h4 id="9-2-3-6-测试"><a href="#9-2-3-6-测试" class="headerlink" title="9.2.3.6 测试"></a>9.2.3.6 测试</h4><h5 id="9-2-3-6-1-保证-Nacos-Server-8848-是启动的"><a href="#9-2-3-6-1-保证-Nacos-Server-8848-是启动的" class="headerlink" title="9.2.3.6.1 保证 Nacos Server 8848 是启动的"></a><strong>9.2.3.6.1</strong> 保证 <strong>Nacos Server 8848</strong> 是启动的</h5><h5 id="9-2-3-6-2-启动-member-service-nacos-provider-10006"><a href="#9-2-3-6-2-启动-member-service-nacos-provider-10006" class="headerlink" title="9.2.3.6.2 启动 **member-service-nacos-provider-10006 **"></a><strong>9.2.3.6.2</strong> 启动 **member-service-nacos-provider-10006 **</h5><h5 id="9-2-3-6-3-观察-nacos-服务是否注册成功"><a href="#9-2-3-6-3-观察-nacos-服务是否注册成功" class="headerlink" title="9.2.3.6.3 观察 nacos 服务是否注册成功"></a><strong>9.2.3.6.3</strong> 观察 <strong>nacos</strong> 服务是否注册成功</h5><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230605235515301.png" alt="image-20230605235515301"></p><h5 id="9-2-3-6-4-浏览器-http-localhost-10006-member-get-1"><a href="#9-2-3-6-4-浏览器-http-localhost-10006-member-get-1" class="headerlink" title="9.2.3.6.4 浏览器**: http://localhost:10006/member/get/1**"></a><strong>9.2.3.6.4</strong> 浏览器**: <a href="http://localhost:10006/member/get/1">http://localhost:10006/member/get/1</a>**</h5><h2 id="9-3-创建-Nacos-的服务消费者"><a href="#9-3-创建-Nacos-的服务消费者" class="headerlink" title="9.3 创建 Nacos 的服务消费者"></a>9.3 创建 Nacos 的服务消费者</h2><h3 id="9-3-1-需求说明-x2F-图解"><a href="#9-3-1-需求说明-x2F-图解" class="headerlink" title="9.3.1 需求说明**&#x2F;**图解"></a><strong>9.3.1</strong> 需求说明**&#x2F;**图解</h3><p><strong>–</strong> 示意图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230619155537025.png" alt="image-20230619155537025" style="zoom:50%;" /><h3 id="9-3-2-创建-member-service-nacos-consumer-80-并注册到-NacosServer8848"><a href="#9-3-2-创建-member-service-nacos-consumer-80-并注册到-NacosServer8848" class="headerlink" title="9.3.2 创建 member-service-nacos-consumer-80 并注册到 NacosServer8848"></a><strong>9.3.2</strong> 创建 <strong>member-service-nacos-consumer-80</strong> 并注册到 <strong>NacosServer8848</strong></h3><h4 id="9-3-2-1-创建-member-service-nacos-consumer-80"><a href="#9-3-2-1-创建-member-service-nacos-consumer-80" class="headerlink" title="9.3.2.1 创建 member-service-nacos-consumer-80"></a>9.3.2.1 创建 member-service-nacos-consumer-80</h4><ol><li>参考 member-service-consumer-80 来创建 member-service-nacos-consumer-80 即可</li></ol><h4 id="9-3-2-2-修改-pom-xml"><a href="#9-3-2-2-修改-pom-xml" class="headerlink" title="9.3.2.2 修改 pom.xml"></a>9.3.2.2 修改 pom.xml</h4><p>将 <strong>member-service-consumer-80</strong> 的 <strong>pom.xml</strong> 的<dependencies>…</dependencies> 拷 贝过来，修改即可</p><h4 id="9-3-2-3-创建-application-yml"><a href="#9-3-2-3-创建-application-yml" class="headerlink" title="9.3.2.3 创建 application.yml"></a>9.3.2.3 创建 application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">member-service-consumer-80</span></span><br><span class="line">    <span class="comment">#配置nacos</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment">#启动nacos服务的ip以及端口</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure><h4 id="9-3-2-4-创建主启动类"><a href="#9-3-2-4-创建主启动类" class="headerlink" title="9.3.2.4 创建主启动类"></a>9.3.2.4 创建主启动类</h4><p>……</p><h4 id="9-3-2-5-业务类"><a href="#9-3-2-5-业务类" class="headerlink" title="9.3.2.5 业务类"></a>9.3.2.5 业务类</h4><p><em>nacos</em> 本身就集成了 <em>Ribbon,</em> 直接支持 <em>Ribbon(负载均衡)+RestTemplate(远程调用)</em> 调用</p><p><strong>1.</strong> 创建配置类 <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;config&#x2F;CustomizationBean.java</strong></p><p><strong>2.</strong> 创建 <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;MemberNacosConsumerController.java</strong></p><h4 id="9-3-2-6-测试"><a href="#9-3-2-6-测试" class="headerlink" title="9.3.2.6 测试"></a>9.3.2.6 测试</h4><h5 id="9-3-2-6-1-启动-Nacos-Server-8848"><a href="#9-3-2-6-1-启动-Nacos-Server-8848" class="headerlink" title="9.3.2.6.1 启动 Nacos Server 8848"></a><strong>9.3.2.6.1</strong> 启动 Nacos Server 8848</h5><h5 id="9-3-2-6-2-启动-member-service-nacos-provider-10004-x2F-10006-9-3-2-6-3-启动-member-service-nacos-consumer-80"><a href="#9-3-2-6-2-启动-member-service-nacos-provider-10004-x2F-10006-9-3-2-6-3-启动-member-service-nacos-consumer-80" class="headerlink" title="9.3.2.6.2 启动 member-service-nacos-provider-10004&#x2F;10006 9.3.2.6.3 启动 member-service-nacos-consumer-80"></a>9.3.2.6.2 启动 <strong>member-service-nacos-provider-10004&#x2F;10006 9.3.2.6.3</strong> 启动 member-service-nacos-consumer-80</h5><h5 id="9-3-2-6-4-浏览器-http-localhost-member-nacos-consumer-get-1"><a href="#9-3-2-6-4-浏览器-http-localhost-member-nacos-consumer-get-1" class="headerlink" title="9.3.2.6.4 浏览器**: http://localhost/member/nacos/consumer/get/1**"></a>9.3.2.6.4 浏览器**: <a href="http://localhost/member/nacos/consumer/get/1">http://localhost/member/nacos/consumer/get/1</a>**</h5><h4 id="9-3-2-7-配置自己的负载均衡算法，-测试完毕恢复成原来的轮询算法"><a href="#9-3-2-7-配置自己的负载均衡算法，-测试完毕恢复成原来的轮询算法" class="headerlink" title="9.3.2.7 配置自己的负载均衡算法， 测试完毕恢复成原来的轮询算法"></a>9.3.2.7 配置自己的负载均衡算法， 测试完毕恢复成原来的轮询算法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.springcloud.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.IRule;</span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.RandomRule;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/6/19</span></span><br><span class="line"><span class="comment"> * 16:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * RibbonRule配置类，配置自己的负载均衡算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RibbonRule</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IRule <span class="title function_">myRibbonRule</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-4-NacosAP和CP切换-理论"><a href="#9-4-NacosAP和CP切换-理论" class="headerlink" title="9.4 NacosAP和CP切换-理论"></a>9.4 NacosAP和CP切换-理论</h2><h3 id="9-4-1-各种注册中心对比"><a href="#9-4-1-各种注册中心对比" class="headerlink" title="9.4.1 各种注册中心对比"></a><strong>9.4.1</strong> 各种注册中心对比</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230619224742402.png" alt="image-20230619224742402"></p><h3 id="9-4-2-选择-AP-还是-CP"><a href="#9-4-2-选择-AP-还是-CP" class="headerlink" title="9.4.2 选择 AP 还是 CP?"></a><strong>9.4.2</strong> 选择 <strong>AP</strong> 还是 <strong>CP?</strong></h3><p> <strong>1</strong>、<strong>CP:</strong> 服务可以不能用，但必须要保证数据的一致性。<br> <strong>2</strong>、<strong>AP:</strong> 数据可以短暂不一致，但最终是需要一致的，无论如何都要保证服务的可用。<br> <strong>3</strong>、取舍:只能在 <strong>CP</strong> 和 <strong>AP</strong> 选择一个平衡点**,** 大多数都是选择 <strong>AP</strong> 模式</p><h3 id="9-4-3-AP和CP切换"><a href="#9-4-3-AP和CP切换" class="headerlink" title="9.4.3 AP和CP切换"></a><strong>9.4.3 AP</strong>和<strong>CP</strong>切换</h3><p><strong>Nacos</strong> 集群默认支持的是<strong>CAP</strong>原则中的<strong>AP</strong>原则，但是也可切换为<strong>CP</strong>原则**(<strong>一般不切换</strong>)**</p><h4 id="9-4-3-2-参考-https-www-jianshu-com-p-c56e22c222bb"><a href="#9-4-3-2-参考-https-www-jianshu-com-p-c56e22c222bb" class="headerlink" title="9.4.3.2 参考: https://www.jianshu.com/p/c56e22c222bb"></a>9.4.3.2 参考: <a href="https://www.jianshu.com/p/c56e22c222bb">https://www.jianshu.com/p/c56e22c222bb</a></h4><h2 id="9-5-Nacos-配置中心实例"><a href="#9-5-Nacos-配置中心实例" class="headerlink" title="9.5 Nacos 配置中心实例"></a>9.5 Nacos 配置中心实例</h2><h3 id="9-5-1-需求分析-x2F-图解"><a href="#9-5-1-需求分析-x2F-图解" class="headerlink" title="9.5.1 需求分析**&#x2F;**图解"></a><strong>9.5.1</strong> 需求分析**&#x2F;**图解</h3><p>微服务各个模块中有许多配置是相同的，在配置中心进行统一的配置不仅配置更方便，也便于日后修改。</p><p><strong>–</strong> 示意图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230619225914409.png" alt="image-20230619225914409" style="zoom: 33%;" /><h3 id="9-5-2-在-Nacos-Server-加入配置"><a href="#9-5-2-在-Nacos-Server-加入配置" class="headerlink" title="9.5.2 在 Nacos Server 加入配置"></a><strong>9.5.2</strong> 在 <strong>Nacos Server</strong> 加入配置</h3><ol><li>进入到 Nacos Server</li><li>加入配置， 老韩特别提醒: 文件后缀.yaml 别忘了</li></ol><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230619230758715.png" alt="image-20230619230758715" style="zoom:50%;" /><p><strong>Data ID: e-commerce-nacos-config-client-dev.yaml</strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230619230855754.png" alt="image-20230619230855754" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230619230930267.png" alt="image-20230619230930267" style="zoom:50%;" /><h3 id="9-5-3-创建-Nacos-配置客户端模块-e-commerce-nacos-config-client5000"><a href="#9-5-3-创建-Nacos-配置客户端模块-e-commerce-nacos-config-client5000" class="headerlink" title="9.5.3 创建 Nacos 配置客户端模块 e-commerce-nacos-config-client5000"></a><strong>9.5.3</strong> 创建 <strong>Nacos</strong> 配置客户端模块 <strong>e-commerce-nacos-config-client5000</strong></h3><h4 id="9-5-3-1-创建-Module"><a href="#9-5-3-1-创建-Module" class="headerlink" title="9.5.3.1 创建 Module"></a>9.5.3.1 创建 Module</h4><p>先创建 <strong>e-commerce-nacos-config-client5000</strong> 模块，参考以前的方法</p><h4 id="9-5-3-2-修改-pom-xml"><a href="#9-5-3-2-修改-pom-xml" class="headerlink" title="9.5.3.2 修改 pom.xml"></a>9.5.3.2 修改 pom.xml</h4><p><strong>1.</strong> 修改 <strong>pom.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在之前的消费方xml文件的基础上添加：</span><br><span class="line"><span class="comment">&lt;!--nacos-config--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="9-5-3-3-创建-application-xml"><a href="#9-5-3-3-创建-application-xml" class="headerlink" title="9.5.3.3 创建 application.xml"></a>9.5.3.3 创建 application.xml</h4><p>创建 <strong>application.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#指定环境，常见的环境有 dev/test/prod 开发，测试，生产</span></span><br></pre></td></tr></table></figure><p>参考*: <a href="https://blog.csdn.net/zsl131557/article/details/80886114">https://blog.csdn.net/zsl131557/article/details/80886114</a>*</p><h4 id="9-5-3-4-创建-bootstrap-yml"><a href="#9-5-3-4-创建-bootstrap-yml" class="headerlink" title="9.5.3.4 创建 bootstrap.yml"></a>9.5.3.4 创建 bootstrap.yml</h4><p>创建 <strong>bootstrap.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 这里的name 需要参考nacos配置中心的DataId</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">e-commerce-nacos-config-client</span></span><br><span class="line">  <span class="comment">#配置nacos</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#nacos配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定读取配置中心的yaml后缀的配置</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#老韩解读[重要]</span></span><br><span class="line"><span class="comment">#nacos 配置客户端，会根据配置，找到资源获取配置文件</span></span><br><span class="line"><span class="comment">#(1 config-server-addr)                       localhost:8848</span></span><br><span class="line"><span class="comment">#(2 spring.application.name/对应 DataId)       e-commerce-nacos-config-client </span></span><br><span class="line"><span class="comment">#(3 spring.profiles.active)                   dev</span></span><br><span class="line"><span class="comment">#(4 spring.cloud.nacos.config.file-extension 文件扩展名)    .yaml</span></span><br><span class="line"><span class="comment">#也就到 localhost:8848 下的 e-commerce-nacos-config-client-dev.yaml 获取配置信息</span></span><br><span class="line"><span class="comment">#规则总结: $&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span></span><br></pre></td></tr></table></figure><h4 id="9-5-3-5-主启动类"><a href="#9-5-3-5-主启动类" class="headerlink" title="9.5.3.5 主启动类"></a>9.5.3.5 主启动类</h4><p>……</p><h4 id="9-5-3-6-业务类"><a href="#9-5-3-6-业务类" class="headerlink" title="9.5.3.6 业务类"></a>9.5.3.6 业务类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.springcloud.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/6/20</span></span><br><span class="line"><span class="comment"> * 15:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NacosConfigClientController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解读 <span class="doctag">@Value</span>(&quot;$&#123;config.ip&#125;&quot;)</span></span><br><span class="line"><span class="comment">    * 1. client 会拉取 Nacos Server 的 e-commerce-nacos-config-client-dev.yaml * config:</span></span><br><span class="line"><span class="comment">    * ip: &quot;122.11.11.11&quot;</span></span><br><span class="line"><span class="comment">    * name: &quot;韩顺平教育&quot;</span></span><br><span class="line"><span class="comment">    * 2. <span class="doctag">@Value</span>(&quot;$&#123;config.ip&#125;&quot;) 会将 config.ip 赋给 configIp</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.ip&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configIp;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/nacos/config/ip&quot;)</span> <span class="keyword">public</span> String <span class="title function_">getConfigIp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> configIp; &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/nacos/config/name&quot;)</span> <span class="keyword">public</span> String <span class="title function_">getConfigName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> configName; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-5-3-7-测试"><a href="#9-5-3-7-测试" class="headerlink" title="9.5.3.7 测试"></a>9.5.3.7 测试</h4><h5 id="9-5-3-7-1-启动-Nacos-Server"><a href="#9-5-3-7-1-启动-Nacos-Server" class="headerlink" title="9.5.3.7.1 启动 **Nacos Server"></a><strong>9.5.3.7.1</strong> 启动 **Nacos Server</h5><h5 id="9-5-3-7-2-启动-e-commerce-nacos-config-client5000"><a href="#9-5-3-7-2-启动-e-commerce-nacos-config-client5000" class="headerlink" title="9.5.3.7.2 启动 **e-commerce-nacos-config-client5000 **"></a>9.5.3.7.2 启动 **e-commerce-nacos-config-client5000 **</h5><h5 id="9-5-3-7-3-浏览器-http-localhost-5000-nacos-config-ip"><a href="#9-5-3-7-3-浏览器-http-localhost-5000-nacos-config-ip" class="headerlink" title="9.5.3.7.3 浏览器**: http://localhost:5000/nacos/config/ip**"></a><strong>9.5.3.7.3</strong> 浏览器**: <a href="http://localhost:5000/nacos/config/ip">http://localhost:5000/nacos/config/ip</a>**</h5><p>​浏览器输入**: <a href="http://localhost:5000/nacos/config/ip">http://localhost:5000/nacos/config/ip</a>**</p><h4 id="9-5-3-8-注意事项和细节"><a href="#9-5-3-8-注意事项和细节" class="headerlink" title="9.5.3.8 注意事项和细节"></a>9.5.3.8 注意事项和细节</h4><p><strong>0. src\main\java\com\study\springcloud\controller\NacosConfigClientController.java</strong> 的 @Value(“${config.ip}”), 是 import org.springframework.beans.factory.annotation.Value; 而不是 lombok 包下的.</p><p><strong>1.</strong> <strong>配置文件</strong> <strong>application.yml</strong> <strong>和</strong> <strong>bootstrap.yml</strong> 结合会得到配置文件&#x2F;资源的地址</p><p> <strong>2.</strong> <strong>参考文档</strong>: <a href="https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html">https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html</a></p><p><strong>3.</strong> <strong>注意在</strong> <strong>Nacos Server</strong> <strong>的配置文件的后缀是</strong> <strong>.yaml ,</strong> <strong>而不是</strong> <strong>.yml</strong></p><p><strong>4.</strong> <strong>在项目初始化时，要保证先从配置中心进行配置拉取，拉取配置之后，才能保证项目的正常启动</strong>, <strong>也就是说如果项目不能正确的获取到</strong> <strong>Nacos Server</strong> <strong>的配置数据，项目是启动不了的</strong>.[<strong>演示</strong>]</p><p><strong>5. springboot</strong> <strong>中配置文件的加载是存在优先级顺序的，</strong>bootstrap.yml <strong>优先级高于</strong> <strong>application.yml</strong></p><p>🌟<strong>6.</strong> <strong>@RefreshScope</strong> <strong>是</strong> <strong>springcloud</strong> <strong>原生注解，实现配置信息自动刷新</strong>, <strong>如果在</strong> <strong>Nacos Server</strong> <strong>修改了配置数据，</strong>Client <strong>端就会得到最新配置</strong></p><h2 id="9-6-Nacos-分类配置-实现配置隔离"><a href="#9-6-Nacos-分类配置-实现配置隔离" class="headerlink" title="9.6 Nacos 分类配置 (实现配置隔离)"></a>9.6 Nacos 分类配置 (实现配置隔离)</h2><h3 id="9-6-1-DataID方案"><a href="#9-6-1-DataID方案" class="headerlink" title="9.6.1 DataID方案"></a><strong>9.6.1 DataID</strong>方案</h3><h4 id="9-6-1-1-需求分析-x2F-图解"><a href="#9-6-1-1-需求分析-x2F-图解" class="headerlink" title="9.6.1.1 需求分析&#x2F;图解"></a>9.6.1.1 需求分析&#x2F;图解</h4><p><strong>–</strong> 示意图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620155605713.png" alt="image-20230620155605713" style="zoom:50%;" /><h4 id="9-6-1-2-解决方案分析"><a href="#9-6-1-2-解决方案分析" class="headerlink" title="9.6.1.2 解决方案分析"></a>9.6.1.2 解决方案分析</h4><h5 id="9-6-1-2-1-使用-Data-ID-方案解决"><a href="#9-6-1-2-1-使用-Data-ID-方案解决" class="headerlink" title="9.6.1.2.1 使用 Data ID 方案解决"></a><strong>9.6.1.2.1</strong> 使用 <strong>Data ID</strong> 方案解决</h5><h4 id="9-6-1-3-配置实现"><a href="#9-6-1-3-配置实现" class="headerlink" title="9.6.1.3 配置实现"></a>9.6.1.3 配置实现</h4><p><strong>1.</strong> 在 <strong>nacos server</strong> 创建新的配置:<strong>e-commerce-nacos-config-client-test.yaml</strong></p><h4 id="9-6-1-4-修改-application-yml"><a href="#9-6-1-4-修改-application-yml" class="headerlink" title="9.6.1.4 修改 application.yml"></a>9.6.1.4 修改 application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">test</span> <span class="comment">#指定环境，常见的环境有 dev/test/prod 开发，测试，生产</span></span><br></pre></td></tr></table></figure><h4 id="9-6-1-5-测试"><a href="#9-6-1-5-测试" class="headerlink" title="9.6.1.5 测试"></a>9.6.1.5 测试</h4><h5 id="9-6-1-5-1-浏览器-http-localhost-5000-nacos-config-ip"><a href="#9-6-1-5-1-浏览器-http-localhost-5000-nacos-config-ip" class="headerlink" title="9.6.1.5.1 浏览器**: http://localhost:5000/nacos/config/ip**"></a><strong>9.6.1.5.1</strong> 浏览器**: <a href="http://localhost:5000/nacos/config/ip">http://localhost:5000/nacos/config/ip</a>**</h5><p>**1.**浏览器输入: <a href="http://localhost:5000/nacos/config/ip">http://localhost:5000/nacos/config/ip</a></p><h3 id="9-6-2-Group方案"><a href="#9-6-2-Group方案" class="headerlink" title="9.6.2 Group方案"></a><strong>9.6.2 Group</strong>方案</h3><h4 id="9-6-2-1-需求分析-x2F-图解"><a href="#9-6-2-1-需求分析-x2F-图解" class="headerlink" title="9.6.2.1 需求分析&#x2F;图解"></a>9.6.2.1 需求分析&#x2F;图解</h4><p><strong>–</strong> 示意图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620161153853.png" alt="image-20230620161153853" style="zoom:50%;" /><h4 id="9-6-2-2-解决方案分析"><a href="#9-6-2-2-解决方案分析" class="headerlink" title="9.6.2.2 解决方案分析"></a>9.6.2.2 解决方案分析</h4><h5 id="9-6-2-2-1-使用-Group-方案解决"><a href="#9-6-2-2-1-使用-Group-方案解决" class="headerlink" title="9.6.2.2.1 使用 Group 方案解决"></a><strong>9.6.2.2.1</strong> 使用 <strong>Group</strong> 方案解决</h5><h4 id="9-6-2-3-配置实现"><a href="#9-6-2-3-配置实现" class="headerlink" title="9.6.2.3 配置实现"></a>9.6.2.3 配置实现</h4><p><strong>1.</strong> 在 <strong>nacos server</strong> 创建新的配置:<strong>order&#x2F;e-commerce-nacos-config-client-dev.yaml</strong></p><p><strong>2.</strong> <strong>在</strong> <strong>nacos server</strong> **创建新的配置:**seckill&#x2F;e-commerce-nacos-config-client-dev.yaml</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230620161749751.png" alt="image-20230620161749751" style="zoom:50%;" /><h4 id="9-6-2-4-修改-application-yml"><a href="#9-6-2-4-修改-application-yml" class="headerlink" title="9.6.2.4 修改 application.yml"></a>9.6.2.4 修改 application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#指定环境，常见的环境有 dev/test/prod 开发，测试，生产</span></span><br></pre></td></tr></table></figure><h4 id="9-6-2-5-修改-bootstrap-yml"><a href="#9-6-2-5-修改-bootstrap-yml" class="headerlink" title="9.6.2.5 修改 bootstrap.yml"></a>9.6.2.5 修改 bootstrap.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">20000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 这里的name 需要参考nacos配置中心的DataId</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">e-commerce-nacos-config-client</span></span><br><span class="line">  <span class="comment">#配置nacos</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#nacos配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定读取配置中心的yaml后缀的配置</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">order</span> <span class="comment">#指定order组，默认为DEFAULT_GROUP</span></span><br></pre></td></tr></table></figure><h4 id="9-6-2-6-测试"><a href="#9-6-2-6-测试" class="headerlink" title="9.6.2.6 测试"></a>9.6.2.6 测试</h4><h5 id="9-6-2-6-1-浏览器-http-localhost-5000-nacos-config-ip"><a href="#9-6-2-6-1-浏览器-http-localhost-5000-nacos-config-ip" class="headerlink" title="9.6.2.6.1 浏览器**: http://localhost:5000/nacos/config/ip**"></a><strong>9.6.2.6.1</strong> 浏览器**: <a href="http://localhost:5000/nacos/config/ip">http://localhost:5000/nacos/config/ip</a>**</h5><p>**1.**浏览器输入: <a href="http://localhost:5000/nacos/config/ip">http://localhost:5000/nacos/config/ip</a></p><h3 id="9-6-3-Namespace方案"><a href="#9-6-3-Namespace方案" class="headerlink" title="9.6.3 Namespace方案"></a><strong>9.6.3 Namespace</strong>方案</h3><h4 id="9-6-3-1-需求分析-x2F-图解"><a href="#9-6-3-1-需求分析-x2F-图解" class="headerlink" title="9.6.3.1 需求分析&#x2F;图解"></a>9.6.3.1 需求分析&#x2F;图解</h4><p><strong>–</strong> 示意图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620162224978.png" alt="image-20230620162224978" style="zoom:50%;" /><h4 id="9-6-3-2-解决方案分析"><a href="#9-6-3-2-解决方案分析" class="headerlink" title="9.6.3.2 解决方案分析"></a>9.6.3.2 解决方案分析</h4><h5 id="9-6-3-2-1-使用-Namespace-方案解决"><a href="#9-6-3-2-1-使用-Namespace-方案解决" class="headerlink" title="9.6.3.2.1 使用 Namespace 方案解决"></a><strong>9.6.3.2.1</strong> 使用 <strong>Namespace</strong> 方案解决</h5><h4 id="9-6-3-3-配置实现"><a href="#9-6-3-3-配置实现" class="headerlink" title="9.6.3.3 配置实现"></a>9.6.3.3 配置实现</h4><p><strong>1.</strong> 在 <strong>nacos server</strong> 创建新的 <strong>namespace , baidu</strong> 和 <strong>alibaba</strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620162934242.png" alt="image-20230620162934242" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620163057931.png" alt="image-20230620163057931" style="zoom:50%;" /><p><strong>2.</strong> <strong>在</strong> <strong>nacos server</strong> <strong>创建新的</strong> <strong>group&#x2F;dataid</strong></p><h4 id="9-6-3-4-修改-application-yml"><a href="#9-6-3-4-修改-application-yml" class="headerlink" title="9.6.3.4 修改 application.yml"></a>9.6.3.4 修改 application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#指定环境，常见的环境有 dev/test/prod 开发，测试，生产</span></span><br></pre></td></tr></table></figure><h4 id="9-6-3-5-修改-bootstrap-yml"><a href="#9-6-3-5-修改-bootstrap-yml" class="headerlink" title="9.6.3.5 修改 bootstrap.yml"></a>9.6.3.5 修改 bootstrap.yml</h4><p><strong>1.</strong> 增加 <strong>Namespace</strong> 参数</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">20000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 这里的name 需要参考nacos配置中心的DataId</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">e-commerce-nacos-config-client</span></span><br><span class="line">  <span class="comment">#配置nacos</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#nacos配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定读取配置中心的yaml后缀的配置</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">seckill</span> <span class="comment">#指定order组，默认为DEFAULT_GROUP</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">8b005a7a-89b9-40ba-a5da-aac3e6c7a564</span></span><br></pre></td></tr></table></figure><h4 id="9-6-3-6-测试"><a href="#9-6-3-6-测试" class="headerlink" title="9.6.3.6 测试"></a>9.6.3.6 测试</h4><h5 id="9-6-3-6-1-浏览器-http-localhost-5000-nacos-config-ip"><a href="#9-6-3-6-1-浏览器-http-localhost-5000-nacos-config-ip" class="headerlink" title="9.6.3.6.1 浏览器**: http://localhost:5000/nacos/config/ip**"></a><strong>9.6.3.6.1</strong> 浏览器**: <a href="http://localhost:5000/nacos/config/ip">http://localhost:5000/nacos/config/ip</a>**</h5><p>**1.**浏览器输入: <a href="http://localhost:5000/nacos/config/ip">http://localhost:5000/nacos/config/ip</a></p><h3 id="9-6-4-Namespace-x2F-Group-x2F-Data-ID-关系"><a href="#9-6-4-Namespace-x2F-Group-x2F-Data-ID-关系" class="headerlink" title="9.6.4 Namespace&#x2F;Group&#x2F;Data ID 关系"></a><strong>9.6.4 Namespace&#x2F;Group&#x2F;Data ID</strong> 关系</h3><h4 id="9-6-4-1-一图胜千言"><a href="#9-6-4-1-一图胜千言" class="headerlink" title="9.6.4.1 一图胜千言"></a>9.6.4.1 一图胜千言</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620164046357.png" alt="image-20230620164046357" style="zoom:50%;" /><h4 id="9-6-4-2-详解介绍"><a href="#9-6-4-2-详解介绍" class="headerlink" title="9.6.4.2 详解介绍"></a>9.6.4.2 详解介绍</h4><p><strong>1. namespace &#x2F; group &#x2F; data id</strong> 的关系</p><p>2.梳理:</p><ul><li><p>Nacos默认的命名空间是public，Namespace主要用来实现配置隔离,隔离范围大</p></li><li><p>Group默认是DEFAULT GROUP, Group可以把不同的微服务划分到同一个分组里面去</p></li><li><p>Service就是微服务,相同的Service可以是一个Cluster(簇&#x2F;集群), Instance就是微服务的实例</p></li></ul><h1 id="10-SpringCloud-Alibaba-Sentinel——分布式系统的流量哨兵"><a href="#10-SpringCloud-Alibaba-Sentinel——分布式系统的流量哨兵" class="headerlink" title="10 SpringCloud Alibaba Sentinel——分布式系统的流量哨兵"></a>10 SpringCloud Alibaba Sentinel——分布式系统的流量哨兵</h1><h2 id="10-1-Sentinel基础"><a href="#10-1-Sentinel基础" class="headerlink" title="10.1 Sentinel基础"></a>10.1 Sentinel基础</h2><h3 id="10-1-1-官网"><a href="#10-1-1-官网" class="headerlink" title="10.1.1 官网"></a><strong>10.1.1</strong> 官网</h3><h4 id="10-1-1-1-Github-https-github-com-alibaba-Sentinel"><a href="#10-1-1-1-Github-https-github-com-alibaba-Sentinel" class="headerlink" title="10.1.1.1 Github: https://github.com/alibaba/Sentinel"></a>10.1.1.1 Github: <a href="https://github.com/alibaba/Sentinel">https://github.com/alibaba/Sentinel</a></h4><h4 id="10-1-1-2-快速开始-https-sentinelguard-io-zh-cn-docs-quick-start-html"><a href="#10-1-1-2-快速开始-https-sentinelguard-io-zh-cn-docs-quick-start-html" class="headerlink" title="10.1.1.2 快速开始: https://sentinelguard.io/zh-cn/docs/quick-start.html"></a>10.1.1.2 快速开始: <a href="https://sentinelguard.io/zh-cn/docs/quick-start.html">https://sentinelguard.io/zh-cn/docs/quick-start.html</a></h4><h4 id="10-1-1-3-中文-https-github-com-alibaba-Sentinel-wiki-E4-BB-8B-E7-BB-8D"><a href="#10-1-1-3-中文-https-github-com-alibaba-Sentinel-wiki-E4-BB-8B-E7-BB-8D" class="headerlink" title="10.1.1.3 中文: https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D"></a>10.1.1.3 中文: <a href="https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D">https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D</a></h4><h4 id="10-1-1-4-使-用-手-册-https-spring-cloud-alibaba-group-github-io-github-pages-greenwich-spring-cloud-alibaba-html-spring-cloud-alibaba-sentinel"><a href="#10-1-1-4-使-用-手-册-https-spring-cloud-alibaba-group-github-io-github-pages-greenwich-spring-cloud-alibaba-html-spring-cloud-alibaba-sentinel" class="headerlink" title="10.1.1.4 使 用 手 册 https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_sentinel"></a>10.1.1.4 使 用 手 册 <a href="https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_sentinel">https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_sentinel</a></h4><h3 id="10-1-2-Sentinel是什么"><a href="#10-1-2-Sentinel是什么" class="headerlink" title="10.1.2 Sentinel是什么?"></a><strong>10.1.2 Sentinel</strong>是什么?</h3><h4 id="10-1-2-1-Sentinel-概述"><a href="#10-1-2-1-Sentinel-概述" class="headerlink" title="10.1.2.1 Sentinel 概述"></a>10.1.2.1 Sentinel 概述</h4><ol><li>Sentinel 是什么?</li></ol><p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p><ol start="2"><li>Sentinel 的主要特性</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620201315601.png" alt="image-20230620201315601"></p><p><strong>梳理</strong>: sentinel **可以完成的功能 **: <strong>绿色方框</strong>列出的部分</p><ol start="3"><li>Sentinel 的开源生态</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620201431927.png" alt="image-20230620201431927"></p><h4 id="10-1-2-2-一句话-Sentinel-分布式系统的流量防卫兵-保护你的微服务"><a href="#10-1-2-2-一句话-Sentinel-分布式系统的流量防卫兵-保护你的微服务" class="headerlink" title="10.1.2.2 一句话: Sentinel: 分布式系统的流量防卫兵, 保护你的微服务"></a>10.1.2.2 一句话: Sentinel: 分布式系统的流量防卫兵, 保护你的微服务</h4><h3 id="10-1-3-Sentinel核心功能"><a href="#10-1-3-Sentinel核心功能" class="headerlink" title="10.1.3 Sentinel核心功能"></a><strong>10.1.3 Sentinel</strong>核心功能</h3><h4 id="10-1-3-1-流量控制"><a href="#10-1-3-1-流量控制" class="headerlink" title="10.1.3.1 流量控制"></a>10.1.3.1 流量控制</h4><h4 id="10-1-3-2-熔断降级"><a href="#10-1-3-2-熔断降级" class="headerlink" title="10.1.3.2 熔断降级"></a>10.1.3.2 熔断降级</h4><p><strong>-</strong> 在调用系统的时候，如果调用链路中的某个资源出现了不稳定，最终会导致请求发生堆积，如下图：</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620201814295.png" alt="image-20230620201814295" style="zoom:50%;" /><p><strong>解读</strong>：</p><p>​<u>熔断降级可以解决这个问题</u>，所谓的熔断降级就是当检测到调用链路中某个资源出现不稳定的表现，例如请求响应时间长或异常比例升高的时候，则<u>对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联故障</u>。</p><h4 id="10-1-3-3-系统负载保护"><a href="#10-1-3-3-系统负载保护" class="headerlink" title="10.1.3.3 系统负载保护"></a>10.1.3.3 系统负载保护</h4><p>​根据系统能够处理的请求，和允许进来的请求，来做平衡，追求的目标是在系统不被拖垮的情况下**,** 提高系统的吞吐率</p><h4 id="10-1-3-4-消息削峰填谷"><a href="#10-1-3-4-消息削峰填谷" class="headerlink" title="10.1.3.4 消息削峰填谷"></a>10.1.3.4 消息削峰填谷</h4><p>​某瞬时来了大流量的请求**,** 而如果此时要处理所有请求，很可能会导致系统负载过高，影响稳定性。</p><p>​但其实可能后面几秒之内都没有消息投递，若直接把多余的消息丢掉则没有充分利用系统处理消息的能力</p><p><strong>- Sentinel 的Rate Limiter模式能在某一段时间间隔内以匀速方式处理这样的请求, 充分利用系统的处理能力, 也就是削峰填谷, 保证资源的稳定性</strong></p><h3 id="10-1-4-Sentinel两个组成部分"><a href="#10-1-4-Sentinel两个组成部分" class="headerlink" title="10.1.4 Sentinel两个组成部分"></a><strong>10.1.4 Sentinel</strong>两个组成部分</h3><h4 id="10-1-4-1-核心库-Java-客户端-不依赖任何框架-x2F-库，能够运行在所有-Java运行时环境，对-Spring-Cloud有较好的支持"><a href="#10-1-4-1-核心库-Java-客户端-不依赖任何框架-x2F-库，能够运行在所有-Java运行时环境，对-Spring-Cloud有较好的支持" class="headerlink" title="10.1.4.1 核心库:(Java 客户端)不依赖任何框架&#x2F;库，能够运行在所有 Java运行时环境，对 Spring Cloud有较好的支持"></a>10.1.4.1 核心库:(Java 客户端)不依赖任何框架&#x2F;库，能够运行在所有 Java运行时环境，对 Spring Cloud有较好的支持</h4><h4 id="10-1-4-2-控制台-Dashboard-基于-Spring-Boot-开发，打包后可以直接运行，不需要额外的-Tomcat-等应用容器-就跟nacos、eureka那种控制台那样"><a href="#10-1-4-2-控制台-Dashboard-基于-Spring-Boot-开发，打包后可以直接运行，不需要额外的-Tomcat-等应用容器-就跟nacos、eureka那种控制台那样" class="headerlink" title="10.1.4.2 控制台:(Dashboard)基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器(就跟nacos、eureka那种控制台那样)"></a>10.1.4.2 控制台:(Dashboard)基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器(就跟nacos、eureka那种控制台那样)</h4><h2 id="10-2-Sentinel控制台"><a href="#10-2-Sentinel控制台" class="headerlink" title="10.2 Sentinel控制台"></a>10.2 Sentinel控制台</h2><h3 id="10-2-1-需求分析-x2F-图解"><a href="#10-2-1-需求分析-x2F-图解" class="headerlink" title="10.2.1 需求分析**&#x2F;**图解"></a><strong>10.2.1</strong> 需求分析**&#x2F;**图解</h3><p><strong>1.</strong> 需求**:** 搭建 <strong>Sentinel</strong> 控制台，用于显示各个微服务的使用情况</p><h3 id="10-2-2-下载"><a href="#10-2-2-下载" class="headerlink" title="10.2.2 下载"></a><strong>10.2.2</strong> 下载</h3><h4 id="10-2-2-1-https-github-com-alibaba-Sentinel-releases-tag-v1-8-0"><a href="#10-2-2-1-https-github-com-alibaba-Sentinel-releases-tag-v1-8-0" class="headerlink" title="10.2.2.1 https://github.com/alibaba/Sentinel/releases/tag/v1.8.0"></a>10.2.2.1 <a href="https://github.com/alibaba/Sentinel/releases/tag/v1.8.0">https://github.com/alibaba/Sentinel/releases/tag/v1.8.0</a></h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620203427041.png" alt="image-20230620203427041" style="zoom:50%;" /><h3 id="10-2-3-运行"><a href="#10-2-3-运行" class="headerlink" title="10.2.3 运行"></a><strong>10.2.3</strong> 运行</h3><h4 id="10-2-3-1-指令"><a href="#10-2-3-1-指令" class="headerlink" title="10.2.3.1 指令:"></a>10.2.3.1 指令:</h4><p>我把下载的jar包放在 &#x2F;Applications&#x2F;Java&#x2F;jar包资源 此处了</p><p>因此在终端运行以下指令即可启动 Sentinel</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /Applications/Java/jar包资源</span><br><span class="line">java -jar sentinel-dashboard-1.8.0.jar //启动</span><br><span class="line">java -jar sentinel-dashboard-1.8.0.jar --server.port=9999//也可以自定义端口运行该进程</span><br><span class="line">Ctrl+C即可关闭服务</span><br></pre></td></tr></table></figure><h4 id="10-2-3-2-注意-Sentinel-控制台-默认端口是-8080"><a href="#10-2-3-2-注意-Sentinel-控制台-默认端口是-8080" class="headerlink" title="10.2.3.2 注意: Sentinel 控制台 默认端口是 8080"></a>10.2.3.2 注意: Sentinel 控制台 默认端口是 8080</h4><h3 id="10-2-4-访问"><a href="#10-2-4-访问" class="headerlink" title="10.2.4 访问"></a><strong>10.2.4</strong> 访问</h3><h4 id="10-2-4-1-浏览器-http-localhost-8080"><a href="#10-2-4-1-浏览器-http-localhost-8080" class="headerlink" title="10.2.4.1 浏览器: http://localhost:8080"></a>10.2.4.1 浏览器: <a href="http://localhost:8080/">http://localhost:8080</a></h4><h4 id="10-2-4-2-控制台页面"><a href="#10-2-4-2-控制台页面" class="headerlink" title="10.2.4.2 控制台页面"></a>10.2.4.2 控制台页面</h4><p><strong>1.</strong> 浏览器输入**: <a href="http://localhost:8080/">http://localhost:8080</a> ,** 用户**&#x2F;**密码都是 <strong>sentinel</strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620203842208.png" alt="image-20230620203842208" style="zoom:25%;" /><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620204626829.png" alt="image-20230620204626829" style="zoom:50%;" /><p><strong>2.</strong> <strong>登录成功后的页面</strong>, <strong>目前是空的，因为</strong> <strong>sentinel</strong> <strong>还没有进行流量监控</strong></p><h2 id="10-3-Sentinel监控微服务"><a href="#10-3-Sentinel监控微服务" class="headerlink" title="10.3 Sentinel监控微服务"></a>10.3 Sentinel监控微服务</h2><h3 id="10-3-1-需求分析-x2F-图解"><a href="#10-3-1-需求分析-x2F-图解" class="headerlink" title="10.3.1 需求分析**&#x2F;**图解"></a><strong>10.3.1</strong> 需求分析**&#x2F;**图解</h3><ol><li>需求**:** 使用 <strong>Sentinel</strong> 控制台对 <strong>member-service-nacos-provider-10004</strong> 微服务 进行实时监控</li></ol><p><strong>–</strong> 示意图</p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230620204744222.png" alt="image-20230620204744222" style="zoom: 50%;" /><ol start="2"><li>当调用了member-service-nacos-provider-10004微服务时,可以监控到请求的<strong>url&#x2F;QPS(每秒查询率)&#x2F;响应时间&#x2F;流量</strong></li></ol><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230620205650814.png" alt="image-20230620205650814" style="zoom:50%;" /><h3 id="10-3-2-代码-x2F-配置实现"><a href="#10-3-2-代码-x2F-配置实现" class="headerlink" title="10.3.2 代码**&#x2F;**配置实现"></a><strong>10.3.2</strong> 代码**&#x2F;**配置实现</h3><p><strong>1.</strong> 修改 <strong>member-service-nacos-provider-10004</strong> 的 <strong>pom.xml,</strong> 引入 <strong>alibaba-sentinel</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    引入alibaba-sentinel starter    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.</strong> <strong>修改</strong> <strong>member-service-nacos-provider-10004</strong> <strong>的</strong> <strong>application.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10004</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">member-service-nacos-provider</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/e_commerce_center_db?serverTimezone=GMT%2B8&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">QWEASDzxc123</span></span><br><span class="line"><span class="comment">#  配置nacos</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#配置nacos server的地址</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span> <span class="comment">#这个是 sentinel 控制台(sentinel dashboard)的地址 </span></span><br><span class="line">        <span class="comment">#解读 spring.cloud.sentinel.transport.port：</span></span><br><span class="line">        <span class="comment">#1. spring.cloud.sentinel.transport.port 端口配置会在被监控的微服务</span></span><br><span class="line">        <span class="comment"># 对应的机器上启动一个 Http Server</span></span><br><span class="line">        <span class="comment">#2. 该 Server 会与 Sentinel 控制台做交互</span></span><br><span class="line">        <span class="comment">#3. 比如 Sentinel 控制台添加了 1 个限流规则，会把规则数据 push 给这个</span></span><br><span class="line">        <span class="comment"># Http Server 接收，Http Server 再将规则注册到 微服务 中</span></span><br><span class="line">        <span class="comment">#4. 简单的说明: spring.cloud.sentinel.transport.port:指定被监控的微服务应用与</span></span><br><span class="line">        <span class="comment"># Sentinel 控制台交互的端口，微服务应用本地会起一个该端口占用的 Http Server</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span> <span class="comment">#默认 8719，假如被占用了, 会自动从 8719 开始依次+1 扫描。</span></span><br><span class="line">        <span class="comment">#直至找到未被占用的端口</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.study.springcloud.entity</span></span><br><span class="line"><span class="comment">#配置暴露所有的监控点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>3.</strong> <strong>成功启动后</strong>, netstat -anb <strong>可以查看到该端口</strong>.</p><h3 id="10-3-3-测试"><a href="#10-3-3-测试" class="headerlink" title="10.3.3 测试"></a><strong>10.3.3</strong> 测试</h3><h4 id="10-3-3-1-启动-Nacos-Server-8848"><a href="#10-3-3-1-启动-Nacos-Server-8848" class="headerlink" title="10.3.3.1 启动 Nacos Server 8848"></a>10.3.3.1 启动 Nacos Server 8848</h4><h4 id="10-3-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-3-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.3.3.2 启动 Sentinel8080 控制台 &#x2F; Sentinel dashboard"></a>10.3.3.2 启动 Sentinel8080 控制台 &#x2F; Sentinel dashboard</h4><h4 id="10-3-3-3-启动-member-service-nacos-provider-10004"><a href="#10-3-3-3-启动-member-service-nacos-provider-10004" class="headerlink" title="10.3.3.3 启动 member-service-nacos-provider-10004"></a>10.3.3.3 启动 member-service-nacos-provider-10004</h4><h4 id="10-3-3-4-浏览器-localhost-10004-x2F-member-x2F-get-x2F-1"><a href="#10-3-3-4-浏览器-localhost-10004-x2F-member-x2F-get-x2F-1" class="headerlink" title="10.3.3.4 浏览器: localhost:10004&#x2F;member&#x2F;get&#x2F;1"></a>10.3.3.4 浏览器: localhost:10004&#x2F;member&#x2F;get&#x2F;1</h4><h4 id="10-3-3-5-Sentinel-控制台监控页面"><a href="#10-3-3-5-Sentinel-控制台监控页面" class="headerlink" title="10.3.3.5 Sentinel 控制台监控页面"></a>10.3.3.5 Sentinel 控制台监控页面</h4><p><strong>1.</strong> 浏览器输入**: <a href="http://localhost:10004/member/get/1">http://localhost:10004/member/get/1</a>**</p><p><strong>2.</strong> <strong>进入到</strong> <strong>Sentinel</strong> <strong>查看实时监控效果</strong>, <a href="http://localhost:8080/#/dashboard">http://localhost:8080/#/dashboard</a></p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230620211122568.png" alt="image-20230620211122568" style="zoom:50%;" /><h3 id="10-3-4-注意事项和细节"><a href="#10-3-4-注意事项和细节" class="headerlink" title="10.3.4 注意事项和细节"></a><strong>10.3.4</strong> 注意事项和细节</h3><h4 id="10-3-4-1-QPS-Queries-Per-Second-每秒查询率-，是服务器每秒响应的查询次数"><a href="#10-3-4-1-QPS-Queries-Per-Second-每秒查询率-，是服务器每秒响应的查询次数" class="headerlink" title="10.3.4.1 QPS: Queries Per Second(每秒查询率)，是服务器每秒响应的查询次数"></a>10.3.4.1 QPS: Queries Per Second(每秒查询率)，是服务器每秒响应的查询次数</h4><h4 id="10-3-4-2-Sentinel采用的是懒加载，只有调用了某个接口-x2F-服务，才能看到监控数据"><a href="#10-3-4-2-Sentinel采用的是懒加载，只有调用了某个接口-x2F-服务，才能看到监控数据" class="headerlink" title="10.3.4.2 Sentinel采用的是懒加载，只有调用了某个接口&#x2F;服务，才能看到监控数据"></a>10.3.4.2 Sentinel采用的是懒加载，只有调用了某个接口&#x2F;服务，才能看到监控数据</h4><h2 id="10-4-Sentinel流量控制"><a href="#10-4-Sentinel流量控制" class="headerlink" title="10.4 Sentinel流量控制"></a>10.4 Sentinel流量控制</h2><h3 id="10-4-1-规则"><a href="#10-4-1-规则" class="headerlink" title="10.4.1 规则"></a><strong>10.4.1</strong> 规则</h3><p><strong>1.</strong> 先看一张图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230620211426555.png" alt="image-20230620211426555" style="zoom:40%;" /><ol start="2"><li>对上图的解读</li></ol><ul><li><p>资源名：唯一名称，默认请求路径</p></li><li><p>针对来源：Sentine可以<u>针对调用者进行限流，填写微服务名</u>，默认default（不区分来源）</p></li><li><p>阈值类型&#x2F;单机阈值：</p><ul><li>QPS（每秒钟的请求数量）：当调用该 api 的 QPS 达到阈值的时候，进行限流</li><li>线程数：当调用该 api 的线程数达到阈值的时候，进行限流</li></ul></li></ul><p>解读： <strong>QPS和线程数的区别</strong>，注意听，比如 QPS和线程我们都设置阈值为1</p><p>（1）对QPS而言，如果在1秒内，客户端发出了2 次请求，就达到阈值，从而限流</p><p>（2）对线程数而言，如果在1秒内，客户端发出了2 次请求，不一定达到线程限制的國值，为什么呢？假设我们1 次请求后台会创建一个线程，但是这个请求完成时间是 0.1 秒（可以视为该请求对应的线程存活 0.1 秒)，所以当客户端第2 次请求时(比如客户端是在0.3秒发出的），这时第 1个请求的线程就己经结束了，因此就没有达到线程的闻值，也不会限流。</p><p>（3）小伙伴可以这样理解，如果1个请求对应的线程平均执行时间为 0.1 那么，就相当于 QPS 为 10</p><ul><li><p>是否集群：不需要集群</p></li><li><p>流控模式：</p><ul><li>直接：api 达到限流条件时，直接限流</li><li>关联：当关联的资源达到闻值时，就限流自己</li><li>链路：当从某个接口过来的资源达到限流条件时，开启限流</li></ul></li><li><p>流控效果：</p><ul><li>快速失败：直接失败，抛异常</li><li>Warm Up：根据 code Factor（冷加载因子，默认3）的值，从阈值&#x2F;codeFactor，经过预热时长，才达到设置的 QPS 阈值</li><li>排队等待：匀速排队，让请求以匀速的速度通过，阈值类型必须设置为 QPS， 否则无效</li></ul></li></ul><h3 id="10-4-2-流量控制实例-QPS"><a href="#10-4-2-流量控制实例-QPS" class="headerlink" title="10.4.2 流量控制实例**-QPS**"></a><strong>10.4.2</strong> 流量控制实例**-QPS**</h3><h4 id="10-4-2-1-需求分析-x2F-图解"><a href="#10-4-2-1-需求分析-x2F-图解" class="headerlink" title="10.4.2.1 需求分析&#x2F;图解"></a>10.4.2.1 需求分析&#x2F;图解</h4><p> <strong>1.</strong> 需求**:** 通过 <strong>Sentinel</strong> 实现 流量控制<br> <strong>2.</strong> <strong>当调用</strong> <strong>member-service-nacos-provider-10004</strong> <strong>的</strong> <strong>&#x2F;member&#x2F;get&#x2F;</strong>   **API **时，限制 <strong>1</strong>秒内最多访问 <strong>1</strong> <strong>次，否则直接失败，抛异常</strong></p><h4 id="10-4-2-2-配置实现步骤"><a href="#10-4-2-2-配置实现步骤" class="headerlink" title="10.4.2.2 配置实现步骤"></a>10.4.2.2 配置实现步骤</h4><p> <strong>1.</strong> 为**&#x2F;member&#x2F;get&#x2F;1** 增加流控规则</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230622221155249.png" alt="image-20230622221155249"></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230622221223336.png" alt="image-20230622221223336" style="zoom:40%;" /><p><strong>2.</strong> <strong>在流控规则菜单，可以看到新增的流控规则</strong></p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230622221447805.png" alt="image-20230622221447805" style="zoom: 33%;" /><h4 id="10-4-2-3-测试"><a href="#10-4-2-3-测试" class="headerlink" title="10.4.2.3 测试"></a>10.4.2.3 测试</h4><h5 id="10-4-2-3-1-启动-Nacos-Server-8848"><a href="#10-4-2-3-1-启动-Nacos-Server-8848" class="headerlink" title="10.4.2.3.1 启动 Nacos Server 8848"></a><strong>10.4.2.3.1</strong> 启动 Nacos Server 8848</h5><h5 id="10-4-2-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard-10-4-2-3-3-启动-member-service-nacos-provider-10004"><a href="#10-4-2-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard-10-4-2-3-3-启动-member-service-nacos-provider-10004" class="headerlink" title="10.4.2.3.2 启动 Sentinel8080 控制台**&#x2F;Sentinel dashboard 10.4.2.3.3** 启动 **member-service-nacos-provider-10004 **"></a>10.4.2.3.2 启动 <strong>Sentinel8080</strong> 控制台**&#x2F;Sentinel dashboard 10.4.2.3.3** 启动 **member-service-nacos-provider-10004 **</h5><h5 id="10-4-2-3-4-浏览器-localhost-10004-x2F-member-x2F-get-x2F-1"><a href="#10-4-2-3-4-浏览器-localhost-10004-x2F-member-x2F-get-x2F-1" class="headerlink" title="10.4.2.3.4 浏览器**: localhost:10004&#x2F;member&#x2F;get&#x2F;1 **"></a><strong>10.4.2.3.4</strong> 浏览器**: localhost:10004&#x2F;member&#x2F;get&#x2F;1 **</h5><h5 id="10-4-2-3-5-Sentinel-控制台监控页面"><a href="#10-4-2-3-5-Sentinel-控制台监控页面" class="headerlink" title="10.4.2.3.5 Sentinel 控制台监控页面"></a><strong>10.4.2.3.5 Sentinel</strong> 控制台监控页面</h5><p><strong>1.</strong> 浏览器输入**: <a href="http://localhost:10004/member/get/1">http://localhost:10004/member/get/1</a> , 1** 秒钟内访问次数不超过 <strong>1</strong> 次**,** 页 面显示正常</p><p><strong>2.</strong> <strong>浏览器输入</strong>:<a href="http://localhost:10004/member/get/1">http://localhost:10004/member/get/1</a> ,1秒钟内访问次数超过1次, <strong>页面出现错误提示</strong></p><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230622221636917.png" alt="image-20230622221636917" style="zoom:33%;" /><h4 id="10-4-2-4-注意事项和细节"><a href="#10-4-2-4-注意事项和细节" class="headerlink" title="10.4.2.4 注意事项和细节"></a>10.4.2.4 注意事项和细节</h4><h5 id="1-流量规则改动，实时生效，不需重启微服务-Sentinel-控制台"><a href="#1-流量规则改动，实时生效，不需重启微服务-Sentinel-控制台" class="headerlink" title="1. 流量规则改动，实时生效，不需重启微服务 , Sentinel 控制台"></a><strong>1.</strong> 流量规则改动，实时生效，<u>不需重启微服务 <strong>, Sentinel</strong> 控制台</u></h5><p>​为什么？因为sentinel中规则一发生改动，就会将信息push到微服务主机监听sentinel服务的进程</p><h5 id="2-在-sentinel-配置流量规则时，如何配置通配符问题，-比如-x2F-member-x2F-get-x2F-1-x2F-member-x2F-get-x2F-2-统一使用一个规则"><a href="#2-在-sentinel-配置流量规则时，如何配置通配符问题，-比如-x2F-member-x2F-get-x2F-1-x2F-member-x2F-get-x2F-2-统一使用一个规则" class="headerlink" title="2. 在 sentinel 配置流量规则时，如何配置通配符问题， 比如 &#x2F;member&#x2F;get&#x2F;1 &#x2F;member&#x2F;get&#x2F;2 统一使用一个规则"></a><strong>2.</strong> 在 sentinel 配置流量规则时，如何配置通配符问题， 比如 &#x2F;member&#x2F;get&#x2F;1 &#x2F;member&#x2F;get&#x2F;2 统一使用一个规则</h5><ul><li>方案1: 在sentinel中 &#x2F;member&#x2F;get?id&#x3D;1 和 &#x2F;member&#x2F;get?id&#x3D;2 被统一认为是**&#x2F;member&#x2F;get** 所以只要对&#x2F;member&#x2F;get 限流就OK了.      (将要携带的参数放在载荷而不是路径中)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/member/get&quot;, params = &quot;id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">getgetMemberById</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">    <span class="type">Member</span> <span class="variable">member</span> <span class="operator">=</span> memberService.queryMemberById(id);</span><br><span class="line">    <span class="keyword">if</span>(member != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;查询成功 member-service-nacos-provider-10004&quot;</span>,member);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;402&quot;</span>,<span class="string">&quot;ID = &quot;</span>+ id + <span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/Users/donn/Library/Application Support/typora-user-images/image-20230622223803411.png" alt="image-20230622223803411" style="zoom: 50%;" /><p>访问：<a href="http://localhost:10004/member/get?id=3">http://localhost:10004/member/get?id=3</a></p><ul><li>方案2: URL资源清洗<br>可以通过 UrlCleaner 接口来实现资源清洗，也就是对于&#x2F;member&#x2F;get&#x2F;{id}这个 URL，我们可以统一归集到&#x2F;member&#x2F;get&#x2F;*资源下，具体配置代码如下，实现 UrlCleaner 接口，并重写 clean 方法即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加代码：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.study.springcloud.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.adapter.servlet.callback.UrlCleaner;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/6/22</span></span><br><span class="line"><span class="comment"> * 22:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomUrlCleaner</span> <span class="keyword">implements</span> <span class="title class_">UrlCleaner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">clean</span><span class="params">(String originURL)</span> &#123;</span><br><span class="line">        <span class="comment">//资源清洗</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(originURL))&#123;</span><br><span class="line">            <span class="keyword">return</span> originURL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (originURL.startsWith(<span class="string">&quot;/member/get&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">// 1. 如果请求的是接口 /member/get 开头的, 比如/member/get/1</span></span><br><span class="line">            <span class="comment">// 2. 给 sentinel 的返回的资源名就是 /member/get/*</span></span><br><span class="line">            <span class="comment">// 3. 在 sentinel 对 /member/get/* 添加流控规则即可</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;/member/get/*&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则 返回收到的URL即可</span></span><br><span class="line">        <span class="keyword">return</span> originURL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-如果-sentinel-流控规则没有持久化，当我们重启调用-API-所在微服务模块后，规则会丢失，需要重新加入"><a href="#3-如果-sentinel-流控规则没有持久化，当我们重启调用-API-所在微服务模块后，规则会丢失，需要重新加入" class="headerlink" title="3. 如果 sentinel 流控规则没有持久化，当我们重启调用 API 所在微服务模块后，规则会丢失，需要重新加入"></a><strong>3.</strong> <strong>如果</strong> <strong>sentinel</strong> <strong>流控规则没有持久化，当我们重启调用</strong> <strong>API</strong> <strong>所在微服务模块后，规则会丢失，需要重新加入</strong></h5><h3 id="10-4-3-流量控制实例-线程数"><a href="#10-4-3-流量控制实例-线程数" class="headerlink" title="10.4.3 流量控制实例**-**线程数"></a><strong>10.4.3</strong> 流量控制实例**-**线程数</h3><h4 id="10-4-3-1-需求分析-x2F-图解"><a href="#10-4-3-1-需求分析-x2F-图解" class="headerlink" title="10.4.3.1 需求分析&#x2F;图解"></a>10.4.3.1 需求分析&#x2F;图解</h4><p> <strong>1.</strong> 需求**:** 通过 <strong>Sentinel</strong> 实现 流量控制<br> <strong>2.</strong> 当调用 <strong>member-service-nacos-provider-10004</strong> 的 <strong>&#x2F;member&#x2F;get&#x2F;*</strong>   <strong>API</strong> 时，<u>限制只有一个工作线程</u>，否则直接失败，抛异常**.**</p><h4 id="10-4-3-2-配置实现步骤"><a href="#10-4-3-2-配置实现步骤" class="headerlink" title="10.4.3.2 配置实现步骤"></a>10.4.3.2 配置实现步骤</h4><p><strong>1.</strong> 为**&#x2F;member&#x2F;get&#x2F;*** 增加流控规则</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623143357430.png" alt="image-20230623143357430"></p><p><strong>2.</strong> <strong>在流控规则菜单，可以看到新增的流控规则</strong></p><h4 id="10-4-3-3-测试"><a href="#10-4-3-3-测试" class="headerlink" title="10.4.3.3 测试"></a>10.4.3.3 测试</h4><h5 id="10-4-3-3-1-启动-Nacos-Server-8848"><a href="#10-4-3-3-1-启动-Nacos-Server-8848" class="headerlink" title="10.4.3.3.1 启动 Nacos Server 8848"></a><strong>10.4.3.3.1</strong> 启动 Nacos Server 8848</h5><h5 id="10-4-3-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-4-3-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.4.3.3.2 启动 Sentinel8080 控制台**&#x2F;Sentinel dashboard **"></a>10.4.3.3.2 启动 <strong>Sentinel8080</strong> 控制台**&#x2F;Sentinel dashboard **</h5><h5 id="10-4-3-3-3-启动-member-service-nacos-provider-10004"><a href="#10-4-3-3-3-启动-member-service-nacos-provider-10004" class="headerlink" title="10.4.3.3.3 启动 **member-service-nacos-provider-10004 **"></a><strong>10.4.3.3.3</strong> 启动 **member-service-nacos-provider-10004 **</h5><h5 id="10-4-3-3-4-浏览器-localhost-10004-x2F-member-x2F-get-x2F-1"><a href="#10-4-3-3-4-浏览器-localhost-10004-x2F-member-x2F-get-x2F-1" class="headerlink" title="10.4.3.3.4 浏览器**: localhost:10004&#x2F;member&#x2F;get&#x2F;1 **"></a><strong>10.4.3.3.4</strong> 浏览器**: localhost:10004&#x2F;member&#x2F;get&#x2F;1 **</h5><h5 id="10-4-3-3-5-结果页面"><a href="#10-4-3-3-5-结果页面" class="headerlink" title="10.4.3.3.5 结果页面"></a><strong>10.4.3.3.5</strong> 结果页面</h5><p><strong>1.</strong> 浏览器输入**: <a href="http://localhost:10004/member/get/1">http://localhost:10004/member/get/1</a> ,** 快速刷新**,** 页面显示正常**(<strong>原因是服务执行时间很短，刷新下一次的时候，启动的工作线程，已经完成</strong>)**</p><p><strong>2.</strong> <strong>为了看到效果，我们修改下</strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;MemberController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//让它睡眠一下</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.</strong> <strong>重启</strong> <strong>member-service-nacos-provider-10004 ,</strong> <strong>注意</strong>需要重新加入流控规则.</p><p><strong>4.</strong> <strong>浏览器输入</strong>: <a href="http://localhost:10004/member/get/1">http://localhost:10004/member/get/1</a> , <strong>快速刷新</strong>, <strong>页面出现异常</strong></p><h4 id="10-4-3-4-注意事项和细节"><a href="#10-4-3-4-注意事项和细节" class="headerlink" title="10.4.3.4 注意事项和细节"></a>10.4.3.4 注意事项和细节</h4><p> <strong>1.</strong> <u>当我们请求一次微服务的 <strong>API</strong> 接口时，后台会启动一个线程</u></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623144551449.png" alt="image-20230623144551449" style="zoom:50%;" /><p>2.阈值类型 QPS 和 线程数的区别讨论</p><ul><li>如果一个线程平均执行时间为0.05秒，就说明在1秒钟，可以执行20次(相当于 QPS为20)</li><li>如果一个线程平均执行时间为1秒，说明1秒钟，可以执行1次(相当于 QPS为1)</li><li>如果一个线程平均执行时间为2秒，说明2秒钟内，才能执行1次请求</li></ul><h3 id="10-4-4-流量控制实例-关联"><a href="#10-4-4-流量控制实例-关联" class="headerlink" title="10.4.4 流量控制实例**-**关联"></a><strong>10.4.4</strong> 流量控制实例**-**关联</h3><h4 id="10-4-4-1-关联的含义"><a href="#10-4-4-1-关联的含义" class="headerlink" title="10.4.4.1 关联的含义"></a>10.4.4.1 关联的含义</h4><h5 id="10-4-4-1-1-当关联的资源达到阈值时，就限流自己"><a href="#10-4-4-1-1-当关联的资源达到阈值时，就限流自己" class="headerlink" title="10.4.4.1.1 当关联的资源达到阈值时，就限流自己"></a><strong>10.4.4.1.1</strong> <u>当关联的资源达到阈值时，就限流自己</u></h5><h4 id="10-4-4-2-需求分析-x2F-图解"><a href="#10-4-4-2-需求分析-x2F-图解" class="headerlink" title="10.4.4.2 需求分析&#x2F;图解"></a>10.4.4.2 需求分析&#x2F;图解</h4><p><strong>1.</strong> 需求**:** 通过 <strong>Sentinel</strong> 实现 流量控制</p><p><strong>2.</strong> 当调用 <strong>member-service-nacos-provider-10004</strong> 的 <strong>&#x2F;t2 API</strong> 接口时，如果 <strong>QPS</strong> 超过 <strong>1</strong>，这时调用 <strong>&#x2F;t1 API</strong> 接口 直接失败，抛异常**.** </p><p>​梳理: <strong>&#x2F;t2</strong> 是关联的资源 <strong>,</strong> 限流的资源是**&#x2F;t1**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/t1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">t1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;t1执行...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/t2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">t2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;t2执行...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-4-4-3-配置实现步骤"><a href="#10-4-4-3-配置实现步骤" class="headerlink" title="10.4.4.3 配置实现步骤"></a>10.4.4.3 配置实现步骤</h4><p> <strong>1.</strong> 为**&#x2F;t1** 增加流控规则</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623150310128.png" alt="image-20230623150310128" style="zoom:50%;" /><p><strong>2.</strong> <strong>在流控规则菜单，可以看到新增的流控规则</strong></p><h4 id="10-4-4-4-测试"><a href="#10-4-4-4-测试" class="headerlink" title="10.4.4.4 测试"></a>10.4.4.4 测试</h4><h5 id="10-4-4-4-1-启动-Nacos-Server-8848"><a href="#10-4-4-4-1-启动-Nacos-Server-8848" class="headerlink" title="10.4.4.4.1 启动 Nacos Server 8848"></a><strong>10.4.4.4.1</strong> 启动 Nacos Server 8848</h5><h5 id="10-4-4-4-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-4-4-4-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.4.4.4.2 启动 Sentinel8080 控制台**&#x2F;Sentinel dashboard**"></a>10.4.4.4.2 启动 <strong>Sentinel8080</strong> 控制台**&#x2F;Sentinel dashboard**</h5><h5 id="10-4-4-4-3-启动-member-service-nacos-provider-10004"><a href="#10-4-4-4-3-启动-member-service-nacos-provider-10004" class="headerlink" title="10.4.4.4.3 启动 **member-service-nacos-provider-10004 **"></a>10.4.4.4.3 启动 **member-service-nacos-provider-10004 **</h5><h5 id="10-4-4-4-4-「Postman模拟高并发访问-x2F-t2-」"><a href="#10-4-4-4-4-「Postman模拟高并发访问-x2F-t2-」" class="headerlink" title="10.4.4.4.4 「Postman模拟高并发访问**&#x2F;t2**」"></a><strong>10.4.4.4.4 「Postman</strong>模拟高并发访问**&#x2F;t2**」</h5><p><strong>1.</strong> 创建新的 <strong>http request</strong></p><p><strong>2.</strong> <strong>保存</strong> <strong>request</strong> <strong>到 一个新的</strong> <strong>collection</strong> <strong>中</strong></p><p><strong>3.</strong> <strong>设置</strong> <strong>run collection</strong> <strong>参数</strong>, <strong>并运行</strong></p><p><strong>4.</strong> <strong>浏览器访问</strong>: <a href="http://localhost:10004/t1">http://localhost:10004/t1</a></p><h5 id="10-4-4-4-5-浏览器-localhost-10004-x2F-t1"><a href="#10-4-4-4-5-浏览器-localhost-10004-x2F-t1" class="headerlink" title="10.4.4.4.5 浏览器: localhost:10004&#x2F;t1"></a><strong>10.4.4.4.5</strong> 浏览器: localhost:10004&#x2F;t1</h5><p><strong>1.</strong> 浏览器访问 <strong><a href="http://localhost:10004/t1">http://localhost:10004/t1</a></strong> 的结果页面</p><h4 id="10-4-4-5-注意事项和细节"><a href="#10-4-4-5-注意事项和细节" class="headerlink" title="10.4.4.5 注意事项和细节"></a>10.4.4.5 注意事项和细节</h4><p> <strong>10.4.4.5.1</strong> 在 <strong>postman</strong> 执行 高并发访问 <strong>&#x2F;t2</strong> 没有结束时， 去访问 <strong>&#x2F;t1</strong> 才能看到流控异常出现</p><h3 id="10-4-5-流量控制实例-Warm-up"><a href="#10-4-5-流量控制实例-Warm-up" class="headerlink" title="10.4.5 流量控制实例**-Warm up**"></a>10.4.5 流量控制实例**-Warm up**</h3><h4 id="10-4-5-1-Warm-up-介绍"><a href="#10-4-5-1-Warm-up-介绍" class="headerlink" title="10.4.5.1 Warm up 介绍"></a>10.4.5.1 Warm up 介绍</h4><p><strong>1.</strong> 概述</p><ul><li><strong>当流量突然增大的时候，我们常常会希望系统从空闲状态到繁忙状态的切换的时间长 一些。即如果系统在此之前长期处于空闲的状态，我们希望处理请求的数量是缓步的 增多，经过预期的时间以后，到达系统处理请求个数的最大值。</strong>Warm Up(<strong>冷启动， 预热</strong>)<strong>模式就是为了实现这个目的的。</strong></li><li><strong>这个场景主要用于启动需要额外开销的场景，例如建立数据库连接等</strong></li></ul><p><strong>2.</strong> <strong>一张图</strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623215536876.png" alt="image-20230623215536876" style="zoom:50%;" /><ul><li><strong>通常冷启动的过程系统允许通过的</strong> <strong>QPS</strong> <strong>曲线图</strong>(上图)</li><li><strong>默认</strong> <strong>coldFactor</strong> <strong>为</strong> <strong>3</strong>，即请求 <strong>QPS</strong> <strong>从</strong> <strong>threshold &#x2F; 3</strong> <strong>开始，经预热时长逐渐升至设定的</strong> <strong>QPS</strong> <strong>阈值</strong></li><li><strong>这里的</strong>threshold <strong>就是最终要达到的</strong>QPS阈值.</li></ul><h5 id="10-4-5-1-1-文-档"><a href="#10-4-5-1-1-文-档" class="headerlink" title="10.4.5.1.1 文 档 :"></a><strong>10.4.5.1.1</strong> 文 档 <strong>:</strong></h5><p><strong><a href="https://github.com/alibaba/Sentinel/wiki/%E9%99%90%E6%B5%81---%E5%86%B7%E5%90%AF%E5%8A%A8">https://github.com/alibaba/Sentinel/wiki/%E9%99%90%E6%B5%81---%E5%86%B7%E5%90%AF%E5%8A%A8</a></strong></p><h5 id="10-4-5-1-2-默认-coldFactor-为-3，即请求-QPS-从-threshold-x2F-3-开始，经预热时长逐渐升至设定的-QPS-阈值"><a href="#10-4-5-1-2-默认-coldFactor-为-3，即请求-QPS-从-threshold-x2F-3-开始，经预热时长逐渐升至设定的-QPS-阈值" class="headerlink" title="10.4.5.1.2 默认 coldFactor 为 3，即请求 QPS 从 threshold &#x2F; 3 开始，经预热时长逐渐升至设定的 QPS 阈值"></a><strong>10.4.5.1.2</strong> 默认 <strong>coldFactor</strong> 为 <strong>3</strong>，即请求 <strong>QPS</strong> 从 <strong>threshold &#x2F; 3</strong> 开始，经预热时长逐渐升至设定的 <strong>QPS</strong> 阈值</h5><h5 id="10-4-5-1-3-Warm-up-称为-冷启动-x2F-预热"><a href="#10-4-5-1-3-Warm-up-称为-冷启动-x2F-预热" class="headerlink" title="10.4.5.1.3 Warm up 称为 冷启动**&#x2F;**预热"></a><strong>10.4.5.1.3 Warm up</strong> 称为 冷启动**&#x2F;**预热</h5><h5 id="10-4-5-1-4-应用场景-秒杀在开启瞬间，大流量很容易造成冲垮系统，Warmup-可慢慢的把流量放入，最终将阀值增长到设置阀值"><a href="#10-4-5-1-4-应用场景-秒杀在开启瞬间，大流量很容易造成冲垮系统，Warmup-可慢慢的把流量放入，最终将阀值增长到设置阀值" class="headerlink" title="10.4.5.1.4 应用场景**:** 秒杀在开启瞬间，大流量很容易造成冲垮系统，Warmup 可慢慢的把流量放入，最终将阀值增长到设置阀值"></a><strong>10.4.5.1.4</strong> 应用场景**:** 秒杀在开启瞬间，大流量很容易造成冲垮系统，<strong>Warmup</strong> 可慢慢的把流量放入，最终将阀值增长到设置阀值</h5><h4 id="10-4-5-2-需求分析-x2F-图解"><a href="#10-4-5-2-需求分析-x2F-图解" class="headerlink" title="10.4.5.2 需求分析&#x2F;图解"></a>10.4.5.2 需求分析&#x2F;图解</h4><p><strong>1.</strong> 需求**:** 通过 <strong>Sentinel</strong> 实现流量控制**,**演示 <strong>Warm up</strong></p><p><strong>2.</strong> 调用 <strong>member-service-nacos-provider-10004</strong> 的 <strong>&#x2F;t2 API</strong> 接口，将 <strong>QPS</strong> 设置为 <strong>9,</strong> 设置 <strong>Warm up</strong> 值为 <strong>3</strong></p><p><strong>4.</strong> 含义为 请求 <strong>&#x2F;t2</strong> 的 <strong>QPS</strong> 从 <strong>threshold &#x2F; 3( 9 &#x2F;3 &#x3D; 3)</strong> 开始，经预热时长**(3** 秒**)<strong>逐渐升至 设定的 <strong>QPS</strong> 阈值</strong>(9)**</p><p><strong>5.</strong> 为什么是 <strong>9 &#x2F; 3,</strong> 这个是 <strong>3</strong> 就是默认冷启动启动加载因子 <strong>coldFactor&#x3D;3</strong></p><p><strong>6.</strong> 测试预期效果**:** 在前 <strong>3</strong> 秒，如果访问 <strong>&#x2F;t2</strong> 的 <strong>QPS</strong> 超过 <strong>3,</strong> 会直接报错，在 <strong>3</strong> 秒后 访问 <strong>&#x2F;t2</strong> 的 <strong>QPS</strong> 超过 <strong>3,</strong> 小于等于 <strong>9,</strong> 是正常访问</p><h4 id="10-4-5-3-配置实现步骤"><a href="#10-4-5-3-配置实现步骤" class="headerlink" title="10.4.5.3 配置实现步骤"></a>10.4.5.3 配置实现步骤</h4><p><strong>1.</strong> 为**&#x2F;t2** 增加流控规则</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623220623200.png" alt="image-20230623220623200" style="zoom:50%;" /><p><strong>2.</strong> <strong>在流控规则菜单，可以看到新增的流控规则</strong></p><h4 id="10-4-5-4-测试"><a href="#10-4-5-4-测试" class="headerlink" title="10.4.5.4 测试"></a>10.4.5.4 测试</h4><h5 id="10-4-5-4-1-启动-Nacos-Server-8848"><a href="#10-4-5-4-1-启动-Nacos-Server-8848" class="headerlink" title="10.4.5.4.1 启动 Nacos Server 8848"></a><strong>10.4.5.4.1</strong> 启动 Nacos Server 8848</h5><h5 id="10-4-5-4-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-4-5-4-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.4.5.4.2 启动 Sentinel8080 控制台**&#x2F;Sentinel dashboard **"></a>10.4.5.4.2 启动 <strong>Sentinel8080</strong> 控制台**&#x2F;Sentinel dashboard **</h5><h5 id="10-4-5-4-3-启动-member-service-nacos-provider-10004"><a href="#10-4-5-4-3-启动-member-service-nacos-provider-10004" class="headerlink" title="10.4.5.4.3 启动 **member-service-nacos-provider-10004 **"></a><strong>10.4.5.4.3</strong> 启动 **member-service-nacos-provider-10004 **</h5><h5 id="10-4-5-4-4-浏览器-localhost-10004-x2F-t2"><a href="#10-4-5-4-4-浏览器-localhost-10004-x2F-t2" class="headerlink" title="10.4.5.4.4 浏览器**: localhost:10004&#x2F;t2**"></a><strong>10.4.5.4.4</strong> 浏览器**: localhost:10004&#x2F;t2**</h5><p><strong>1.</strong> 浏览器访问 <strong><a href="http://localhost:10004/t2">http://localhost:10004/t2</a></strong> 快速刷新页面，在前 <strong>3</strong> 秒，会出现流控异常， 后 <strong>3</strong> 秒就正常了**(<strong>如果你刷新非常快 <strong>QPS&gt;9</strong> <strong>,</strong> 仍然会出现流控异常</strong>)**</p><h4 id="10-4-5-5-注意事项和细节"><a href="#10-4-5-5-注意事项和细节" class="headerlink" title="10.4.5.5 注意事项和细节"></a>10.4.5.5 注意事项和细节</h4><p> <strong>10.4.5.5.1</strong> 测试 <strong>Warm up</strong> 效果不是很好测，如果出不来可以尝试，调整流控规则**:** 比如 <strong>QPS</strong> 为 **11, Warm up 预热时间 **6 秒</p><h5 id="10-4-5-5-2-如果请求停止-即-一段时间没有达到阈值-Warm-up-过程将重复-小伙伴可以理解是一个弹性过程"><a href="#10-4-5-5-2-如果请求停止-即-一段时间没有达到阈值-Warm-up-过程将重复-小伙伴可以理解是一个弹性过程" class="headerlink" title="10.4.5.5.2 如果请求停止**(即:** 一段时间没有达到阈值**), Warm up** 过程将重复**,** 小伙伴可以理解是一个弹性过程"></a><strong>10.4.5.5.2</strong> 如果请求停止**(<strong>即</strong>:** 一段时间没有达到阈值**), Warm up** 过程将重复**,** 小伙伴可以理解是一个弹性过程</h5><h3 id="10-4-6-流量控制实例-排队"><a href="#10-4-6-流量控制实例-排队" class="headerlink" title="10.4.6 流量控制实例**-**排队"></a>10.4.6 流量控制实例**-**排队</h3><h4 id="10-4-6-1-排队-介绍"><a href="#10-4-6-1-排队-介绍" class="headerlink" title="10.4.6.1 排队 介绍"></a>10.4.6.1 排队 介绍</h4><p><strong>1.</strong> 排队方式:这种方式严格控制了请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法</p><p><strong>2.</strong> <strong>一张图</strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623221119829.png" alt="image-20230623221119829" style="zoom:33%;" /><p><strong>3.</strong> <strong>这种方式主要用于处理间隔性突发的流量，例如消息队列。比如这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，<u>我们希望系统能够在接下来的空闲期间逐渐处理这些请求</u>，而不是在第一秒直接拒绝多余的请求。-类似前面说的削峰填谷</strong></p><p><strong>4.</strong> <strong>匀速排队，阈值必须设置为QPS</strong></p><h4 id="10-4-6-2-需求分析-x2F-图解"><a href="#10-4-6-2-需求分析-x2F-图解" class="headerlink" title="10.4.6.2 需求分析&#x2F;图解"></a>10.4.6.2 需求分析&#x2F;图解</h4><p><strong>1.</strong> 需求**:** 通过 <strong>Sentinel</strong> 实现 流量控制**-<strong>排队<br><strong>2.</strong> 调用 <strong>member-service-nacos-provider-10004</strong> 的 <strong>&#x2F;t2 API</strong> 接口，将 <strong>QPS</strong> 设置为 <strong>1 **<br><strong>3.</strong> 当调用 <strong>&#x2F;t2</strong> 的 <strong>QPS</strong> 超过 <strong>1</strong> 时，不拒绝请求，而是排队等待</strong>,</strong> 依次执行<br><strong>4.<strong>当等待时间超过 <strong>10</strong> 秒，则为等待超时——</strong>等待超时就不要了</strong></p><h4 id="10-4-6-3-修改业务类"><a href="#10-4-6-3-修改业务类" class="headerlink" title="10.4.6.3 修改业务类"></a>10.4.6.3 修改业务类</h4><p><strong>1.</strong> 为了测试看到效果，修改 <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;MemberController.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/t2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">t2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//模拟线程执行时间为1秒</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  log.info(<span class="string">&quot;执行 t2() 线程 id= &quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;t2执行...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-4-6-4-配置实现步骤"><a href="#10-4-6-4-配置实现步骤" class="headerlink" title="10.4.6.4 配置实现步骤"></a>10.4.6.4 配置实现步骤</h4><p><strong>1.</strong> 为**&#x2F;t2** 增加流控规则</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623222712777.png" alt="image-20230623222712777" style="zoom:50%;" /><p><strong>2.</strong> <strong>在流控规则菜单，可以看到新增的流控规则</strong></p><h4 id="10-4-6-5-测试"><a href="#10-4-6-5-测试" class="headerlink" title="10.4.6.5 测试"></a>10.4.6.5 测试</h4><h5 id="10-4-6-5-1-启动-Nacos-Server-8848"><a href="#10-4-6-5-1-启动-Nacos-Server-8848" class="headerlink" title="10.4.6.5.1 启动 Nacos Server 8848"></a><strong>10.4.6.5.1</strong> 启动 Nacos Server 8848</h5><h5 id="10-4-6-5-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-4-6-5-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.4.6.5.2 启动 Sentinel8080 控制台**&#x2F;Sentinel dashboard **"></a>10.4.6.5.2 启动 <strong>Sentinel8080</strong> 控制台**&#x2F;Sentinel dashboard **</h5><h5 id="10-4-6-5-3-启动-member-service-nacos-provider-10004"><a href="#10-4-6-5-3-启动-member-service-nacos-provider-10004" class="headerlink" title="10.4.6.5.3 启动 **member-service-nacos-provider-10004 **"></a><strong>10.4.6.5.3</strong> 启动 **member-service-nacos-provider-10004 **</h5><h5 id="10-4-6-5-4-浏览器-localhost-10004-x2F-t2"><a href="#10-4-6-5-4-浏览器-localhost-10004-x2F-t2" class="headerlink" title="10.4.6.5.4 浏览器**: localhost:10004&#x2F;t2**"></a><strong>10.4.6.5.4</strong> 浏览器**: localhost:10004&#x2F;t2**</h5><p><strong>1.</strong> 浏览器访问 <strong><a href="http://localhost:10004/t2">http://localhost:10004/t2</a></strong> 快速刷新页面 <strong>9</strong> 次，观察前台**&#x2F;**后台输出的情况</p><p>输出结果分析：没有报错误，后台请求排队执行，每隔1s匀速执行</p><p><strong>2.</strong> <strong>浏览器访问</strong> <strong><a href="http://localhost:10004/t2">http://localhost:10004/t2</a></strong> <strong>快速刷新页面</strong>20<strong>次，当请求等待时间超过</strong>10S, <strong>仍然出现流控异常</strong></p><h2 id="10-5-Sentinel熔断降级"><a href="#10-5-Sentinel熔断降级" class="headerlink" title="10.5 Sentinel熔断降级"></a>10.5 Sentinel熔断降级</h2><h3 id="10-5-1-线程堆积引出熔断降级"><a href="#10-5-1-线程堆积引出熔断降级" class="headerlink" title="10.5.1 线程堆积引出熔断降级"></a><strong>10.5.1</strong> 线程堆积引出熔断降级</h3><p><strong>1.</strong> 一个服务常常会调用别的模块，可能是另外的一个远程服务、数据库，或者第三方 API 等。</p><p><strong>2.</strong> 例如，支付的时候，可能需要远程调用银联提供的 API;查询某个商品的价格，可能需 要进行数据库查询。然而，这个被依赖服务的稳定性是不能保证的。如果依赖的服务出现 了不稳定的情况，请求的响应时间变长，那么调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身也变得不可用</p><p><strong>3.</strong> 这时，我们<u>对不稳定的服务进行熔断降级，让其快速返回结果，不要造成线程堆积</u></p><h3 id="10-5-2-文档地址-https-sentinelguard-io-zh-cn-docs-circuit-breaking-html"><a href="#10-5-2-文档地址-https-sentinelguard-io-zh-cn-docs-circuit-breaking-html" class="headerlink" title="10.5.2 文档地址**: https://sentinelguard.io/zh-cn/docs/circuit-breaking.html**"></a><strong>10.5.2</strong> 文档地址**: <a href="https://sentinelguard.io/zh-cn/docs/circuit-breaking.html">https://sentinelguard.io/zh-cn/docs/circuit-breaking.html</a>**</h3><h3 id="10-5-3-基本介绍"><a href="#10-5-3-基本介绍" class="headerlink" title="10.5.3 基本介绍"></a><strong>10.5.3</strong> 基本介绍</h3><p><strong>1.</strong> 一张图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623223928543.png" alt="image-20230623223928543" style="zoom:50%;" /><p><strong>2.</strong> <strong>解读上图</strong>:</p><ul><li><strong>现代微服务架构都是分布式的，由非常多的服务组成。不同服务之间相互调用，组成复杂的调用链路。</strong></li><li><strong>链路调用中会产生放大的效果。复杂链路上的某一环不稳定，就可能会层层级联，最终导致整个链路都不可用。</strong></li><li><strong>因此需要对不稳定的弱依赖服务调用进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩</strong></li></ul><p><strong>3.</strong> <strong>熔断,降级,限流三者的关系</strong></p><ul><li><p>熔断：强调的是服务之间的调用能实现自我恢复的状态 </p></li><li><p>限流：是从系统的流量入口考虑, 从进入的流量上进行限制**, **达到保护系统的作用</p></li><li><p>降级：是从系统业务的维度考虑，流量大了或者频繁异常, 可以牺牲一些非核心业务，保护核心流程正常使用</p></li></ul><p>-熔断是降级方式的一种</p><p>-降级又是限流的一种方式  </p><p>-三者都是为了通过一定的方式<strong>在流量过大或者出现异常时,保护系统的手段</strong></p><h3 id="10-5-4-熔断策略"><a href="#10-5-4-熔断策略" class="headerlink" title="10.5.4 熔断策略"></a><strong>10.5.4</strong> 熔断策略</h3><h4 id="10-5-4-1-慢调用比例"><a href="#10-5-4-1-慢调用比例" class="headerlink" title="10.5.4.1 慢调用比例"></a>10.5.4.1 慢调用比例</h4><p>1、慢调用比例 (SLOW_REQUEST_RATIO):选择以慢调用比例作为阈值，需要设置允许的慢调用 <strong>RT</strong>(即最大的响应时间)，<strong>请求的响应时间大于该值则统计为<u>慢调用</u></strong></p><p>2、当<strong>单位统计时长(statIntervalMs)内请求数目大于设置的最小请求数目</strong>，并且<strong>慢调用的<u>比例</u>大于阈值</strong>，则接下来的熔断时长内请求会自动被熔断</p><p>3、熔断时长后,熔断器会进入探测恢复状态(HALF-OPEN 状态)，若接下来的一个请求响应时间小于设置的慢调用RT则结束熔断，若大于设置的慢调用RT 则会再次被熔断</p><p>4、配置参考</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623225930567.png" alt="image-20230623225930567" style="zoom:33%;" /><h4 id="10-5-4-2-异常比例"><a href="#10-5-4-2-异常比例" class="headerlink" title="10.5.4.2 异常比例"></a>10.5.4.2 异常比例</h4><p>1、异常比例 (ERROR_RATIO):当单位统计时长(statIntervalMs)内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断</p><p>2、经过熔断时长后熔断器会进入探测恢复状态(HALF-OPEN状态) </p><p>3、若接下来的一个请求成功完成(没有错误)则结束熔断,否则会再次被熔断</p><p>4、异常比率的阈值范围是[0.0, 1.0]，代表0% - 100%</p><p>5、配置参考</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623230152696.png" alt="image-20230623230152696" style="zoom:33%;" /><p>6、工作示意图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623230238823.png" alt="image-20230623230238823" style="zoom:33%;" /><h4 id="10-5-4-3-异常数"><a href="#10-5-4-3-异常数" class="headerlink" title="10.5.4.3 异常数"></a>10.5.4.3 异常数</h4><p>1、异常数 (ERROR_COUNT):<u>当单位统计时长内的异常数目超过阈值之后会自动进行熔断</u></p><p>2、经过熔断时长后熔断器会进入探测恢复状态(HALF-OPEN 状态) </p><p>3、若接下来的一个请求成功完成(没有错误)则结束熔断，否则会再次被熔断</p><p>4、配置参考</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623230424805.png" alt="image-20230623230424805" style="zoom:33%;" /><h3 id="10-5-5-熔断降级实例-慢调用比例"><a href="#10-5-5-熔断降级实例-慢调用比例" class="headerlink" title="10.5.5 熔断降级实例**-**慢调用比例"></a><strong>10.5.5</strong> 熔断降级实例**-**慢调用比例</h3><h4 id="10-5-5-1-需求分析-x2F-图解"><a href="#10-5-5-1-需求分析-x2F-图解" class="headerlink" title="10.5.5.1 需求分析&#x2F;图解"></a>10.5.5.1 需求分析&#x2F;图解</h4><p><strong>1.</strong> 需求**:** 通过 <strong>Sentinel</strong> 实现 熔断降级控制**-**<u>慢调用比例</u></p><p><strong>2.</strong> <strong>当调用</strong> <strong>member-service-nacos-provider-10004</strong> <strong>的</strong> <strong>&#x2F;t3 API</strong> <strong>接口时，如果在</strong> <strong>1s</strong> <strong>内持续进入了</strong> <strong>5</strong> <strong>个请求，并且请求的平均响应时间超过</strong> <strong>200ms,</strong> <strong>那么就在未来</strong> <strong>10</strong> <strong>秒钟内，断路器打开</strong>, <strong>让</strong> <strong>&#x2F;t3 API</strong> <strong>接口微服务不可用</strong></p><p><strong>3.</strong> <strong>后面对</strong>&#x2F;t3 API <strong>接口访问降到</strong> <strong>1S</strong> <strong>内</strong> <strong>1</strong> <strong>个请求，降低访问量了，断路器关闭，微服务恢复</strong></p><h4 id="10-5-5-2-修改业务类"><a href="#10-5-5-2-修改业务类" class="headerlink" title="10.5.5.2 修改业务类"></a>10.5.5.2 修改业务类</h4><p><strong>1.</strong> 修改 <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;MemberController.java</strong> 增加方法 <strong>t3()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/t3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">t3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//模拟线程执行时间为1秒</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;熔断降级测试 执行 t3() 线程 id= &quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;t3执行...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-5-5-3-配置实现步骤"><a href="#10-5-5-3-配置实现步骤" class="headerlink" title="10.5.5.3 配置实现步骤"></a>10.5.5.3 配置实现步骤</h4><p><strong>1.</strong> 为**&#x2F;t3** 增加降级规则</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230623231431243.png" alt="image-20230623231431243" style="zoom:50%;" /><p><strong>2.</strong> <strong>在流控规则菜单，可以看到新增的降级规则</strong></p><h4 id="10-5-5-4-测试"><a href="#10-5-5-4-测试" class="headerlink" title="10.5.5.4 测试"></a>10.5.5.4 测试</h4><h5 id="10-5-5-4-1-启动-Nacos-Server-8848"><a href="#10-5-5-4-1-启动-Nacos-Server-8848" class="headerlink" title="10.5.5.4.1 启动 Nacos Server 8848"></a><strong>10.5.5.4.1</strong> 启动 Nacos Server 8848</h5><h5 id="10-5-5-4-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-5-5-4-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.5.5.4.2 启动 Sentinel8080 控制台**&#x2F;Sentinel dashboard **"></a>10.5.5.4.2 启动 <strong>Sentinel8080</strong> 控制台**&#x2F;Sentinel dashboard **</h5><h5 id="10-5-5-4-3-启动-member-service-nacos-provider-10004"><a href="#10-5-5-4-3-启动-member-service-nacos-provider-10004" class="headerlink" title="10.5.5.4.3 启动 member-service-nacos-provider-10004"></a><strong>10.5.5.4.3</strong> 启动 <strong>member-service-nacos-provider-10004</strong></h5><h5 id="10-5-5-4-4-Postman测试"><a href="#10-5-5-4-4-Postman测试" class="headerlink" title="10.5.5.4.4 Postman测试"></a><strong>10.5.5.4.4 Postman</strong>测试</h5><p><strong>1.</strong> 先创建 <strong>collection ,</strong> 也可以在已经存在的 <strong>collection</strong> 进行修改</p><p>…………</p><h4 id="10-5-5-5-注意事项和细节"><a href="#10-5-5-5-注意事项和细节" class="headerlink" title="10.5.5.5 注意事项和细节"></a>10.5.5.5 注意事项和细节</h4><h5 id="10-5-5-5-1-平均响应时间超出阈值且在-1s-内通过的请求-gt-x3D-5-，-两个条件同时满足后触发降级"><a href="#10-5-5-5-1-平均响应时间超出阈值且在-1s-内通过的请求-gt-x3D-5-，-两个条件同时满足后触发降级" class="headerlink" title="10.5.5.5.1 平均响应时间超出阈值且在 1s 内通过的请求**&gt;&#x3D;5**， 两个条件同时满足后触发降级"></a>10.5.5.5.1 平均响应时间超出阈值且在 <strong>1s</strong> 内通过的请求**&gt;&#x3D;5**， 两个条件同时满足后触发降级</h5><h5 id="10-5-5-5-2-熔断时间过后，关闭断路器，访问恢复正常"><a href="#10-5-5-5-2-熔断时间过后，关闭断路器，访问恢复正常" class="headerlink" title="10.5.5.5.2 熔断时间过后，关闭断路器，访问恢复正常"></a>10.5.5.5.2 熔断时间过后，关闭断路器，访问恢复正常</h5><h3 id="10-5-6-熔断降级实例-异常比例"><a href="#10-5-6-熔断降级实例-异常比例" class="headerlink" title="10.5.6 熔断降级实例-异常比例"></a>10.5.6 熔断降级实例-异常比例</h3><h4 id="10-5-6-1-需求分析-x2F-图解"><a href="#10-5-6-1-需求分析-x2F-图解" class="headerlink" title="10.5.6.1 需求分析&#x2F;图解"></a>10.5.6.1 需求分析&#x2F;图解</h4><p><strong>1.</strong> 需求**:** 通过 <strong>Sentinel</strong> 实现 熔断降级控制</p><p><strong>2.</strong> 当调用 <strong>member-service-nacos-provider-10004</strong> 的 <strong>&#x2F;t4 API</strong> 接口时，当资源的每秒请求量**&gt;&#x3D;5<strong>，并且每秒异常总数占通过量的比值超过</strong>20%(<strong>即异常比例到</strong>20%),** 断路器打开**(<strong>即</strong>:** 进入降级状态**),** 让 <strong>&#x2F;t4 API</strong> 接口微服务不可用</p><p><strong>3.</strong> 当对**&#x2F;t4 API** 接口 访问降到 <strong>1S</strong> 内 <strong>1</strong> 个请求，降低访问量了，断路器关闭，<strong>5</strong> 秒后微服务恢复</p><h4 id="10-5-6-2-修改业务类"><a href="#10-5-6-2-修改业务类" class="headerlink" title="10.5.6.2 修改业务类"></a>10.5.6.2 修改业务类</h4><p><strong>1.</strong> 修改 <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;MemberController.java</strong> 增加方法 <strong>t4()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/t4&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">t4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((++num) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//异常比例 50% System.out.println(3 / 0);</span></span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;熔断降级测试【异常比例】 执行 t4() 线程 id= &quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;t4()执行&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-5-6-3-配置实现步骤"><a href="#10-5-6-3-配置实现步骤" class="headerlink" title="10.5.6.3 配置实现步骤"></a>10.5.6.3 配置实现步骤</h4><p><strong>1.</strong> 为**&#x2F;t4** 增加降级规则</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230624094738411.png" alt="image-20230624094738411" style="zoom:50%;" /><p><strong>2.</strong> <strong>在流控规则菜单，可以看到新增的降级规则</strong></p><h4 id="10-5-6-4-测试"><a href="#10-5-6-4-测试" class="headerlink" title="10.5.6.4 测试"></a>10.5.6.4 测试</h4><h5 id="10-5-6-4-1-启动-Nacos-Server-8848"><a href="#10-5-6-4-1-启动-Nacos-Server-8848" class="headerlink" title="10.5.6.4.1 启动 Nacos Server 8848"></a>10.5.6.4.1 启动 Nacos Server 8848</h5><h5 id="10-5-6-4-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-5-6-4-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.5.6.4.2 启动 Sentinel8080 控制台&#x2F;Sentinel dashboard"></a>10.5.6.4.2 启动 Sentinel8080 控制台&#x2F;Sentinel dashboard</h5><h5 id="10-5-6-4-3-启动-member-service-nacos-provider-10004"><a href="#10-5-6-4-3-启动-member-service-nacos-provider-10004" class="headerlink" title="10.5.6.4.3 启动 member-service-nacos-provider-10004"></a>10.5.6.4.3 启动 member-service-nacos-provider-10004</h5><h5 id="10-5-6-4-4-Postman测试"><a href="#10-5-6-4-4-Postman测试" class="headerlink" title="10.5.6.4.4 Postman测试"></a>10.5.6.4.4 Postman测试</h5><p><strong>1.</strong> 先创建给 <strong>collection ,</strong> 也可以在已经存在的 <strong>collection</strong> 进行修改**,** 一定确保更新成功**.**</p><p><strong>2.</strong> <strong>点击</strong> <strong>Run sentinel</strong></p><p><strong>3.</strong> 浏览器访问: <a href="http://localhost:10004/t4">http://localhost:10004/t4</a> 出现 Blocked by Sentinel (flow limiting)</p><p><strong>4.</strong> <strong>停止</strong> <strong>Postman</strong></p><p><strong>5.</strong> 浏览器访问: <a href="http://localhost:10004/t4">http://localhost:10004/t4</a> , 结果正常了(一次返回异常，一次返回正确结 果)</p><h4 id="10-5-7-5注意事项和细节"><a href="#10-5-7-5注意事项和细节" class="headerlink" title="10.5.7.5注意事项和细节"></a>10.5.7.5注意事项和细节</h4><h5 id="10-5-7-5-1-资源在-1-分钟的异常数目超过阈值之后会进行熔断降级"><a href="#10-5-7-5-1-资源在-1-分钟的异常数目超过阈值之后会进行熔断降级" class="headerlink" title="10.5.7.5.1 资源在 1 分钟的异常数目超过阈值之后会进行熔断降级"></a><strong>10.5.7.5.1</strong> 资源在 <strong>1</strong> 分钟的异常数目超过阈值之后会进行熔断降级</h5><p><strong>10.5.7.5.2</strong> 异常数统计是分钟级别的，若 设置的时间窗口 小于 <strong>60s</strong>，则结束熔断状态后仍可能再进入熔断状态**,** 测试时，最好将时间窗口设置超过 <strong>60S</strong></p><h2 id="10-6-Sentinel-热点规则"><a href="#10-6-Sentinel-热点规则" class="headerlink" title="10.6 Sentinel 热点规则"></a>10.6 Sentinel 热点规则</h2><h3 id="10-6-1-一个问题引出热点-key-限流"><a href="#10-6-1-一个问题引出热点-key-限流" class="headerlink" title="10.6.1 一个问题引出热点 key 限流"></a><strong>10.6.1</strong> 一个问题引出热点 <strong>key</strong> 限流</h3><p><strong>1.</strong> 热点**:** 热点即经常访问的数据。很多时候我们希望统计热点数据中**,** 访问频次最高的 <strong>Top K</strong> 数据，并对其访问进行限制。</p><p><strong>2.</strong> 比如某条新闻上热搜 ，在某段时间内高频访问， 为了防止系统雪崩**,** 可以对该条新闻进行热点限流</p><h3 id="10-6-2文档地址"><a href="#10-6-2文档地址" class="headerlink" title="10.6.2文档地址 :"></a>10.6.2文档地址 :</h3><p> <a href="https://github.com/alibaba/Sentinel/wiki/%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81">https://github.com/alibaba/Sentinel/wiki/%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81</a></p><h3 id="10-6-3-基本介绍"><a href="#10-6-3-基本介绍" class="headerlink" title="10.6.3 基本介绍"></a><strong>10.6.3</strong> 基本介绍</h3><p><strong>1.</strong> 一张图<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230624102921499.png" alt="image-20230624102921499"></p><p><strong>2.</strong> 解读上图:</p><ul><li><p>热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。</p></li><li><p>热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效</p></li><li><p>Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控 <strong><a href="https://blog.csdn.net/qq_34416331/article/details/106668747">https://blog.csdn.net/qq_34416331/article/details/106668747</a></strong></p></li><li><p>热点参数限流支持集群模式</p></li></ul><h3 id="10-6-4-热点-Key-限流-实例"><a href="#10-6-4-热点-Key-限流-实例" class="headerlink" title="10.6.4 热点 Key 限流**-**实例"></a><strong>10.6.4</strong> 热点 <strong>Key</strong> 限流**-**实例</h3><h4 id="10-6-4-1-需求分析-x2F-图解"><a href="#10-6-4-1-需求分析-x2F-图解" class="headerlink" title="10.6.4.1 需求分析&#x2F;图解"></a>10.6.4.1 需求分析&#x2F;图解</h4><p> <strong>1.</strong> 需求**:** 通过 <strong>Sentinel</strong> 实现热点 <strong>Key</strong> 限流<br> <strong>2.</strong> 对 <strong>member-service-nacos-provider-10004</strong> 的 <strong>&#x2F;news?id&#x3D;x&amp;type&#x3D;x API</strong> 接口进行热点限流<br> <strong>3.</strong> 假定 <strong>id&#x3D;10</strong> 这一条新闻是当前的热点新闻， 当查询新闻时，对通常的 <strong>id(<strong>非热点新闻</strong>)<strong>请求 <strong>QPS</strong> 限定为 <strong>2,</strong> 如果 <strong>id&#x3D;10 QPS</strong> 限定为 <strong>100<br> 4.</strong> 如果访问超出了规定的 <strong>QPS,</strong> 触发热点限流机制</strong>,</strong> 调用自定义的方法，给出提示信息**. **</p><p> <strong>5.</strong> 当对 <strong>&#x2F;news?id&#x3D;x&amp;type&#x3D;x API</strong> 接口降低访问量，<strong>QPS</strong> 达到规定范围**,** 服务恢复</p><h4 id="10-6-4-2-修改业务类"><a href="#10-6-4-2-修改业务类" class="headerlink" title="10.6.4.2 修改业务类"></a>10.6.4.2 修改业务类</h4><p><strong>1.</strong> 修 改 <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;MemberController.java</strong> 增 加 方 法 <strong>queryNews()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意 <span class="doctag">@GetMapping</span> 是 url 带有 / , <span class="doctag">@SentinelResource</span> 的 value 是没有 /的</span></span><br><span class="line"><span class="comment"> * * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/news&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;news&quot;,blockHandler = &quot;newsBlockHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryNews</span><span class="params">(<span class="meta">@RequestParam(value = &quot;id&quot;,required = false)</span> String id,</span></span><br><span class="line"><span class="params">                        <span class="meta">@RequestParam(value = &quot;type&quot;,required = false)</span> String type)</span></span><br><span class="line">&#123;</span><br><span class="line">    log.info(<span class="string">&quot;到 DB 查询数据库.... &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;返回 id= &quot;</span> + id + <span class="string">&quot; 新闻 fromDB&quot;</span>); &#125;</span><br><span class="line"><span class="comment">//热点 key 限制异常处理方法</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">newsBlockHandler</span><span class="params">(String id, String type, BlockException exception)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;查询 id= &quot;</span> + id</span><br><span class="line">            + <span class="string">&quot; 新闻 触发热点 key 限制保护.. sorry&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-6-4-3-测试"><a href="#10-6-4-3-测试" class="headerlink" title="10.6.4.3 测试"></a>10.6.4.3 测试</h4><h5 id="10-6-4-3-1-启动-Nacos-Server-8848"><a href="#10-6-4-3-1-启动-Nacos-Server-8848" class="headerlink" title="10.6.4.3.1 启动 Nacos Server 8848"></a><strong>10.6.4.3.1</strong> 启动 Nacos Server 8848</h5><h5 id="10-6-4-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-6-4-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.6.4.3.2 启动 Sentinel8080 控制台&#x2F;Sentinel dashboard"></a>10.6.4.3.2 启动 <strong>Sentinel8080</strong> 控制台&#x2F;Sentinel dashboard</h5><h5 id="10-6-4-3-3-启动-member-service-nacos-provider-10004"><a href="#10-6-4-3-3-启动-member-service-nacos-provider-10004" class="headerlink" title="10.6.4.3.3 启动 member-service-nacos-provider-10004"></a>10.6.4.3.3 启动 member-service-nacos-provider-10004</h5><h5 id="10-6-4-3-4-配置实现步骤"><a href="#10-6-4-3-4-配置实现步骤" class="headerlink" title="10.6.4.3.4 配置实现步骤"></a>10.6.4.3.4 配置实现步骤</h5><p><strong>1.</strong> 为资源 <strong>news</strong> 增加热点规则**,** 注意不是 <strong>&#x2F;news</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230624104344763.png" alt="image-20230624104344763"></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230624104402958.png" alt="image-20230624104402958" style="zoom: 33%;" /><p><strong>2.</strong> <strong>在热点参数限流规则菜单，可以看到新增规则</strong></p><h5 id="10-6-4-3-5-浏览器-http-localhost-10004-news-id-1-amp-type-E6-95-99-E8-82-B2"><a href="#10-6-4-3-5-浏览器-http-localhost-10004-news-id-1-amp-type-E6-95-99-E8-82-B2" class="headerlink" title="10.6.4.3.5 浏览器**: http://localhost:10004/news?id=1&amp;type=%E6%95%99%E8%82%B2**"></a>10.6.4.3.5 浏览器**: <a href="http://localhost:10004/news?id=1&type=%E6%95%99%E8%82%B2">http://localhost:10004/news?id=1&amp;type=%E6%95%99%E8%82%B2</a>**</h5><p>如果QPS没有超过2,则返回正确结果</p><p>如果QPS超过2,则返回热点key处理信息</p><h5 id="10-6-4-3-6-独立设置热点-id-x3D-10-的-QPS-阈值-即添加例外"><a href="#10-6-4-3-6-独立设置热点-id-x3D-10-的-QPS-阈值-即添加例外" class="headerlink" title="10.6.4.3.6 独立设置热点 id&#x3D;10 的 QPS 阈值(即添加例外)"></a>10.6.4.3.6 独立设置热点 id&#x3D;10 的 QPS 阈值(即添加例外)</h5><p><strong>1.</strong> 独立设置热点 <strong>id&#x3D;10</strong> 的 <strong>QPS</strong> 阈值**(<strong>即添加例外</strong>)**</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230624104744651.png" alt="image-20230624104744651" style="zoom: 50%;" /><h5 id="10-6-4-3-7-浏览器-http-localhost-10004-news-id-10-amp-type-E6-95-99-E8-82-B2"><a href="#10-6-4-3-7-浏览器-http-localhost-10004-news-id-10-amp-type-E6-95-99-E8-82-B2" class="headerlink" title="10.6.4.3.7 浏览器: http://localhost:10004/news?id=10&amp;type=%E6%95%99%E8%82%B2"></a>10.6.4.3.7 浏览器: <a href="http://localhost:10004/news?id=10&type=%E6%95%99%E8%82%B2">http://localhost:10004/news?id=10&amp;type=%E6%95%99%E8%82%B2</a></h5><p><strong>1.</strong> 浏览器输入: <a href="http://localhost:10004/news?id=10&type=%E6%95%99%E8%82%B2">http://localhost:10004/news?id=10&amp;type=%E6%95%99%E8%82%B2</a> , 如果QPS没有超过 100,则返回正确结果</p><p><strong>2.</strong> <strong>浏览器访问的</strong> <strong>id</strong> <strong>不是</strong>10 <strong>的，仍然遵守</strong> <strong>QPS</strong> <strong>不能超过</strong> <strong>2</strong> <strong>的热点限制</strong></p><h3 id="10-6-5-注意事项和细节"><a href="#10-6-5-注意事项和细节" class="headerlink" title="10.6.5 注意事项和细节"></a>10.6.5 注意事项和细节</h3><h4 id="10-6-5-1-热点参数类型是-byte-x2F-int-x2F-long-x2F-float-x2F-double-x2F-char-x2F-String"><a href="#10-6-5-1-热点参数类型是-byte-x2F-int-x2F-long-x2F-float-x2F-double-x2F-char-x2F-String" class="headerlink" title="10.6.5.1 热点参数类型是(byte&#x2F;int&#x2F;long&#x2F;float&#x2F;double&#x2F;char&#x2F;String)"></a>10.6.5.1 热点参数类型是(byte&#x2F;int&#x2F;long&#x2F;float&#x2F;double&#x2F;char&#x2F;String)</h4><h4 id="10-6-5-2-热点参数值，可以配置多个"><a href="#10-6-5-2-热点参数值，可以配置多个" class="headerlink" title="10.6.5.2 热点参数值，可以配置多个"></a>10.6.5.2 热点参数值，可以配置多个</h4><h4 id="10-6-5-3-热点规则只对指定的参数生效-比如本实例对-id-生效-对-type-不生效"><a href="#10-6-5-3-热点规则只对指定的参数生效-比如本实例对-id-生效-对-type-不生效" class="headerlink" title="10.6.5.3 热点规则只对指定的参数生效 (比如本实例对 id 生效, 对 type 不生效)"></a>10.6.5.3 热点规则只对指定的参数生效 (比如本实例对 id 生效, 对 type 不生效)</h4><h2 id="10-7-系统规则"><a href="#10-7-系统规则" class="headerlink" title="10.7 系统规则"></a>10.7 系统规则</h2><h3 id="10-7-1-一个问题引出系统规则"><a href="#10-7-1-一个问题引出系统规则" class="headerlink" title="10.7.1 一个问题引出系统规则"></a><strong>10.7.1</strong> 一个问题引出系统规则</h3><p>1.如我们系统最大性能能抗 100QPS，如何分配 &#x2F;t1 &#x2F;t2 的 QPS?</p><p><strong>方案1:</strong> &#x2F;t1 分配 QPS&#x3D;50；&#x2F;t2 分配 QPS&#x3D;50，问题，如果&#x2F;t1 当前 QPS 达到 50，而&#x2F;t2 的 QPS 才 10，会造成没有充分利用服务器性能</p><p><strong>方案2:</strong> &#x2F;t1 分配 QPS&#x3D;100 &#x2F;t2 分配 QPS&#x3D;100，问题，容易造成系统没有流量保护造成请求线程堆积，形成雪崩</p><p><u><strong>有没有对各个资源请求的QPS弹性设置，只要总数不超过系统最大QPS的流量保护规则?&#x3D;&gt; 系统规则</strong></u></p><h3 id="10-7-2文-档-地-址"><a href="#10-7-2文-档-地-址" class="headerlink" title="10.7.2文 档 地 址 :"></a><strong>10.7.2</strong>文 档 地 址 <strong>:</strong></h3><p><strong><a href="https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81">https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81</a></strong></p><h3 id="10-7-3-一句话-系统规则作用-在系统稳定的前提下，保持系统的吞吐量"><a href="#10-7-3-一句话-系统规则作用-在系统稳定的前提下，保持系统的吞吐量" class="headerlink" title="10.7.3 一句话**:** 系统规则作用**,** 在系统稳定的前提下，保持系统的吞吐量"></a><strong>10.7.3</strong> 一句话**:** 系统规则作用**,** 在系统稳定的前提下，保持系统的吞吐量</h3><h3 id="10-7-4-基本介绍"><a href="#10-7-4-基本介绍" class="headerlink" title="10.7.4 基本介绍"></a><strong>10.7.4</strong> 基本介绍</h3><p><strong>1.</strong> 一张图<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230624105741809.png" alt="image-20230624105741809" style="zoom:50%;" /></p><p>**2.**解读上图:</p><p>系统处理请求的过程想象为一个水管，到来的请求是往这个水管灌水，当系统处理顺畅的时候，请求不需要排队，直接从水管中穿过，这个请求的RT是最短的，反之，当请求堆积的时候，那么处理请求的时间则会变为:排队时间 + 最短处理时间</p><p>**3.**系统规则(参考以下五种数据来判断系统是否超负荷)</p><ul><li><p>Load 自适应(仅对 Linux&#x2F;Unix-like 机器生效): 系统的 load1 作为启发指标，进行自适应系统保护。当系统 <u>load1 超过设定的启发值</u>，且<u>系统当前的并发线程数超过估算的系统容量</u>时才会触发系统保护(BBR 阶段)。系统容量由系统的 maxQps * minRt 估算得出。设定参考值一般是 CPU cores *2.5</p></li><li><p>CPU usage (1.5.0+ 版本): 当系统 CPU 使用率超过阈值即触发系统保护 (取值范围0.0-1.0)，比较灵敏。</p></li><li><p>平均 RT: 当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</p></li><li><p>并发线程数:当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</p></li><li><p>入口 QPS:当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</p></li></ul><h3 id="10-7-5-实例"><a href="#10-7-5-实例" class="headerlink" title="10.7.5 实例"></a><strong>10.7.5</strong> 实例</h3><h4 id="10-7-5-1-需求分析-x2F-图解"><a href="#10-7-5-1-需求分析-x2F-图解" class="headerlink" title="10.7.5.1 需求分析&#x2F;图解"></a>10.7.5.1 需求分析&#x2F;图解</h4><p><strong>1.<strong>需求</strong>:</strong> 通过 <strong>Sentinel</strong> 实现 系统规则**-**入口 <strong>QPS</strong></p><p><strong>2.<strong>对 <strong>member-service-nacos-provider-10004</strong> 的 所有 <strong>API</strong> 接口进行流量保护，不管访问哪个 <strong>API</strong> 接口</strong>,</strong> 系统入口总的 <strong>QPS</strong> 不能大于 <strong>2,</strong> 大于 <strong>2</strong>，就进行限流控制 </p><p><strong>3.</strong> 提示**:** 上面的 <strong>QPS</strong> 是为了方便看效果**,** 设置的很小</p><h4 id="10-7-5-2-配置实现步骤"><a href="#10-7-5-2-配置实现步骤" class="headerlink" title="10.7.5.2 配置实现步骤"></a>10.7.5.2 配置实现步骤</h4><p><strong>1.</strong> 增加入口 <strong>QPS</strong> 系统规则</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230624110601568.png" alt="image-20230624110601568"></p><h4 id="10-7-5-3-测试"><a href="#10-7-5-3-测试" class="headerlink" title="10.7.5.3 测试"></a>10.7.5.3 测试</h4><h5 id="10-7-5-3-1-启动-Nacos-Server-8848"><a href="#10-7-5-3-1-启动-Nacos-Server-8848" class="headerlink" title="10.7.5.3.1 启动 Nacos Server 8848"></a>10.7.5.3.1 启动 Nacos Server 8848</h5><h5 id="10-7-5-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-7-5-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.7.5.3.2 启动 Sentinel8080 控制台&#x2F;Sentinel dashboard"></a>10.7.5.3.2 启动 Sentinel8080 控制台&#x2F;Sentinel dashboard</h5><h5 id="10-7-5-3-3-启动-member-service-nacos-provider-10004"><a href="#10-7-5-3-3-启动-member-service-nacos-provider-10004" class="headerlink" title="10.7.5.3.3 启动 member-service-nacos-provider-10004"></a>10.7.5.3.3 启动 member-service-nacos-provider-10004</h5><h5 id="10-7-5-3-4-浏览器-http-localhost-10004-t1"><a href="#10-7-5-3-4-浏览器-http-localhost-10004-t1" class="headerlink" title="10.7.5.3.4 浏览器: http://localhost:10004/t1"></a>10.7.5.3.4 浏览器: <a href="http://localhost:10004/t1">http://localhost:10004/t1</a></h5><p><strong>1.</strong> 浏览器输入**: <a href="http://localhost:10004/t1">http://localhost:10004/t1</a> ,** 如果 <strong>QPS</strong> 超过 <strong>2,</strong> 打开断路器，返回流控信息</p><p><strong>2.</strong> 浏览器输入: <a href="http://localhost:10004/news?id=1&type=%E6%95%99%E8%82%B2">http://localhost:10004/news?id=1&amp;type=%E6%95%99%E8%82%B2</a> , 如果QPS 超过2, 打开断路器，返回流控信息(说明: 项目的 &#x2F;t2 资源对应方法有休眠代码，所以使用 &#x2F;news?id&#x3D;x&amp;type&#x3D;x 测试)</p><h2 id="10-8-SentinelResource"><a href="#10-8-SentinelResource" class="headerlink" title="10.8 @SentinelResource"></a>10.8 @SentinelResource</h2><h3 id="10-8-1-自定义全局限流处理类"><a href="#10-8-1-自定义全局限流处理类" class="headerlink" title="10.8.1 自定义全局限流处理类"></a><strong>10.8.1</strong> 自定义全局限流处理类</h3><h4 id="10-8-1-1-需求分析-x2F-图解"><a href="#10-8-1-1-需求分析-x2F-图解" class="headerlink" title="10.8.1.1 需求分析&#x2F;图解"></a>10.8.1.1 需求分析&#x2F;图解</h4><p><strong>1.</strong> 先看前面的一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/news&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;news&quot;,blockHandler = &quot;newsBlockHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryNews</span><span class="params">(<span class="meta">@RequestParam(value = &quot;id&quot;,required = false)</span> String id,</span></span><br><span class="line"><span class="params">                        <span class="meta">@RequestParam(value = &quot;type&quot;,required = false)</span> String type)</span></span><br><span class="line">&#123;</span><br><span class="line">    log.info(<span class="string">&quot;到 DB 查询数据库.... &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;返回 id= &quot;</span> + id + <span class="string">&quot; 新闻 fromDB&quot;</span>); &#125;</span><br><span class="line"><span class="comment">//热点 key 限制异常处理方法</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">newsBlockHandler</span><span class="params">(String id, String type, BlockException exception)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;查询 id= &quot;</span> + id</span><br><span class="line">            + <span class="string">&quot; 新闻 触发热点 key 限制保护.. sorry&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>: <strong>当配置的资源名</strong> news <strong>触发限流机制时，会调用</strong> newsBlockHandler <strong>方法</strong></p><p><strong>2.</strong> <strong>上面的处理方案存在一些问题</strong></p><ul><li><p><strong>每个</strong>@SentinelResource <strong>对应一个异常处理方法，会造成方法很多</strong> </p></li><li><p>异常处理方法和资源请求方法在一起，不利于业务逻辑的分离</p></li></ul><ul><li><strong>解决方案</strong>-&gt; 自定义全局限流处理类</li></ul><p><strong>3.</strong> <strong>需求</strong>: <strong>请编写一个自定义全局限流处理类，完成对异常处理</strong>.</p><h4 id="10-8-1-2-代码实现"><a href="#10-8-1-2-代码实现" class="headerlink" title="10.8.1.2 代码实现"></a>10.8.1.2 代码实现</h4><p><strong>1.</strong> 修改 <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;MemberController.java</strong> 增加方法 <strong>t6()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解读：</span></span><br><span class="line"><span class="comment"> * value = &quot;t6&quot;: SentinelResource 资源名</span></span><br><span class="line"><span class="comment"> * blockHandlerClass = CustomGlobalBlockHandler.class: 全局限流处理类 * blockHandler = &quot;handlerMethod1&quot;: 全局限流处理类的哪个方法,可以指定. */</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/t6&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(</span></span><br><span class="line"><span class="meta">        value = &quot;t6&quot;,</span></span><br><span class="line"><span class="meta">        blockHandlerClass = CustomGlobalBlockHandler.class, blockHandler = &quot;handlerMethod1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">t6</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;执行 t6() 线程 id= &quot;</span> + Thread.currentThread().getId()); <span class="keyword">return</span> Result.success(<span class="string">&quot;200&quot;</span>, <span class="string">&quot;t6()执行成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> <strong>创建</strong> com&#x2F;hspedu&#x2F;springcloud&#x2F;handler&#x2F;CustomGlobalBlockHandler.java </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.springcloud.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;</span><br><span class="line"><span class="keyword">import</span> com.study.springcloud.entity.Result;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/6/24</span></span><br><span class="line"><span class="comment"> * 13:54</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 创建的异常处理方法需要是 static</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomGlobalBlockHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">handlerMethod1</span> <span class="params">(BlockException exception)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;400&quot;</span>, <span class="string">&quot;客户自定义异常处理 handlerm1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">handlerMethod2</span> <span class="params">(BlockException exception)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;401&quot;</span>, <span class="string">&quot;客户自定义异常处理 handlerm2()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-8-1-3-配置实现步骤"><a href="#10-8-1-3-配置实现步骤" class="headerlink" title="10.8.1.3 配置实现步骤"></a>10.8.1.3 配置实现步骤</h4><p><strong>1.</strong> 为资源 <strong>&#x2F;t6</strong> 增加流控规则**,**方便测试</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230624135913223.png" alt="image-20230624135913223" style="zoom:50%;" /><p><strong>2.</strong> <strong>在流控规则菜单，可以看到新增规则</strong></p><h4 id="10-8-1-4-测试"><a href="#10-8-1-4-测试" class="headerlink" title="10.8.1.4 测试"></a>10.8.1.4 测试</h4><h5 id="10-8-1-4-1-启动-Nacos-Server-8848"><a href="#10-8-1-4-1-启动-Nacos-Server-8848" class="headerlink" title="10.8.1.4.1 启动 Nacos Server 8848"></a><strong>10.8.1.4.1</strong> 启动 Nacos Server 8848</h5><h5 id="10-8-1-4-2-启动-Sentinel8080控制台-x2F-Sentinel-dashboard"><a href="#10-8-1-4-2-启动-Sentinel8080控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.8.1.4.2 启动 Sentinel8080控制台&#x2F;Sentinel dashboard"></a>10.8.1.4.2 启动 Sentinel8080控制台&#x2F;Sentinel dashboard</h5><h5 id="10-8-1-4-3-启动-member-service-nacos-provider-10004"><a href="#10-8-1-4-3-启动-member-service-nacos-provider-10004" class="headerlink" title="10.8.1.4.3 启动 member-service-nacos-provider-10004"></a>10.8.1.4.3 启动 member-service-nacos-provider-10004</h5><h5 id="10-8-1-4-4-浏览器-http-localhost-10004-t6"><a href="#10-8-1-4-4-浏览器-http-localhost-10004-t6" class="headerlink" title="10.8.1.4.4 浏览器: http://localhost:10004/t6"></a>10.8.1.4.4 浏览器: <a href="http://localhost:10004/t6">http://localhost:10004/t6</a></h5><p><strong>1.</strong> 浏览器输入**: <a href="http://localhost:10004/t6">http://localhost:10004/t6</a> ,** 如果 <strong>QPS</strong> 没有超过 <strong>1,</strong> 返回正常结果</p><p><strong>2.</strong> 浏览器输入: <a href="http://localhost:10004/t6">http://localhost:10004/t6</a> ,如果QPS 超过 1, 断路器打开，返回自定义限流处理方法信息</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230624140131429.png" alt="image-20230624140131429" style="zoom:50%;" /><h3 id="10-8-2-fallback自定义程序错误处理"><a href="#10-8-2-fallback自定义程序错误处理" class="headerlink" title="10.8.2 fallback自定义程序错误处理"></a>10.8.2 fallback自定义程序错误处理</h3><h4 id="10-8-2-1-看一段代码-引出-fallback"><a href="#10-8-2-1-看一段代码-引出-fallback" class="headerlink" title="10.8.2.1 看一段代码-引出 fallback"></a>10.8.2.1 看一段代码-引出 fallback</h4><p><strong>1.</strong> 修 改 <strong>member-service-nacos-provider-10004</strong> 的<strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;MemberController.java</strong> 增加一段代码**.**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/t6&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(</span></span><br><span class="line"><span class="meta">        value = &quot;t6&quot;,</span></span><br><span class="line"><span class="meta">        blockHandlerClass = CustomGlobalBlockHandler.class, blockHandler = &quot;handlerMethod1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">t6</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//假定: 当访问 t6 资源次数是 5 的倍数时，就出现了一个 java 的异常</span></span><br><span class="line">    <span class="keyword">if</span> (++num % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;num 的值异常 num= &quot;</span> + num); &#125;</span><br><span class="line">        log.info(<span class="string">&quot;执行 t6() 线程 id= &quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;200&quot;</span>, <span class="string">&quot;t6()执行成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 浏览器: <a href="http://localhost:10004/t6">http://localhost:10004/t6</a> , 看效果当num为 5的整数时，返回的是error页面，不友好.</p><p><strong>3.</strong> 怎么解决&#x3D;&gt; 使用 fallback</p><h4 id="10-8-2-2-基本介绍"><a href="#10-8-2-2-基本介绍" class="headerlink" title="10.8.2.2 基本介绍"></a>10.8.2.2 基本介绍</h4><h5 id="10-8-2-2-1-blockHandler只负责sentinel控制台配置违规"><a href="#10-8-2-2-1-blockHandler只负责sentinel控制台配置违规" class="headerlink" title="10.8.2.2.1 blockHandler只负责sentinel控制台配置违规"></a>10.8.2.2.1 blockHandler只负责sentinel控制台配置违规</h5><h5 id="10-8-2-2-2-fallback负责Java异常-x2F-业务异常"><a href="#10-8-2-2-2-fallback负责Java异常-x2F-业务异常" class="headerlink" title="10.8.2.2.2 fallback负责Java异常&#x2F;业务异常"></a>10.8.2.2.2 fallback<strong>负责</strong>Java<strong>异常</strong>&#x2F;业务异常</h5><h4 id="10-8-2-3-需求分析-x2F-图解"><a href="#10-8-2-3-需求分析-x2F-图解" class="headerlink" title="10.8.2.3 需求分析&#x2F;图解"></a>10.8.2.3 需求分析&#x2F;图解</h4><p><strong>1.</strong> 需求**:** 请编写一个自定义全局 <strong>fallback</strong> 处理类**,** 处理 <strong>java</strong> 异常**&#x2F;**业务异常 </p><p><strong>2.</strong> 也就是解决前面我们提出的问题</p><h4 id="10-8-2-4-代码实现"><a href="#10-8-2-4-代码实现" class="headerlink" title="10.8.2.4 代码实现"></a>10.8.2.4 代码实现</h4><p><strong>1.</strong> 在 <strong>member-service-nacos-provider-10004</strong> 创建<strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;handler&#x2F;CustomGlobalFallbackHandler.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomGlobalFallbackHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">fallBackHandlerMethod1</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;400&quot;</span>, <span class="string">&quot;java 异常信息= &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">fallBackHandlerMethod2</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;401&quot;</span>, <span class="string">&quot;java 异常信息= &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.<strong>在 member-service-nacos-provider-10004修改</strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;MemberController.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解读</span></span><br><span class="line"><span class="comment"> * value = &quot;t6&quot;: SentinelResource 资源名</span></span><br><span class="line"><span class="comment"> * blockHandlerClass = CustomGlobalBlockHandler.class: 全局限流处理类 * blockHandler = &quot;handlerMethod1&quot;: 全局限流处理类的哪个方法,可以指定. */</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/t6&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(</span></span><br><span class="line"><span class="meta">        value = &quot;t6&quot;,</span></span><br><span class="line"><span class="meta">        fallbackClass = CustomGlobalFallbackHandler.class,</span></span><br><span class="line"><span class="meta">        fallback = &quot;fallBackHandlerMethod1&quot;,</span></span><br><span class="line"><span class="meta">        blockHandlerClass = CustomGlobalBlockHandler.class,</span></span><br><span class="line"><span class="meta">        blockHandler = &quot;handlerMethod1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">t6</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//假定: 当访问 t6 资源次数是 5 的倍数时，就出现了一个 java 的异常</span></span><br><span class="line">    <span class="keyword">if</span> (++num % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;num 的值异常 num= &quot;</span> + num); &#125;</span><br><span class="line">        log.info(<span class="string">&quot;执行 t6() 线程 id= &quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;200&quot;</span>, <span class="string">&quot;t6()执行成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-8-2-5-测试"><a href="#10-8-2-5-测试" class="headerlink" title="10.8.2.5 测试"></a>10.8.2.5 测试</h4><h5 id="10-8-2-5-1-启动-Nacos-Server-8848"><a href="#10-8-2-5-1-启动-Nacos-Server-8848" class="headerlink" title="10.8.2.5.1 启动 Nacos Server 8848"></a>10.8.2.5.1 启动 Nacos Server 8848</h5><h5 id="10-8-2-5-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-8-2-5-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.8.2.5.2 启动 Sentinel8080 控制台&#x2F;Sentinel dashboard"></a>10.8.2.5.2 启动 <strong>Sentinel8080</strong> 控制台&#x2F;Sentinel dashboard</h5><h5 id="10-8-2-5-3-启动-member-service-nacos-provider-10004"><a href="#10-8-2-5-3-启动-member-service-nacos-provider-10004" class="headerlink" title="10.8.2.5.3 启动 member-service-nacos-provider-10004"></a>10.8.2.5.3 启动 member-service-nacos-provider-10004</h5><h5 id="10-8-2-5-4-浏览器-http-localhost-10004-t6"><a href="#10-8-2-5-4-浏览器-http-localhost-10004-t6" class="headerlink" title="10.8.2.5.4 浏览器: http://localhost:10004/t6"></a>10.8.2.5.4 浏览器: <a href="http://localhost:10004/t6">http://localhost:10004/t6</a></h5><p><strong>1.</strong> 浏览器输入**: <a href="http://localhost:10004/t6">http://localhost:10004/t6</a> ,** 访问次数不是 <strong>5</strong> 的倍数**,** 返回正常结果</p><p><strong>2.</strong> 浏览器输入: <a href="http://localhost:10004/t6">http://localhost:10004/t6</a> , 访问次数是 5 的倍数, 返回 fallback指定方法信息</p><p><strong>3.</strong> <strong>为资源</strong> <strong>&#x2F;t6</strong> <strong>增加流控规则</strong>,方便测试</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230624142029799.png" alt="image-20230624142029799" style="zoom:50%;" /><p><strong>4.</strong> <strong>在流控规则菜单，可以看到新增规则</strong></p><p><strong>5.</strong> 浏览器输入: <a href="http://localhost:10004/t6">http://localhost:10004/t6</a> , <strong>如果访问 QPS 大于1 , 由blockHandler指定的方法处理,访问次数是 5 的倍数, 由fallback指定方法处理,其它情况返回正常的结果.</strong></p><h3 id="10-8-3-exceptionsToIgnore-希望忽略某个异常"><a href="#10-8-3-exceptionsToIgnore-希望忽略某个异常" class="headerlink" title="10.8.3 exceptionsToIgnore  希望忽略某个异常"></a>10.8.3 exceptionsToIgnore  希望忽略某个异常</h3><h4 id="10-8-3-1-如果希望忽略某个异常，可以使用-exceptionsToIgnore"><a href="#10-8-3-1-如果希望忽略某个异常，可以使用-exceptionsToIgnore" class="headerlink" title="10.8.3.1 如果希望忽略某个异常，可以使用 exceptionsToIgnore"></a>10.8.3.1 如果希望忽略某个异常，可以使用 exceptionsToIgnore</h4><h4 id="10-8-3-2-应用实例"><a href="#10-8-3-2-应用实例" class="headerlink" title="10.8.3.2 应用实例"></a>10.8.3.2 应用实例</h4><p><strong>1.</strong> 如果希望忽略某个异常**(<strong>支持数组</strong>)**，可以使用 <strong>exceptionsToIgnore</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/t6&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(</span></span><br><span class="line"><span class="meta">        value = &quot;t6&quot;,</span></span><br><span class="line"><span class="meta">        fallbackClass = CustomGlobalFallbackHandler.class,</span></span><br><span class="line"><span class="meta">        fallback = &quot;fallBackHandlerMethod1&quot;,</span></span><br><span class="line"><span class="meta">        blockHandlerClass = CustomGlobalBlockHandler.class,</span></span><br><span class="line"><span class="meta">        blockHandler = &quot;handlerMethod1&quot;,</span></span><br><span class="line"><span class="meta">        exceptionsToIgnore = &#123;RuntimeException.class&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">t6</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//假定: 当访问 t6 资源次数是 5 的倍数时，就出现了一个 java 的异常</span></span><br><span class="line">    <span class="keyword">if</span> (++num % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;num 的值异常 num= &quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;执行 t6() 线程 id= &quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;200&quot;</span>, <span class="string">&quot;t6()执行成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 浏览器输入: <a href="http://localhost:10004/t6">http://localhost:10004/t6</a> , 你会发现访问次数为 5 的倍数时，不再调用 fallback 指定方法处理</p><p>​而是使用RuntimeException.class中的方式(即默认方式)处理</p><h3 id="10-8-4-接入-Sentinel-的方式"><a href="#10-8-4-接入-Sentinel-的方式" class="headerlink" title="10.8.4 接入 Sentinel 的方式"></a>10.8.4 接入 Sentinel 的方式</h3><p><u>即(不进入sentinel控制台网页而使用sentinel)</u></p><h4 id="10-8-4-1-代码方式-硬编码，侵入性强-不推荐"><a href="#10-8-4-1-代码方式-硬编码，侵入性强-不推荐" class="headerlink" title="10.8.4.1 代码方式(硬编码，侵入性强, 不推荐)"></a>10.8.4.1 代码方式(硬编码，侵入性强, 不推荐)</h4><p><strong>1.</strong> 文档地址**:** <strong><a href="https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D">https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D</a></strong></p><p><strong>2.</strong> 基本使用</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230629202935657.png" alt="image-20230629202935657" style="zoom:50%;" /><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230629203105770.png" alt="image-20230629203105770"></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230629203336858.png" alt="image-20230629203336858"></p><h4 id="10-8-4-2-注解方式-低侵入性-前面用过-推荐"><a href="#10-8-4-2-注解方式-低侵入性-前面用过-推荐" class="headerlink" title="10.8.4.2 注解方式(低侵入性, 前面用过, 推荐)"></a>10.8.4.2 注解方式(低侵入性, 前面用过, 推荐)</h4><p><strong>1.</strong> 注解方式埋点不支持 <strong>private</strong> 方法</p><p><a href="https://xue.baidu.com/okam/pages/strategy-tp/index?strategyId=136707206360879&source=natural">https://xue.baidu.com/okam/pages/strategy-tp/index?strategyId=136707206360879&amp;source=natural</a></p><p><strong>2.</strong> @SentinelResource 用于定义资源，并提供可选的异常处理和fallback配置项。</p><p><strong>3. @SentinelResource</strong> <strong>注解包含以下属性</strong>(我们再梳理一下)</p><ul><li><p><strong>value</strong>:资源名称，必需项(不能为空)</p></li><li><p><strong>entryType</strong>:entry 类型，可选项(默认为EntryType.OUT)</p></li><li><p><strong>blockHandler &#x2F; blockHandlerClass</strong>: blockHandler <strong>对应处理</strong> <strong>BlockException</strong> 的函数名称，可选项blockHandler<u>函数访问范围需要是public</u>，返回类型需要与原方法相匹配，参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为BlockException。blockHandler 函数默认需要和原方法在同一个类中。若希望使用其 他类的函数，则可以指定blockHandlerClass为对应的类的Class对象，注意对应的函数必需为 static 函数，否则无法解析。</p></li><li><p><strong>fallback &#x2F; fallbackClass</strong>:fallback 函数名称，可选项，<u>用于在抛出异常的时候提供fallback处理逻辑</u>。fallback函数可以针对所有类型的异常(除了exceptionsToIgnore里面排除掉的异常类型)进行处理。fallback 函数签名和位置要求:</p></li></ul><ol><li>返回值类型必须与原函数返回值类型一致;</li><li>方法参数列表需要和原函数一致，或者可以额外多一个Throwable类型的参数用于接收对应的异常。</li><li>fallback函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定<u>fallbackClass</u>为对应的类的Class对象，注意对应的函数必需为static函数，否则无法解析。</li></ol><ul><li><strong>defaultFallback(since 1.6.0</strong>):默认的 fallback函数名称，可选项，通常用于通用的fallback逻辑(即可以用于很多服务或方法)。默认fallback函数可以针对所有类型 的异常(除了exceptionsToIgnore里面排除掉的异常类型)进行处理。若同时配置了fallback和defaultFallback，则只有fallback会生效。defaultFallback 函数签名要求:</li></ul><ol><li>返回值类型必须与原函数返回值类型一致;</li><li>方法参数列表需要为空，或者可以额外多一个Throwable类型的参数用于接收对应的异常。</li><li>defaultFallback函数默认需要和原方法在同一个类中。若希望使用其他类的函数， 则可以指定fallbackClass为对应的类的Class对象，注意对应的函数必需为static函数，否则无法解析。</li></ol><ul><li>exceptionsToIgnore(since 1.6.0)：用于指定哪些异常被排除掉，不会进入异常统计中，也不会进入fallback逻辑中，而是会原样抛出。</li></ul><h2 id="10-9-openFeign-sentinel-对远程调用熔断降级"><a href="#10-9-openFeign-sentinel-对远程调用熔断降级" class="headerlink" title="10.9 openFeign+sentinel 对远程调用熔断降级"></a>10.9 openFeign+sentinel 对远程调用熔断降级</h2><h3 id="10-9-1-当前微服务基础环境"><a href="#10-9-1-当前微服务基础环境" class="headerlink" title="10.9.1 当前微服务基础环境"></a><strong>10.9.1</strong> 当前微服务基础环境</h3><h4 id="10-9-1-1-当前微服务环境架构图"><a href="#10-9-1-1-当前微服务环境架构图" class="headerlink" title="10.9.1.1 当前微服务环境架构图"></a>10.9.1.1 当前微服务环境架构图</h4><p>– 示意图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230629205804092.png" alt="image-20230629205804092"></p><h4 id="10-9-1-2-测试"><a href="#10-9-1-2-测试" class="headerlink" title="10.9.1.2 测试"></a>10.9.1.2 测试</h4><h5 id="10-9-1-2-1-启动-Nacos-Server-8848"><a href="#10-9-1-2-1-启动-Nacos-Server-8848" class="headerlink" title="10.9.1.2.1 启动 Nacos Server 8848"></a>10.9.1.2.1 启动 Nacos Server 8848</h5><h5 id="10-9-1-2-2-启动-member-service-nacos-provider-10004-x2F-10006"><a href="#10-9-1-2-2-启动-member-service-nacos-provider-10004-x2F-10006" class="headerlink" title="10.9.1.2.2 启动 member-service-nacos-provider-10004&#x2F;10006"></a>10.9.1.2.2 启动 member-service-nacos-provider-10004&#x2F;10006</h5><h5 id="10-9-1-2-3-启动-member-service-nacos-consumer-80"><a href="#10-9-1-2-3-启动-member-service-nacos-consumer-80" class="headerlink" title="10.9.1.2.3 启动 member-service-nacos-consumer-80"></a>10.9.1.2.3 启动 member-service-nacos-consumer-80</h5><h5 id="10-9-1-2-4-浏览器-http-localhost-member-nacos-consumer-get-1"><a href="#10-9-1-2-4-浏览器-http-localhost-member-nacos-consumer-get-1" class="headerlink" title="10.9.1.2.4 浏览器**: http://localhost/member/nacos/consumer/get/1**"></a>10.9.1.2.4 浏览器**: <a href="http://localhost/member/nacos/consumer/get/1">http://localhost/member/nacos/consumer/get/1</a>**</h5><p><strong>1.</strong> 浏 览 器 输 入 <strong>: <a href="http://localhost/member/nacos/consumer/get/1">http://localhost/member/nacos/consumer/get/1</a> ,</strong> 目 前 是 <strong>Ribbon+RestTemplate</strong></p><h3 id="10-9-2-服务消费者整合-Openfeign"><a href="#10-9-2-服务消费者整合-Openfeign" class="headerlink" title="10.9.2 服务消费者整合 Openfeign"></a><strong>10.9.2</strong> 服务消费者整合 Openfeign</h3><p><strong>1.</strong> 需求:在 <strong>member-service-nacos-consumer-80</strong> 整合 <strong>Openfeign</strong> 实现远程调用</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230629210226986.png" alt="image-20230629210226986"></p><h4 id="10-9-2-2-代码-配置实现步骤"><a href="#10-9-2-2-代码-配置实现步骤" class="headerlink" title="10.9.2.2 代码+配置实现步骤"></a>10.9.2.2 代码+配置实现步骤</h4><p><strong>1.</strong> 修改 <strong>member-service-nacos-consumer-80</strong> 的 <strong>pom.xml</strong> 加入 <strong>openfeign</strong> 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    引入openfeign-start，即场景启动器    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.</strong> <strong>在</strong> <strong>member-service-nacos-consumer-80</strong> <strong>创 建</strong>com&#x2F;study&#x2F;springcloud&#x2F;service&#x2F;MemberOpenFeignService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.springcloud.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.study.springcloud.entity.Member;</span><br><span class="line"><span class="keyword">import</span> com.study.springcloud.entity.Result;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/6/29</span></span><br><span class="line"><span class="comment"> * 21:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;member-service-nacos-provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MemberOpenFeignService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 老韩解读</span></span><br><span class="line"><span class="comment">     * 1. 远程调用的方式为 get</span></span><br><span class="line"><span class="comment">     * 2. 远程调用的 url 为 http://member-service-nacos-provider/member/get/&#123;id&#125;</span></span><br><span class="line"><span class="comment">     * 3. member-service-nacos-provider 是 nacos 注册中心服务 member-service-nacos-provider:10004/10006 </span></span><br><span class="line"><span class="comment">     * 4. 会根据 OpenFeign 的均衡算法来决定是调用 10004 还是 10006</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/member/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Member&gt; <span class="title function_">getMembertById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.</strong> <strong>在</strong> <strong>member-service-nacos-consumer-80</strong> <strong>修改</strong> <strong>com&#x2F;study&#x2F;springcloud&#x2F;controller&#x2F;MemberNacosConsumerController.java</strong> 增加方法getMemberOpenfeignById()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/member/openfeign/consumer/get/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;Member&gt; <span class="title function_">getMemberOpenfeignById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//这里使用 Openfeign 接口方式远程调用服务</span></span><br><span class="line">    System.out.println(<span class="string">&quot;通过 openfeignd+负载均衡 调用服务&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> memberOpenFeignService.getMemberById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.</strong> <strong>再在</strong> <strong>member-service-nacos-consumer-80</strong> <strong>的主启动类加入注解</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;MemberNacosConsumerApplication80.java</strong></p><p>「@EnableFeignClients」</p><h4 id="10-9-2-3-测试"><a href="#10-9-2-3-测试" class="headerlink" title="10.9.2.3 测试"></a>10.9.2.3 测试</h4><h5 id="10-9-2-3-1-启动-Nacos-Server-8848"><a href="#10-9-2-3-1-启动-Nacos-Server-8848" class="headerlink" title="10.9.2.3.1 启动 Nacos Server 8848"></a>10.9.2.3.1 启动 Nacos Server 8848</h5><h5 id="10-9-2-3-2-启动-member-service-nacos-provider-10004-x2F-10006"><a href="#10-9-2-3-2-启动-member-service-nacos-provider-10004-x2F-10006" class="headerlink" title="10.9.2.3.2 启动 **member-service-nacos-provider-10004&#x2F;10006 **"></a>10.9.2.3.2 启动 **member-service-nacos-provider-10004&#x2F;10006 **</h5><h5 id="10-9-2-3-3-启动-member-service-nacos-consumer-80"><a href="#10-9-2-3-3-启动-member-service-nacos-consumer-80" class="headerlink" title="10.9.2.3.3 启动 member-service-nacos-consumer-80"></a><strong>10.9.2.3.3</strong> 启动 member-service-nacos-consumer-80</h5><h5 id="10-9-2-3-4-浏览器-http-localhost-member-openfeign-consumer-get-1"><a href="#10-9-2-3-4-浏览器-http-localhost-member-openfeign-consumer-get-1" class="headerlink" title="10.9.2.3.4 浏览器**: http://localhost/member/openfeign/consumer/get/1**"></a>10.9.2.3.4 浏览器**: <a href="http://localhost/member/openfeign/consumer/get/1">http://localhost/member/openfeign/consumer/get/1</a>**</h5><p><strong>1.</strong> 浏览器输入**: <a href="http://localhost/member/openfeign/consumer/get/1">http://localhost/member/openfeign/consumer/get/1</a> , 目前是 <strong>Openfeign 调用</strong>(<strong>负载均衡</strong>)**</p><h3 id="10-9-3-服务消费者整合-Sentinel"><a href="#10-9-3-服务消费者整合-Sentinel" class="headerlink" title="10.9.3 服务消费者整合 Sentinel"></a>10.9.3 服务消费者整合 Sentinel</h3><h4 id="10-9-3-1-需求分析-x2F-图解"><a href="#10-9-3-1-需求分析-x2F-图解" class="headerlink" title="10.9.3.1 需求分析&#x2F;图解"></a>10.9.3.1 需求分析&#x2F;图解</h4><p><strong>1.</strong> 需求:在 <strong>member-service-nacos-consumer-80</strong> 整合 <strong>Sentinel</strong> 能被 <strong>Sentinel</strong> 监控</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230630165412038.png" alt="image-20230630165412038" style="zoom:50%;" /><h4 id="10-9-3-2-代码-配置实现步骤"><a href="#10-9-3-2-代码-配置实现步骤" class="headerlink" title="10.9.3.2 代码+配置实现步骤"></a>10.9.3.2 代码+配置实现步骤</h4><p><strong>1.</strong> 修改 <strong>member-service-nacos-consumer-80</strong> 的 <strong>pom.xml</strong> 加入 <strong>sentinel</strong> 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入 alibaba-sentinel --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.</strong> 修改 <strong>member-service-nacos-consumer-80</strong> 的 <strong>application.yml</strong> 配置 <strong>sentinel</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">member-service-consumer-80</span></span><br><span class="line">    <span class="comment">#配置nacos</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment">#启动nacos服务的ip以及端口</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span> <span class="comment">#这个是 sentinel 控制台(sentinel dashboard)的地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span> <span class="comment">#默认 8719，假如被占用了, 会自动从 8719 开始依次+1 扫描。直至找到未被占用的端口</span></span><br><span class="line"><span class="attr">management:</span> <span class="comment">#暴露所有监控点</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="10-9-3-3-测试"><a href="#10-9-3-3-测试" class="headerlink" title="10.9.3.3 测试"></a>10.9.3.3 测试</h4><h5 id="10-9-3-3-1-启动-Nacos-Server-8848"><a href="#10-9-3-3-1-启动-Nacos-Server-8848" class="headerlink" title="10.9.3.3.1 启动 Nacos Server 8848"></a><strong>10.9.3.3.1</strong> 启动 Nacos Server 8848</h5><h5 id="10-9-3-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-9-3-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.9.3.3.2 启动 Sentinel8080 控制台&#x2F;Sentinel dashboard"></a>10.9.3.3.2 启动 <strong>Sentinel8080</strong> 控制台&#x2F;Sentinel dashboard</h5><h5 id="10-9-3-3-3-启动-member-service-nacos-provider-10004-x2F-10006"><a href="#10-9-3-3-3-启动-member-service-nacos-provider-10004-x2F-10006" class="headerlink" title="10.9.3.3.3 启动 **member-service-nacos-provider-10004&#x2F;10006 **"></a>10.9.3.3.3 启动 **member-service-nacos-provider-10004&#x2F;10006 **</h5><h5 id="10-9-3-3-4-启动-member-service-nacos-consumer-80"><a href="#10-9-3-3-4-启动-member-service-nacos-consumer-80" class="headerlink" title="10.9.3.3.4 启动 member-service-nacos-consumer-80"></a><strong>10.9.3.3.4</strong> 启动 member-service-nacos-consumer-80</h5><h5 id="10-9-3-3-5-浏览器-http-localhost-member-openfeign-consumer-get-1"><a href="#10-9-3-3-5-浏览器-http-localhost-member-openfeign-consumer-get-1" class="headerlink" title="10.9.3.3.5 浏览器**: http://localhost/member/openfeign/consumer/get/1**"></a>10.9.3.3.5 浏览器**: <a href="http://localhost/member/openfeign/consumer/get/1">http://localhost/member/openfeign/consumer/get/1</a>**</h5><p><strong>1.</strong> 浏览器输入**: <a href="http://localhost/member/openfeign/consumer/get/1">http://localhost/member/openfeign/consumer/get/1</a> ,** 目前是 <strong>Openfeign</strong> 调用**(<strong>负载均衡</strong>)**</p><p><strong>2.</strong> <strong>登录</strong> <strong>sentinel</strong> <strong>控制台</strong>: <strong>可以看到已经监控到</strong> <strong>member-service-nacos-consumer</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230630170804677.png" alt="image-20230630170804677"></p><h3 id="10-9-4-openFeign-sentinel-对远程调用熔断降级"><a href="#10-9-4-openFeign-sentinel-对远程调用熔断降级" class="headerlink" title="10.9.4 openFeign+sentinel 对远程调用熔断降级"></a>10.9.4 openFeign+sentinel 对远程调用熔断降级</h3><h4 id="10-9-4-1-需求分析-x2F-图解"><a href="#10-9-4-1-需求分析-x2F-图解" class="headerlink" title="10.9.4.1 需求分析&#x2F;图解"></a>10.9.4.1 需求分析&#x2F;图解</h4><p><strong>1.</strong> 需求**&#x2F;<strong>如图:在 <strong>member-service-nacos-consumer-80</strong> 调用某个无效服务时，启动 Sentinel 的熔断降级机制 <strong>,</strong> 能够快速返回响应，而不是使用默认的超时机制(因为超时机制容易线程堆积</strong>,** 从而导致雪崩)</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230630170956206.png" alt="image-20230630170956206"></p><p><strong>2.</strong> <strong>先测试一下，关闭</strong> <strong>10004&#x2F;10006,</strong> <strong>这时</strong> <strong>openfeign</strong> <strong>去调用会怎么样</strong>? (返回 <strong>time out)</strong></p><p><strong>3.</strong> <strong>还可以测试一下，让</strong> <strong>10004</strong> <strong>服务对应的</strong> <strong>API</strong> <strong>执行时间很长</strong>(比如休眠 <strong>2</strong> <strong>秒</strong>), <strong>这 时</strong> <strong>openfeign</strong> <strong>去调用会怎么样</strong>?</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230630171235813.png" alt="image-20230630171235813"></p><h4 id="10-9-4-2-代码-配置实现步骤"><a href="#10-9-4-2-代码-配置实现步骤" class="headerlink" title="10.9.4.2 代码+配置实现步骤"></a>10.9.4.2 代码+配置实现步骤</h4><p><strong>1.</strong> 修 改 <strong>member-service-nacos-consumer-80</strong> 的</p><p><strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;service&#x2F;MemberOpenFeignService.java,</strong> 加入 <strong>fallback</strong> 的处理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.springcloud.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.study.springcloud.entity.Member;</span><br><span class="line"><span class="keyword">import</span> com.study.springcloud.entity.Result;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/6/29</span></span><br><span class="line"><span class="comment"> * 21:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;member-service-nacos-provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MemberOpenFeignService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 老韩解读</span></span><br><span class="line"><span class="comment">     * 1. 远程调用的方式为 get</span></span><br><span class="line"><span class="comment">     * 2. 远程调用的 url 为 http://member-service-nacos-provider/member/get/&#123;id&#125;</span></span><br><span class="line"><span class="comment">     * 3. member-service-nacos-provider 是</span></span><br><span class="line"><span class="comment">     * nacos 注册中心服务 member-service-nacos-provider:10004/10006 </span></span><br><span class="line"><span class="comment">     * 4. 会根据 OpenFeign 的均衡算法来决定是调用 10004 还是 10006</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/member/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Member&gt; <span class="title function_">getMemberById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 创建 <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;service&#x2F;MemberFeignFallbackService.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.springcloud.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.study.springcloud.entity.Member;</span><br><span class="line"><span class="keyword">import</span> com.study.springcloud.entity.Result;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/6/30</span></span><br><span class="line"><span class="comment"> * 17:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberFeignFallbackService</span> <span class="keyword">implements</span> <span class="title class_">MemberOpenFeignService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Member&gt; <span class="title function_">getMemberById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;500&quot;</span>, <span class="string">&quot;被调用服务异常, 熔断降级，快速返回结果, 防止线程堆 积&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.</strong> 修改 <strong>member-service-nacos-consumer-80</strong> 的 <strong>application.yml ,</strong> 加入 <strong>openfeign</strong> 和 <strong>sentinel</strong> 整合配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">末尾添加以下：</span></span><br><span class="line"><span class="comment">#openfeign 和 sentinel 整合，必须配</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="10-9-4-3-测试"><a href="#10-9-4-3-测试" class="headerlink" title="10.9.4.3 测试"></a>10.9.4.3 测试</h4><h5 id="10-9-4-3-1-启动-Nacos-Server-8848"><a href="#10-9-4-3-1-启动-Nacos-Server-8848" class="headerlink" title="10.9.4.3.1 启动 Nacos Server 8848"></a><strong>10.9.4.3.1</strong> 启动 Nacos Server 8848</h5><h5 id="10-9-4-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-9-4-3-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.9.4.3.2 启动 Sentinel8080 控制台&#x2F;Sentinel dashboard"></a>10.9.4.3.2 启动 <strong>Sentinel8080</strong> 控制台&#x2F;Sentinel dashboard</h5><h5 id="10-9-4-3-3-关闭-member-service-nacos-provider-10004-x2F-10006"><a href="#10-9-4-3-3-关闭-member-service-nacos-provider-10004-x2F-10006" class="headerlink" title="10.9.4.3.3 关闭 **member-service-nacos-provider-10004&#x2F;10006 **"></a>10.9.4.3.3 关闭 **member-service-nacos-provider-10004&#x2F;10006 **</h5><h5 id="10-9-4-3-4-启动-member-service-nacos-consumer-80"><a href="#10-9-4-3-4-启动-member-service-nacos-consumer-80" class="headerlink" title="10.9.4.3.4 启动 member-service-nacos-consumer-80"></a><strong>10.9.4.3.4</strong> 启动 member-service-nacos-consumer-80</h5><h5 id="10-9-4-3-5-浏览器-http-localhost-member-openfeign-consumer-get-1"><a href="#10-9-4-3-5-浏览器-http-localhost-member-openfeign-consumer-get-1" class="headerlink" title="10.9.4.3.5 浏览器**: http://localhost/member/openfeign/consumer/get/1**"></a>10.9.4.3.5 浏览器**: <a href="http://localhost/member/openfeign/consumer/get/1">http://localhost/member/openfeign/consumer/get/1</a>**</h5><p><strong>1.</strong> 浏览器输入**: <a href="http://localhost/member/openfeign/consumer/get/1">http://localhost/member/openfeign/consumer/get/1</a> ,** 目前是 <strong>Openfeign</strong> 调用**(<strong>负载均衡</strong>)**</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230630172238879.png" alt="image-20230630172238879" style="zoom:50%;" /><h4 id="10-9-4-4-注意事项和细节说明"><a href="#10-9-4-4-注意事项和细节说明" class="headerlink" title="10.9.4.4 注意事项和细节说明"></a>10.9.4.4 注意事项和细节说明</h4><p><strong>1.</strong> 因为 <strong>member-service-nacos-consumer-80</strong> 已经被 <strong>sentinel</strong> 监控，所以我们可以加入相</p><p>关的流控规则**,** 比如为 <strong>&#x2F;member&#x2F;openfeign&#x2F;consumer&#x2F;get&#x2F;1</strong> 加入流控规则 <strong>qps &#x3D; 1</strong></p><p><strong>测试</strong>: <strong>如果</strong>&#x2F;member&#x2F;openfeign&#x2F;consumer&#x2F;get&#x2F;1 <strong>请求</strong> <strong>QPS</strong> <strong>超过</strong> <strong>1,</strong> <strong>会输出Blocked by Sentinel (flow limiting)</strong></p><p><strong>QPS</strong> <strong>没有超过</strong> <strong>1,</strong> <strong>会被</strong> <strong>fallback</strong> <strong>处理</strong></p><p><strong>2.</strong> <strong>如果远程服务恢复正常</strong>, <strong>又会正常调用</strong>.</p><h2 id="10-10-规则持久化"><a href="#10-10-规则持久化" class="headerlink" title="10.10 规则持久化"></a>10.10 规则持久化</h2><h3 id="10-10-1-规则没有持久化的问题"><a href="#10-10-1-规则没有持久化的问题" class="headerlink" title="10.10.1 规则没有持久化的问题"></a><strong>10.10.1</strong> 规则没有持久化的问题</h3><h4 id="10-10-1-1-如果-sentinel-流控规则没有持久化，当重启调用-API-x2F-接口-所在微服务后，规则就会丢失，需要-重新加入"><a href="#10-10-1-1-如果-sentinel-流控规则没有持久化，当重启调用-API-x2F-接口-所在微服务后，规则就会丢失，需要-重新加入" class="headerlink" title="10.10.1.1 如果 sentinel 流控规则没有持久化，当重启调用 API&#x2F;接口 所在微服务后，规则就会丢失，需要 重新加入"></a>10.10.1.1 如果 sentinel 流控规则没有持久化，当重启调用 API&#x2F;接口 所在微服务后，规则就会丢失，需要 重新加入</h4><h4 id="10-10-1-2-解决方案-通过-Nacos-进行持久化"><a href="#10-10-1-2-解决方案-通过-Nacos-进行持久化" class="headerlink" title="10.10.1.2 解决方案:通过 Nacos 进行持久化"></a>10.10.1.2 解决方案:通过 Nacos 进行持久化</h4><h3 id="10-10-2-规则持久化方案"><a href="#10-10-2-规则持久化方案" class="headerlink" title="10.10.2 规则持久化方案"></a><strong>10.10.2</strong> 规则持久化方案</h3><h4 id="10-10-2-1-阿里云-Ahas-最方便-x2F-付费"><a href="#10-10-2-1-阿里云-Ahas-最方便-x2F-付费" class="headerlink" title="10.10.2.1 阿里云 Ahas[最方便&#x2F;付费]"></a>10.10.2.1 阿里云 Ahas[最方便&#x2F;付费]</h4><p><strong>1.</strong> 官方文档 <strong>: <a href="https://help.aliyun.com/product/87450.html?spm=5176.cnahas.0.0.78034bb7ef0y86">https://help.aliyun.com/product/87450.html?spm=5176.cnahas.0.0.78034bb7ef0y86</a></strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230630190919413.png" alt="image-20230630190919413" style="zoom:50%;" /><h4 id="10-10-2-2-🌟在-Nacos-Server-配置规则-完成持久化-官方推荐"><a href="#10-10-2-2-🌟在-Nacos-Server-配置规则-完成持久化-官方推荐" class="headerlink" title="10.10.2.2 🌟在 Nacos Server 配置规则, 完成持久化 -官方推荐"></a>10.10.2.2 🌟在 Nacos Server 配置规则, 完成持久化 -官方推荐</h4><h4 id="10-10-2-3-将规则持久化到本地文件-定时同步"><a href="#10-10-2-3-将规则持久化到本地文件-定时同步" class="headerlink" title="10.10.2.3 将规则持久化到本地文件, 定时同步"></a>10.10.2.3 将规则持久化到本地文件, 定时同步</h4><h4 id="10-10-2-4-其它…"><a href="#10-10-2-4-其它…" class="headerlink" title="10.10.2.4 其它…"></a>10.10.2.4 其它…</h4><h3 id="10-10-3-Nacos-Server-配置中心-规则持久化实例"><a href="#10-10-3-Nacos-Server-配置中心-规则持久化实例" class="headerlink" title="10.10.3 Nacos Server 配置中心**-**规则持久化实例"></a><strong>10.10.3 Nacos Server</strong> 配置中心**-**规则持久化实例</h3><h4 id="10-10-3-1-工作原理示意图"><a href="#10-10-3-1-工作原理示意图" class="headerlink" title="10.10.3.1 工作原理示意图"></a>10.10.3.1 工作原理示意图</h4><p>其实就是靠把规则保存到nacos中，下次重启服务时再从nacos中获取先前设置的规则信息</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230630191350485.png" alt="image-20230630191350485"></p><h4 id="10-10-3-2-需求分析-x2F-图解"><a href="#10-10-3-2-需求分析-x2F-图解" class="headerlink" title="10.10.3.2 需求分析&#x2F;图解"></a>10.10.3.2 需求分析&#x2F;图解</h4><p><strong>1.</strong> 需 求 <strong>:</strong> 为 <strong>member-service-nacos-consumer-80</strong> 微服务的**&#x2F;member&#x2F;openfeign&#x2F;consumer&#x2F;get&#x2F;1 API** 接口添加流控规则 **QPS&#x3D;1&#x2F;**快速失败 <strong>.</strong></p><p><strong>2.</strong> <strong>要求将该流控规则加入到</strong> <strong>nacos server</strong> <strong>配置中心，实现持久化</strong></p><h4 id="10-10-3-3-代码-配置实现步骤"><a href="#10-10-3-3-代码-配置实现步骤" class="headerlink" title="10.10.3.3 代码+配置实现步骤"></a>10.10.3.3 代码+配置实现步骤</h4><p><strong>1.</strong> 在 <strong>Nacos Server</strong> 配置中心增加 <strong>Sentinel</strong> 客户端**&#x2F;**微服务模块的流控规则</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230630191715975.png" alt="image-20230630191715975" style="zoom:50%;" /><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span><span class="string">&quot;/member/openfeign/consumer/get/1&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;limitApp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;grade&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;strategy&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;controlBehavior&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;clusterMode&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230630192956899.png" alt="image-20230630192956899"></p><p><strong>2.</strong> <strong>在</strong> <strong>Nacos Server</strong> <strong>配置中心增加</strong> <strong>Sentinel</strong> <strong>客户端</strong>&#x2F;微服务模块的流控规则参数说明</p><ul><li><strong>resource</strong> ∶ 资源名称;</li><li><strong>limlitApp</strong> ∶  来源应用;</li><li>**grade **∶ 阈值类型，0 表示线程数，1 表示QPS;</li><li><strong>count</strong> ∶ 单机阈值;</li><li>**strategy **∶ 流控模式，0 表示直接，1 表示关联，2 表示链路;</li><li>**controlBehavior **∶ 流控效果，0 表示快速失败，1 表示Warm Up，2 表示排队等待;</li><li>**clusterMode **∶ 是否集群</li></ul><p><strong>3.</strong> <strong>修改</strong> <strong>member-service-nacos-consumer-80</strong> <strong>的</strong> <strong>pom.xml,</strong> <strong>加入</strong> <strong>sentinel</strong> <strong>和</strong> <strong>nacos</strong> <strong>持久化整合依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加入 sentinel 和 nacos 持久化整合依赖 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>4.</strong> <strong>修改</strong> <strong>member-service-nacos-consumer-80</strong>的application.yml , 配置该微服务从Nacos  Server获取流控规则</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在原本的基础上添加以下代码：</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">    <span class="comment"># 配置该微服务从 Nacos Server 获取流控规则</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">ds1:</span></span><br><span class="line">          <span class="attr">nacos:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">        <span class="attr">dataId:</span> <span class="string">member-service-nacos-consumer</span></span><br><span class="line">        <span class="attr">groupId:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">        <span class="attr">data-type:</span> <span class="string">json</span></span><br><span class="line">        <span class="attr">rule-type:</span> <span class="string">flow</span></span><br></pre></td></tr></table></figure><h4 id="10-10-3-4-测试"><a href="#10-10-3-4-测试" class="headerlink" title="10.10.3.4 测试"></a>10.10.3.4 测试</h4><h5 id="10-10-3-4-1-启动-Nacos-Server-8848"><a href="#10-10-3-4-1-启动-Nacos-Server-8848" class="headerlink" title="10.10.3.4.1 启动 Nacos Server 8848"></a><strong>10.10.3.4.1</strong> 启动 Nacos Server 8848</h5><h5 id="10-10-3-4-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard"><a href="#10-10-3-4-2-启动-Sentinel8080-控制台-x2F-Sentinel-dashboard" class="headerlink" title="10.10.3.4.2 启动 Sentinel8080 控制台&#x2F;Sentinel dashboard"></a>10.10.3.4.2 启动 <strong>Sentinel8080</strong> 控制台&#x2F;Sentinel dashboard</h5><h5 id="10-10-3-4-3-启动-member-service-nacos-provider-10004-x2F-10006"><a href="#10-10-3-4-3-启动-member-service-nacos-provider-10004-x2F-10006" class="headerlink" title="10.10.3.4.3 启动 **member-service-nacos-provider-10004&#x2F;10006 **"></a>10.10.3.4.3 启动 **member-service-nacos-provider-10004&#x2F;10006 **</h5><h5 id="10-10-3-4-4-启动-member-service-nacos-consumer-80"><a href="#10-10-3-4-4-启动-member-service-nacos-consumer-80" class="headerlink" title="10.10.3.4.4 启动 member-service-nacos-consumer-80"></a><strong>10.10.3.4.4</strong> 启动 member-service-nacos-consumer-80</h5><h5 id="10-10-3-4-5-浏览器-http-localhost-member-openfeign-consumer-get-1"><a href="#10-10-3-4-5-浏览器-http-localhost-member-openfeign-consumer-get-1" class="headerlink" title="10.10.3.4.5 浏览器**: http://localhost/member/openfeign/consumer/get/1**"></a>10.10.3.4.5 浏览器**: <a href="http://localhost/member/openfeign/consumer/get/1">http://localhost/member/openfeign/consumer/get/1</a>**</h5><p><strong>1.</strong> 浏览器输入**: <a href="http://localhost/member/openfeign/consumer/get/1">http://localhost/member/openfeign/consumer/get/1</a> ,** 目前是 <strong>Openfeign</strong> 调用**(<strong>负载均衡</strong>),** <u><em><strong>而且流控规则已经生效了.</strong></em></u></p><p><strong>2.</strong> <strong>查看</strong> <strong>Sentinel</strong> <strong>控制台</strong>,<strong>发现已经同步了流控规则</strong></p><h4 id="10-10-3-5-注意事项和细节"><a href="#10-10-3-5-注意事项和细节" class="headerlink" title="10.10.3.5 注意事项和细节"></a>10.10.3.5 注意事项和细节</h4><p><strong>1.</strong> 在 <strong>nacos server</strong> 配置 <strong>sentinel</strong> 流控规则的 <strong>Data ID</strong> 也可以自己指定，比如写成 <strong>hsp-id,</strong> 只要在 **sentinel client&#x2F;**微服务 的 <strong>applicaion.yml</strong> 的 <strong>datasource.ds1.nacos.dataId</strong> 的值保持一致即可</p><p><strong>2.</strong> <strong>如图所示</strong></p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230630194533516.png" alt="image-20230630194533516" style="zoom:50%;" /><h1 id="11-SpringCloud-Alibaba-Seata全局事务"><a href="#11-SpringCloud-Alibaba-Seata全局事务" class="headerlink" title="11 SpringCloud Alibaba Seata全局事务"></a>11 SpringCloud Alibaba Seata全局事务</h1><p><strong>全局事务</strong>——保证一个牵扯修改多个数据库的操作由于意外情况导致数据库中数据不一致的情况</p><h2 id="11-1-Seata基础"><a href="#11-1-Seata基础" class="headerlink" title="11.1 Seata基础"></a>11.1 Seata基础</h2><h3 id="11-1-1-先看一个问题，引出-Seata"><a href="#11-1-1-先看一个问题，引出-Seata" class="headerlink" title="11.1.1 先看一个问题，引出 Seata"></a><strong>11.1.1</strong> 先看一个问题，引出 <strong>Seata</strong></h3><p><strong>1.</strong> 单机单库**(<strong>多表</strong>)**处理事务示意图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230630203651434.png" alt="image-20230630203651434"></p><p><strong>2.</strong> <strong>分布式微服务架构下的数据库事务示意图</strong>（RPC，远程过程调用）</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230630204333902.png" alt="image-20230630204333902" style="zoom:50%;" /><p><strong>3.</strong> <strong>梳理上图</strong></p><p>用户购买商品的业务逻辑。整个业务逻辑由3个微服务提供支持∶</p><ul><li><strong>仓储服务∶对给定的商品扣除仓库&#x2F;商品数量</strong></li><li><strong>订单服务;根据采购需求创建订单</strong></li><li><strong>帐户服务∶从用户帐户中扣除余额</strong></li></ul><p><strong>4.</strong> <strong>问题分析</strong></p><ul><li><p><strong>单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用，分别使用三个独立的数据源</strong></p></li><li><p>业务操作需要调用三个服务来完成。此时<strong>每个服务内部的数据一致性由本地事务来保证</strong></p></li><li><p><strong>但是全局的数据—致性问题没法保证</strong></p></li><li><p>简单的说: <u>一次业务操作需要跨多个数据源或需要跨多个系统进行远程调用</u>，就会<strong>产生分布式事务问题</strong>—–</p><p>——-&gt;seata</p></li></ul><h3 id="11-1-2-分布式事务问题-amp-解决方案"><a href="#11-1-2-分布式事务问题-amp-解决方案" class="headerlink" title="11.1.2 分布式事务问题**&amp;**解决方案"></a><strong>11.1.2</strong> 分布式事务问题**&amp;**解决方案</h3><h4 id="11-1-2-1-分布式微服务架构下的全局数据一致性问题-即-分布式事务问题"><a href="#11-1-2-1-分布式微服务架构下的全局数据一致性问题-即-分布式事务问题" class="headerlink" title="11.1.2.1 分布式微服务架构下的全局数据一致性问题 [即: 分布式事务问题]"></a>11.1.2.1 分布式微服务架构下的全局数据一致性问题 [即: 分布式事务问题]</h4><h4 id="11-1-2-2-解决方案-Seata"><a href="#11-1-2-2-解决方案-Seata" class="headerlink" title="11.1.2.2 解决方案: Seata"></a>11.1.2.2 解决方案: Seata</h4><h3 id="11-1-3-官网"><a href="#11-1-3-官网" class="headerlink" title="11.1.3 官网"></a><strong>11.1.3</strong> 官网</h3><h4 id="11-1-3-1-http-seata-io-zh-cn"><a href="#11-1-3-1-http-seata-io-zh-cn" class="headerlink" title="11.1.3.1 http://seata.io/zh-cn/"></a>11.1.3.1 <a href="http://seata.io/zh-cn/">http://seata.io/zh-cn/</a></h4><h4 id="11-1-3-2-使用手册-https-seata-io-zh-cn-docs-overview-what-is-seata-html"><a href="#11-1-3-2-使用手册-https-seata-io-zh-cn-docs-overview-what-is-seata-html" class="headerlink" title="11.1.3.2 使用手册: https://seata.io/zh-cn/docs/overview/what-is-seata.html"></a>11.1.3.2 使用手册: <a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></h4><h3 id="11-1-4-Seata是什么"><a href="#11-1-4-Seata是什么" class="headerlink" title="11.1.4 Seata是什么?"></a>11.1.4 Seata是什么?</h3><p>Seata 是一款开源的分布式事务解决方案，致力于<strong>在微服务架构下提供<u>高性能和简单易用的分布式事务服务</u></strong></p><h2 id="11-2-🌟Seata-工作机制-x2F-返讲"><a href="#11-2-🌟Seata-工作机制-x2F-返讲" class="headerlink" title="11.2 🌟Seata 工作机制&#x2F;返讲"></a>11.2 🌟Seata 工作机制&#x2F;返讲</h2><h3 id="11-2-1-分布式事务过程分析"><a href="#11-2-1-分布式事务过程分析" class="headerlink" title="11.2.1 分布式事务过程分析"></a><strong>11.2.1</strong> 分布式事务过程分析</h3><p><strong>1. Seata</strong> 分布式事务处理过程-ID+三组件模型</p><p><strong>2.</strong> 一图胜千言</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703150121800.png" alt="image-20230703150121800"></p><p>上图展示了一个分布式事务在Seata的处理过程</p><ul><li>Transaction ID <strong>XID</strong>:全局唯一的事务ID</li><li>Transaction Coordinator(<strong>TC</strong>): 事务协调器，<u>维护全局事务的运行状态</u>，负责<u>协调并驱动全局事务的提交或回滚</u></li><li>Transaction Manager(<strong>TM</strong>): 控制<u>全局事务</u>的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议;</li><li>Resource Manager(<strong>RM</strong>):控制<u>分支事务</u>，负责分支注册，状态汇报，并接收事务协调器的指令，驱动分支 (本地)事务的<strong>提交和回滚</strong></li></ul><p>执行过程</p><ul><li>TM向 TC申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID</li><li>XID在微服务调用链路的上下文中传播</li><li>RM 向 TC注册分支事务，将其纳入 XID 对应全局事务的管辖</li><li>TM 向 TC 发起针对 XID 的全局提交或回滚决议。</li><li>TC 调度 XID下管辖的全部分支事务完成提交或回滚请求</li></ul><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703152243363.png" alt="image-20230703152243363" style="zoom:150%;" /><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703152337277.png" alt="image-20230703152337277"></p><h3 id="11-2-2-Seata-事务模式"><a href="#11-2-2-Seata-事务模式" class="headerlink" title="11.2.2 Seata 事务模式"></a>11.2.2 Seata 事务模式</h3><p><strong>1.</strong> <strong>地址</strong>: <a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></p><h4 id="11-2-2-1-AT-默认模式"><a href="#11-2-2-1-AT-默认模式" class="headerlink" title="11.2.2.1 AT(默认模式)"></a>11.2.2.1 AT(默认模式)</h4><h4 id="11-2-2-2-TCC"><a href="#11-2-2-2-TCC" class="headerlink" title="11.2.2.2 TCC"></a>11.2.2.2 TCC</h4><h4 id="11-2-2-3-SAGA"><a href="#11-2-2-3-SAGA" class="headerlink" title="11.2.2.3 SAGA"></a>11.2.2.3 SAGA</h4><h4 id="11-2-2-4-XA"><a href="#11-2-2-4-XA" class="headerlink" title="11.2.2.4 XA"></a>11.2.2.4 XA</h4><h3 id="11-2-3-AT无侵入模式"><a href="#11-2-3-AT无侵入模式" class="headerlink" title="11.2.3 AT无侵入模式"></a>11.2.3 AT无侵入模式</h3><h4 id="11-2-3-1-文档-https-seata-io-zh-cn-docs-overview-what-is-seata-html"><a href="#11-2-3-1-文档-https-seata-io-zh-cn-docs-overview-what-is-seata-html" class="headerlink" title="11.2.3.1 文档: https://seata.io/zh-cn/docs/overview/what-is-seata.html"></a>11.2.3.1 文档: <a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></h4><h4 id="11-2-3-2-一阶段加载"><a href="#11-2-3-2-一阶段加载" class="headerlink" title="11.2.3.2 一阶段加载"></a>11.2.3.2 一阶段加载</h4><p>在一阶段，<strong>Seata</strong> 会拦截**”**业务 <strong>SQL”</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703161643439.png" alt="image-20230703161643439"></p><ol><li><p>解析 SQL 语义，找到“业务SQL”要更新的业务数据，在业务数据被更新前，将其保存成”before image”(前罝镜像）</p></li><li><p>执行”业务 SQL”更新业务数据，在业务数据更新之后，其保存成”after image” &#x2F;后置镜像</p></li><li><p>最后生成行锁</p></li><li><p>以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性</p></li></ol><p>其中，<strong>前像与后像存于undo_log数据表中</strong></p><h4 id="11-2-3-3-二阶段提交"><a href="#11-2-3-3-二阶段提交" class="headerlink" title="11.2.3.3 二阶段提交"></a>11.2.3.3 二阶段提交</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703162629147.png" alt="image-20230703162629147" style="zoom: 40%;" /><p><strong>1.</strong> <strong>二阶段如果是顺利提交</strong></p><p><strong>2.</strong> <strong>因为”业务 SQL”在一阶段已经提交至数据库，所以 Seata 框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可</strong></p><h4 id="11-2-3-4-二阶段回滚"><a href="#11-2-3-4-二阶段回滚" class="headerlink" title="11.2.3.4 二阶段回滚"></a>11.2.3.4 二阶段回滚</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703162812449.png" alt="image-20230703162812449"></p><ol><li><p>二阶段如果是回滚的话，seata 就需要<strong>回滚一阶段己经执行的“业务 SQL”‘，还原业务数据</strong>。</p></li><li><p>回滚方式便是用”before image”还原业务数据;但在还原前要首先要校验脏号，对比”数据库当前业务数据”和”after image 如果两份数据完全一致就说明没有脏写，可以还原业务数据</p></li><li><p>如果不一致就说明有脏写，出现脏写就需要转人工处理</p></li></ol><h3 id="11-2-4-AT事务模式Debug验证"><a href="#11-2-4-AT事务模式Debug验证" class="headerlink" title="11.2.4 AT事务模式Debug验证"></a>11.2.4 AT<strong>事务模式</strong>Debug验证</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703163149523.png" alt="image-20230703163149523"></p><h3 id="11-2-5-SEATA的分布式交易解决方案"><a href="#11-2-5-SEATA的分布式交易解决方案" class="headerlink" title="11.2.5 SEATA的分布式交易解决方案"></a>11.2.5 SEATA的分布式交易解决方案</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703163341180.png" alt="image-20230703163341180"></p><h2 id="11-3-SeataServer安装"><a href="#11-3-SeataServer安装" class="headerlink" title="11.3 SeataServer安装"></a>11.3 SeataServer安装</h2><h3 id="11-3-1-下载"><a href="#11-3-1-下载" class="headerlink" title="11.3.1 下载"></a><strong>11.3.1</strong> 下载</h3><h4 id="11-3-1-1-https-github-com-seata-seata-releases-tag-v0-9-0"><a href="#11-3-1-1-https-github-com-seata-seata-releases-tag-v0-9-0" class="headerlink" title="11.3.1.1 https://github.com/seata/seata/releases/tag/v0.9.0"></a>11.3.1.1 <a href="https://github.com/seata/seata/releases/tag/v0.9.0">https://github.com/seata/seata/releases/tag/v0.9.0</a></h4><h3 id="11-3-2-安装和配置"><a href="#11-3-2-安装和配置" class="headerlink" title="11.3.2 安装和配置"></a><strong>11.3.2</strong> 安装和配置</h3><p><strong>1.</strong> 将 <strong>seata-server-0.9.0.zip</strong> 解压到 指定目录，比如 <strong>d:\program</strong></p><p><strong>2.</strong> <strong>修改</strong> <strong>conf\file.conf</strong> <strong>文件</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">transport &#123;</span><br><span class="line">  # tcp udt unix-domain-socket</span><br><span class="line">  type = <span class="string">&quot;TCP&quot;</span></span><br><span class="line">  #<span class="variable constant_">NIO</span> <span class="variable constant_">NATIVE</span></span><br><span class="line">  server = <span class="string">&quot;NIO&quot;</span></span><br><span class="line">  #enable heartbeat</span><br><span class="line">  heartbeat = <span class="literal">true</span></span><br><span class="line">  #thread factory <span class="keyword">for</span> netty</span><br><span class="line">  thread-factory &#123;</span><br><span class="line">    boss-thread-prefix = <span class="string">&quot;NettyBoss&quot;</span></span><br><span class="line">    worker-thread-prefix = <span class="string">&quot;NettyServerNIOWorker&quot;</span></span><br><span class="line">    server-executor-thread-prefix = <span class="string">&quot;NettyServerBizHandler&quot;</span></span><br><span class="line">    share-boss-worker = <span class="literal">false</span></span><br><span class="line">    client-selector-thread-prefix = <span class="string">&quot;NettyClientSelector&quot;</span></span><br><span class="line">    client-selector-thread-size = <span class="number">1</span></span><br><span class="line">    client-worker-thread-prefix = <span class="string">&quot;NettyClientWorkerThread&quot;</span></span><br><span class="line">    # netty boss thread size,will not be used <span class="keyword">for</span> <span class="variable constant_">UDT</span></span><br><span class="line">    boss-thread-size = <span class="number">1</span></span><br><span class="line">    #auto <span class="keyword">default</span> pin or <span class="number">8</span></span><br><span class="line">    worker-thread-size = <span class="number">8</span></span><br><span class="line">  &#125;</span><br><span class="line">  shutdown &#123;</span><br><span class="line">    # when destroy server, wait seconds</span><br><span class="line">    wait = <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  serialization = <span class="string">&quot;seata&quot;</span></span><br><span class="line">  compressor = <span class="string">&quot;none&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">service &#123;</span><br><span class="line">  #vgroup-&gt;rgroup</span><br><span class="line">  #vgroup_mapping.<span class="property">my_test_tx_group</span> = <span class="string">&quot;default&quot;</span></span><br><span class="line">  vgroup_mapping.<span class="property">my_test_tx_group</span> = <span class="string">&quot;hspedu_order_tx_group&quot;</span></span><br><span class="line">  #only support single node</span><br><span class="line">  <span class="keyword">default</span>.<span class="property">grouplist</span> = <span class="string">&quot;127.0.0.1:8091&quot;</span></span><br><span class="line">  #degrade current not support</span><br><span class="line">  enableDegrade = <span class="literal">false</span></span><br><span class="line">  #disable</span><br><span class="line">  disable = <span class="literal">false</span></span><br><span class="line">  #unit ms,s,m,h,d represents milliseconds, seconds, minutes, hours, days, <span class="keyword">default</span> permanent</span><br><span class="line">  max.<span class="property">commit</span>.<span class="property">retry</span>.<span class="property">timeout</span> = <span class="string">&quot;-1&quot;</span></span><br><span class="line">  max.<span class="property">rollback</span>.<span class="property">retry</span>.<span class="property">timeout</span> = <span class="string">&quot;-1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client &#123;</span><br><span class="line">  <span class="keyword">async</span>.<span class="property">commit</span>.<span class="property">buffer</span>.<span class="property">limit</span> = <span class="number">10000</span></span><br><span class="line">  lock &#123;</span><br><span class="line">    retry.<span class="property">internal</span> = <span class="number">10</span></span><br><span class="line">    retry.<span class="property">times</span> = <span class="number">30</span></span><br><span class="line">  &#125;</span><br><span class="line">  report.<span class="property">retry</span>.<span class="property">count</span> = <span class="number">5</span></span><br><span class="line">  tm.<span class="property">commit</span>.<span class="property">retry</span>.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line">  tm.<span class="property">rollback</span>.<span class="property">retry</span>.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## transaction log store</span><br><span class="line">store &#123;</span><br><span class="line">  ## store <span class="attr">mode</span>: file、db</span><br><span class="line">  ##mode = <span class="string">&quot;file&quot;</span></span><br><span class="line">  mode = <span class="string">&quot;db&quot;</span></span><br><span class="line"></span><br><span class="line">  ## file store</span><br><span class="line">  file &#123;</span><br><span class="line">    dir = <span class="string">&quot;sessionStore&quot;</span></span><br><span class="line"></span><br><span class="line">    # branch session size , <span class="keyword">if</span> exceeded first <span class="keyword">try</span> compress lockkey, still exceeded throws exceptions</span><br><span class="line">    max-branch-session-size = <span class="number">16384</span></span><br><span class="line">    # globe session size , <span class="keyword">if</span> exceeded throws exceptions</span><br><span class="line">    max-<span class="variable language_">global</span>-session-size = <span class="number">512</span></span><br><span class="line">    # file buffer size , <span class="keyword">if</span> exceeded allocate <span class="keyword">new</span> buffer</span><br><span class="line">    file-write-buffer-cache-size = <span class="number">16384</span></span><br><span class="line">    # when recover batch read size</span><br><span class="line">    session.<span class="property">reload</span>.<span class="property">read_size</span> = <span class="number">100</span></span><br><span class="line">    # <span class="keyword">async</span>, sync</span><br><span class="line">    flush-disk-mode = <span class="keyword">async</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ## database store</span><br><span class="line">  db &#123;</span><br><span class="line">    ## the implement <span class="keyword">of</span> javax.<span class="property">sql</span>.<span class="property">DataSource</span>, such <span class="keyword">as</span> <span class="title class_">DruidDataSource</span>(druid)/<span class="title class_">BasicDataSource</span>(dbcp) etc.</span><br><span class="line">    datasource = <span class="string">&quot;dbcp&quot;</span></span><br><span class="line">    ## mysql/oracle/h2/oceanbase etc.</span><br><span class="line">    db-type = <span class="string">&quot;mysql&quot;</span></span><br><span class="line">    driver-<span class="keyword">class</span>-name = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span><br><span class="line">    url = <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/seata&quot;</span></span><br><span class="line">    ##user = <span class="string">&quot;mysql&quot;</span></span><br><span class="line">    user = <span class="string">&quot;root&quot;</span></span><br><span class="line">    ##password = <span class="string">&quot;mysql&quot;</span></span><br><span class="line">    password = <span class="string">&quot;QWEASDzxc123&quot;</span></span><br><span class="line">    min-conn = <span class="number">1</span></span><br><span class="line">    max-conn = <span class="number">3</span></span><br><span class="line">    <span class="variable language_">global</span>.<span class="property">table</span> = <span class="string">&quot;global_table&quot;</span></span><br><span class="line">    branch.<span class="property">table</span> = <span class="string">&quot;branch_table&quot;</span></span><br><span class="line">    lock-table = <span class="string">&quot;lock_table&quot;</span></span><br><span class="line">    query-limit = <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">lock &#123;</span><br><span class="line">  ## the lock store <span class="attr">mode</span>: local、remote</span><br><span class="line">  mode = <span class="string">&quot;remote&quot;</span></span><br><span class="line"></span><br><span class="line">  local &#123;</span><br><span class="line">    ## store locks <span class="keyword">in</span> user<span class="string">&#x27;s database</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  remote &#123;</span></span><br><span class="line"><span class="string">    ## store locks in the seata&#x27;</span>s server</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">recovery &#123;</span><br><span class="line">  #schedule committing retry period <span class="keyword">in</span> milliseconds</span><br><span class="line">  committing-retry-period = <span class="number">1000</span></span><br><span class="line">  #schedule asyn committing retry period <span class="keyword">in</span> milliseconds</span><br><span class="line">  asyn-committing-retry-period = <span class="number">1000</span></span><br><span class="line">  #schedule rollbacking retry period <span class="keyword">in</span> milliseconds</span><br><span class="line">  rollbacking-retry-period = <span class="number">1000</span></span><br><span class="line">  #schedule timeout retry period <span class="keyword">in</span> milliseconds</span><br><span class="line">  timeout-retry-period = <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">transaction &#123;</span><br><span class="line">  undo.<span class="property">data</span>.<span class="property">validation</span> = <span class="literal">true</span></span><br><span class="line">  undo.<span class="property">log</span>.<span class="property">serialization</span> = <span class="string">&quot;jackson&quot;</span></span><br><span class="line">  undo.<span class="property">log</span>.<span class="property">save</span>.<span class="property">days</span> = <span class="number">7</span></span><br><span class="line">  #schedule <span class="keyword">delete</span> expired undo_log <span class="keyword">in</span> milliseconds</span><br><span class="line">  undo.<span class="property">log</span>.<span class="property">delete</span>.<span class="property">period</span> = <span class="number">86400000</span></span><br><span class="line">  undo.<span class="property">log</span>.<span class="property">table</span> = <span class="string">&quot;undo_log&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## metrics settings</span><br><span class="line">metrics &#123;</span><br><span class="line">  enabled = <span class="literal">false</span></span><br><span class="line">  registry-type = <span class="string">&quot;compact&quot;</span></span><br><span class="line">  # multi exporters use comma divided</span><br><span class="line">  exporter-list = <span class="string">&quot;prometheus&quot;</span></span><br><span class="line">  exporter-prometheus-port = <span class="number">9898</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">support &#123;</span><br><span class="line">  ## spring</span><br><span class="line">  spring &#123;</span><br><span class="line">    # auto proxy the <span class="title class_">DataSource</span> bean</span><br><span class="line">    datasource.<span class="property">autoproxy</span> = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.</strong> <strong>在</strong> <strong>mysql5.7</strong> <strong>创建</strong> <strong>seata</strong> <strong>数据库</strong></p><p><strong>4.</strong> <strong>修改</strong> <strong>seata</strong> <strong>的</strong> <strong>\conf\registry.conf ,</strong> <strong>配置注册中心</strong> <strong>nacos server</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span><br><span class="line">  # type = <span class="string">&quot;file&quot;</span></span><br><span class="line">  type = <span class="string">&quot;nacos&quot;</span></span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    # serverAddr = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">    serverAddr = <span class="string">&quot;localhost:8848&quot;</span></span><br><span class="line">    namespace = <span class="string">&quot;&quot;</span></span><br><span class="line">    cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  eureka &#123;</span><br><span class="line">    serviceUrl = <span class="string">&quot;http://localhost:8761/eureka&quot;</span></span><br><span class="line">    application = <span class="string">&quot;default&quot;</span></span><br><span class="line">    weight = <span class="string">&quot;1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  redis &#123;</span><br><span class="line">    serverAddr = <span class="string">&quot;localhost:6379&quot;</span></span><br><span class="line">    db = <span class="string">&quot;0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">    serverAddr = <span class="string">&quot;127.0.0.1:2181&quot;</span></span><br><span class="line">    session.<span class="property">timeout</span> = <span class="number">6000</span></span><br><span class="line">    connect.<span class="property">timeout</span> = <span class="number">2000</span></span><br><span class="line">  &#125;</span><br><span class="line">  consul &#123;</span><br><span class="line">    cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">    serverAddr = <span class="string">&quot;127.0.0.1:8500&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  etcd3 &#123;</span><br><span class="line">    cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">    serverAddr = <span class="string">&quot;http://localhost:2379&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  sofa &#123;</span><br><span class="line">    serverAddr = <span class="string">&quot;127.0.0.1:9603&quot;</span></span><br><span class="line">    application = <span class="string">&quot;default&quot;</span></span><br><span class="line">    region = <span class="string">&quot;DEFAULT_ZONE&quot;</span></span><br><span class="line">    datacenter = <span class="string">&quot;DefaultDataCenter&quot;</span></span><br><span class="line">    cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">    group = <span class="string">&quot;SEATA_GROUP&quot;</span></span><br><span class="line">    addressWaitTime = <span class="string">&quot;3000&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name = <span class="string">&quot;file.conf&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config &#123;</span><br><span class="line">  # file、nacos 、apollo、zk、consul、etcd3</span><br><span class="line">  type = <span class="string">&quot;file&quot;</span></span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">    namespace = <span class="string">&quot;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  consul &#123;</span><br><span class="line">    serverAddr = <span class="string">&quot;127.0.0.1:8500&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  apollo &#123;</span><br><span class="line">    app.<span class="property">id</span> = <span class="string">&quot;seata-server&quot;</span></span><br><span class="line">    apollo.<span class="property">meta</span> = <span class="string">&quot;http://192.168.1.204:8801&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    serverAddr = <span class="string">&quot;127.0.0.1:2181&quot;</span></span><br><span class="line">    session.<span class="property">timeout</span> = <span class="number">6000</span></span><br><span class="line">    connect.<span class="property">timeout</span> = <span class="number">2000</span></span><br><span class="line">  &#125;</span><br><span class="line">  etcd3 &#123;</span><br><span class="line">    serverAddr = <span class="string">&quot;http://localhost:2379&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name = <span class="string">&quot;file.conf&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="11-3-3-启动"><a href="#11-3-3-启动" class="headerlink" title="11.3.3 启动"></a><strong>11.3.3</strong> 启动</h3><h4 id="11-3-3-1-启动-Nacos-Server-8848"><a href="#11-3-3-1-启动-Nacos-Server-8848" class="headerlink" title="11.3.3.1 启动 Nacos Server 8848"></a>11.3.3.1 启动 Nacos Server 8848</h4><h4 id="11-3-3-2-双击-Seata-的-bin-seata-server-bat-启动-Seata-Server"><a href="#11-3-3-2-双击-Seata-的-bin-seata-server-bat-启动-Seata-Server" class="headerlink" title="11.3.3.2 双击 Seata 的\bin\seata-server.bat , 启动 Seata Server"></a>11.3.3.2 双击 Seata 的\bin\seata-server.bat , 启动 Seata Server</h4><p><strong>1.</strong> 启动 <strong>seata-server.bat ,</strong> 看到如下界面说明成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /Applications/seata/bin</span><br><span class="line">./seata-server.sh -h 127.0.0.1 -p 8848 -m db -n 1 </span><br></pre></td></tr></table></figure><h4 id="11-3-3-3-登录-Nacos-Server-查看-Seata-Server-是否注册成功"><a href="#11-3-3-3-登录-Nacos-Server-查看-Seata-Server-是否注册成功" class="headerlink" title="11.3.3.3 登录 Nacos Server , 查看 Seata Server 是否注册成功"></a>11.3.3.3 登录 Nacos Server , 查看 Seata Server 是否注册成功</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230702162714540.png" alt="image-20230702162714540"></p><h2 id="11-4-Seata-分布式事务-应用实例"><a href="#11-4-Seata-分布式事务-应用实例" class="headerlink" title="11.4 Seata 分布式事务-应用实例"></a>11.4 Seata 分布式事务-应用实例</h2><h3 id="11-4-1-需求分析-x2F-图解"><a href="#11-4-1-需求分析-x2F-图解" class="headerlink" title="11.4.1 需求分析**&#x2F;**图解"></a><strong>11.4.1</strong> 需求分析**&#x2F;**图解</h3><p><strong>1.</strong> 需求:完成下订单功能，由三个微服务模块协同完成**,** 涉及到多数据库**,** 多张表</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230702164527518.png" alt="image-20230702164527518" style="zoom:50%;" /><h3 id="11-4-2-创建数据库和表"><a href="#11-4-2-创建数据库和表" class="headerlink" title="11.4.2 创建数据库和表"></a>11.4.2 创建数据库和表</h3><p><strong>1.</strong> 创建业务数据库和表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 订单微服务的数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE order_micro_service </span><br><span class="line">USE order_micro_service</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">order</span>`(</span><br><span class="line">id <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">user_id <span class="type">BIGINT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">product_id <span class="type">BIGINT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">nums <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">money <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`status` <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;0:创建中; 1:已完结&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">order</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 库存微服务的数据库`storage``order` </span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE storage_micro_service </span><br><span class="line">USE storage_micro_service</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `storage`(</span><br><span class="line">id <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY, </span><br><span class="line">  product_id <span class="type">BIGINT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">amount <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;库存量&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 初始化库存表</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `storage` <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>, <span class="number">1</span>, <span class="number">10</span>); </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `storage`</span><br><span class="line"><span class="comment">-- 账号微服务的数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE account_micro_service </span><br><span class="line">USE account_micro_service</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `account`(</span><br><span class="line">id <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY , </span><br><span class="line">  user_id <span class="type">BIGINT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">money <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;账户金额&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 初始化账户表</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `account` <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>, <span class="number">666</span>, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 分别为 <strong>3</strong> 库创建对应的回滚日志表**,** 说明回滚日志表在 <strong>seata</strong> 的 <strong>\conf\db_undo_log.sql</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">use order_micro_service </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `undo_log` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT, </span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`log_created` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `log_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `ext` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line"><span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">use storage_micro_service </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `undo_log` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT, </span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`log_created` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `ext` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line"><span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">use account_micro_service </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `undo_log` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT, </span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`log_created` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `log_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `ext` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line"><span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="11-4-3-开发-seata-storage-micro-service-10010-微服务"><a href="#11-4-3-开发-seata-storage-micro-service-10010-微服务" class="headerlink" title="11.4.3 开发 seata_storage_micro_service-10010 微服务"></a>11.4.3 开发 seata_storage_micro_service-10010 微服务</h3><p><strong>1.</strong> 参考以前的方式，创建 <strong>seata_storage_micro_service-10010</strong> 微服务模块</p><p><strong>2.</strong> <strong>修改</strong> <strong>pom.xml,</strong> <strong>添加相关的</strong> <strong>jar</strong> <strong>依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 提示 application.yml --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入 openfeign，因为可能需要用到远程调用 --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 在微服务模块引入 nacos-discovery starter --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 排除自带的 seata-all --&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入指定版本的 io.seata --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入 e_commerce_center-common-api --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hspedu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>e_commerce_center-common-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 这里我们重新指定一下 version --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3.</strong> <strong>创建</strong> <strong>application.yml,</strong> <strong>进行相关的配置</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">seata_storage_micor_service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">alibaba:</span></span><br><span class="line">      <span class="attr">seata:</span></span><br><span class="line">        <span class="comment">#自定义事务组名称需要与 seata-server 中的对应,看 \conf\file.conf</span></span><br><span class="line">        <span class="attr">tx-service-group:</span> <span class="string">hspedu_order_tx_group</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#配置 Nacos Server</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/storage_micro_service</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">QWEASDzxc123</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">io:</span></span><br><span class="line">      <span class="attr">seata:</span> <span class="string">info</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapperLocations:</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure><p><strong>4.</strong> <strong>创建</strong> <strong>file.conf,</strong> <strong>进行相关的配置</strong>, <strong>说明:该文件从</strong> <strong>seata</strong> <strong>的</strong>\conf\file.conf <strong>拷贝，进行修改即可</strong></p><p><strong>5.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;entity&#x2F;Storage.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.springcloud.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/7/2</span></span><br><span class="line"><span class="comment"> * 20:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Long productId;</span><br><span class="line">    <span class="keyword">private</span> Integer amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6.</strong> <strong>创建</strong> com&#x2F;hspedu&#x2F;springcloud&#x2F;dao&#x2F;StorageDao.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StorageDao</span> &#123;</span><br><span class="line">    <span class="comment">//扣减库存信息</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(<span class="meta">@Param(&quot;productId&quot;)</span> Long productId, <span class="meta">@Param(&quot;nums&quot;)</span> Integer nums)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7.</strong> <strong>创建</strong> **resources&#x2F;**mapper&#x2F;StorageMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.hspedu.springcloud.dao.StorageDao&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.hspedu.springcloud.entity.Storage&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;product_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;productId&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">property</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 减少库存 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;reduce&quot;</span>&gt;</span></span><br><span class="line">        UPDATE</span><br><span class="line">            storage</span><br><span class="line">        SET</span><br><span class="line">            amount = amount - #&#123;nums&#125;</span><br><span class="line">        WHERE</span><br><span class="line">            product_id = #&#123;productId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>8.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;service&#x2F;StorageService.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line">    <span class="comment">// 扣减库存</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(Long productId, Integer nums)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>9.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;service&#x2F;impl&#x2F;StorageServiceImpl.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StorageServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private static final Logger LOGGER = LoggerFactory.getLogger(StorageServiceImpl.class);</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StorageDao storageDao;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(Long productId, Integer nums)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;==========seata_storage_micro_service-10010 扣 减 库 存 start==========&quot;</span>);</span><br><span class="line">        storageDao.reduce(productId, nums);</span><br><span class="line">        log.info(<span class="string">&quot;==========seata_storage_micro_service-10010 扣 减 库 存 end==========&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>10.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;StorageController.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StorageController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StorageService storageService;</span><br><span class="line">    <span class="comment">//扣减库存</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/storage/reduce&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">reduce</span><span class="params">(Long productId, Integer nums)</span> &#123;</span><br><span class="line">        storageService.reduce(productId, nums);</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;扣减库存成功 ok&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>11.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;config&#x2F;MyBatisConfig.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&#123;&quot;com.hspedu.springcloud.dao&quot;&#125;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>12.</strong> <strong>创建com&#x2F;hspedu&#x2F;springcloud&#x2F;config&#x2F;DataSourceProxyConfig.java ,常规配置(拿来使用即可)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.springcloud.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> io.seata.rm.datasource.DataSourceProxy;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.transaction.SpringManagedTransactionFactory; <span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/7/3</span></span><br><span class="line"><span class="comment"> * 11:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceProxyConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mybatis.mapperLocations&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String mapperLocations;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">druidDataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceProxy <span class="title function_">dataSourceProxy</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProxy</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSourceProxy dataSourceProxy)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>(); sqlSessionFactoryBean.setDataSource(dataSourceProxy);</span><br><span class="line">                sqlSessionFactoryBean.setMapperLocations(<span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>().getResources(mapperLocations));</span><br><span class="line">        sqlSessionFactoryBean.setTransactionFactory(<span class="keyword">new</span> <span class="title class_">SpringManagedTransactionFactory</span>()); <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>13.</strong> <strong>创 建 主 启 动 类</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;SeataStorageMicroServiceApplication10010.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.springcloud;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 浦原</span></span><br><span class="line"><span class="comment"> * 2023/7/3</span></span><br><span class="line"><span class="comment"> * 12:24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeataStorageMicroServiceApplication10010</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SeataStorageMicroServiceApplication10010.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-4-4-测试-seata-storage-micro-service-10010-微服务"><a href="#11-4-4-测试-seata-storage-micro-service-10010-微服务" class="headerlink" title="11.4.4 测试 seata_storage_micro_service-10010 微服务"></a><strong>11.4.4</strong> 测试 <strong>seata_storage_micro_service-10010</strong> 微服务</h3><h4 id="11-4-4-1-启动-Nacos-Server-8848"><a href="#11-4-4-1-启动-Nacos-Server-8848" class="headerlink" title="11.4.4.1 启动 Nacos Server 8848"></a>11.4.4.1 启动 Nacos Server 8848</h4><h4 id="11-4-4-2-双击-Seata-的-bin-seata-server-bat-启动-Seata-Server"><a href="#11-4-4-2-双击-Seata-的-bin-seata-server-bat-启动-Seata-Server" class="headerlink" title="11.4.4.2 双击 Seata 的\bin\seata-server.bat , 启动 Seata Server"></a>11.4.4.2 双击 Seata 的\bin\seata-server.bat , 启动 Seata Server</h4><h4 id="11-4-4-3-启动-seata-storage-micro-service-10010"><a href="#11-4-4-3-启动-seata-storage-micro-service-10010" class="headerlink" title="11.4.4.3 启动 seata_storage_micro_service-10010"></a>11.4.4.3 启动 seata_storage_micro_service-10010</h4><h4 id="11-4-4-4-登录-Nacos-Server-查看-10010-微服务是否注册成功"><a href="#11-4-4-4-登录-Nacos-Server-查看-10010-微服务是否注册成功" class="headerlink" title="11.4.4.4 登录 Nacos Server , 查看 10010 微服务是否注册成功"></a>11.4.4.4 登录 Nacos Server , 查看 10010 微服务是否注册成功</h4><p><strong>1.</strong> 登录 <strong>Nacos Server,</strong> 查看 <strong>10010</strong> 是否注册成功</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703125536604.png" alt="image-20230703125536604"></p><h3 id="11-4-5-开发-seata-account-micro-service-10012-微服务"><a href="#11-4-5-开发-seata-account-micro-service-10012-微服务" class="headerlink" title="11.4.5 开发 seata_account_micro_service-10012 微服务"></a><strong>11.4.5</strong> 开发 <strong>seata_account_micro_service-10012</strong> 微服务</h3><p>(account模块，参照上面storage模块的创建过程即可)</p><p><strong>1.</strong> 参考以前的方式，创建 <strong>seata_account_micro_service-10012</strong> 微服务模块</p><p><strong>2.</strong> <strong>修改</strong> <strong>pom.xml,</strong> <strong>添加相关的</strong> <strong>jar</strong> <strong>依赖</strong></p><p><strong>3.</strong> <strong>创建</strong> <strong>application.yml,</strong> <strong>进行相关的配置</strong></p><p><strong>4.1</strong> <strong>创建</strong> <strong>file.conf,</strong> <strong>进行相关的配置</strong>, <strong>说明:该文件从</strong> <strong>seata</strong> <strong>的</strong>\conf\file.conf <strong>拷贝，进行修 改即可</strong></p><p><strong>4.2</strong> <strong>创建</strong> <strong>registry.conf,</strong> <strong>进行相关的配置</strong>, <strong>说明:该文件从</strong> <strong>seata</strong> <strong>的</strong>\conf\registry.conf <strong>拷贝， 进行修改即可</strong></p><p><strong>5.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;entity&#x2F;Account.java</strong></p><p><strong>6.</strong> <strong>创建</strong> com&#x2F;hspedu&#x2F;springcloud&#x2F;dao&#x2F;AccountDao.java</p><p><strong>7.</strong> <strong>创建</strong> **resources&#x2F;**mapper&#x2F;AccountMapper.xml</p><p><strong>8.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;service&#x2F;AccountService.java</strong></p><p><strong>9.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;service&#x2F;impl&#x2F;AccountServiceImpl.java</strong></p><p><strong>10.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;AccountController.java</strong></p><p><strong>11.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;config&#x2F;MyBatisConfig.java</strong></p><p><strong>12.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;config&#x2F;DataSourceProxyConfig.java ,</strong> <strong>常规配置</strong>(拿来使用即可)</p><p><strong>13.</strong> <strong>创 建 主 启 动 类</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;SeataAccountMicroServiceApplication10012.java</strong></p><h3 id="11-4-6-测试-seata-account-micro-service-10012-微服务"><a href="#11-4-6-测试-seata-account-micro-service-10012-微服务" class="headerlink" title="11.4.6 测试 seata_account_micro_service-10012 微服务"></a><strong>11.4.6</strong> 测试 <strong>seata_account_micro_service-10012</strong> 微服务</h3><h4 id="11-4-6-1-启动-Nacos-Server-8848"><a href="#11-4-6-1-启动-Nacos-Server-8848" class="headerlink" title="11.4.6.1 启动 Nacos Server 8848"></a>11.4.6.1 启动 Nacos Server 8848</h4><h4 id="11-4-6-2-双击-Seata-的-bin-seata-server-bat-启动-Seata-Server"><a href="#11-4-6-2-双击-Seata-的-bin-seata-server-bat-启动-Seata-Server" class="headerlink" title="11.4.6.2 双击 Seata 的\bin\seata-server.bat , 启动 Seata Server"></a>11.4.6.2 双击 Seata 的\bin\seata-server.bat , 启动 Seata Server</h4><h4 id="11-4-6-3-启动-seata-account-micro-service-10012"><a href="#11-4-6-3-启动-seata-account-micro-service-10012" class="headerlink" title="11.4.6.3 启动 seata_account_micro_service-10012"></a>11.4.6.3 启动 seata_account_micro_service-10012</h4><h4 id="11-4-6-4-登录-Nacos-Server-查看-10012-微服务是否注册成功"><a href="#11-4-6-4-登录-Nacos-Server-查看-10012-微服务是否注册成功" class="headerlink" title="11.4.6.4 登录 Nacos Server , 查看 10012 微服务是否注册成功"></a>11.4.6.4 登录 Nacos Server , 查看 10012 微服务是否注册成功</h4><p><strong>1.</strong> 登录 <strong>Nacos Server,</strong> 查看 <strong>10012</strong> 是否注册成功</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703143135194.png" alt="image-20230703143135194"></p><p><strong>11.4.7</strong> 开发 <strong>seata-order-micro-service-10008</strong> 微服务</p><p>(Order模块，参照上面storage模块的创建过程即可)</p><p><strong>1.</strong> 参考以前的方式，创建 <strong>seata-order-micro-service-10008</strong> 微服务模块</p><p><strong>2.</strong> <strong>修改</strong> <strong>pom.xml,</strong> <strong>添加相关的</strong> <strong>jar</strong> <strong>依赖</strong></p><p><strong>3.</strong> <strong>创建</strong> <strong>application.yml,</strong> <strong>进行相关的配置</strong></p><p><strong>4.1</strong> <strong>创建</strong> <strong>file.conf,</strong> <strong>进行相关的配置</strong>, <strong>说明:该文件从</strong> <strong>seata</strong> <strong>的</strong>\conf\file.conf <strong>拷贝，进行修 改即可</strong></p><p><strong>4.2</strong> <strong>创建</strong> <strong>registry.conf,</strong> <strong>进行相关的配置</strong>, <strong>说明:该文件从</strong> <strong>seata</strong> <strong>的</strong>\conf\registry.conf <strong>拷贝， 进行修改即可</strong></p><p><strong>5.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;entity&#x2F;Order.java</strong></p><p><strong>6.</strong> <strong>创建</strong> com&#x2F;hspedu&#x2F;springcloud&#x2F;dao&#x2F;OrderDao.java</p><p><strong>7.</strong> <strong>创建</strong> **resources&#x2F;**mapper&#x2F;OrderMapper.xml</p><p><strong>8.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;service&#x2F;OrderService.java</strong></p><p><strong>9.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;service&#x2F;AccountService.java</strong></p><p><strong>10.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;service&#x2F;impl&#x2F;OrderServiceImpl.java</strong></p><p><strong>11.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;OrderController.java</strong></p><p><strong>12.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;config&#x2F;MyBatisConfig.java</strong></p><p><strong>13.</strong> <strong>创建</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;config&#x2F;DataSourceProxyConfig.java ,</strong> <strong>常规配置</strong>(拿来使用即可)</p><p><strong>14.</strong> <strong>创 建 主 启 动 类</strong> <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;SeataOrderMicroServiceApplication10008.java</strong></p><h3 id="11-4-8-测试-seata-order-micro-service-10008-微服务"><a href="#11-4-8-测试-seata-order-micro-service-10008-微服务" class="headerlink" title="11.4.8 测试 seata-order-micro-service-10008 微服务"></a><strong>11.4.8</strong> 测试 <strong>seata-order-micro-service-10008</strong> 微服务</h3><p>……</p><h3 id="11-4-9-集成测试-1-三个微服务协同完成-正常下单"><a href="#11-4-9-集成测试-1-三个微服务协同完成-正常下单" class="headerlink" title="11.4.9 集成测试**(1)** 三个微服务协同完成**-**正常下单"></a><strong>11.4.9</strong> 集成测试**(1)** 三个微服务协同完成**-**正常下单</h3><h4 id="11-4-9-1-启动-Nacos-Server-8848"><a href="#11-4-9-1-启动-Nacos-Server-8848" class="headerlink" title="11.4.9.1 启动 Nacos Server 8848"></a>11.4.9.1 启动 Nacos Server 8848</h4><h4 id="11-4-9-2-双击-Seata-的-bin-seata-server-bat-启动-Seata-Server"><a href="#11-4-9-2-双击-Seata-的-bin-seata-server-bat-启动-Seata-Server" class="headerlink" title="11.4.9.2 双击 Seata 的\bin\seata-server.bat , 启动 Seata Server"></a>11.4.9.2 双击 Seata 的\bin\seata-server.bat , 启动 Seata Server</h4><h4 id="11-4-9-3-启动-seata-order-micro-service-10010-x2F-10012-x2F-10008-三个微服务"><a href="#11-4-9-3-启动-seata-order-micro-service-10010-x2F-10012-x2F-10008-三个微服务" class="headerlink" title="11.4.9.3 启动 seata-order-micro-service-10010 &#x2F;10012&#x2F;10008 三个微服务"></a>11.4.9.3 启动 seata-order-micro-service-10010 &#x2F;10012&#x2F;10008 三个微服务</h4><h4 id="11-4-9-4-浏览器-http-localhost-10008-order-save-userId-666-amp-productId-1-amp-nums-1-amp-money-100"><a href="#11-4-9-4-浏览器-http-localhost-10008-order-save-userId-666-amp-productId-1-amp-nums-1-amp-money-100" class="headerlink" title="11.4.9.4 浏览器 : http://localhost:10008/order/save?userId=666&amp;productId=1&amp;nums=1&amp;money=100"></a>11.4.9.4 浏览器 : <a href="http://localhost:10008/order/save?userId=666&productId=1&nums=1&money=100">http://localhost:10008/order/save?userId=666&amp;productId=1&amp;nums=1&amp;money=100</a></h4><p><strong>1.</strong> 浏 览 器 <strong>: <a href="http://localhost:10008/order/save?userId=666&productId=1&nums=1&money=100">http://localhost:10008/order/save?userId=666&amp;productId=1&amp;nums=1&amp;money=100</a></strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703143712667.png" alt="image-20230703143712667"></p><p><strong>2.</strong> <strong>查看数据库&#x2F;表的情况是否正常,结论:如果没有异常出现，正常下单，数据库三张表 数据一致性是OK的</strong></p><h4 id="11-4-9-5-注意事项和细节"><a href="#11-4-9-5-注意事项和细节" class="headerlink" title="11.4.9.5 注意事项和细节"></a>11.4.9.5 注意事项和细节</h4><p><strong>1. MySQL</strong> 出现 <strong>too many connections</strong>(<strong>1040</strong>)错误解决方法：</p><p>在 <strong>my.ini</strong> 设置 </p><p><strong>max_connections&#x3D;1000</strong></p><p><strong>2.</strong> 如果出现**: service id not legal hostname<br>** 报错 <strong>Service id not legal hostname</strong> 的原因是服务名称不能带有下划线，可以使用中划线**,**</p><p><strong>springcloud</strong> 无法识别下划线，把下划线改成中划线就好</p><h3 id="11-4-10-集成测试-2-三个微服务协同完成-模拟异常"><a href="#11-4-10-集成测试-2-三个微服务协同完成-模拟异常" class="headerlink" title="11.4.10 集成测试**(2)** 三个微服务协同完成**-**模拟异常"></a><strong>11.4.10</strong> 集成测试**(2)** 三个微服务协同完成**-**模拟异常</h3><h4 id="11-4-10-1-启动-Nacos-Server-8848"><a href="#11-4-10-1-启动-Nacos-Server-8848" class="headerlink" title="11.4.10.1 启动 Nacos Server 8848"></a>11.4.10.1 启动 Nacos Server 8848</h4><h4 id="11-4-10-2-双击-Seata-的-bin-seata-server-bat-启动-Seata-Server"><a href="#11-4-10-2-双击-Seata-的-bin-seata-server-bat-启动-Seata-Server" class="headerlink" title="11.4.10.2 双击 Seata 的\bin\seata-server.bat , 启动 Seata Server"></a>11.4.10.2 双击 Seata 的\bin\seata-server.bat , 启动 Seata Server</h4><h4 id="11-4-10-3-启动-seata-order-micro-service-100010-x2F-10012-x2F-10008-三个微服务"><a href="#11-4-10-3-启动-seata-order-micro-service-100010-x2F-10012-x2F-10008-三个微服务" class="headerlink" title="11.4.10.3 启动 seata-order-micro-service-100010 &#x2F;10012&#x2F;10008 三个微服务"></a>11.4.10.3 启动 seata-order-micro-service-100010 &#x2F;10012&#x2F;10008 三个微服务</h4><h4 id="11-4-10-4-浏览器-http-localhost-10008-order-save-userId-666-amp-productId-1-amp-nums-1-amp-money-100"><a href="#11-4-10-4-浏览器-http-localhost-10008-order-save-userId-666-amp-productId-1-amp-nums-1-amp-money-100" class="headerlink" title="11.4.10.4 浏览器 : http://localhost:10008/order/save?userId=666&amp;productId=1&amp;nums=1&amp;money=100"></a>11.4.10.4 浏览器 : <a href="http://localhost:10008/order/save?userId=666&productId=1&nums=1&money=100">http://localhost:10008/order/save?userId=666&amp;productId=1&amp;nums=1&amp;money=100</a></h4><p><strong>1.</strong> 修 改 <strong>seata_account_micro_service-10012</strong> 的<strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;AccountController.java</strong>， 模拟异常出现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/account/reduce&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">result</span><span class="params">(<span class="meta">@RequestParam(&quot;userId&quot;)</span> Long userId, <span class="meta">@RequestParam(&quot;money&quot;)</span> Integer money)</span>&#123;</span><br><span class="line"><span class="comment">//模拟异常, 超时</span></span><br><span class="line"><span class="comment">//openfeign 接口调用默认超时时间为 1s try &#123;</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">12</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace(); &#125;</span><br><span class="line">accountService.reduce(userId,money);</span><br><span class="line"><span class="keyword">return</span> Result.success(<span class="string">&quot;200&quot;</span>, <span class="string">&quot;扣减账户余额 OK&quot;</span>); &#125;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> <strong>浏 览 器</strong> <strong>: <a href="http://localhost:10008/order/save?userId=666&productId=1&nums=1&money=100">http://localhost:10008/order/save?userId=666&amp;productId=1&amp;nums=1&amp;money=100</a></strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703143951841.png" alt="image-20230703143951841"></p><p><strong>3.</strong> <strong>查看数据库&#x2F;表的情况是否正常</strong></p><p><strong>结论</strong>:这时数据库&#x2F;表，出现数据不一致现象, 订单是<u>未支付</u>，但是<u>库存减少了</u>，账号<u>钱也扣了</u>(提示:等休眠时间完成后，再查看account表，会看到数据不一致)</p><h3 id="11-4-11-集成测试-3-三个微服务协同完成-使用-GlobalTransactional-完成分布式事务控制-出现异常，也能保证数据一致性"><a href="#11-4-11-集成测试-3-三个微服务协同完成-使用-GlobalTransactional-完成分布式事务控制-出现异常，也能保证数据一致性" class="headerlink" title="11.4.11 集成测试**(3)** 三个微服务协同完成**-使用@GlobalTransactional** 完成分布式事务控制(出现异常，也能保证数据一致性)"></a><strong>11.4.11</strong> 集成测试**(3)** 三个微服务协同完成**-<strong>使用</strong>@GlobalTransactional** 完成分布式事务控制(出现异常，也能保证数据一致性)</h3><h4 id="11-4-11-1-启动-Nacos-Server-8848"><a href="#11-4-11-1-启动-Nacos-Server-8848" class="headerlink" title="11.4.11.1 启动 Nacos Server 8848"></a>11.4.11.1 启动 Nacos Server 8848</h4><h4 id="11-4-11-2-双击-Seata-的-bin-seata-server-bat-启动-Seata-Server"><a href="#11-4-11-2-双击-Seata-的-bin-seata-server-bat-启动-Seata-Server" class="headerlink" title="11.4.11.2 双击 Seata 的\bin\seata-server.bat , 启动 Seata Server"></a>11.4.11.2 双击 Seata 的\bin\seata-server.bat , 启动 Seata Server</h4><h4 id="11-4-11-3-启动-seata-order-micro-service-10008-x2F-10010-x2F-10012-三个微服务"><a href="#11-4-11-3-启动-seata-order-micro-service-10008-x2F-10010-x2F-10012-三个微服务" class="headerlink" title="11.4.11.3 启动 seata-order-micro-service-10008 &#x2F;10010&#x2F;10012 三个微服务"></a>11.4.11.3 启动 seata-order-micro-service-10008 &#x2F;10010&#x2F;10012 三个微服务</h4><h4 id="11-4-11-4-浏览器-http-localhost-10008-order-save-userId-666-amp-productId-1-amp-nums-1-amp-money-100"><a href="#11-4-11-4-浏览器-http-localhost-10008-order-save-userId-666-amp-productId-1-amp-nums-1-amp-money-100" class="headerlink" title="11.4.11.4 浏览器 : http://localhost:10008/order/save?userId=666&amp;productId=1&amp;nums=1&amp;money=100"></a>11.4.11.4 浏览器 : <a href="http://localhost:10008/order/save?userId=666&productId=1&nums=1&money=100">http://localhost:10008/order/save?userId=666&amp;productId=1&amp;nums=1&amp;money=100</a></h4><p><strong>1.</strong> 修 改 <strong>seata_account_micro_service-10012</strong> 的 <strong>com&#x2F;hspedu&#x2F;springcloud&#x2F;controller&#x2F;AccountController.java</strong>， 模拟异常出现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">AccountService accountService; </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 扣减账户余额</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/account/reduce&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">result</span><span class="params">(<span class="meta">@RequestParam(&quot;userId&quot;)</span> Long userId, <span class="meta">@RequestParam(&quot;money&quot;)</span> Integer money)</span>&#123;</span><br><span class="line"><span class="comment">//模拟异常, 超时，或者 int i = 9 / 0; </span></span><br><span class="line">  <span class="comment">//openfeign 接口调用默认超时时间为 1s</span></span><br><span class="line">  <span class="comment">//说明 1. 也可以使用其它方式模拟异常, 但在 Debug 看 Seata 分布式事务机制不方便, 不好看效果 , 所以这里我们使用超时异常</span></span><br><span class="line"><span class="comment">//说明 2. 因为是超时异常, 所以在 Debug 分析 Seata 机制时, 可能会发现某张表 被锁几条记录, 因为 seata 会做最终一致性操作(即尝试再提交上次超时的事务).</span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">12</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">accountService.reduce(userId,money);</span><br><span class="line"><span class="keyword">return</span> Result.success(<span class="string">&quot;200&quot;</span>, <span class="string">&quot;扣减账户余额 OK&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**2.**修 改 <strong>seata-order-micro-service-10008</strong> <strong>的</strong>com&#x2F;study&#x2F;springcloud&#x2F;service&#x2F;impl&#x2F;OrderServicelmpl.java</p><p><strong>使用<u>@GlobalTransactional</u>控制分布式事务，保证数据一致性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建订单-&gt;调用库存服务扣减库存-&gt;调用账户服务扣减账户余额-&gt;修改订单状态 </span></span><br><span class="line"><span class="comment">* 解读</span></span><br><span class="line"><span class="comment">* 1. <span class="doctag">@GlobalTransactional</span>: 分布式全局事务控制</span></span><br><span class="line"><span class="comment">* 2. name = &quot;hspedu-save-order&quot; 名称自己写，保证唯一即可</span></span><br><span class="line"><span class="comment">* 3. rollbackFor = Exception.class 指定发生什么异常就回滚，</span></span><br><span class="line"><span class="comment">* 这里指定只要发生异常就回滚</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">//下面这句话是做全局事务控制的, 如果没有，则没有分布式全局事务控制 </span></span><br><span class="line"><span class="meta">@GlobalTransactional(name = &quot;hspedu-save-order&quot;, rollbackFor = Exception.class)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">log.info(<span class="string">&quot;=========开始新建订单 start ==========&quot;</span>); </span><br><span class="line">  <span class="comment">//新建订单</span></span><br><span class="line">orderDao.save(order);</span><br><span class="line">System.out.println(<span class="string">&quot;order=&quot;</span> + order); </span><br><span class="line">  log.info(<span class="string">&quot;=========减库存 start ==========&quot;</span>); </span><br><span class="line">  storageService.reduce(order.getProductId(), order.getNums()); </span><br><span class="line">  log.info(<span class="string">&quot;=========减库存 end ==========&quot;</span>);</span><br><span class="line">log.info(<span class="string">&quot;=========减账户金额 start ==========&quot;</span>); </span><br><span class="line">  accountService.reduce(order.getUserId(), order.getMoney()); </span><br><span class="line">  log.info(<span class="string">&quot;=========减账户金额 end ==========&quot;</span>);</span><br><span class="line">log.info(<span class="string">&quot;=========修改订单状态 start ==========&quot;</span>); </span><br><span class="line">  orderDao.update(order.getUserId(), <span class="number">0</span>); </span><br><span class="line">  log.info(<span class="string">&quot;=========修改订单状态 end ==========&quot;</span>); </span><br><span class="line">  log.info(<span class="string">&quot;=========下订单 end==========&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3.</strong> <strong>重启</strong> <strong>seata-order-micro-service-10008</strong></p><p><strong>4.</strong> <strong>浏 览 器</strong> <strong>: <a href="http://localhost:10008/order/save?userId=666&productId=1&nums=1&money=100">http://localhost:10008/order/save?userId=666&amp;productId=1&amp;nums=1&amp;money=100</a></strong></p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230703143951841.png" alt="image-20230703143951841"></p><p><strong>5.</strong> 查看数据库&#x2F;表的情况是否正常, 结论:这时数据库&#x2F;表，数据不一致性得到保证.</p><h3 id="11-4-12-注意事项和细节"><a href="#11-4-12-注意事项和细节" class="headerlink" title="11.4.12 注意事项和细节"></a><strong>11.4.12</strong> 注意事项和细节</h3><h4 id="11-4-12-1-如果数据库-x2F-表使用到关键字，需要使用反引号"><a href="#11-4-12-1-如果数据库-x2F-表使用到关键字，需要使用反引号" class="headerlink" title="11.4.12.1 如果数据库&#x2F;表使用到关键字，需要使用反引号"></a>11.4.12.1 如果数据库&#x2F;表使用到关键字，需要使用反引号</h4><ul><li>举例说明**:** 比如<strong>mapper&#x2F;OrderMapper.xml ,</strong> 这里的 <strong>order</strong> 就要使用**&#96;&#96;,** 否则会报错</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;save&quot;</span>&gt;</span></span><br><span class="line">insert into `order` (id,user_id,product_id,nums,money,status) </span><br><span class="line">  values (null,#&#123;userId&#125;,#&#123;productId&#125;,#&#123;nums&#125;,#&#123;money&#125;,0);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">update `order` set status = 1</span><br><span class="line">where user_id=#&#123;userId&#125; and status = #&#123;status&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="11-4-12-2-openfeign在远程调用api接口时，默认超时时间为1s"><a href="#11-4-12-2-openfeign在远程调用api接口时，默认超时时间为1s" class="headerlink" title="11.4.12.2 openfeign在远程调用api接口时，默认超时时间为1s"></a>11.4.12.2 openfeign在远程调用api接口时，默认超时时间为1s</h4>]]></content>
      
      
      <categories>
          
          <category> Spring开发框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 写文章步骤</title>
      <link href="/2023/06/02/hexo-%E5%86%99%E6%96%87%E7%AB%A0%E6%AD%A5%E9%AA%A4/"/>
      <url>/2023/06/02/hexo-%E5%86%99%E6%96%87%E7%AB%A0%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo搭建博客配置注意事项："><a href="#hexo搭建博客配置注意事项：" class="headerlink" title="hexo搭建博客配置注意事项："></a>hexo搭建博客配置注意事项：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对文件夹进行配置</span></span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建新文章</span></span><br><span class="line">hexo <span class="keyword">new</span> <span class="string">&quot;文章名称&quot;</span></span><br><span class="line">hexo n <span class="string">&quot;文章名称&quot;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//清理hexo缓存</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新生成博客的静态文件</span></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line"><span class="comment">//本地运行博客若无法运行需要安装依赖：npm install hexo-server --save</span></span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line"><span class="comment">//部署博客到github仓库</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>在blog的package.json中修改：</p><p>“server”: “hexo server” 👉 “server”: “hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server”</p><p>此后 执行npm run server &#x3D; 同时执行以上三个命令</p><h2 id="博客配置注意事项："><a href="#博客配置注意事项：" class="headerlink" title="博客配置注意事项："></a>博客配置注意事项：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文章头部：</span><br><span class="line">title: 文章标题</span><br><span class="line">date: 2023-06-02 12:04:52</span><br><span class="line">tags: 博客创建</span><br><span class="line">categories: 博客创建</span><br><span class="line">cover: https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">title【必需】文章标题</span><br><span class="line">date【必需】文章创建日期</span><br><span class="line">updated【可选】文章更新日期</span><br><span class="line">tags【可选】文章标签</span><br><span class="line">categories【可选】文章分类</span><br><span class="line">keywords【可选】文章关键字</span><br><span class="line">description【可选】文章描述</span><br><span class="line">top_img【可选】文章顶部图片</span><br><span class="line">cover【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)</span><br><span class="line">comments【可选】显示文章评论模块(默认 true)</span><br><span class="line">toc【可选】显示文章TOC(默认为设置中toc的enable配置)</span><br><span class="line">toc_number【可选】显示toc_number(默认为设置中toc的number配置)</span><br><span class="line">toc_style_simple【可选】显示 toc 简洁模式</span><br><span class="line">copyright【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)</span><br><span class="line">copyright_author【可选】文章版权模块的文章作者</span><br><span class="line">copyright_author_href【可选】文章版权模块的文章作者链接</span><br><span class="line">copyright_url【可选】文章版权模块的文章连结链接</span><br><span class="line">copyright_info【可选】文章版权模块的版权声明文字</span><br><span class="line">mathjax【可选】显示mathjax(当设置 mathjax 的 per_page: false 时，才需要配置，默认 false )</span><br><span class="line">katex【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false )</span><br><span class="line">aplayer【可选】在需要的页面加载 aplayer 的 js 和 css,请参考文章下面的音乐 配置</span><br><span class="line">highlight_shrink【可选】配置代码框是否展开(true/false)(默认为设置中 highlight_shrink 的配置)</span><br><span class="line">aside【可选】显示侧边栏 (默认 true)</span><br><span class="line">abcjs【可选】加载 abcjs (当设置 abcjs 的 per_page: false 时，才需要配置，默认 false )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者: Jerry</span><br><span class="line">連結: https://butterfly.js.org/posts/dc584b87/#Post-Front-matter</span><br><span class="line">來源: Butterfly</span><br><span class="line">著作權歸作者所有。商業轉載請聯絡作者獲得授權，非商業轉載請註明出處。</span><br></pre></td></tr></table></figure><h2 id="对博客进行git版本控制："><a href="#对博客进行git版本控制：" class="headerlink" title="对博客进行git版本控制："></a>对博客进行git版本控制：</h2><p>将本地blog文件夹推送到仓库</p><p>当需要重新拉取blog文件夹时，只需要：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//进入想要放置blog的终端</span><br><span class="line">git clone 仓库链接</span><br><span class="line">//安装依赖</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>将本地代码更新到仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在blog目录下中端执行：</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;commit的名称(个人习惯：20230604commit01)&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h2 id="hexo-写文章步骤："><a href="#hexo-写文章步骤：" class="headerlink" title="hexo 写文章步骤："></a>hexo 写文章步骤：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">donn@Macc blog % hexo new &quot;算法小结&quot;</span><br><span class="line"></span><br><span class="line">INFO Validating config</span><br><span class="line"></span><br><span class="line">INFO Created: /opt/blog/source/_posts/算法小结.md</span><br></pre></td></tr></table></figure><ol><li><p>hexo new “文章名称”</p></li><li><p>在对应文件中写内容</p></li><li><p>完成部署：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g -c</span><br><span class="line">hexo s</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li></ol><p>🌟push到github仓库时出现超时报错的解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://github.com/Tangjiayang/Tangjiayang.github.io.git/&#x27;: Failed to connect to github.com port 443 after 75012 ms: Couldn&#x27;t connect to server</span><br><span class="line">FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: Spawn failed</span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (/opt/blog/node_modules/hexo-util/lib/spawn.js:51:21)</span><br><span class="line">    at ChildProcess.emit (node:events:511:28)</span><br><span class="line">    at ChildProcess._handle.onexit (node:internal/child_process:293:12)</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">取消全局代理：</span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果还不能解决：</span><br><span class="line">尝试刷新DNS缓存</span><br><span class="line">mac用户刷新DNS缓存指令：</span><br><span class="line">sudo killall -HUP mDNSResponder</span><br><span class="line">刷新后就可以啦～</span><br></pre></td></tr></table></figure><p>文章操作：</p><p>​文章置顶：</p><p>​添加配置      sticky: 1</p><h3 id="使用picgo-github搭建免费个人图床！"><a href="#使用picgo-github搭建免费个人图床！" class="headerlink" title="使用picgo+github搭建免费个人图床！"></a>使用picgo+github搭建免费个人图床！</h3><p>git使用：<a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></p><p><a href="https://blog.csdn.net/Jimmy_wei_2010/article/details/130268408">https://blog.csdn.net/Jimmy_wei_2010/article/details/130268408</a></p><p><a href="https://blog.csdn.net/qq_41982020/article/details/121437344">https://blog.csdn.net/qq_41982020/article/details/121437344</a></p><p>有关sshkey： <a href="https://blog.csdn.net/D_Ray_/article/details/120240909">https://blog.csdn.net/D_Ray_/article/details/120240909</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客创建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-Plus</title>
      <link href="/2023/06/02/MyBatis-Plus/"/>
      <url>/2023/06/02/MyBatis-Plus/</url>
      
        <content type="html"><![CDATA[<h1 id="一、MyBatis-Plus"><a href="#一、MyBatis-Plus" class="headerlink" title="一、MyBatis-Plus"></a>一、MyBatis-Plus</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus (opens new window)</a>（简称 MP）是一个 <a href="https://www.mybatis.org/mybatis-3/">MyBatis (opens new window)</a>的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><blockquote><p>我们的愿景是成为 MyBatis 最好的搭档，就像 <a href="https://baomidou.com/img/contra.jpg">魂斗罗</a> 中的 1P、2P，基友搭配，效率翻倍。</p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/relationship-with-mybatis.png" alt="img"></p><h2 id="2-特性"><a href="#2-特性" class="headerlink" title="2.特性"></a>2.特性</h2><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h2 id="3-支持数据库"><a href="#3-支持数据库" class="headerlink" title="3.支持数据库"></a>3.支持数据库</h2><blockquote><p>任何能使用 <code>MyBatis</code> 进行 CRUD, 并且支持标准 SQL 的数据库，具体支持情况如下，如果不在下列表查看分页部分教程 PR 您的支持。</p></blockquote><ul><li>MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb</li><li>达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库</li></ul><h2 id="4-框架结构"><a href="#4-框架结构" class="headerlink" title="4.框架结构"></a>4.框架结构</h2><p>![image-20230517103049072](&#x2F;Users&#x2F;donn&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230517103049072.png)</p><h2 id="5-官方地址"><a href="#5-官方地址" class="headerlink" title="5.官方地址"></a>5.官方地址</h2><blockquote><p><strong>官方网站：</strong><a href="https://baomidou.com/">https://baomidou.com/</a></p><p><strong>官方文档：</strong><a href="https://baomidou.com/pages/24112f/">https://baomidou.com/pages/24112f/</a></p></blockquote><h1 id="二、入门案例"><a href="#二、入门案例" class="headerlink" title="二、入门案例"></a>二、入门案例</h1><h2 id="1-开发环境"><a href="#1-开发环境" class="headerlink" title="1.开发环境"></a>1.开发环境</h2><ul><li><strong>IDE：IDEA 2019.3.5</strong></li><li><strong>JDK：JDK8+</strong></li><li><strong>构建工具：Maven 3.5.4</strong></li><li><strong>MySQL：MySQL 8.0.24</strong></li><li><strong>Navicat：Navicat Premium 15</strong></li><li><strong>Spring Boot：2.6.7</strong></li><li><strong>MyBatis-Plus：3.5.1</strong></li></ul><h2 id="2-建库建表"><a href="#2-建库建表" class="headerlink" title="2.建库建表"></a>2.建库建表</h2><ul><li><p><strong>打开Navicat运行以下SQL脚本进行建库建表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `mybatis_plus` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 */</span>; </span><br><span class="line">use `mybatis_plus`; </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` ( </span><br><span class="line">    `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>, </span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>, </span><br><span class="line">    `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>, </span><br><span class="line">    `email` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>, </span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`) </span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure></li><li><p><strong>插入几条测试数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (id, name, age, email) <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Jone&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;test1@baomidou.com&#x27;</span>), </span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;test2@baomidou.com&#x27;</span>), </span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;test3@baomidou.com&#x27;</span>), </span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;Sandy&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;test4@baomidou.com&#x27;</span>), </span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;Billie&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;test5@baomidou.com&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-创建工程"><a href="#3-创建工程" class="headerlink" title="3.创建工程"></a>3.创建工程</h2><ul><li><p><strong>使用<code>Spring Initializer</code>快速初始化一个 Spring Boot 工程</strong></p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519140839640.png" alt="image-20220519140839640" style="zoom:80%;" /><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519141335981.png" alt="image-20220519141335981" style="zoom:80%;" /><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519141737405.png" alt="image-20220519141737405" style="zoom:80%;" /><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519141849937.png" alt="image-20220519141849937" style="zoom:80%;" /></li><li><p><strong>引入<code>MyBatis-Plus</code>的依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">其他相关依赖：</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>安装<code>Lombok</code>插件</strong></p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519143257305.png" alt="image-20220519143257305" style="zoom:80%;" /></li></ul><h2 id="4-配置编码"><a href="#4-配置编码" class="headerlink" title="4.配置编码"></a>4.配置编码</h2><ul><li><p><strong>配置<code>application.yml</code>文件</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#配置数据源</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment">#配置数据源类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="comment">#配置连接数据库的信息</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> &#123;<span class="string">username</span>&#125;</span><br><span class="line">    <span class="attr">password:</span> &#123;<span class="string">password</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#MyBatis-Plus相关配置</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment">#配置日志</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure></li><li><p><strong>在 Spring Boot 启动类中添加 <code>@MapperScan</code> 注解，扫描 Mapper 文件夹</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;指定Mapper接口所在的包&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusDemoApplication</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(MybatisPlusDemoApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>编写实体类 <code>User.java</code>（此处使用了 Lombok 简化代码）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>编写 Mapper 包下的 <code>UserMapper</code>接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-测试查询"><a href="#5-测试查询" class="headerlink" title="5.测试查询"></a>5.测试查询</h2><ul><li><p><strong>编写一个测试类<code>MyBatisPlusTest.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusTest</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试查询所有数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSelectList</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//通过条件构造器查询一个list集合，若没有条件，则可以设置null为参数</span></span><br><span class="line">        List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>控制台打印查询结果</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220519150454211.png" alt="image-20220519150454211"></p></li></ul><h1 id="三、增删改查"><a href="#三、增删改查" class="headerlink" title="三、增删改查"></a>三、增删改查</h1><h2 id="1-BaseMapper-lt-T-gt"><a href="#1-BaseMapper-lt-T-gt" class="headerlink" title="1.BaseMapper&lt;T&gt;"></a>1.BaseMapper&lt;T&gt;</h2><blockquote><p>说明:</p><ul><li>通用 CRUD 封装BaseMapper 接口，为 <code>Mybatis-Plus</code> 启动时自动解析实体表关系映射转换为 <code>Mybatis</code> 内部对象注入容器</li><li>泛型 <code>T</code> 为任意实体对象</li><li>参数 <code>Serializable</code> 为任意类型主键 <code>Mybatis-Plus</code> 不推荐使用复合主键约定每一张表都有自己的唯一 <code>id</code> 主键</li><li>对象 <code>Wrapper</code> 为条件构造器</li></ul></blockquote><p>MyBatis-Plus中的基本CRUD在内置的BaseMapper中都已得到了实现，因此我们继承该接口以后可以直接使用。</p><p>本次演示的CRUD操作不包含参数带有条件构造器的方法，关于条件构造器将单独在一个章节进行演示。</p><hr><blockquote><p><strong>BaseMapper中提供的CRUD方法：</strong></p></blockquote><ul><li><p><strong>增加：Insert</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入一条记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(T entity)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>删除：Delete</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; wrapper)</span>;</span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>修改：Update</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T updateEntity, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; whereWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 修改</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateById</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T entity)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>查询：Selete</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">selectById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 entity 条件，查询一条记录</span></span><br><span class="line">T <span class="title function_">selectOne</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMaps</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">selectObjs</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录（并翻页）</span></span><br><span class="line">IPage&lt;T&gt; <span class="title function_">selectPage</span><span class="params">(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录（并翻页）</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMapsPage</span><span class="params">(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line">Integer <span class="title function_">selectCount</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-调用Mapper层实现CRUD"><a href="#2-调用Mapper层实现CRUD" class="headerlink" title="2.调用Mapper层实现CRUD"></a>2.调用Mapper层实现CRUD</h2><h3 id="2-1插入"><a href="#2-1插入" class="headerlink" title="2.1插入"></a>2.1插入</h3><hr><blockquote><p><strong>最终执行的结果，所获取的id为1527206783590903810</strong></p><p><strong>这是因为MyBatis-Plus在实现插入数据时，会默认基于雪花算法的策略生成id</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试插入一条数据</span></span><br><span class="line"><span class="comment">  * MyBatis-Plus在实现插入数据时，会默认基于雪花算法的策略生成id</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;Vz&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">21</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;vz@oz6.cn&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insert(user);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;添加成功！&quot;</span> : <span class="string">&quot;添加失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">    <span class="comment">//1527206783590903810（当前 id 为雪花算法自动生成的id）</span></span><br><span class="line">    System.out.println(<span class="string">&quot;id自动获取&quot;</span> + user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2删除"><a href="#2-2删除" class="headerlink" title="2.2删除"></a>2.2删除</h3><hr><h4 id="a、根据ID删除数据"><a href="#a、根据ID删除数据" class="headerlink" title="a、根据ID删除数据"></a>a、根据ID删除数据</h4><blockquote><p><strong>调用方法：int deleteById(Serializable id);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试根据id删除一条数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteById</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteById(<span class="number">1527206783590903810L</span>);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;删除成功！&quot;</span> : <span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="b、根据ID批量删除数据"><a href="#b、根据ID批量删除数据" class="headerlink" title="b、根据ID批量删除数据"></a>b、根据ID批量删除数据</h4><blockquote><p><strong>调用方法：int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试通过id批量删除数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteBatchIds</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Long&gt; ids = Arrays.asList(<span class="number">6L</span>,<span class="number">7L</span>,<span class="number">8L</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteBatchIds(ids);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;删除成功！&quot;</span> : <span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="c、根据Map条件删除数据"><a href="#c、根据Map条件删除数据" class="headerlink" title="c、根据Map条件删除数据"></a>c、根据Map条件删除数据</h4><blockquote><p><strong>调用方法：int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 测试根据Map集合中所设置的条件删除数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteByMap</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//当前演示为根据name和age删除数据</span></span><br><span class="line">    <span class="comment">//执行SQL为：DELETE FROM user WHERE name = ? AND age = ?</span></span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Vz&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>,<span class="number">21</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteByMap(map);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;删除成功！&quot;</span> : <span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3修改"><a href="#2-3修改" class="headerlink" title="2.3修改"></a>2.3修改</h3><blockquote><p><strong>调用方法：int updateById(@Param(Constants.ENTITY) T entity);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试根据id修改用户信息</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateById</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//执行SQL为： UPDATE user SET name=?, age=?, email=? WHERE id=?</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setId(<span class="number">6L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;VzUpdate&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;Vz@sina.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.updateById(user);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;修改成功！&quot;</span> : <span class="string">&quot;修改失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4查询"><a href="#2-4查询" class="headerlink" title="2.4查询"></a>2.4查询</h3><hr><h4 id="a、根据ID查询用户信息"><a href="#a、根据ID查询用户信息" class="headerlink" title="a、根据ID查询用户信息"></a>a、根据ID查询用户信息</h4><blockquote><p><strong>调用方法：T selectById(Serializable id);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试根据id查询用户数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectById</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="b、根据多个ID查询多个用户信息"><a href="#b、根据多个ID查询多个用户信息" class="headerlink" title="b、根据多个ID查询多个用户信息"></a>b、根据多个ID查询多个用户信息</h4><blockquote><p><strong>调用方法：List<T> selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 根据多个id查询用户数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectBatchIds</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//执行SQL为：SELECT id,name,age,email FROM user WHERE id IN ( ? , ? , ? )</span></span><br><span class="line">    List&lt;Long&gt; ids = Arrays.asList(<span class="number">1L</span>,<span class="number">2L</span>,<span class="number">3L</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectBatchIds(ids);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="c、根据Map条件查询用户信息"><a href="#c、根据Map条件查询用户信息" class="headerlink" title="c、根据Map条件查询用户信息"></a>c、根据Map条件查询用户信息</h4><blockquote><p><strong>调用方法：List<T> selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 根据Map所设置的条件查询用户</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByMap</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//执行SQL为：SELECT id,name,age,email FROM user WHERE age = ?</span></span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectByMap(map);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="d、查询所有用户信息"><a href="#d、查询所有用户信息" class="headerlink" title="d、查询所有用户信息"></a>d、查询所有用户信息</h4><blockquote><p><strong>调用方法：List<T> selectList(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试查询所有数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSelectList</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-通用Service"><a href="#3-通用Service" class="headerlink" title="3.通用Service"></a>3.通用Service</h2><blockquote><p>说明:</p><ul><li>通用 Service CRUD 封装<code>IService</code>接口，进一步封装 CRUD 采用 <code>get 查询单行</code> <code>remove 删除</code> <code>list 查询集合</code> <code>page 分页</code> 前缀命名方式区分 <code>Mapper</code> 层避免混淆，</li><li>泛型 <code>T</code> 为任意实体对象</li><li>建议如果存在自定义通用 Service 方法的可能，请创建自己的 <code>IBaseService</code> 继承 <code>Mybatis-Plus</code> 提供的基类</li><li>对象 <code>Wrapper</code> 为 条件构造器</li></ul></blockquote><p>MyBatis-Plus中有一个接口 **<code>IService</code>**和其实现类 **<code>ServiceImpl</code>**，封装了常见的业务层逻辑，详情查看源码IService和ServiceImpl</p><p>因此我们在使用的时候仅需在自己定义的**<code>Service</code><strong>接口中继承</strong><code>IService</code><strong>接口，在自己的实现类中实现自己的Service并继承</strong><code>ServiceImpl</code>**即可</p><hr><blockquote><p><strong>IService中的CRUD方法</strong></p></blockquote><ul><li><p><strong>增加：Save、SaveOrUpdate</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入一条记录（选择字段，策略插入）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">save</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TableId 注解存在更新记录，否插入一条记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>删除：Remove</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>修改：Update</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 UpdateWrapper 条件，更新记录 需要设置sqlset</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(T updateEntity, Wrapper&lt;T&gt; whereWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 选择修改</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateById</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>查询：Get、List、Count</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">getById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, <span class="type">boolean</span> throwEx)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getMap</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">&lt;V&gt; V <span class="title function_">getObj</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">list</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line">Collection&lt;T&gt; <span class="title function_">listByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line">Collection&lt;T&gt; <span class="title function_">listByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 查询所有列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line">&lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">&lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询总记录数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>分页：Page</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">getById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, <span class="type">boolean</span> throwEx)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getMap</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">&lt;V&gt; V <span class="title function_">getObj</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-调用Service层操作数据"><a href="#4-调用Service层操作数据" class="headerlink" title="4.调用Service层操作数据"></a>4.调用Service层操作数据</h2><blockquote><p>我们在自己的Service接口中通过继承MyBatis-Plus提供的IService接口，不仅可以获得其提供的CRUD方法，而且还可以使用自身定义的方法。</p></blockquote><ul><li><p><strong>创建<code>UserService</code>并继承<code>IService</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * UserService继承IService模板提供的基础功能 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建<code>UserService</code>的实现类并继承<code>ServiceImpl</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * ServiceImpl实现了IService，提供了IService中基础功能的实现 </span></span><br><span class="line"><span class="comment">  * 若ServiceImpl无法满足业务需求，则可以使用自定的UserService定义方法，并在实现类中实现</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper,User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>测试查询记录数</strong></p><blockquote><p><strong>调用方法：int count();</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//查询总记录数</span></span><br><span class="line">    <span class="comment">//执行的SQL为：SELECT COUNT( * ) FROM user</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> userService.count();</span><br><span class="line">    System.out.println(<span class="string">&quot;总记录数：&quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>测试批量插入数据</strong></p><blockquote><p><strong>调用方法：boolean saveBatch(Collection<T> entityList);</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;Vz&quot;</span>+i);</span><br><span class="line">        user.setAge(<span class="number">20</span>+i);</span><br><span class="line">        list.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> userService.saveBatch(list);</span><br><span class="line">    System.out.println(b ? <span class="string">&quot;添加成功！&quot;</span> : <span class="string">&quot;添加失败！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="四、常用注解"><a href="#四、常用注解" class="headerlink" title="四、常用注解"></a>四、常用注解</h1><blockquote><p>MyBatis-Plus提供的注解可以帮我们解决一些数据库与实体之间相互映射的问题。</p></blockquote><h2 id="1-TableName"><a href="#1-TableName" class="headerlink" title="1.@TableName"></a>1.@TableName</h2><blockquote><p>经过以上的测试，在使用MyBatis-Plus实现基本的CRUD时，我们并没有指定要操作的表，只是在Mapper接口继承BaseMapper时，设置了泛型User，而操作的表为user表，由此得出结论，MyBatis-Plus在确定操作的表时，由BaseMapper的泛型决定，即实体类型决定，且默认操作的表名和实体类型的类名一致。</p></blockquote><h3 id="1-1引出问题"><a href="#1-1引出问题" class="headerlink" title="1.1引出问题"></a>1.1引出问题</h3><hr><blockquote><p><strong>若实体类类型的类名和要操作的表的表名不一致，会出现什么问题？</strong></p></blockquote><ul><li><p>我们将表<code>user</code>更名为<code>t_user</code>，测试查询功能</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520093844842.png" alt="image-20220520093844842"></p></li><li><p>程序抛出异常，<strong>Table ‘mybatis_plus.user’ doesn’t exist</strong>，因为现在的表名为<code>t_user</code>，而默认操作的表名和实体类型的类名一致，即<code>user</code>表</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520094126411.png" alt="image-20220520094126411"></p></li></ul><h3 id="1-2解决问题"><a href="#1-2解决问题" class="headerlink" title="1.2解决问题"></a>1.2解决问题</h3><hr><h4 id="a、使用注解解决问题"><a href="#a、使用注解解决问题" class="headerlink" title="a、使用注解解决问题"></a>a、使用注解解决问题</h4><blockquote><p><strong>在实体类类型上添加<code>@TableName(&quot;t_user&quot;)</code>，标识实体类对应的表，即可成功执行SQL语句</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;t_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="b、使用全局配置解决问题"><a href="#b、使用全局配置解决问题" class="headerlink" title="b、使用全局配置解决问题"></a>b、使用全局配置解决问题</h4><blockquote><p><strong>在开发的过程中，我们经常遇到以上的问题，即实体类所对应的表都有固定的前缀，例如 <code>t_</code> 或 <code>tbl_</code> 此时，可以使用MyBatis-Plus提供的全局配置，为实体类所对应的表名设置默认的前缀，那么就不需要在每个实体类上通过@TableName标识实体类对应的表</strong></p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment"># 设置实体类所对应的表的统一前缀</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">t_</span></span><br></pre></td></tr></table></figure><h2 id="2-TableId"><a href="#2-TableId" class="headerlink" title="2.@TableId"></a>2.@TableId</h2><blockquote><p><strong>经过以上的测试，MyBatis-Plus在实现CRUD时，会默认将id作为主键列，并在插入数据时，默认基于雪花算法的策略生成id</strong></p></blockquote><h3 id="2-1引出问题"><a href="#2-1引出问题" class="headerlink" title="2.1引出问题"></a>2.1引出问题</h3><hr><blockquote><p><strong>若实体类和表中表示主键的不是id，而是其他字段，例如uid，MyBatis-Plus会自动识别uid为主键列吗？</strong></p></blockquote><ul><li><p>我们实体类中的属性<code>id</code>改为<code>uid</code>，将表中的字段<code>id</code>也改为<code>uid</code>，测试添加功能</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520100939157.png" alt="image-20220520100939157"></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520100715109.png" alt="image-20220520100715109"></p></li><li><p>程序抛出异常，<strong>Field ‘uid’ doesn’t have a default value</strong>，说明MyBatis-Plus没有将<code>uid</code>作为主键赋值</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520101317761.png" alt="image-20220520101317761"></p></li></ul><h3 id="2-2解决问题"><a href="#2-2解决问题" class="headerlink" title="2.2解决问题"></a>2.2解决问题</h3><hr><blockquote><p><strong>在实体类中uid属性上通过<code>@TableId</code>将其标识为主键，即可成功执行SQL语句</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Date</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long uid;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-TableId的value属性"><a href="#2-3-TableId的value属性" class="headerlink" title="2.3@TableId的value属性"></a>2.3@TableId的value属性</h3><hr><blockquote><p>若实体类中主键对应的属性为id，而表中表示主键的字段为uid，此时若只在属性id上添加注解@TableId，则抛出异常**Unknown column ‘id’ in ‘field list’**，即MyBatis-Plus仍然会将id作为表的主键操作，而表中表示主键的是字段uid此时需要通过@TableId注解的value属性，指定表中的主键字段，<code>@TableId(&quot;uid&quot;)</code>或<code>@TableId(value=&quot;uid&quot;)</code></p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520103030977.png" alt="image-20220520103030977"></p><h3 id="2-4-TableId的type属性"><a href="#2-4-TableId的type属性" class="headerlink" title="2.4@TableId的type属性"></a>2.4@TableId的type属性</h3><hr><blockquote><p><strong>type属性用来定义主键策略：默认雪花算法</strong></p></blockquote><p><strong>常用的主键策略：</strong></p><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">IdType.ASSIGN_ID（默认）</td><td align="center">基于雪花算法的策略生成数据id，与数据库id是否设置自增无关</td></tr><tr><td align="center">IdType.AUTO</td><td align="center">使用数据库的自增策略，注意，该类型请确保数据库设置了id自增，</td></tr></tbody></table><p><strong>配置全局主键策略：</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#MyBatis-Plus相关配置</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment">#配置日志</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment">#配置mp的主键策略为自增</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">      <span class="comment"># 设置实体类所对应的表的统一前缀</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">t_</span></span><br></pre></td></tr></table></figure><h2 id="3-TbaleField"><a href="#3-TbaleField" class="headerlink" title="3.@TbaleField"></a>3.@TbaleField</h2><blockquote><p>经过以上的测试，我们可以发现，MyBatis-Plus在执行SQL语句时，要保证实体类中的属性名和表中的字段名一致</p><p>如果实体类中的属性名和字段名不一致的情况，会出现什么问题呢？</p></blockquote><h3 id="3-1情况一"><a href="#3-1情况一" class="headerlink" title="3.1情况一"></a>3.1情况一</h3><hr><p>若实体类中的属性使用的是驼峰命名风格，而表中的字段使用的是下划线命名风格</p><p>例如实体类属性<code>userName</code>，表中字段<code>user_name</code></p><p>此时MyBatis-Plus会<strong>自动</strong>将下划线命名风格转化为驼峰命名风格</p><p>相当于在MyBatis中配置</p><h3 id="3-2情况二"><a href="#3-2情况二" class="headerlink" title="3.2情况二"></a>3.2情况二</h3><hr><blockquote><p>若实体类中的属性和表中的字段不满足情况1</p><p>例如实体类属性<code>name</code>，表中字段<code>username</code></p><p>此时需要在实体类属性上使用<code>@TableField(&quot;username&quot;)</code>设置属性所对应的字段名</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(&quot;uid&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@TableField(&quot;username&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-TableLogic"><a href="#4-TableLogic" class="headerlink" title="4.@TableLogic"></a>4.@TableLogic</h2><h3 id="4-1逻辑删除"><a href="#4-1逻辑删除" class="headerlink" title="4.1逻辑删除"></a>4.1逻辑删除</h3><hr><blockquote><p>物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据</p><p>逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录</p><p>使用场景：可以进行数据恢复</p></blockquote><h3 id="4-2实现逻辑删除"><a href="#4-2实现逻辑删除" class="headerlink" title="4.2实现逻辑删除"></a>4.2实现逻辑删除</h3><hr><ul><li><p><strong>数据库中创建逻辑删除状态列，设置默认值为0</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520134529809.png" alt="image-20220520134529809"></p></li><li><p><strong>实体类中添加逻辑删除属性</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520134636112.png" alt="image-20220520134636112"></p></li><li><p><strong>测试删除功能，真正执行的是修改</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteById</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteById(<span class="number">1527472864163348482L</span>);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;删除成功！&quot;</span> : <span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520135637388.png" alt="image-20220520135637388"></p></li><li><p><strong>此时执行查询方法，查询的结果为自动添加条件<code>is_deleted=0</code></strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220520140036445.png" alt="image-20220520140036445"></p></li></ul><h1 id="五、条件构造器"><a href="#五、条件构造器" class="headerlink" title="五、条件构造器"></a>五、条件构造器</h1><h2 id="1-Wrapper介绍"><a href="#1-Wrapper介绍" class="headerlink" title="1.Wrapper介绍"></a>1.Wrapper介绍</h2><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220521092812125.png" alt="image-20220521092812125"></p><ul><li><p><code>Wrapper</code> ： 条件构造抽象类，最顶端父类</p><ul><li><p><code>AbstractWrapper </code>： 用于查询条件封装，生成 sql 的 where 条件</p><ul><li><p><code>QueryWrapper </code>： 查询条件封装</p></li><li><p><code>UpdateWrapper </code>： Update 条件封装</p></li><li><p><code>AbstractLambdaWrapper </code>： 使用Lambda 语法</p><ul><li><p><code>LambdaQueryWrapper </code>：用于Lambda语法使用的查询Wrapper</p></li><li><p><code>LambdaUpdateWrapper </code>： Lambda 更新封装Wrapper</p></li></ul></li></ul></li></ul></li></ul><h2 id="2-QueryWrapper"><a href="#2-QueryWrapper" class="headerlink" title="2.QueryWrapper"></a>2.QueryWrapper</h2><ul><li><p><strong>组装查询条件</strong></p><blockquote><p><strong>执行SQL：</strong>SELECT uid AS id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted&#x3D;0 AND (username LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//查询用户名包含a，年龄在20到30之间，邮箱信息不为null的用户信息</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.like(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;a&quot;</span>).between(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>,<span class="number">30</span>).isNotNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>组装排序条件</strong></p><blockquote><p><strong>执行SQL：</strong>SELECT uid AS id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted&#x3D;0 ORDER BY age DESC,id ASC</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//查询用户信息，按照年龄的降序排序，若年龄相同，则按照id升序排序</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.orderByDesc(<span class="string">&quot;age&quot;</span>).orderByAsc(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>组装删除条件</strong></p><blockquote><p><strong>执行SQL：</strong>UPDATE t_user SET is_deleted&#x3D;1 WHERE is_deleted&#x3D;0 AND (email IS NULL)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//删除邮箱地址为null的用户信息</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.delete(queryWrapper);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;删除成功！&quot;</span> : <span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>条件的优先级</strong></p><blockquote><p><strong>执行SQL：</strong>UPDATE t_user SET user_name&#x3D;?, email&#x3D;? WHERE is_deleted&#x3D;0 AND (age &gt; ? AND user_name LIKE ? OR email IS NULL)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//将（年龄大于20并且用户名中包含有a）或邮箱为null的用户信息修改</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    updateWrapper.gt(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>).like(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;a&quot;</span>).or().isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;Oz&quot;</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;test@oz6.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(user, updateWrapper);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;修改成功！&quot;</span> : <span class="string">&quot;修改失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>执行SQL：</strong>UPDATE t_user SET username&#x3D;?, email&#x3D;? WHERE is_deleted&#x3D;0 AND (username LIKE ? AND (age &gt; ? OR email IS NULL))</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    updateWrapper.like(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;a&quot;</span>).and(i-&gt;i.gt(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>).or().isNull(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;Vz7797&quot;</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;test@ss8o.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(user, updateWrapper);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;修改成功！&quot;</span> : <span class="string">&quot;修改失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>组装select子句</strong></p><blockquote><p><strong>执行SQL：</strong>SELECT username,age,email FROM t_user WHERE is_deleted&#x3D;0</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//查询用户的用户名、年龄、邮箱信息</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.select(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper);</span><br><span class="line">    maps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>实现子查询</strong></p><blockquote><p><strong>执行SQL：</strong>SELECT uid AS id,user_name AS name,age,email,is_deleted FROM t_user WHERE is_deleted&#x3D;0 AND (uid IN (select uid from t_user where uid &lt;&#x3D; 100))</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test07</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//查询id小于等于100的用户信息</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.inSql(<span class="string">&quot;uid&quot;</span>, <span class="string">&quot;select uid from t_user where uid &lt;= 100&quot;</span>);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-UpdateWrapper"><a href="#3-UpdateWrapper" class="headerlink" title="3.UpdateWrapper"></a>3.UpdateWrapper</h2><blockquote><p>UpdateWrapper不仅拥有QueryWrapper的组装条件功能，还提供了set方法进行修改对应条件的数据库信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test08</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    updateWrapper.like(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;a&quot;</span>).and( i -&gt; i.gt(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>).or().isNull(<span class="string">&quot;email&quot;</span>)).set(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;svip@qq.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(<span class="literal">null</span>, updateWrapper);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;修改成功！&quot;</span> : <span class="string">&quot;修改失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-condition"><a href="#4-condition" class="headerlink" title="4.condition"></a>4.condition</h2><blockquote><p>在真正开发的过程中，组装条件是常见的功能，而这些条件数据来源于用户输入，是可选的，因此我们在组装这些条件时，<strong>必须先判断用户是否选择了这些条件，若选择则需要组装该条件</strong>，若没有选择则一定不能组装，以免影响SQL执行的结果</p></blockquote><ul><li><p><strong>思路一</strong></p><blockquote><p><strong>执行SQL：</strong>SELECT uid AS id,user_name AS name,age,email,is_deleted FROM t_user WHERE is_deleted&#x3D;0 AND (user_name LIKE ? AND age &lt;&#x3D; ?)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test09</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageBegin</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageEnd</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotBlank(username))&#123;</span><br><span class="line">        <span class="comment">//isNotBlank判断某个字符创是否不为空字符串、不为null、不为空白符</span></span><br><span class="line">        queryWrapper.like(<span class="string">&quot;user_name&quot;</span>, username);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ageBegin != <span class="literal">null</span>)&#123;</span><br><span class="line">        queryWrapper.ge(<span class="string">&quot;age&quot;</span>, ageBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ageEnd != <span class="literal">null</span>)&#123;</span><br><span class="line">        queryWrapper.le(<span class="string">&quot;age&quot;</span>, ageEnd);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>思路二</strong></p><blockquote><p>上面的实现方案没有问题，但是代码比较复杂，我们可以使用带condition参数的重载方法构建查询条件，简化代码的编写</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test10</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageBegin</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageEnd</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.like(StringUtils.isNotBlank(username), <span class="string">&quot;user_name&quot;</span>, username)</span><br><span class="line">        .ge(ageBegin != <span class="literal">null</span>, <span class="string">&quot;age&quot;</span>, ageBegin)</span><br><span class="line">        .le(ageEnd != <span class="literal">null</span>, <span class="string">&quot;age&quot;</span>, ageEnd);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-LambdaQueryWrapper"><a href="#5-LambdaQueryWrapper" class="headerlink" title="5.LambdaQueryWrapper"></a>5.LambdaQueryWrapper</h2><blockquote><p>功能等同于QueryWrapper，提供了Lambda表达式的语法可以避免填错列名。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test11</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageBegin</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageEnd</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.like(StringUtils.isNotBlank(username), User::getName, username)</span><br><span class="line">        .ge(ageBegin != <span class="literal">null</span>, User::getAge, ageBegin)</span><br><span class="line">        .le(ageEnd != <span class="literal">null</span>, User::getAge, ageEnd);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-LambdaUpdateWrapper"><a href="#6-LambdaUpdateWrapper" class="headerlink" title="6.LambdaUpdateWrapper"></a>6.LambdaUpdateWrapper</h2><blockquote><p>功能等同于UpdateWrapper，提供了Lambda表达式的语法可以避免填错列名。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test12</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改</span></span><br><span class="line">    LambdaUpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    updateWrapper.like(User::getName, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">        .and(i -&gt; i.gt(User::getAge, <span class="number">20</span>).or().isNull(User::getEmail));</span><br><span class="line">    updateWrapper.set(User::getName, <span class="string">&quot;小黑&quot;</span>).set(User::getEmail,<span class="string">&quot;abc@atguigu.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(<span class="literal">null</span>, updateWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;result：&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、常用插件"><a href="#六、常用插件" class="headerlink" title="六、常用插件"></a>六、常用插件</h1><h2 id="1-分页插件"><a href="#1-分页插件" class="headerlink" title="1.分页插件"></a>1.分页插件</h2><blockquote><p>MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能</p></blockquote><ul><li><p><strong>添加配置类<code>MyBatisPlusConfig</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.atguigu.mybatisplus.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">//添加分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>编写测试方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//new Page()中的两个参数分别是当前页码，每页显示数量</span></span><br><span class="line">    Page&lt;User&gt; page = userMapper.selectPage(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">2</span>), <span class="literal">null</span>);</span><br><span class="line">    List&lt;User&gt; users = page.getRecords();</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-自定义分页"><a href="#2-自定义分页" class="headerlink" title="2.自定义分页"></a>2.自定义分页</h2><blockquote><p>上面调用的是MyBatis-Plus提供的带有分页的方法，那么我们自己定义的方法如何实现分页呢？</p></blockquote><ul><li><p><strong>在<code>UserMapper</code>接口中定义一个方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 根据年龄查询用户列表，分页显示 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> page 分页对象,xml中可以从里面进行取值,传递参数 Page 即自动分页,必须放在第一位 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> age 年龄 </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">Page&lt;User&gt; <span class="title function_">selectPageVo</span><span class="params">(<span class="meta">@Param(&quot;page&quot;)</span> Page&lt;User&gt; page,<span class="meta">@Param(&quot;age&quot;)</span> Integer age)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>在<code>UserMapper.xml</code>中编写SQL实现该方法</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPageVo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select id,username as name,age,email from t_user where age &gt; #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>编写测试方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPageVo</span><span class="params">()</span>&#123;</span><br><span class="line">    Page&lt;User&gt; page = userMapper.selectPageVo(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;User&gt;(<span class="number">1</span>,<span class="number">2</span>), <span class="number">20</span>);</span><br><span class="line">    List&lt;User&gt; users = page.getRecords();</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-乐观锁"><a href="#3-乐观锁" class="headerlink" title="3.乐观锁"></a>3.乐观锁</h2><blockquote><p><strong>作用：当要更新一条记录的时候，希望这条记录没有被别人更新</strong></p></blockquote><p>乐观锁的实现方式：</p><ul><li>取出记录时，获取当前 version</li><li>更新时，带上这个 version</li><li>执行更新时， set version &#x3D; newVersion where version &#x3D; oldVersion</li><li>如果 version 不对，就更新失败</li></ul><h3 id="3-1场景"><a href="#3-1场景" class="headerlink" title="3.1场景"></a>3.1场景</h3><hr><ul><li>一件商品，成本价是80元，售价是100元。老板先是通知小李，说你去把商品价格增加50元。小李正在玩游戏，耽搁了一个小时。正好一个小时后，老板觉得商品价格增加到150元，价格太高，可能会影响销量。又通知小王，你把商品价格降低30元。</li><li>此时，小李和小王同时操作商品后台系统。小李操作的时候，系统先取出商品价格100元；小王也在操作，取出的商品价格也是100元。小李将价格加了50元，并将100+50&#x3D;150元存入了数据库；小王将商品减了30元，并将100-30&#x3D;70元存入了数据库。是的，如果没有锁，小李的操作就完全被小王的覆盖了。</li><li>现在商品价格是70元，比成本价低10元。几分钟后，这个商品很快出售了1千多件商品，老板亏1万多。</li></ul><h3 id="3-2乐观锁与悲观锁"><a href="#3-2乐观锁与悲观锁" class="headerlink" title="3.2乐观锁与悲观锁"></a>3.2乐观锁与悲观锁</h3><hr><ul><li>上面的故事，如果是乐观锁，小王保存价格前，会检查下价格是否被人修改过了。如果被修改过了，则重新取出的被修改后的价格，150元，这样他会将120元存入数据库。</li><li>如果是悲观锁，小李取出数据后，小王只能等小李操作完之后，才能对价格进行操作，也会保证最终的价格是120元。</li></ul><h3 id="3-3模拟修改冲突"><a href="#3-3模拟修改冲突" class="headerlink" title="3.3模拟修改冲突"></a>3.3模拟修改冲突</h3><hr><ul><li><p><strong>数据库中增加商品表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_product ( </span><br><span class="line">    id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>, </span><br><span class="line">    NAME <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品名称&#x27;</span>, </span><br><span class="line">    price <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;价格&#x27;</span>, </span><br><span class="line">    VERSION <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;乐观锁版本号&#x27;</span>, </span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id) </span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><strong>添加一条数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_product (id, NAME, price) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;外星人笔记本&#x27;</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>添加一个实体类<code>Product</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>添加一个Mapper接口<code>ProductMapper</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Product&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>测试方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProduct01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.小李获取商品价格</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productLi</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李获取的商品价格为：&quot;</span> + productLi.getPrice());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.小王获取商品价格</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productWang</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李获取的商品价格为：&quot;</span> + productWang.getPrice());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.小李修改商品价格+50</span></span><br><span class="line">    productLi.setPrice(productLi.getPrice()+<span class="number">50</span>);</span><br><span class="line">    productMapper.updateById(productLi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.小王修改商品价格-30</span></span><br><span class="line">    productWang.setPrice(productWang.getPrice()-<span class="number">30</span>);</span><br><span class="line">    productMapper.updateById(productWang);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.老板查询商品价格</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productBoss</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;老板获取的商品价格为：&quot;</span> + productBoss.getPrice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>执行结果</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220521225803162.png" alt="image-20220521225803162"></p></li></ul><h3 id="3-4乐观锁解决问题"><a href="#3-4乐观锁解决问题" class="headerlink" title="3.4乐观锁解决问题"></a>3.4乐观锁解决问题</h3><hr><ul><li><p><strong>实体类<code>version</code>字段添加注解<code>@Version</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="meta">@Version</span></span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>添加乐观锁插件配置</strong>(在配置类中添加)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    <span class="comment">//添加分页插件</span></span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">    <span class="comment">//添加乐观锁插件</span></span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>再次执行测试方法</strong></p><blockquote><p>小李查询商品信息：</p><p>​SELECT id,name,price,version FROM t_product WHERE id&#x3D;?</p><p>小王查询商品信息：</p><p>​SELECT id,name,price,version FROM t_product WHERE id&#x3D;?</p><p>小李修改商品价格，自动将version+1</p><p>​UPDATE t_product SET name&#x3D;?, price&#x3D;?, version&#x3D;? WHERE id&#x3D;? AND version&#x3D;?</p><p>​Parameters: 外星人笔记本(String), 150(Integer), 1(Integer), 1(Long), 0(Integer)</p><p>小王修改商品价格，此时version已更新，条件不成立，修改失败</p><p>​UPDATE t_product SET name&#x3D;?, price&#x3D;?, version&#x3D;? WHERE id&#x3D;? AND version&#x3D;?</p><p>​Parameters: 外星人笔记本(String), 70(Integer), 1(Integer), 1(Long), 0(Integer)</p><p>最终，小王修改失败，查询价格：150</p><p>​SELECT id,name,price,version FROM t_product WHERE id&#x3D;?</p></blockquote></li><li><p><strong>优化执行流程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProduct01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.小李获取商品价格</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productLi</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李获取的商品价格为：&quot;</span> + productLi.getPrice());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.小王获取商品价格</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productWang</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李获取的商品价格为：&quot;</span> + productWang.getPrice());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.小李修改商品价格+50</span></span><br><span class="line">    productLi.setPrice(productLi.getPrice()+<span class="number">50</span>);</span><br><span class="line">    productMapper.updateById(productLi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.小王修改商品价格-30</span></span><br><span class="line">    productWang.setPrice(productWang.getPrice()-<span class="number">30</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> productMapper.updateById(productWang);</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//操作失败，重试</span></span><br><span class="line">        <span class="type">Product</span> <span class="variable">productNew</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">        productNew.setPrice(productNew.getPrice()-<span class="number">30</span>);</span><br><span class="line">        productMapper.updateById(productNew);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.老板查询商品价格</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productBoss</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;老板获取的商品价格为：&quot;</span> + productBoss.getPrice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220521230448577.png" alt="image-20220521230448577"></p></li></ul><h1 id="七、通用枚举"><a href="#七、通用枚举" class="headerlink" title="七、通用枚举"></a>七、通用枚举</h1><blockquote><p>表中的有些字段值是固定的，例如性别（男或女），此时我们可以使用MyBatis-Plus的通用枚举来实现</p></blockquote><ul><li><p><strong>数据库表添加字段<code>sex</code></strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220521231317777.png" alt="image-20220521231317777"></p></li><li><p><strong>创建通用枚举类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SexEnum</span> &#123;</span><br><span class="line">    MALE(<span class="number">1</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">    FEMALE(<span class="number">2</span>, <span class="string">&quot;女&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EnumValue</span> <span class="comment">//将注解所标识的属性的值存储到数据库中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sex;</span><br><span class="line">    <span class="keyword">private</span> String sexName;</span><br><span class="line"></span><br><span class="line">    SexEnum(Integer sex, String sexName) &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.sexName = sexName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>User实体类中添加属性sex</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@TableField(&quot;username&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> isDeleted;  <span class="comment">//逻辑删除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SexEnum sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>配置扫描通用枚举</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#MyBatis-Plus相关配置</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="comment">#指定mapper文件所在的地址</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment">#配置日志</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">banner:</span> <span class="string">off</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment">#配置mp的主键策略为自增</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">      <span class="comment"># 设置实体类所对应的表的统一前缀</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">t_</span></span><br><span class="line">  <span class="comment">#配置类型别名所对应的包</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.atguigu.mybatisplus.pojo</span></span><br><span class="line">  <span class="comment"># 扫描通用枚举的包</span></span><br><span class="line">  <span class="attr">type-enums-package:</span> <span class="string">com.atguigu.mybatisplus.enums</span></span><br></pre></td></tr></table></figure></li><li><p><strong>执行测试方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">33</span>);</span><br><span class="line">    user.setSex(SexEnum.MALE);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insert(user);</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="八、多数据源"><a href="#八、多数据源" class="headerlink" title="八、多数据源"></a>八、多数据源</h1><blockquote><p>适用于多种场景：纯粹多库、 读写分离、 一主多从、 混合模式等</p></blockquote><p>场景说明：</p><p>我们创建两个库，分别为：<code>mybatis_plus</code>（以前的库不动）与<code>mybatis_plus_1</code>（新建），将mybatis_plus库的<code>product</code>表移动到mybatis_plus_1库，这样每个库一张表，通过一个测试用例分别获取用户数据与商品数据，如果获取到说明多库模拟成功</p><h2 id="1-创建数据库及表"><a href="#1-创建数据库及表" class="headerlink" title="1.创建数据库及表"></a>1.创建数据库及表</h2><ul><li><p><strong>创建数据库<code>mybatis_plus_1</code>和表&#96;product</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `mybatis_plus_1` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 */</span>;</span><br><span class="line">use `mybatis_plus_1`; </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> product ( </span><br><span class="line">    id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>, </span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品名称&#x27;</span>, </span><br><span class="line">    price <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;价格&#x27;</span>, </span><br><span class="line">    version <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;乐观锁版本号&#x27;</span>, </span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id) </span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><strong>添加测试数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product (id, NAME, price) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;外星人笔记本&#x27;</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>删除<code>mybatis_plus</code>库中的<code>product</code>表</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use mybatis_plus; </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> product;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-新建工程引入依赖"><a href="#2-新建工程引入依赖" class="headerlink" title="2.新建工程引入依赖"></a>2.新建工程引入依赖</h2><blockquote><p><strong>自行新建一个Spring Boot工程并选择MySQL驱动及Lombok依赖</strong></p></blockquote><p><strong>引入MyBaits-Plus的依赖及多数据源的依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dynamic-datasource-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-编写配置文件"><a href="#3-编写配置文件" class="headerlink" title="3.编写配置文件"></a>3.编写配置文件</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 配置数据源信息</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">dynamic:</span></span><br><span class="line">      <span class="comment"># 设置默认的数据源或者数据源组,默认值即为master</span></span><br><span class="line">      <span class="attr">primary:</span> <span class="string">master</span></span><br><span class="line">      <span class="comment"># 严格匹配数据源,默认false.true未匹配到指定数据源时抛异常,false使用默认数据源</span></span><br><span class="line">      <span class="attr">strict:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">master:</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="number">132537</span></span><br><span class="line">        <span class="attr">slave_1:</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus_1?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="number">132537</span></span><br></pre></td></tr></table></figure><h2 id="4-创建实体类"><a href="#4-创建实体类" class="headerlink" title="4.创建实体类"></a>4.创建实体类</h2><ul><li><p>新建一个<code>User</code>实体类（如果数据库表名有t_前缀记得配置）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建一个实体类<code>Product</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-创建Mapper及Service"><a href="#5-创建Mapper及Service" class="headerlink" title="5.创建Mapper及Service"></a>5.创建Mapper及Service</h2><ul><li><p>新建接口<code>UserMapper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建接口<code>ProductMapper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Product&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建Service接口<code>UserService</code>指定操作的数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DS(&quot;master&quot;)</span> <span class="comment">//指定操作的数据源，master为user表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建Service接口<code>ProductService</code>指定操作的数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DS(&quot;slave_1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Product&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>自行建立Service的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-编写测试方法"><a href="#6-编写测试方法" class="headerlink" title="6.编写测试方法"></a>6.编写测试方法</h2><blockquote><p><strong>记得在启动类中添加注解<code>@MapperScan()</code></strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestDatasourceApplicationTests</span> &#123;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line">UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line">ProductService productService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(<span class="number">1L</span>);</span><br><span class="line"><span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> productService.getById(<span class="number">1L</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;User = &quot;</span> + user);</span><br><span class="line">System.out.println(<span class="string">&quot;Product = &quot;</span> + product);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522113049945.png" alt="image-20220522113049945"></p><h1 id="九、MyBatisX插件"><a href="#九、MyBatisX插件" class="headerlink" title="九、MyBatisX插件"></a>九、MyBatisX插件</h1><blockquote><p>MyBatis-Plus为我们提供了强大的mapper和service模板，能够大大的提高开发效率。</p><p>但是在真正开发过程中，MyBatis-Plus并不能为我们解决所有问题，例如一些复杂的SQL，多表联查，我们就需要自己去编写代码和SQL语句，我们该如何快速的解决这个问题呢，这个时候可以使用MyBatisX插件。</p><p>MyBatisX一款基于 IDEA 的快速开发插件，为效率而生。</p></blockquote><h2 id="1-安装MyBatisX插件"><a href="#1-安装MyBatisX插件" class="headerlink" title="1.安装MyBatisX插件"></a>1.安装MyBatisX插件</h2><blockquote><p><strong>打开IDEA，File-&gt; Setteings-&gt;Plugins-&gt;MyBatisX，搜索栏搜索MyBatisX然后安装。</strong></p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522115718361.png" alt="image-20220522115718361"></p><h2 id="2-快速生成代码"><a href="#2-快速生成代码" class="headerlink" title="2.快速生成代码"></a>2.快速生成代码</h2><ul><li><p>新建一个Spring Boot项目引入依赖（创建工程时记得勾选lombok及mysql驱动）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dynamic-datasource-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置数据源信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">132537</span></span><br></pre></td></tr></table></figure></li><li><p>在IDEA中与数据库建立链接</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522120758740.png" alt="image-20220522120758740"></p></li><li><p>填写数据库信息并保存</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522121434468.png" alt="image-20220522121434468"></p></li><li><p>找到我们需要生成的表点击右键</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522121613909.png" alt="image-20220522121613909"></p></li><li><p>填写完信息以后下一步</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522122127649.png" alt="image-20220522122127649"></p></li><li><p>继续填写信息</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522122525598.png" alt="image-20220522122525598"></p></li><li><p><strong>大功告成（真特么好用yyds）</strong></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522122612334.png" alt="image-20220522122612334"></p></li></ul><h2 id="3-快速生成CRUD"><a href="#3-快速生成CRUD" class="headerlink" title="3.快速生成CRUD"></a>3.快速生成CRUD</h2><blockquote><p>MyBaitsX可以根据我们在Mapper接口中输入的方法名快速帮我们生成对应的sql语句</p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522123143852.png" alt="image-20220522123143852"></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522123202310.png" alt="image-20220522123202310"></p><h1 id="十、致谢"><a href="#十、致谢" class="headerlink" title="十、致谢"></a>十、致谢</h1><p>感谢尚硅谷杨博超老师：<a href="https://www.bilibili.com/video/BV12R4y157Be?p=1">https://www.bilibili.com/video/BV12R4y157Be?p=1</a></p><p>感谢MyBatis-Plus作者苞米豆：<a href="https://baomidou.com/">https://baomidou.com/</a></p><p>感谢自己又坚持学习了一门课程：<a href="https://www.oz6.cn/">https://www.oz6.cn/</a></p><h1 id="代码生成器："><a href="#代码生成器：" class="headerlink" title="代码生成器："></a>代码生成器：</h1><h2 id="MyBatis-Plus-逆向程依赖："><a href="#MyBatis-Plus-逆向程依赖：" class="headerlink" title="MyBatis-Plus 逆向程依赖："></a>MyBatis-Plus 逆向程依赖：</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--MyBatis-Plus 逆向工程依赖代码生成器的核心依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 一个模板的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.freemarker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="生成代码："><a href="#生成代码：" class="headerlink" title="生成代码："></a>生成代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastAutoGeneratorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置我们需要创建在哪的路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/Users/luxiaogen/Documents/RoadTo2w/Java/尚硅谷/MyBatisPlus-2022/demo&quot;</span>;</span><br><span class="line">        <span class="comment">// 这里我是mysql8 5版本可以换成 jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">        FastAutoGenerator.create(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis_plus?serverTimezone=GMT%2B8&amp;characterEncoding=utf-8&amp;useSSL=false&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>)</span><br><span class="line">                .globalConfig(builder -&gt; &#123;</span><br><span class="line">                    builder.author(<span class="string">&quot;atguigu&quot;</span>) <span class="comment">// 设置作者</span></span><br><span class="line">                    <span class="comment">// .enableSwagger() // 开启 swagger 模式</span></span><br><span class="line">                    .fileOverride() <span class="comment">// 覆盖已生成文件</span></span><br><span class="line">                    .outputDir(path); <span class="comment">// 指定输出目录</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .packageConfig(builder -&gt; &#123;</span><br><span class="line">                    builder.parent(<span class="string">&quot;com.atguigu&quot;</span>) <span class="comment">// 设置父包名</span></span><br><span class="line">                            .moduleName(<span class="string">&quot;mybatisplus&quot;</span>) <span class="comment">// 设置父包模块名</span></span><br><span class="line">                            .pathInfo(Collections.singletonMap(OutputFile.mapperXml, path)); <span class="comment">// 设置mapperXml生成路径</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .strategyConfig(builder -&gt; &#123;</span><br><span class="line">                    builder.addInclude(<span class="string">&quot;t_user&quot;</span>) <span class="comment">// 设置需要生成的表名</span></span><br><span class="line">                            .addTablePrefix(<span class="string">&quot;t_&quot;</span>, <span class="string">&quot;c_&quot;</span>); <span class="comment">// 设置过滤表前缀</span></span><br><span class="line">                &#125;).templateEngine(<span class="keyword">new</span> <span class="title class_">FreemarkerTemplateEngine</span>()) <span class="comment">// 使用Freemarker 引擎模板，默认的是Velocity引擎模板</span></span><br><span class="line">                .execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h1><h4 id="MyBatisPlus-添加新的实体："><a href="#MyBatisPlus-添加新的实体：" class="headerlink" title="MyBatisPlus 添加新的实体："></a>MyBatisPlus 添加新的实体：</h4><p>​1.在entity包中编写实体类，添加@Date注解</p><p>​2.在mapper包中添加对应的mapper接口</p><p>​需要继承BaseMapper：extends BaseMapper&lt;实体类名&gt;</p><p>因为在需要对数据库进行实体类相应的表的查询时，我们需要用到xxMapper的实现类，</p><p>然而xxMapper是接口，没有实现类，因此我们在@Autowired定义的实现类后会报错，</p><p>因此我们需要<strong>在Mapper接口中添加@Repository注解</strong></p><p>​3.</p>]]></content>
      
      
      <categories>
          
          <category> 数据库相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis-Plus </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java核心卷研读</title>
      <link href="/2023/05/26/java%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/05/26/java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="java基础："><a href="#java基础：" class="headerlink" title="java基础："></a>java基础：</h1><h2 id="1-JVM："><a href="#1-JVM：" class="headerlink" title="1. JVM："></a>1. JVM：</h2><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728164853677.png" alt="image-20230728164853677"></p><h3 id="运行过程："><a href="#运行过程：" class="headerlink" title="运行过程："></a>运行过程：</h3><p>​Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件，而字节码文件又通过 <strong>Java 虚拟机中的解释器</strong>，编译成特定机器上的机器码 。</p><p>① Java 源文件(.java)—-&gt;编译器(javac)—-&gt;字节码文件(.class)</p><p>② 字节码文件(.class)—-&gt;JVM—-&gt;机器码</p><h3 id="1-1线程"><a href="#1-1线程" class="headerlink" title="1.1线程"></a>1.1线程</h3><p>​这里所说的线程指程序执行过程中的一个线程实体。 JVM 允许一个应用并发执行多个线程。<u>Hotspot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系。</u> <strong>当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。Java 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。当线程结束时，会释放原生线程和 Java 线程的所有资源。</strong></p><h3 id="1-2JVM内存区域"><a href="#1-2JVM内存区域" class="headerlink" title="1.2JVM内存区域"></a>1.2JVM内存区域</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728184623227.png" alt="image-20230728184623227"></p><p>JVM内存区域分为：</p><ul><li>线程私有区域<ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法区</li></ul></li><li>线程共享区域<ul><li>JAVA<strong>堆</strong></li><li>方法区<ul><li>常量池</li></ul></li></ul></li><li>直接内存</li></ul><ol><li><p><strong>线程私有数据区域生命周期与线程相同, 依赖用户线程的启动&#x2F;结束 而 创建&#x2F;销毁</strong>(在 HotspotVM 内, <u>每个线程都与操作系统的本地线程直接映射</u>, 因此这部分内存区域的存&#x2F;否跟随本地线程的生&#x2F;死对应)。</p></li><li><p><strong>线程共享区域</strong>随虚拟机的 启动&#x2F;关闭 而 创建&#x2F;销毁 </p></li><li><p><strong>直接内存</strong>并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728185217834.png" alt="image-20230728185217834"></p><h4 id="1-2-1程序计数器-线程私有"><a href="#1-2-1程序计数器-线程私有" class="headerlink" title="1.2.1程序计数器(线程私有)"></a>1.2.1程序计数器(线程私有)</h4><ul><li>一块较小的内存空间, 是<strong>当前线程所执行的字节码的行号指示器</strong>，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有” 的内存。</li><li>正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址） 。如果还是 Native 方法，则为空。</li></ul><h4 id="1-2-2虚拟机栈-线程私有"><a href="#1-2-2虚拟机栈-线程私有" class="headerlink" title="1.2.2虚拟机栈(线程私有)"></a>1.2.2虚拟机栈(线程私有)</h4><p>​是<strong>描述java<u>方法</u>执行的内存模型</strong>，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于<u>存储局部变量表、操作数栈、动态链接、方法出口</u>等信息。 每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><h4 id="1-2-3本地方法区-线程私有"><a href="#1-2-3本地方法区-线程私有" class="headerlink" title="1.2.3本地方法区(线程私有)"></a>1.2.3本地方法区(线程私有)</h4><p>​本地方法区和 虚拟机栈 作用类似, 区别是<strong>虚拟机栈为执行 Java 方法服务, 而本地方法栈则为Native 方法服务</strong>, 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用, 那么该栈将会是一个C 栈，但 <u>HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一</u>。</p><h4 id="1-2-4-堆（Heap-线程共享）-运行时数据区"><a href="#1-2-4-堆（Heap-线程共享）-运行时数据区" class="headerlink" title="1.2.4. 堆（Heap-线程共享）-运行时数据区"></a>1.2.4. 堆（Heap-线程共享）-运行时数据区</h4><p>​是被线程共享的一块内存区域， <strong>创建的<u>对象和数组</u>都保存在 Java 堆内存中</strong>，也是<strong>垃圾收集器进行垃圾收集</strong>的最重要的内存区域。 由于现代 VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、 From Survivor 区和 To Survivor 区)和老年代。</p><h4 id="1-2-5-方法区-x2F-永久代（线程共享）"><a href="#1-2-5-方法区-x2F-永久代（线程共享）" class="headerlink" title="1.2.5. 方法区&#x2F;永久代（线程共享）"></a>1.2.5. 方法区&#x2F;永久代（线程共享）</h4><p>​即我们常说的永久代(Permanent Generation), 用于存储被 JVM 加载的<strong>类信息、 常量、 静态变量、 即时编译器编译后的代码</strong>等数据. </p><p>​HotSpot VM把GC分代收集扩展至方法区, 即使用Java堆的永久代来实现方法区, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存,而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对<u>常量池的回收和类型的卸载</u>, 因此收益一般很小)。</p><p>​运行时**<u>常量池</u><strong>（Runtime Constant Pool）是方法区的一部分。 Class 文件中除了有</strong>类的版本、字段、方法、接口等描述等信息**外，还有一项信息是常量池（Constant Pool Table），用于<u>存放编译期生成的各种字面量和符号引用</u>，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java 虚拟机对 Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。</p><h3 id="1-3-JVM-运行时内存"><a href="#1-3-JVM-运行时内存" class="headerlink" title="1.3 JVM 运行时内存"></a>1.3 JVM 运行时内存</h3><p>java堆可以细分为</p><ul><li><p><em>新生代</em>——用于存放新生的对象，<strong>一般占据1&#x2F;3堆空间</strong>，由于频繁创建对象，所以<strong>新生代会频繁触发MinorGC 进行垃圾回收</strong>，新生代细分为以下三个区域：</p><ul><li><p><strong>Eden区</strong>：<strong>Java 新对象的出生地</strong>（如果新创建的对象占用内存很大，则直接分配到老年代）。<u>当 Eden 区内存不够的时候就会触发 MinorGC，对<strong>新生代区</strong>进行一次垃圾回收。</u></p></li><li><p><strong>ServivorFrom区</strong>：上一次 GC 的幸存者，作为这一次 GC 的被扫描者。</p></li><li><p><strong>ServivorTo区</strong>：<u>保留</u>了一次 MinorGC 过程中的<u>幸存者</u></p><ul><li><p>MinorGC 的过程（复制-&gt;清空-&gt;互换）MinorGC 采用<strong>复制算法</strong>。</p><ul><li><p>1： eden、 servicorFrom 复制到 ServicorTo，年龄+1。<br>首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（<u>如果有对象的年龄以及达到了老年的标准，则赋值到老年代区</u>），同时把这些对象的年龄+1（<u>如果 ServicorTo 不够位置了就放到老年区</u>）；</p></li><li><p>2： 清空 eden、 servicorFrom</p><p>​然后，清空 Eden 和 ServicorFrom 中的对象；</p></li><li><p>3： ServicorTo 和 ServicorFrom 互换</p><p>​最后， ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区。</p></li></ul></li></ul></li></ul></li><li><p><em>老年代</em></p></li></ul><p>​<strong>主要存放应用程序中生命周期长的内存对象。</strong></p><p>​老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。<strong>当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间</strong>。</p><p>​MajorGC 采用<strong>标记清除算法</strong>：首先扫描一次所有老年代，<u>标记出存活的对象，然后回收没有标记的对象</u>。 MajorGC 的耗时比较长，因为要扫描再回收。 MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。</p><ul><li>!!!<em>永久代</em></li></ul><p>​指内存的永久保存区域，主要存放 <strong>Class 和 Meta（元数据）</strong>的信息,<u>Class 在被加载的时候被放入永久区域， 它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理。</u>所以这也导致了<u>永久代的区域会随着加载的 Class 的增多而胀满，最</u>终抛出 OOM 异常。</p><p>！！！在 Java8 中， 永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于： <strong>元空间并不在虚拟机中，而是使用本地内存。</strong>因此，<u>默认情况下，元空间的大小仅受本地内存限制。 类的元数据放入 nativememory, 字符串池和类的静态变量放入 java 堆中， 这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制。</u></p><h3 id="1-4垃圾回收与算法"><a href="#1-4垃圾回收与算法" class="headerlink" title="1.4垃圾回收与算法"></a>1.4垃圾回收与算法</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729200359311.png" alt="image-20230729200359311"></p><h4 id="1-4-1如何确定垃圾"><a href="#1-4-1如何确定垃圾" class="headerlink" title="1.4.1如何确定垃圾"></a>1.4.1如何确定垃圾</h4><h5 id="1-4-1-1引用计数法"><a href="#1-4-1-1引用计数法" class="headerlink" title="1.4.1.1引用计数法"></a>1.4.1.1引用计数法</h5><p>​一个对象如果没有任何与之关联的引用， 即他们的引用计数都不为 0， 则说明对象不太可能再被用到，那么这个对象就是可回收对象。</p><h5 id="1-4-1-2-可达性分析"><a href="#1-4-1-2-可达性分析" class="headerlink" title="1.4.1.2. 可达性分析"></a>1.4.1.2. 可达性分析</h5><p>为了解决引用计数法的循环引用问题， Java 使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。</p><p>要注意的是，不可达对象不等价于可回收对象， 不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。</p><h4 id="1-4-2垃圾回收算法"><a href="#1-4-2垃圾回收算法" class="headerlink" title="1.4.2垃圾回收算法"></a>1.4.2垃圾回收算法</h4><h5 id="1-4-2-1-标记-清除算法（Mark-Sweep）"><a href="#1-4-2-1-标记-清除算法（Mark-Sweep）" class="headerlink" title="1.4.2.1 标记-清除算法（Mark-Sweep）"></a>1.4.2.1 标记-清除算法（Mark-Sweep）</h5><p>最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。如图</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729204014222.png" alt="image-20230729204014222" style="zoom:55%;" /><p>从图中我们就可以发现，该算法最大的问题是<strong>内存碎片化严重</strong>，后续可能发生大对象不能找到可利用空间的问题。</p><h5 id="1-4-2-2-复制算法（copying）"><a href="#1-4-2-2-复制算法（copying）" class="headerlink" title="1.4.2.2 复制算法（copying）"></a>1.4.2.2 复制算法（copying）</h5><p>为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。<strong>按内存容量将内存划分为等大小的两块</strong>。每次只使用其中一块，<u><strong>当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉</strong></u>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729204457458.png" alt="image-20230729204457458"></p><p>这种算法虽然<u>实现简单，内存效率高，不易产生碎片</u>，但是最大的问题是**<u>可用内存被压缩到了原本的一半</u>**。且存活对象增多的话， Copying 算法的效率会大大降低。</p><h5 id="1-4-2-3-标记整理算法-Mark-Compact"><a href="#1-4-2-3-标记整理算法-Mark-Compact" class="headerlink" title="1.4.2.3 标记整理算法(Mark-Compact)"></a>1.4.2.3 标记整理算法(Mark-Compact)</h5><p>​结合了以上两个算法，为了避免缺陷而提出。<strong>标记阶段和 Mark-Sweep 算法相同， 标记后不是清理对象，而是将存活对象移向内存的一端。</strong>然后清除端边界外的对象。如图</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230729204701947.png" alt="image-20230729204701947"></p><h5 id="1-4-2-4-🌟分代收集算法"><a href="#1-4-2-4-🌟分代收集算法" class="headerlink" title="1.4.2.4 🌟分代收集算法"></a>1.4.2.4 🌟分代收集算法</h5><p>——根据对象销毁频率特点进行分区，各个分区采用合适的算法</p><p>分代收集法是目前大部分 JVM 所采用的方法，其核心思想是<strong>根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured&#x2F;Old Generation)和新生代(YoungGeneration)。</strong><u>老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。</u></p><h4 id="1-4-3如今广泛采用的回收方法："><a href="#1-4-3如今广泛采用的回收方法：" class="headerlink" title="1.4.3如今广泛采用的回收方法："></a>1.4.3如今广泛采用的回收方法：</h4><ul><li><strong>新生代与复制算法</strong></li></ul><p>​目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中<u>每次垃圾回收都要回收大部分对象</u>，即要复制的操作比较少，但通常并不是按照 1： 1 来划分新生代。一般将新生代划分为一块较大的 Eden空间(<strong>存放新创建的对象</strong>) 和两个较小的 Survivor 空间(From Space, To Space，存放存活对象)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。</p><ul><li><strong>老年代与标记复制算法</strong></li></ul><p>​而老年代因为每次只回收少量对象，因而采用 <strong>Mark-Compact(标记整理)</strong> 算法。</p><h4 id="1-4-4-🌟垃圾回收方法总结：！！！！！"><a href="#1-4-4-🌟垃圾回收方法总结：！！！！！" class="headerlink" title="1.4.4 🌟垃圾回收方法总结：！！！！！"></a>1.4.4 🌟垃圾回收方法总结：！！！！！</h4><ol><li>JAVA 虚拟机提到过的处于方法区的永生代(Permanet Generation)， 它用来存储 class 类，常量，方法描述等。<strong>对永生代的回收主要包括废弃常量和无用的类</strong>。</li><li>对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor 目前存放对象的那一块)，少数情况会直接分配到老生代(对象过大， To Space 区装不下)。</li><li><strong>当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC</strong>，进行 GC 后， EdenSpace 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 FromSpace 进行清理。</li><li>如果 To Space 无法足够存储某个对象，则将<u>这个对象存储到老生代</u>。</li><li>在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。</li><li>当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。 <strong>默认情况下<u>年龄到达 15 的对象会被移到老生代中</u>。</strong></li></ol><h3 id="1-5-JAVA中-四种引用类型"><a href="#1-5-JAVA中-四种引用类型" class="headerlink" title="1.5 JAVA中 四种引用类型"></a>1.5 JAVA中 四种引用类型</h3><h4 id="1-5-1-强引用"><a href="#1-5-1-强引用" class="headerlink" title="1.5.1. 强引用"></a>1.5.1. 强引用</h4><p>在 Java 中最常见的就是强引用， 把一个对象赋给一个引用变量，这个引用变量就是一个强引用。<u>当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收</u>的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。</p><h4 id="1-5-2-软引用"><a href="#1-5-2-软引用" class="headerlink" title="1.5.2. 软引用"></a>1.5.2. 软引用</h4><p>软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，<u>当系统内存空间不足时它会被回收</u>。软引用通常用在对内存敏感的程序中。</p><h4 id="1-5-3-弱引用"><a href="#1-5-3-弱引用" class="headerlink" title="1.5.3. 弱引用"></a>1.5.3. 弱引用</h4><p>弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，<u>只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。</u></p><h4 id="1-5-4-虚引用"><a href="#1-5-4-虚引用" class="headerlink" title="1.5.4. 虚引用"></a>1.5.4. 虚引用</h4><p>虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。 虚引用的主要作用是<u>跟踪对象被垃圾回收的状态</u>。</p><h3 id="1-6-GC-分代收集算法-VS-分区收集算法"><a href="#1-6-GC-分代收集算法-VS-分区收集算法" class="headerlink" title="1.6.GC 分代收集算法 VS 分区收集算法"></a>1.6.GC 分代收集算法 VS 分区收集算法</h3><h4 id="1-6-1-分代收集算法-1-4-2-4中提到过，只做介绍，分析请看前文"><a href="#1-6-1-分代收集算法-1-4-2-4中提到过，只做介绍，分析请看前文" class="headerlink" title="1.6.1. 分代收集算法(1.4.2.4中提到过，只做介绍，分析请看前文)"></a>1.6.1. 分代收集算法(1.4.2.4中提到过，只做介绍，分析请看前文)</h4><p>​当前主流 VM 垃圾收集都采用”分代收集” (Generational Collection)算法, 这种算法会根据对象存活周期的不同将内存划分为几块, 如 JVM 中的 新生代、老年代、永久代， 这样就可以根据各年代特点分别采用最适当的 GC 算法</p><h5 id="1-6-1-1-在新生代-复制算法"><a href="#1-6-1-1-在新生代-复制算法" class="headerlink" title="1.6.1.1. 在新生代-复制算法"></a>1.6.1.1. 在新生代-复制算法</h5><p>​每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集.</p><h5 id="1-6-1-2-在老年代-标记整理算法"><a href="#1-6-1-2-在老年代-标记整理算法" class="headerlink" title="1.6.1.2. 在老年代-标记整理算法"></a>1.6.1.2. 在老年代-标记整理算法</h5><p>​因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标记—整理” 算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存.</p><h4 id="1-6-2-分区收集算法"><a href="#1-6-2-分区收集算法" class="headerlink" title="1.6.2. 分区收集算法"></a>1.6.2. 分区收集算法</h4><h5 id="分区收集算法产生背景："><a href="#分区收集算法产生背景：" class="headerlink" title="分区收集算法产生背景："></a>分区收集算法产生背景：</h5><p>在垃圾回收过程中，应用软件将处于一种Stop the World 的状态。在Stop the Word 状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成，如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。</p><p>​分区算法则<u>将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收</u>.减少应用程序被挂起的时间 </p><p>​这样做的好处是可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是整个堆), 从而减少一次 GC 所产生的停顿。</p><p>由于分块进行垃圾回收，会导致额外的管理开销。</p><h3 id="1-7-GC-垃圾收集器"><a href="#1-7-GC-垃圾收集器" class="headerlink" title="1.7.GC 垃圾收集器"></a>1.7.GC 垃圾收集器</h3><p>java 虚拟中针对新生代和年老代分别提供了多种不同的垃圾收集器， JDK1.6 中 Sun HotSpot 虚拟机的垃圾收集器如下：</p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730161121359.png" alt="image-20230730161121359" style="zoom: 40%;" /><h4 id="1-7-1-Serial-垃圾收集器（单线程、-复制算法）"><a href="#1-7-1-Serial-垃圾收集器（单线程、-复制算法）" class="headerlink" title="1.7.1. Serial 垃圾收集器（单线程、 复制算法）"></a>1.7.1. Serial 垃圾收集器（单线程、 复制算法）</h4><p>​Serial 是最基本垃圾收集器，使用复制算法，曾经是JDK1.3.1 之前新生代唯一的垃圾收集器。 Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，<u>对于限定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率</u>，因此 Serial垃圾收集器依然是 <u>java 虚拟机运行在 <strong>Client 模式</strong>下默认的新生代垃圾收集器。</u></p><h4 id="1-7-2-ParNew-垃圾收集器（Serial-多线程）"><a href="#1-7-2-ParNew-垃圾收集器（Serial-多线程）" class="headerlink" title="1.7.2. ParNew 垃圾收集器（Serial+多线程）"></a>1.7.2. ParNew 垃圾收集器（Serial+多线程）</h4><p>​ParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了<strong>使用多线程进行垃圾收集之外</strong>，其余的行为和 Serial 收集器完全一样， ParNew 垃圾收集器在垃圾收集过程中<u>同样也要暂停<strong>所有</strong>其他的工作线程。</u></p><p>​ParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过-XX:ParallelGCThreads 参数来限制垃圾收集器的线程数。ParNew 虽然是除了多线程外和Serial 收集器几乎完全一样，但是ParNew垃圾收集器是很多 java虚拟机运行在 <u><strong>Server 模式</strong>下新生代的默认垃圾收集器。</u></p><h4 id="1-7-3-Parallel-Scavenge-收集器（多线程复制算法、高效）"><a href="#1-7-3-Parallel-Scavenge-收集器（多线程复制算法、高效）" class="headerlink" title="1.7.3. Parallel Scavenge 收集器（多线程复制算法、高效）"></a>1.7.3. Parallel Scavenge 收集器（多线程复制算法、高效）</h4><p>​Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器， 它重点关注的是程序达到一个可控制的吞吐量（Thoughput， CPU 用于运行用户代码的时间&#x2F;CPU 总消耗时间，即吞吐量&#x3D;运行用户代码时间&#x2F;(运行用户代码时间+垃圾收集时间)），<strong>高吞吐量</strong>可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要<u>适用于在后台运算而不需要太多交互的任务</u>。 自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个重要区别。</p><h4 id="1-7-4-Serial-Old-收集器（单线程标记整理算法-）"><a href="#1-7-4-Serial-Old-收集器（单线程标记整理算法-）" class="headerlink" title="1.7.4. Serial Old 收集器（单线程标记整理算法 ）"></a>1.7.4. Serial Old 收集器（单线程标记整理算法 ）</h4><p>​Serial Old 是 <strong>Serial 垃圾收集器年老代版本</strong>，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在 <u>Client端</u> 默认的 java 虚拟机默认的年老代垃圾收集器。</p><h4 id="1-7-5-Parallel-Old-收集器（多线程标记整理算法）"><a href="#1-7-5-Parallel-Old-收集器（多线程标记整理算法）" class="headerlink" title="1.7.5. Parallel Old 收集器（多线程标记整理算法）"></a>1.7.5. Parallel Old 收集器（多线程标记整理算法）</h4><p>​Parallel Old 收集器是<strong>Parallel Scavenge的年老代版本</strong>，使用多线程的标记-整理算法，在 JDK1.6才开始提供。在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量， Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器， <u>如果系统对吞吐量要求比较高，可以优先考虑新生代 Parallel Scavenge和年老代 Parallel Old 收集器的搭配策略。</u></p><h4 id="1-7-6-CMS-收集器（多线程标记清除算法）"><a href="#1-7-6-CMS-收集器（多线程标记清除算法）" class="headerlink" title="1.7.6. CMS 收集器（多线程标记清除算法）"></a>1.7.6. CMS 收集器（多线程标记清除算法）</h4><p>Concurrent mark sweep(CMS)收集器是一种<strong>年老代垃圾收集器</strong>，其最主要目标是获取<u>最短垃圾回收停顿时间</u>， 和其他年老代使用标记-整理算法不同，它<u>使用多线程的标记-清除算法</u>。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段：</p><h5 id="1-7-6-1-初始标记"><a href="#1-7-6-1-初始标记" class="headerlink" title="1.7.6.1. 初始标记"></a>1.7.6.1. 初始标记</h5><p>​只是标记一下 GC Roots <u>能直接关联的对象</u>，速度很快，仍然<u>需要暂停所有的工作线程</u>。</p><h5 id="1-7-6-2-并发标记"><a href="#1-7-6-2-并发标记" class="headerlink" title="1.7.6.2. 并发标记"></a>1.7.6.2. 并发标记</h5><p>​进行 GC Roots 跟踪的过程，和用户线程一起工作，<u>不需要暂停工作线程</u>。</p><h5 id="1-7-6-3-重新标记"><a href="#1-7-6-3-重新标记" class="headerlink" title="1.7.6.3. 重新标记"></a>1.7.6.3. 重新标记</h5><p>​为了<u>修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录</u>，仍然<u>需要暂停所有的工作线程</u>。</p><h5 id="1-7-6-4-并发清除"><a href="#1-7-6-4-并发清除" class="headerlink" title="1.7.6.4. 并发清除"></a>1.7.6.4. 并发清除</h5><p>​清除 GC Roots 不可达对象，和用户线程一起工作，<u>不需要暂停工作线程</u>。**<u>由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作， 所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。</u>**</p><h4 id="2-7-7-G1-收集器"><a href="#2-7-7-G1-收集器" class="headerlink" title="2.7.7. G1 收集器"></a>2.7.7. G1 收集器</h4><p>—CMS收集器的升级版</p><p>Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器， G1 收集器两个最突出的改进是：</p><pre><code>1. **基于标记-整理算法，不产生内存碎片。**1. 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。G1 收集器避免全区域垃圾收集，它&lt;u&gt;把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间， 优先回收垃圾最多的区域。&lt;/u&gt;区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率</code></pre><h3 id="1-8-JAVA-IO-x2F-NIO"><a href="#1-8-JAVA-IO-x2F-NIO" class="headerlink" title="1.8. JAVA IO&#x2F;NIO"></a>1.8. JAVA IO&#x2F;NIO</h3><h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><h2 id="https-docs-oracle-com-en-java-javase-17-docs-api"><a href="#https-docs-oracle-com-en-java-javase-17-docs-api" class="headerlink" title="https://docs.oracle.com/en/java/javase/17/docs/api/"></a><a href="https://docs.oracle.com/en/java/javase/17/docs/api/">https://docs.oracle.com/en/java/javase/17/docs/api/</a></h2><h2 id="Java的基本程序设计结构"><a href="#Java的基本程序设计结构" class="headerlink" title="Java的基本程序设计结构"></a>Java的基本程序设计结构</h2><h3 id="3-1一个简单的java程序"><a href="#3-1一个简单的java程序" class="headerlink" title="3.1一个简单的java程序"></a>3.1一个简单的java程序</h3><p>​java编译器对.java文件进行编译(javac 类名.java)，生成对应的.class文件；&#x2F;&#x2F;通过javac工具编译  .class文件中存的是字节码</p><p>​使用java命令运行.class文件(java 类名)*无后缀名！！  &#x2F;&#x2F;jvm只能理解.class文件中的内容 即字节码</p><p>.java -&gt; .class 这个过程使用 javac 是<strong>编译</strong>(一次性将代码转换为字节码)</p><p>.class -&gt; 机器码(直接被cpu执行) 这个过程由JVM逐句<strong>解释</strong></p><p>​java中使用方法的语法为：</p><ul><li>object.method.(parameters…);</li></ul><h3 id="3-2注释"><a href="#3-2注释" class="headerlink" title="3.2注释"></a>3.2注释</h3><ul><li><ol><li>&#x2F;&#x2F;</li></ol></li><li><ol start="2"><li>&#x2F;*    *&#x2F;</li></ol></li><li><ol start="3"><li>&#x2F;**</li></ol></li><li>​          *</li><li>​          *</li><li>​          *&#x2F;</li></ul><h3 id="3-3数据类型"><a href="#3-3数据类型" class="headerlink" title="3.3数据类型"></a>3.3数据类型</h3><h4 id="八大基本数据类型"><a href="#八大基本数据类型" class="headerlink" title="八大基本数据类型"></a>八大基本数据类型</h4><table><thead><tr><th align="center">类型</th><th align="center">存储需求</th><th align="center">取值范围</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">4字节</td><td align="center">-2147483648～2147483647(略高于20亿)</td></tr><tr><td align="center">short</td><td align="center">2字节</td><td align="center">-32768～32767</td></tr><tr><td align="center">long</td><td align="center">8字节</td><td align="center">-9223372036854775808～9223372036854775807</td></tr><tr><td align="center">byte</td><td align="center">1字节</td><td align="center">-128～127</td></tr><tr><td align="center">float</td><td align="center">4字节</td><td align="center">正负3.4*10^38       6~7位有效数字</td></tr><tr><td align="center">double</td><td align="center">8字节</td><td align="center">正负1.79*10^308     15位有效数字</td></tr><tr><td align="center">char</td><td align="center">2字节</td><td align="center">0～65535</td></tr><tr><td align="center">boolean</td><td align="center">boolean变量：4字节(底层使用int)<br />boolean数组中：1字节(底层使用Byte)</td><td align="center">true、fasle</td></tr></tbody></table><p>*我们可以为数字字面量添加下划线(方便看) 如：1_000_000 表示100万  —-&gt;  编译器会自动去除下划线</p><ul><li><p>java中没有无符号数的说法——都是(正)(负+1)参半</p></li><li><p>默认的小数为double类型</p></li><li><p>浮点类型的数据运算一定会带来误差 (我们需要谨慎对浮点数进行 &#x3D;&#x3D; 、 !&#x3D; 操作) </p><p>——根本原因是浮点数采用二进制表示，二进制系统中无法精确地表示分数1&#x2F;10，因此除了二进制能完全表示的数字，都会产生误差</p><p><strong>🌟同样，我们不要在for循环、while循环中使用浮点数作为我们的计数器，如果以 &#x3D;&#x3D; 为终止条件的话，会导致循环无法终止🌟</strong></p></li></ul><h4 id="Unicode转义序列："><a href="#Unicode转义序列：" class="headerlink" title="Unicode转义序列："></a>Unicode转义序列：</h4><p>​\uxxxx (\u+Unicode序号，4位16进制数)可以用这种形式来表示字符</p><p><strong>Unicode转义序列会在解析代码之前处理：</strong>编译器会<strong>先</strong>将转义序列变为对应的字符，再进行编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java中不建议使用char类型数据，为什么呢？</span><br><span class="line"></span><br><span class="line">其实，1个java的char字符并不完全等于一个unicode的字符。char采用的UCS-2编码，是一种淘汰的UTF-16编码，编码方式最多有65536种，远远少于当今Unicode拥有11万字符的需求。java只好对后来新增的Unicode字符用2个char拼出1个Unicode字符。导致String中char的数量不等于unicode字符的数量。 </span><br><span class="line">然而，大家都知道，char在Oracle中，是固定宽度的字符串类型（即所谓的定长字符串类型），长度不够的就会自动使用空格补全。因此，在一些特殊的查询中，就会导致一些问题，而且这种问题还是很隐蔽的，很难被开发人员发现。一旦发现问题的所在，就意味着数据结构需要变更，可想而知，这是多么大的灾难啊。 </span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>Java 基本数据类型的**<u>包装类型</u><strong>的大部分都用到了</strong><u>缓存机制</u>**来提升性能。</p><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <u><strong>[-128，127]</strong></u> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong><u>[0,127]</u></strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><hr><h3 id="3-4变量与常量"><a href="#3-4变量与常量" class="headerlink" title="3.4变量与常量"></a>3.4变量与常量</h3><h4 id="变量命名要求："><a href="#变量命名要求：" class="headerlink" title="变量命名要求："></a>变量命名要求：</h4><p>​由字母、数字、_、各种货币符号($ 一般用于系统工具生成变量的名)</p><p>​第一个字符不能是数字</p><p>​不能使用关键字、保留字作为变量名</p><p>​不能含空格</p><ul><li><strong>java10开始，如果可以从变量的初始值推断出它的类型，就不需要声明类型，使用     var   即可。</strong></li></ul><h4 id="常量："><a href="#常量：" class="headerlink" title="常量："></a>常量：</h4><p>​被final修饰的变量，表示变量<strong>只能被赋值一次</strong>，一旦赋值就不能再更改了。</p><p>​常量命名规范：常量名全部大写！</p><p>我们在开发过程中，可能需要创建一个常量(类常量)以便在类中多个方法中使用   如：static final int CONSTANT &#x3D; 1；<br>如果类常量为 public 那么常量也可以被其他类使用，我们可以在开发中单独创建一个类来存放格中常量！</p><p>​枚举类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    SMALL,</span><br><span class="line">    MEDIUM,</span><br><span class="line">    LARGE</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Size</span> <span class="variable">size</span> <span class="operator">=</span> Size.MEDIUM;</span><br><span class="line">        System.out.println(size);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-5运算符"><a href="#3-5运算符" class="headerlink" title="3.5运算符"></a>3.5运算符</h3><p>​在源文件开头加入 <strong>import static java.lang.Math.</strong>* 之后就能直接使用Math工具类中的常量与方法了(无需前缀Math.)</p><h4 id="数据类型转换："><a href="#数据类型转换：" class="headerlink" title="数据类型转换："></a>数据类型转换：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">无精度损失的转换：</span><br><span class="line"><span class="comment">//byte -&gt; short -&gt; int -&gt; long</span></span><br><span class="line"><span class="comment">//float -&gt; double</span></span><br><span class="line"><span class="comment">//int -&gt; double</span></span><br><span class="line"><span class="comment">//char -&gt; int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">有精度损失的转换：</span><br><span class="line"><span class="comment">//int -&gt; float</span></span><br><span class="line"><span class="comment">//long -&gt; float</span></span><br><span class="line"><span class="comment">//long -&gt; double</span></span><br></pre></td></tr></table></figure><p>!!!! int类型变量 <strong>不能</strong> 转成 char</p><p>数据类型转换有精度损失是因为：浮点型数据的存储方式为：符号+指数部分+数值部分，</p><p><strong>int、long的数值部分多于float中能够表示的位数，因此造成精度损失</strong>(因为float存储时会把数字变为1.xxx ✖️2的xx次方的形式)</p><ul><li>运算时，如果运算符两边的类型不同，则 有浮点数，则会转成出现过的精度最大的浮点数，没有浮点数，优先long，long也没出现过，则默认都转为int(即使是byte + short)</li></ul><p>int x +&#x3D; 1.45 ———&gt; 正确，因为原式： x&#x3D;(int)(x + 1.45)</p><p>int x &#x3D; x + 1.45 ——&gt; 错误</p><p>java中，赋值是一个表达式，赋值语句的值为变量被赋的那个值 </p><p>​如：int y &#x3D; x &#x3D; 5;  —–&gt;  结果是：y &#x3D; 5;</p><p>+&#x3D;等有‘&#x3D;‘的运算符都是右结合运算符，</p><p>​    即 a+&#x3D;b+&#x3D;c  &lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; a+&#x3D;(b+&#x3D;c)</p><h3 id="3-6字符串"><a href="#3-6字符串" class="headerlink" title="3.6字符串"></a>3.6字符串</h3><h4 id="字符串不可变："><a href="#字符串不可变：" class="headerlink" title="字符串不可变："></a>字符串不可变：</h4><p>​我们不能修改String对象中的某个字符，只能将指向某个String对象的引用指向新的String对象来实现对用户而言的修改字符串。</p><p>​由于java中修改字符串需要重新创建一个字符串，如果修改后的字符串不存在，那么需要重新创建(效率很低)，</p><p>但是不可变字符串有一个很大的优点：<strong>编译器可以让字符串共享</strong>！</p><p>​java设计者认为：共享带来的高效率远超过编辑字符串带来的低效率</p><h4 id="检测字符串相等："><a href="#检测字符串相等：" class="headerlink" title="检测字符串相等："></a>检测字符串相等：</h4><p>​java中 仅仅是字符串字面量才实现了共享 (而+或substring得到的字符串并不共享)，因此我们需要经由String类重写的equals()方法判断字符串相等，而不是‘&#x3D;&#x3D;’</p><h4 id="String-API："><a href="#String-API：" class="headerlink" title="String API："></a>String API：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在java.lang.String包中</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String other)</span>;<span class="comment">//如果字符串位于other(小于other),则返回一个负数，相等返回0,...</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;<span class="comment">//判断是否为空字符串“”</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isBlank</span><span class="params">()</span>;<span class="comment">//判断是否为空字符串 或 只由空格组成！</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><h4 id="构建字符串："><a href="#构建字符串：" class="headerlink" title="构建字符串："></a>构建字符串：</h4><p>​如果需要使用许多短字符串构建一个长字符串，如果使用String类型，会导致每次拼接字符串都创建一个新的String对象—–耗时+耗空间(原理是会创建一个StringBuilder，使用append，再使用toString，在java9之后进行了优化，所以也可以尽情使用+了)</p><p>​我们可以使用StringBuilder&#x2F;Buffer(字符串构造器)类避免此类问题！</p><p>以下两个API作用相同</p><p>​· StringBuilder只适合单线程情况，但效率高</p><p>​· StringBuffer是线程安全的</p><h4 id="文本块："><a href="#文本块：" class="headerlink" title="文本块："></a>文本块：</h4><p>​可以容易地提供跨多行的字符串字面量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">hello</span></span><br><span class="line"><span class="string">world!</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">//文本块适合包含用其他语言编写的代码，如 SQL 和 HTML 代码</span></span><br></pre></td></tr></table></figure><hr><h4 id="String-s1-x3D-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#String-s1-x3D-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？"></a>String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</h4><p>​1、如果字符串**常量池中不存在字符串对象“abc”<u>的引用</u>**，那么会在堆中创建 2 个字符串对象“abc”。</p><p>​2、如果字符串**常量池中已存在字符串对象“abc”<u>的引用</u>**，则只会在堆中创建 1 个字符串对象“abc”。</p><hr><h3 id="String-intern-方法有什么作用"><a href="#String-intern-方法有什么作用" class="headerlink" title="String#intern 方法有什么作用?"></a>String#intern 方法有什么作用?</h3><p>​<code>String.intern()</code> 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p><ul><li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li><li>如果字符串常量池中没有保存对应的字符串对象的引用，那就在<strong>常量池中创建一个</strong>指向该字符串对象的引用并返回。</li></ul><hr><p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p><h3 id="3-7输入与输出"><a href="#3-7输入与输出" class="headerlink" title="3.7输入与输出"></a>3.7输入与输出</h3><h4 id="读取输入："><a href="#读取输入：" class="headerlink" title="读取输入："></a>读取输入：</h4><p>​1.构造与”标准输入流” System.in 关联的Scanner对象</p><p>​Scanner in &#x3D; new Scanner(System.in);</p><p>​2.现在，可以使用Scanner类的in对象来调用Scanner类中的各种API来读取输入了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in java.util.Scanner</span></span><br><span class="line">nextLine() <span class="comment">//read hole line</span></span><br><span class="line">next()     <span class="comment">//read a word </span></span><br><span class="line">nextInt()  <span class="comment">//read an Integer</span></span><br><span class="line"><span class="comment">//so as nextDouble() and so on...</span></span><br></pre></td></tr></table></figure><h4 id="格式化输出："><a href="#格式化输出：" class="headerlink" title="格式化输出："></a>格式化输出：</h4><p>​通过 System.out.<strong>printf</strong>() 方法 来自行定制输出的特殊需求</p><h4 id="文件输入与输出："><a href="#文件输入与输出：" class="headerlink" title="文件输入与输出："></a>文件输入与输出：</h4><p>​<strong>it’s wise to 根据文件的编码类型选择响应的编码方式，如果不填会使用主机的默认编码，这可能导致错误</strong></p><h5 id="文件输入："><a href="#文件输入：" class="headerlink" title="文件输入："></a>文件输入：</h5><p>​Scanner in &#x3D; new Scanner(Path.of(“the path of file”), StandardCharsets.UTF_8);</p><h5 id="文件写入："><a href="#文件写入：" class="headerlink" title="文件写入："></a>文件写入：</h5><p>​我们需要构造PrintWriter对象：</p><p>​PrintWriter out &#x3D; new PrintWriter(“myfile.txt”, StandardCharsets.UTF_8);&#x2F;&#x2F;没有该文件就会自动创建这个名字的文件<br>​输出就out.println(“”)这种就可以了！</p><ul><li><p>如果使用了相对路径，那么文件将相对于<strong>启动java虚拟机的那个目录放置</strong>，</p><p>——————我们可以使用命令找到这个目录的位置：String dir &#x3D; System.getProperty(“user.dir”);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.util.Scanner</span></span><br><span class="line">Scanner(Path p, String encoding);<span class="comment">//构造一个Scanner，其使用给定的编码方式从给定路径读取数据</span></span><br><span class="line"></span><br><span class="line">Scanner(String data);<span class="comment">//从给定的字符串中读取数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//java.io.PrintWriter</span></span><br><span class="line">PrintWriter(String fileName);<span class="comment">//构造一个PrintWriter，将数据写入指定文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//java.nio.file.Path</span></span><br><span class="line"><span class="keyword">static</span> Path <span class="title function_">of</span><span class="params">(String pathname)</span>;<span class="comment">//由给定路径构造一个Path对象</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-8控制流程"><a href="#3-8控制流程" class="headerlink" title="3.8控制流程"></a>3.8控制流程</h3><p>​switch语句会从与选项值相匹配的case标签开始执行，<strong>直到遇到下一个break语句结束</strong>。——–穿透性！</p><p>​switch表达式中 1.case后以：结尾，则为直通式switch  2.case后以-&gt;结尾，则为非直通式switch</p><p>​switch有<strong>语句形式</strong>(如果怎么样，就做什么操作)和<strong>表达式形式</strong>(如果怎么样，就返回什么值)</p><p>​性能比较：实现同样的功能时，<strong>switch表达式的性能优于switch语句</strong></p><h3 id="3-9大数"><a href="#3-9大数" class="headerlink" title="3.9大数"></a>3.9大数</h3><p>BigInteger和BigDecimal类可以处理任意长度的数字数列的数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.math.BigInteger</span></span><br><span class="line"><span class="comment">//⬇️实现大数的基本操作，包括开方、取模、比较等操作</span></span><br><span class="line">BigInteger add/subtract/multiply/divide/mod/sqrt/compareTo(BigInteger other);</span><br><span class="line"><span class="keyword">static</span> BigInteger <span class="title function_">valueOf</span><span class="params">(<span class="type">long</span> x)</span>; 将整数类型转换为大数</span><br><span class="line">  <span class="keyword">static</span> BigInteger <span class="title function_">valueOf</span><span class="params">(String str)</span>; 将String类型转换为大数</span><br><span class="line"></span><br><span class="line"><span class="comment">//java.math.BigDecimal</span></span><br><span class="line">  <span class="keyword">static</span> BigDecimal <span class="title function_">valueOf</span><span class="params">(String str)</span>; 将String类型转换为大数</span><br><span class="line">    🌟使用BigDecimal类时，我们应当总是使用 带字符串的构造器生成大数</span><br></pre></td></tr></table></figure><h3 id="3-10数组"><a href="#3-10数组" class="headerlink" title="3.10数组"></a>3.10数组</h3><h4 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组:"></a>声明数组:</h4><p>​可以使用 int[] arr &#x3D; {1,2,3,4};</p><p>​而不必 int[]arr &#x3D; new int[] {1,2,3,4};</p><h4 id="数组拷贝："><a href="#数组拷贝：" class="headerlink" title="数组拷贝："></a>数组拷贝：</h4><h5 id="Arrays-copy-的使用"><a href="#Arrays-copy-的使用" class="headerlink" title="Arrays.copy()的使用"></a><strong>Arrays.copy()的使用</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.使用Arrays.copy(原数组，原数组的前n位 如果n &gt; 原数组长度，则不够的补默认值)返回一个新的数组</span></span><br></pre></td></tr></table></figure><h5 id="System-arraycopy-的使用"><a href="#System-arraycopy-的使用" class="headerlink" title="System.arraycopy()的使用"></a>System.arraycopy()的使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>      src      the source array. 源数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>      srcPos   starting position in the source array. 源数组的起始位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>      dest     the destination array. 目标数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>      destPos  starting position in the destination data. 目标数组的起始位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>      length   the number of array elements to be copied. 复制的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">arraycopy(Object src,<span class="type">int</span> srcPos,Object dest, <span class="type">int</span> destPos, <span class="type">int</span> length)；</span><br></pre></td></tr></table></figure><ul><li>多维数组中的每个元素都是一个数组，因而多维数组的各个元素的结构不必相同，例如二维数组每行的长度可以不相同！</li></ul><p>​</p><h2 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h2><h3 id="4-1面向对象程序设计概述"><a href="#4-1面向对象程序设计概述" class="headerlink" title="4.1面向对象程序设计概述"></a>4.1面向对象程序设计概述</h3><h4 id="OOP三大特性："><a href="#OOP三大特性：" class="headerlink" title="OOP三大特性："></a>OOP三大特性：</h4><h5 id="封装："><a href="#封装：" class="headerlink" title="封装："></a>封装：</h5><p>​将数据和行为组合在一个包中，并对对象的使用者隐藏具体的实现细节。</p><h5 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h5><p>​通过扩展一个类来得到另外一个类</p><h5 id="多态："><a href="#多态：" class="headerlink" title="多态："></a>多态：</h5><p>​</p><h4 id="对象的三个特性："><a href="#对象的三个特性：" class="headerlink" title="对象的三个特性："></a>对象的三个特性：</h4><ul><li>behavior：可以对对象做哪些操作</li><li>state：对象保存着当前状态的信息；⚠️<strong>对象的状态只能通过调用方法而改变</strong>，否则就违背了类的<strong>封装性</strong></li><li>identity：用于区分具有相同行为和状态的不同对象</li></ul><h3 id="4-2使用预定义类"><a href="#4-2使用预定义类" class="headerlink" title="4.2使用预定义类"></a>4.2使用预定义类</h3><p>使用 对象变量 引用 实际创建对象的空间</p><ul><li>java中<strong>所有对象都存储在堆中</strong>，当一个对象包含另一对象变量时，它只是包含了另一个堆中对象的指针。</li></ul><p><strong><u>访问器</u>方法</strong>：只访问对象而不修改对象的方法比如LocalDate的plusDays方法，会创建一个新的对象而不是在原对象上修改</p><p><strong><u>更改器</u>方法</strong>：会修改对象的状态的方法</p><h3 id="4-3自定义类"><a href="#4-3自定义类" class="headerlink" title="4.3自定义类"></a>4.3自定义类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译流程：当编译器发现EmployeeTest.java中使用了Employee类时，它会查找名为Employee.class的.class文件，如果没有找到，则会自动搜索Employee.java文件并对其进行编译(编译成.class文件)</span></span><br></pre></td></tr></table></figure><p> Java10 及以后，可以使用var声明局部变量(if 等号右边的数据类型很明确)    这很方便(减少了写类名的次数)</p><h4 id="null引用："><a href="#null引用：" class="headerlink" title="null引用："></a>null引用：</h4><p>​对于自定义类中的参数，如果含有对象引用，我们在设计类时就应当明确是否能接受该引用值为null的情况(因为若对象引用为null可能造成NullPointerException异常，而我们不容易察觉出错的原因)，如果我们明确地希望对象引用不为null，我们可以使用以下两种方法：</p><p>以对象引用“name”为例：</p><ul><li>name &#x3D; Objects.requireNonNullElse(n, “unknown”)&#x2F;&#x2F;n为构造器中对应的形参 ，这种方式构造出的对象的name如果为null，会有默认值“unknown”</li><li>name &#x3D; Objects.requireNonNull(n, “The name cannot be null”);     &#x2F;&#x2F;这种方式在构造出name &#x3D; null的对象时会抛出异常，明确指出该问题</li></ul><h4 id="隐式参数与显式参数："><a href="#隐式参数与显式参数：" class="headerlink" title="隐式参数与显式参数："></a>隐式参数与显式参数：</h4><p>​对于类中的一个方法，它含有隐式参数和显式参数两种参数，显式参数及我们常写的形参；<strong>隐式参数</strong>是方法的调用者&#x2F;接收者，在每一个方法中，关键词this指示隐式参数。</p><h4 id="final字段："><a href="#final字段：" class="headerlink" title="final字段："></a>final字段：</h4><p>必须在构造对象时初始化</p><p><strong>如果final修饰了一个引用变量，那么该变量指向的地址不会改变，但是该地址表示的对象空间中的内容是可以改变的！</strong></p><p>例如final int[] arr； &#x2F;&#x2F;arr的地址不会变了，但是arr数组中的内容仍可变</p><h3 id="4-4静态字段和静态方法"><a href="#4-4静态字段和静态方法" class="headerlink" title="4.4静态字段和静态方法"></a>4.4静态字段和静态方法</h3><h4 id="静态字段："><a href="#静态字段：" class="headerlink" title="静态字段："></a>静态字段：</h4><p>​类中的静态字段只有一个副本</p><p>​<strong>静态字段属于类</strong>而不与对象相关！</p><p>​System类中的 out 就是一个静态的字段(类型为 PrintStream )</p><h4 id="静态方法："><a href="#静态方法：" class="headerlink" title="静态方法："></a>静态方法：</h4><p>​静态方法是<strong>不操作对象</strong>的方法( 换句话说，静态方法中没有隐式参数！)</p><p>​只能调用静态字段</p><h4 id="工厂方法："><a href="#工厂方法：" class="headerlink" title="工厂方法："></a>工厂方法：</h4><p>​可以使用静态方法作为工厂方法—-&gt;通过该方法而不是构造器我们也可以创建对象</p><p>​好处：因为我们可以构造出其子类(构造器只能创建本类的对象)，并且如果使用静态方法就可以设置合适的名字与该子类的功能相吻合;</p><h3 id="4-5方法参数"><a href="#4-5方法参数" class="headerlink" title="4.5方法参数"></a>4.5方法参数</h3><h4 id="值调用-call-by-value"><a href="#值调用-call-by-value" class="headerlink" title="值调用(call by value)"></a>值调用(call by value)</h4><h4 id="引用调用-call-by-reference"><a href="#引用调用-call-by-reference" class="headerlink" title="引用调用(call by reference)"></a>引用调用(call by reference)</h4><p>​·方法接收调用者提供的变量位置</p><p>​本质是：方法创建了副本，副本保存了调用者提供的变量位置，与传入的实参指向了相同的位置(这里指的是对象的空间)</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<strong>因此！</strong>在方法中交换两个接收到的形参是不起作用的(对调用者无影响！)，<strong>因为交换的是副本</strong>！！&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>总结：</p><ul><li>方法不能修改基本数据类型的参数(因为是值调用!)</li><li>方法可以改变对象参数的状态(改变对象中的字段值 即 改变对象状态)</li><li>方法不能让一个对象参数引用一个新的对象(因为本质是副本指向了新的位置，而实参并未产生改变)</li></ul><h3 id="4-6对象构造"><a href="#4-6对象构造" class="headerlink" title="4.6对象构造"></a>4.6对象构造</h3><h4 id="重载："><a href="#重载：" class="headerlink" title="重载："></a>重载：</h4><p>​方法具有相同方法名但是有不同的参数</p><p>​在java中，(方法名+方法使用的参数)&#x3D;&#x3D;称为方法签名，可以唯一确定一个方法。而方法的返回值不属于方法签名，因此<strong>重载不能只是返回值不同</strong>(因为编译器无法分辨应当使用哪个方法)</p><h4 id="重写："><a href="#重写：" class="headerlink" title="重写："></a>重写：</h4><p>​重写发生在运行期，是子类对父类的<strong>允许访问的方法</strong>的实现过程进行重新编写。</p><ol><li><u>方法名、参数列表必须相同</u>，子类方法返回值类型应比父类方法返回值类型<u>更小或相等</u>，抛出的<u>异常范围小于等于父类</u>，<u>访问修饰符范围大于等于父类</u>。</li><li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><h4 id="默认字段初始化："><a href="#默认字段初始化：" class="headerlink" title="默认字段初始化："></a>默认字段初始化：</h4><p>​在对象创建时，如果构造器没有对某些字段赋值，那么这些字段将会被赋默认值(0、false、null)</p><h4 id="无参构造器："><a href="#无参构造器：" class="headerlink" title="无参构造器："></a>无参构造器：</h4><p>​如果你写的类<strong>没有构造器</strong>，系统会<strong>提供默认无参构造器</strong>，但是但凡你写了一个构造器，系统就不会为你提供默认无差构造器！</p><h4 id="显式字段初始化："><a href="#显式字段初始化：" class="headerlink" title="显式字段初始化："></a>显式字段初始化：</h4><p>​可以直接对类中的字符段赋值</p><h4 id="调用另一个构造器："><a href="#调用另一个构造器：" class="headerlink" title="调用另一个构造器："></a>调用另一个构造器：</h4><p>​可以**<u><em>在构造器的第一行添加this(参数名)来调用另一个构造器</em></u>**，这样就可以提取公共构造代码！</p><h4 id="初始代码块："><a href="#初始代码块：" class="headerlink" title="初始代码块："></a>初始代码块：</h4><p>​与初始化给定值平级，谁在后面听谁的</p><h4 id="对象的初始化流程："><a href="#对象的初始化流程：" class="headerlink" title="对象的初始化流程："></a>对象的初始化流程：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.在方法区加载该类的模块(该类第一次使用时)</span><br><span class="line">2.在堆中为对象分配内存空间(这时候会给属性赋默认值 0、null等)</span><br><span class="line">3.先显式初始化(定义属性时，给其赋的值)，再使用构造器初始化 (int a = 9;</span><br><span class="line">//先等于默认值0，再等于显式默认值9，再等于构造器中的非默认初始化值)</span><br><span class="line">===============此时等号右边的new结束==================</span><br><span class="line">4.再在栈中创建对象名(对象引用)，并指向栈中的空间 </span><br></pre></td></tr></table></figure><h3 id="4-7记录"><a href="#4-7记录" class="headerlink" title="4.7记录"></a>4.7记录</h3><h3 id="4-8包"><a href="#4-8包" class="headerlink" title="4.8包"></a>4.8包</h3><h3 id="4-9JAR文件"><a href="#4-9JAR文件" class="headerlink" title="4.9JAR文件"></a>4.9JAR文件</h3><h3 id="4-10文档注释"><a href="#4-10文档注释" class="headerlink" title="4.10文档注释"></a>4.10文档注释</h3><h3 id="4-11类设计技巧"><a href="#4-11类设计技巧" class="headerlink" title="4.11类设计技巧"></a>4.11类设计技巧</h3><p>hashmap初始大小为16 16个桶</p><p>只要有一个桶中元素到达8，则看看桶是否达到64，若没有，则桶数量翻倍，若有，则将链表转换成红黑树</p><p>hashmap中的总元素达到 负载因子*桶总数时，需要扩容</p><p>扩容为桶的数量*2，</p><p>10000 -&gt; 100000</p><p>如何获取元素在哪个桶中？</p><p>通过 10000 - 1 &#x3D; 01111 &amp;哈希值</p><p>再转回10进制得到下标</p><p>&#x2F;&#x2F;这就是hashmap的桶容量为2^4,并且每次扩容都是容量*2带来的好处！！！！！！！</p><p>扩容后的新下标也很容易获得：10000(原大小) &amp; hash &#x3D;&#x3D;&#x3D;&gt;若为0，则下标不变；为1则下标+&#x3D;原大小</p><h2 id="并发："><a href="#并发：" class="headerlink" title="并发："></a>并发：</h2><h3 id="12-1-什么是线程："><a href="#12-1-什么是线程：" class="headerlink" title="12.1.什么是线程："></a><u>12.1.什么是线程：</u></h3><ul><li><p>每个进程拥有各自的一套变量</p></li><li><p>一个程序可以运行多个线程，线程间共享数据</p></li></ul><p>​<strong>Runnable</strong>接口：需要实现run()方法，使用你希望执行的业务</p><p>​<strong>Thread</strong>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.lang.Thread类的重要信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Thread 类的构造函数，形参为一个Runnable类型的引用，用于得到thread对象</span></span><br><span class="line">Thread(Runnable target);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动线程，会自动调用run方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调动相关Runnable的被实现的run方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//休眠指定的毫秒数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span></span><br></pre></td></tr></table></figure><ul><li><strong>不要直接调用Thread或Runnable中的run方法，因为这样不会创建新的线程</strong></li><li><u><strong>应当创建Thread对象，运行其start方法来创建新的线程</strong></u></li></ul><h3 id="12-2-线程状态："><a href="#12-2-线程状态：" class="headerlink" title="12.2.线程状态："></a><u>12.2.线程状态：</u></h3><p>​线程可以有以下6种状态：</p><table><thead><tr><th>New(新建)</th><th>Runnable(可运行)</th><th>Blocked(阻塞)</th><th>Waiting(等待)</th><th>Time waiting(计时等待)</th><th>Terminated(终止)</th></tr></thead></table><h4 id="new："><a href="#new：" class="headerlink" title="new："></a>new：</h4><p>​new了Thread对象，仅此而已。</p><h4 id="Runnable："><a href="#Runnable：" class="headerlink" title="Runnable："></a>Runnable：</h4><p>​线程调用了start方法后，就会处于可运行状态。</p><h4 id="Blocked-and-Waiting-and-Time-waiting"><a href="#Blocked-and-Waiting-and-Time-waiting" class="headerlink" title="Blocked and Waiting and Time waiting:"></a>Blocked and Waiting and Time waiting:</h4><ul><li>当线程试图获取一个内部对象锁，而锁被其他线程占有时，线程**阻塞(Blocked)**，当所有其他线程都不占有这个锁&amp;线程调度器允许该线程持有这个锁时，变回Runnable状态。</li><li>当线程等待另一线程通知调度器出现某个条件时，该线程会进入**等待(Waiting)**状态。</li><li>某些方法设置了超时参数，调用这些方法会进入**计时等待(Time waiting)**状态，超时期满或收到适当的通知才会回到Runnable状态。</li></ul><h4 id="Terminated："><a href="#Terminated：" class="headerlink" title="Terminated："></a>Terminated：</h4><ul><li>线程正常执行完run方法，自然终止</li><li>线程在执行过程中出现了一个未捕获的异常，会导致线程意外终止</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.lang.Thread类中的相关方法</span></span><br><span class="line"><span class="comment">//使当前正在运行的线程向另一线程交出运行权</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//等待指定的线程终止</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//等待指定的线程终止,或等待经过指定的毫秒数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//获取线程的状态,取值为：New、Runnable、Blocked、Waiting、Time waiting、Terminated</span></span><br><span class="line">Thread.State <span class="title function_">getState</span><span class="params">()</span></span><br></pre></td></tr></table></figure><h3 id="12-3-线程属性"><a href="#12-3-线程属性" class="headerlink" title="12.3.线程属性"></a><u>12.3.线程属性</u></h3><h4 id="中断线程：-线程的一个属性——中断状态"><a href="#中断线程：-线程的一个属性——中断状态" class="headerlink" title="中断线程：(线程的一个属性——中断状态)"></a>中断线程：(线程的一个属性——中断状态)</h4><p>​每个线程都有一个<strong>中断状态属性</strong>(boolean类型),每个线程都应该不时地检查这个属性，以判断线程是否被中断</p><p>​如果在一个<strong>被sleep或wait方法调用阻塞的线程</strong>调用了interrupt方法(设置中断状态)，<br>​那么<strong>该线程的阻塞调用将被InterruptedException异常中断</strong>。</p><p>​如果线程设置了中断**(中断状态为true)<strong>后我们使用sleep等方法调用阻塞，实际上会</strong>清除中断状态(将中断状态置为false)**并抛出InterruptedException异常，<u>因此如果我们需要对此情况进行处理，我们需要对InterruptedException异常进行捕获，而不是检查中断状态</u></p><p>🌟如果我们想让线程的调用者察觉到⬆️上面情况的发生，有2种方式：</p><ul><li>catch InterruptedException异常后，将中断状态再次设置为true(实际上多此一举，因此推荐下面的方法)</li><li>throw InterruptedException 异常即可，调用者再try-catch即可捕获异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.lang.Thread类中的相关方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//向线程发送中断请求，线程的中断状态将被设置为true，此时如果线程已经被sleep方法调用阻塞，将会抛出InterruptedException异常</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//测试当前进程是否被中断——静态方法——会将当前线程的中断状态重制为false！！！</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//测试当前进程是否被中断————不会改变线程的中断状态！</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//返回当前正在执行的线程的Thread对象</span></span><br><span class="line"><span class="keyword">static</span> Thread <span class="title function_">currentThread</span><span class="params">()</span></span><br></pre></td></tr></table></figure><h4 id="守护线程-daemon-thread-："><a href="#守护线程-daemon-thread-：" class="headerlink" title="守护线程(daemon thread)："></a>守护线程(daemon thread)：</h4><ul><li>**可以通过调用 线程名.setDaemon(true)**将一个线程转换为守护线程</li></ul><p>​守护线程用于为其他线程提供服务，如：计时器线程、清空过时缓存项的线程</p><p>​当只剩下守护线程时，虚拟机会退出</p><h4 id="线程名："><a href="#线程名：" class="headerlink" title="线程名："></a>线程名：</h4><ul><li>可以通过 <strong>对象名.setName(“new name”)</strong> 对创建的线程对象进行重命名     ————在线程转储时可能有大用处</li></ul><p>​线程有默认的名字：Thread-1等</p><h4 id="未捕获异常的处理器："><a href="#未捕获异常的处理器：" class="headerlink" title="未捕获异常的处理器："></a>未捕获异常的处理器：</h4><p>​线程有以下两个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> UncaughtExceptionHandler uncaughtExceptionHandler;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> UncaughtExceptionHandler defaultUncaughtExceptionHandler;</span><br></pre></td></tr></table></figure><p>我们可以通过 </p><ul><li><p><strong>Static</strong> void <strong>setDefaultUncaughtExceptionHandler</strong>(Thread.UncaughtExceptionHandler handler)<br>来为所有线程设置默认的未捕获异常的处理器</p></li><li><p>void **setUncaughtExceptionHandler(**Thread.UncaughtExceptionHandler handler)</p><p>来为某个线程对象设置未捕获异常的处理器</p></li></ul><p>注意：</p><p>​1.<strong>uncaughtExceptionHandler优先级 高于 defaultUncaughtExceptionHandler</strong></p><p>​2.传入的handler是实现了Thread.UncaughtExceptionHandler接口中uncaughtException方法的对象，即我们可以自定义未捕获异常的处理器，在set进线程的对应属性里面即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> UncaughtExceptionHandler <span class="title function_">getDefaultUncaughtExceptionHandler</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> defaultUncaughtExceptionHandler;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> UncaughtExceptionHandler <span class="title function_">getUncaughtExceptionHandler</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> uncaughtExceptionHandler != <span class="literal">null</span> ? uncaughtExceptionHandler : group;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程先找自己的<strong>uncaughtExceptionHandler</strong>，若不是null，就用它<br>若是null，则查看该线程所在的group是否实现了Thread.UncaughtExceptionHandler接口中uncaughtException方法，若实现了，就用它否则使用线程的 <strong><u>default</u>UncaughtExceptionHandler</strong>，若不为null，就用它<br>否则将信息输出到System.err中</p><h4 id="线程优先级："><a href="#线程优先级：" class="headerlink" title="线程优先级："></a>线程优先级：</h4><p>​最高优先级为10；</p><p>​最低优先级为1；</p><p>​默认优先级为5；</p><p>可以通过 setPriority(int newPriority)来自行设置线程的优先级</p><h3 id="12-4-同步："><a href="#12-4-同步：" class="headerlink" title="12.4.同步："></a><u>12.4.同步：</u></h3><p>​两个或以上的线程需要共享存取相同的数据，当多个线程对同一数据进行修改，会导致线程相互覆盖(这种情况称为 竞态条件)</p><ul><li><strong>临界区</strong>：是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段，而这些共用资源又无法同时被多个线程访问。</li></ul><h4 id="为了防止并发访问-java提供了两种机制："><a href="#为了防止并发访问-java提供了两种机制：" class="headerlink" title="为了防止并发访问 java提供了两种机制："></a><em>为了防止并发访问 java提供了两种机制：</em></h4><h5 id="1-Lock-Condition-锁对象-条件对象"><a href="#1-Lock-Condition-锁对象-条件对象" class="headerlink" title="1.Lock+Condition(锁对象+条件对象)"></a>1.Lock+Condition(锁对象+条件对象)</h5><h6 id="ReentrantLock类-重入锁-："><a href="#ReentrantLock类-重入锁-：" class="headerlink" title="ReentrantLock类(重入锁)："></a>ReentrantLock类(重入锁)：</h6><p>​重入锁：线程可以重复获取已经获得的锁(通过一个计数变量实现：反复获取一次计数+1，释放则-1，</p><p>​因此计数为0时，表示线程释放了锁)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以在需要上锁的类中添加ReentrantLock对象  Lock k = new ReentrantLock();</span></span><br><span class="line"><span class="comment">//在需要上锁的方法开始前先用此对象获取锁       k.lock()  </span></span><br><span class="line"><span class="comment">//在执行临界区代码：                        try&#123;临界区代码后&#125;finally&#123;k.unlock();&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>必须把 unlock放在finally中，防止临界区代码抛出异常程序终止，导致锁永不被释放</p></li><li><p>注意不能由于抛出异常而绕过临界区的代码(指临界区中产生异常，我们将其抛出至调用者的话，就不会再执行临界区中没走完的代码，即绕过临界区的代码块),因为如果绕过，对象可能处于被破坏的状态(操作做一半未完成)</p></li></ul><h6 id="条件对象："><a href="#条件对象：" class="headerlink" title="条件对象："></a>条件对象：</h6><p>当线程需要满足某些条件才能进入需要锁的临界区时，可能会发生这样的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 线程A满足了条件，下一条语句就是获取锁进入临界区</span><br><span class="line">2. 线程B修改了线程A中的某些值，导致线程A不满足条件</span><br><span class="line">3. 由于线程A已经通过了条件判断的语句，仍然可以获取锁，进入临界区，于是便导致了错误。</span><br></pre></td></tr></table></figure><p>java中可以使用条件对象来管理那些：<strong>已经获得了一个锁却不能有效工作的线程</strong></p><p><strong>每个锁可以创建一个或多个</strong>与这个锁相关的<strong>条件对象</strong>：</p><p>​当条件不满足时，该条件对象(使用 await() 方法)将该线程放入wait set中，即该线程被阻塞</p><p>​当有一个线程满足条件，并执行完临界区中的代码后，其条件对象(使用 signalAll() 方法)将所有处于<strong>该条件的wait set</strong>中的线程激活，让他们重新判断条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.先声明条件对象</span></span><br><span class="line"><span class="comment">//2.使用线程的锁对象生成条件对象</span></span><br><span class="line"><span class="comment">//3.将条件对象与业务条件进行搭配使用</span></span><br><span class="line">  如：</span><br><span class="line">  <span class="comment">//Condition 条件对象；</span></span><br><span class="line">  <span class="comment">//条件对象 = bankLock.newCondition();</span></span><br><span class="line">  bankLock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(account[from] &lt; amount)&#123;</span><br><span class="line">  条件对象.await();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...获取锁并执行临界区代码</span></span><br><span class="line">      条件对象.signalAll();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">        bankLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">相关方法：</span><br><span class="line"><span class="comment">//java.util.concurrent.locks.Lock中：</span></span><br><span class="line"><span class="comment">//返回一个与这个锁相关的条件对象  </span></span><br><span class="line">Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java.util.concurrent.Condition中：</span></span><br><span class="line"><span class="comment">//将该线程放入这个条件的await集中</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//解除这个条件中所有线程的阻塞状态(将所有await集中的线程放出)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//随机解除这个条件中的某个线程的阻塞状态</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h5 id="2-synchronized："><a href="#2-synchronized：" class="headerlink" title="2.synchronized："></a>2.synchronized：</h5><h6 id="synchronized关键字："><a href="#synchronized关键字：" class="headerlink" title="synchronized关键字："></a>synchronized关键字：</h6><p>​java提供的synchronize关键字封装了上述 锁+条件对象 的形式</p><p>​我们直接将需要上锁的方法声明为synchronized即使用了锁</p><p>​我们可以直接使用<strong>Object类</strong>中的 <strong>wait() notifyAll() notyfy()</strong> 方法来实现条件对象的作用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意⚠️：</span><br><span class="line">为了与 Object类中的 wait()  notifyAll()  notyfy() 方法 进行区分 只能用在synchronized修饰的方法中，其中wait中可输入形参表示wait的时间</span><br><span class="line">Condition类中的方法名为 await() signalAll()  signal()</span><br></pre></td></tr></table></figure><p>synchronize底层机制：</p><p>​<strong>java中的每个对象都有一把内部锁</strong>，当你使用synchronized修饰时其中的一个方法，内部锁就会保护整个方法</p><p>​<strong><u><em>java中的每个对象都有一个内部锁，并且这个内部锁有一个内部条件；</em></u></strong></p><p>​<strong><u>内部锁会管理试图进入synchronized方法的线程，内部条件会管理调用了wait()方法的线程；</u></strong></p><p>​我们也可以将静态方法声明为同步(synchronized)，该方法被调用时，关联类对象(类名.class的对象)的内部锁会保护这个类的所有静态同步方法。</p><p>​synchronized方案的劣势：</p><ul><li>不能中断一个正在尝试获得锁的线程，Lock是有中断能力的</li><li>不能指定尝试获得锁的超时时间，                    相比之下，Lock可以设置超时时间。</li><li>每个锁只有一个条件对象，低效</li></ul><p>在实际情况中，能不用锁就不用锁，非要用的话优先使用synchronized，如果无法满足需求再用Lock&#x2F;Condition</p><h6 id="synchronized代码块-同步块，synchronized-block"><a href="#synchronized代码块-同步块，synchronized-block" class="headerlink" title="synchronized代码块(同步块，synchronized block)"></a>synchronized代码块(同步块，synchronized block)</h6><p>​synchronized(obj){</p><p>​   …….</p><p>​}</p><p>​原理是使用obj对象的内部锁来进行锁定，</p><p>​要使用同步代码块时，需要让线程使用相同对象的内部锁(这样才锁得住)，而且不能让无关线程获取你的锁</p><h6 id="监视器-monitor-概念："><a href="#监视器-monitor-概念：" class="headerlink" title="监视器(monitor)概念："></a>监视器(monitor)概念：</h6><p>​监视器指：只有私有对象的类；监视器类的每个对象都有一个相关联的锁，</p><p>​这样看来synchronized修饰的方法似乎与监视器中的方法有相同的作用。</p><p>但java对象不同于监视器：</p><ul><li><p>字段不要求是private</p></li><li><p>方法不要求是synchronized</p></li><li><p>内部锁可以被用户使用</p><p>这削弱了线程安全性</p></li></ul><h6 id="volatile字段："><a href="#volatile字段：" class="headerlink" title="volatile字段："></a>volatile字段：</h6><p>volatile意为不稳定的，只能<strong>修饰类中的属性</strong>，当一个字段被声明为volatile，那么编译器和虚拟机就会考虑到该字段可能被另一线程并发更新。</p><p>​<strong>volatile关键字使系统中所有线程对该关键字修饰的变量共享可见，可以禁止线程的工作内存对volatile修饰的变量进行缓存。</strong></p><ul><li><p><strong>可见性</strong>：</p><p>​    <strong>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</strong></p><p>​而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p></li><li><p><strong>原子性：</strong></p></li></ul><p>​由于直接将变量值更新到主存，volatile修饰的简单数据类型的操作就会变成原子级别的</p><p>​注意⚠️声明为volatile的简单变量<strong>如果当前值由该变量以前的值相关</strong>，那么volatile关键字不起作用，也就是说如下的表达式都不是原子操作： </p><p>​n &#x3D; n +  1 ;<br>​n ++ ;<br>​n &#x3D; !n;</p><h6 id="final变量："><a href="#final变量：" class="headerlink" title="final变量："></a>final变量：</h6><p>​为字段添加final修饰符后，其他线程会看到该字段初始化之后的值，而不会看到字段初始化未完成时默认空值的状态！</p><h6 id="原子性："><a href="#原子性：" class="headerlink" title="原子性："></a>原子性：</h6><p>​java.util.concurrent.atomic包中的API可以实现各种类型数据以原子方式实现自增等操作，</p><p>​其并没有使用加锁的方式实现原子性，而是在硬件层面进行阻塞，因而更加高效。</p><h6 id="死锁："><a href="#死锁：" class="headerlink" title="死锁："></a>死锁：</h6><p>​java中没有任何特性能够避免、打破死锁，设计程序时，我们要确保不出现死锁。</p><h6 id="为什么废弃stop、suspend方法："><a href="#为什么废弃stop、suspend方法：" class="headerlink" title="为什么废弃stop、suspend方法："></a>为什么废弃stop、suspend方法：</h6><p>​stop方法立即停止线程，会终止该线程所有未完成的方法，导致线程处于不一致的状态。</p><p>因为线程不知道什么时候可以安全地stop其他线程，因此stop是不安全(导致stop被弃用)的；</p><p><strong>因此，我们希望停止线程时，应当先中断(interrupt)该线程，被中断的线程可以在安全的时候终止。</strong></p><p>​</p><p>​suspend方法将会挂起一个线程，这个线程如果持有锁，那么在这个线程恢复运行之前，这个锁是不可用的</p><p>一种很常见的死锁：A 将 持有一个锁的B 挂起，而A又需要B占有的锁，这时候就会导致死锁。。</p><p><strong>因此，为了安全地挂起线程，我们需要引入一个suspendRequested(请求挂起)变量，在<u>该线程不持有任何锁的位置</u>测试该变量，如果发现suspendRequested变量被设置为挂起，则让该线程在此处等待，直到被其他线程唤醒！</strong></p><h6 id="按需初始化："><a href="#按需初始化：" class="headerlink" title="按需初始化："></a>按需初始化：</h6><p>​对于某些数据，如果你只希望在第一次使用它的时候才进行初始化，不妨利用这样一个事实：<strong>虚拟机会在第一次使用某个类时执行一个静态初始化器，并只执行一次</strong>——虚拟机利用一个锁确保这一点。</p><p>​我们需要在该类的<strong>静态</strong>初始化器上写入需要初始化的代码，</p><p>​——我们必须确保不会抛出异常，因为虚拟机对每个类只会初始化一次，若抛出异常，可能还没执行初始化语句就跳出了。</p><h6 id="线程局部变量："><a href="#线程局部变量：" class="headerlink" title="线程局部变量："></a>线程局部变量：</h6><p>​各个线程间，有时需要避免共享变量。这时，我们需要使用ThreadLocal辅助类为各个线程提供各自的实例。</p><p>我们需要在线程类中创建ThreadLocal对象，并使用该对象来为每个线程生成属于自己的局部变量</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// One implementation</span></span><br><span class="line">ThreadLocal&lt;DateFormat&gt; localFormatter</span><br><span class="line">  = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>());</span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">formatter</span> <span class="operator">=</span> localFormatter.get();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">java.lang.ThreadLocal&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个线程局部变量，初始值通过调用给定的提供者生成</span></span><br><span class="line"><span class="keyword">static</span> &lt;S&gt; ThreadLocal&lt;S&gt; <span class="title function_">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span></span><br><span class="line">  <span class="comment">//得到属于这个线程的局部变量值</span></span><br><span class="line">  T <span class="title function_">get</span><span class="params">()</span></span><br><span class="line">  <span class="comment">//为 这个线程 的 这个局部变量 设置一个新值，这样会导致这个线程的其他地方如果要获取该局部变量，也会获取新值！</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T t)</span></span><br><span class="line">  <span class="comment">//移除该线程的某个局部变量</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="12-5-线程安全的集合："><a href="#12-5-线程安全的集合：" class="headerlink" title="12.5.线程安全的集合："></a><u>12.5.线程安全的集合：</u></h3><h4 id="阻塞队列："><a href="#阻塞队列：" class="headerlink" title="阻塞队列："></a>阻塞队列：</h4><p>​使用线程安全的队列存放待执行的指令对象 (指令会串行执行 —-&gt; 不会造成线程安全问题)</p><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230421093013063.png" alt="image-20230421093013063"></p><p><strong>如果要使用队列作为线程管理工具，我们需要使用<u>put()</u>、<u>take()</u>方法</strong></p><p>peek和poll通过返回null来表示操作失败，我们切忌在操作中向队列插入null元素(导致无法分辨队列中元素为null还是取数失败)</p><h4 id="高效的映射、集和队列"><a href="#高效的映射、集和队列" class="headerlink" title="高效的映射、集和队列"></a>高效的映射、集和队列</h4><p>​java.util.concurrent包提供<strong>允许并发访问</strong>的数据结构，如：ConcurrentHashMap、……</p><p>​——使用了复杂的算法使访问这些数据结构的不同部分从而减少竞争</p><p>​ConcurrentHashMap中有 size()与mappingCount()方法可以计算map 的大小：</p><p>​size方法用Integer记录大小可能会越界，</p><p>​mappingCount使用Long记录大小，不会越界</p><p>​如果多个线程访问ConcurrentHashMap中<strong>不同的桶</strong>，那么它们都能够访问而<strong>不阻塞</strong></p><h4 id="映射条目的原子更新：暂时看不明白"><a href="#映射条目的原子更新：暂时看不明白" class="headerlink" title="* 映射条目的原子更新：暂时看不明白"></a>* 映射条目的原子更新：暂时看不明白</h4><h4 id="并发散列映射的批操作：暂时看不明白"><a href="#并发散列映射的批操作：暂时看不明白" class="headerlink" title="* 并发散列映射的批操作：暂时看不明白"></a>* 并发散列映射的批操作：暂时看不明白</h4><h4 id="并发集视图：暂时看不明白"><a href="#并发集视图：暂时看不明白" class="headerlink" title="* 并发集视图：暂时看不明白"></a>* 并发集视图：暂时看不明白</h4><h4 id="写时拷贝数组："><a href="#写时拷贝数组：" class="headerlink" title="写时拷贝数组："></a>写时拷贝数组：</h4><p>​CopyOnWriteArrayList、CopyOnWriteArraySet是线程安全的集合，所有更改之前会先创建底层数组的一个副本，因此中途数组被修改了，迭代器也能访问原本的数组(虽然可能过时，但属于一致状态！)</p><h4 id="并行数组算法"><a href="#并行数组算法" class="headerlink" title="* 并行数组算法"></a>* 并行数组算法</h4><h4 id="较早的线程安全集合"><a href="#较早的线程安全集合" class="headerlink" title="* 较早的线程安全集合"></a>* 较早的线程安全集合</h4><p>*本章往后的部分都看得不精，基础不牢，先去看前面的知识了</p><h3 id="12-6-任务和线程池"><a href="#12-6-任务和线程池" class="headerlink" title="12.6.任务和线程池"></a><u>12.6.任务和线程池</u></h3><h4 id="Callable和Future"><a href="#Callable和Future" class="headerlink" title="*Callable和Future"></a>*Callable和Future</h4><h4 id="执行器-Executors-："><a href="#执行器-Executors-：" class="headerlink" title="*执行器(Executors)："></a>*执行器(Executors)：</h4><p>​执行器中有许多构造线程池的静态工厂方法，可以构造各种线程池</p><h5 id="使用线程池一般流程："><a href="#使用线程池一般流程：" class="headerlink" title="使用线程池一般流程："></a>使用线程池一般流程：</h5><ul><li>调用Executor中的静态方法newCachedThreadPool 或 newFixedThreadPool 创建线程池</li><li>调用submit提交Runnable或Callable对象 —&gt;用于将任务提交给线程池</li><li>保留返回的Future对象，以便得到结果或取消任务</li><li>不想再提交任何任务时，调用shutdown()关闭线程池</li></ul><table><thead><tr><th>newCachedThreadPool</th><th>返回一个缓存线程池，必要时创建线程，若线程空闲了60秒则终止该线程</th></tr></thead><tbody><tr><td>newFixedThreadPool(int threads)</td><td>返回一个线程池，使用给定数目的线程执行任务</td></tr></tbody></table><h3 id="12-7-异步计算"><a href="#12-7-异步计算" class="headerlink" title="12.7.异步计算"></a><u>12.7.异步计算</u></h3><h3 id="12-8-进程"><a href="#12-8-进程" class="headerlink" title="12.8.进程"></a><u>12.8.进程</u></h3>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法小结</title>
      <link href="/2023/05/26/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93/"/>
      <url>/2023/05/26/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>华为笔试考点：<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.html#%E5%89%8D%E8%A8%80">this</a></p><h1 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h1><h2 id="双指针："><a href="#双指针：" class="headerlink" title="双指针："></a>双指针：</h2><p>双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。</p><h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><p>满足单调性(指针在移动的过程中，待衡量的量总是朝一个方向变化)</p><h4 id="同向双指针："><a href="#同向双指针：" class="headerlink" title="同向双指针："></a>同向双指针：</h4><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></p><p><a href="https://leetcode.cn/problems/subarray-product-less-than-k/">713. 乘积小于 K 的子数组</a></p><h4 id="相向双指针："><a href="#相向双指针：" class="headerlink" title="相向双指针："></a>相向双指针：</h4><p><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></p><p><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></p><p><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></p><p><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></p><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>有两种计算中值 m 的方式：</p><ul><li><p>m &#x3D; (l + h) &#x2F; 2</p></li><li><p>m &#x3D; l + (h - l) &#x2F; 2</p><p><strong>l + h 可能出现加法溢出</strong>，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，最好使用第二种计算法方法。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果while中是 l &lt;= h 的话，那么下面也要对应的 l = m + 1; r = m - 1</span></span><br><span class="line"><span class="comment">//如：</span></span><br><span class="line"><span class="keyword">while</span>(l &lt;= h)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (h - l)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt;= target)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;tag = <span class="literal">true</span>;&#125;</span><br><span class="line">        h = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是  l &lt; h 的话，那么下面只需要出现一个 &#123;l = m + 1  and  r = m&#125;  或者  &#123;l = m  and  r = m - 1&#125;!</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/">1011. 在 D 天内送达包裹的能力</a></p><p>&#x2F;&#x2F;这题好妙，本菜鸟根本想不到这题还能二分，长见识了！</p><p>我们对运载能力进行讨论：对于某运载能力，</p><ul><li><p>如果此运载能力下需要的天数大于系统所述的天数，那么需要提高运载能力；</p></li><li><p>如果    运载能力下需要的天数小于系统所述的天数，那么需要降低运载能力；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shipWithinDays</span><span class="params">(<span class="type">int</span>[] weights, <span class="type">int</span> days)</span> &#123;</span><br><span class="line">        <span class="comment">// 确定二分查找左右边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Arrays.stream(weights).max().getAsInt(), right = Arrays.stream(weights).sum();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// need 为需要运送的天数</span></span><br><span class="line">            <span class="comment">// cur 为当前这一天已经运送的包裹重量之和</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">need</span> <span class="operator">=</span> <span class="number">1</span>, cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> weight : weights) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur + weight &gt; mid) &#123;</span><br><span class="line">                    ++need;</span><br><span class="line">                    cur = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur += weight;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//因为要求最小的运载能力，所以我们在得到符合条件所述天数的运载能力时，要再往小的运载能力那边试试</span></span><br><span class="line">            <span class="keyword">if</span> (need &lt;= days) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p><a href="https://leetcode.cn/problems/minimize-the-maximum-difference-of-pairs/">2616. 最小化数对的最大差值</a></p><p>与上一题思路相同：</p><p>​🌟看到「<strong>最大化最小值</strong>」或者「<strong>最小化最大值</strong>」就要想到<u>二分答案</u>，这是一个固定的套路。</p><p>为什么？一般来说，二分的值越大，越能&#x2F;不能满足要求；二分的值越小，越不能&#x2F;能满足要求，有单调性，可以二分。</p><p>在这一题中，我们对 <strong>最大差值的最小值</strong> 进行二分(左边界为 两数相等的差值：0；右边界为最大值与最小值的差值)对于某一 最大差值的最小值 mid：如果满足<u>差值小于mid 的数对数量</u>大于p，则应当减小mid(满足的太多了，要让条件严格一些)，否则反之。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimizeMax</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> p)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, left = -<span class="number">1</span>, right = nums[n - <span class="number">1</span>] - nums[<span class="number">0</span>]; <span class="comment">// 开区间</span></span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123; <span class="comment">// 开区间</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt;&gt; <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">                <span class="keyword">if</span> (nums[i + <span class="number">1</span>] - nums[i] &lt;= mid) &#123; <span class="comment">// 都选</span></span><br><span class="line">                    ++cnt;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt;= p) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">作者：endlesscheng</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/minimize-the-maximum-difference-of-pairs/solution/er-fen-da-an-tan-xin-by-endlesscheng-dlxv/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h1 id="分治："><a href="#分治：" class="headerlink" title="分治："></a>分治：</h1><p><a href="https://leetcode.cn/problems/different-ways-to-add-parentheses/">241. 为运算表达式设计优先级</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">diffWaysToCompute</span><span class="params">(String input)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; ways = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> input.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            List&lt;Integer&gt; left = diffWaysToCompute(input.substring(<span class="number">0</span>, i));</span><br><span class="line">            List&lt;Integer&gt; right = diffWaysToCompute(input.substring(i + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> l : left) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> r : right) &#123;</span><br><span class="line">                    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                            ways.add(l + r);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                            ways.add(l - r);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                            ways.add(l * r);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ways.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        ways.add(Integer.valueOf(input));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真的太优美了！</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> generate(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            res.add(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i&lt;=end; i++)&#123;</span><br><span class="line">            List&lt;TreeNode&gt; left = generate(start, i - <span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; right = generate(i + <span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">for</span>(TreeNode l: left)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode r: right)&#123;</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(i);</span><br><span class="line">                    root.left = l;</span><br><span class="line">                    root.right = r;</span><br><span class="line">                    res.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>做完这两道，感觉已经摸清了分治的底细！ 遍历特征点，左边和右边的不同情况排列组合得到多种结果</p><h1 id="搜索："><a href="#搜索：" class="headerlink" title="搜索："></a>搜索：</h1><h2 id="BFS："><a href="#BFS：" class="headerlink" title="BFS："></a>BFS：</h2><p>​在程序实现 BFS 时需要考虑以下问题：</p><ul><li><strong>队列</strong>：用来存储每一轮遍历得到的节点；</li><li><strong>标记</strong>：对于遍历过的节点，应该将它标记，防止重复遍历。</li></ul><p>LinkedList&lt;&gt;() 的API：<strong>poll</strong>获取并删除队头元素；<strong>offer</strong>向队尾添加元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!wordList.contains(endWord))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (beginWord.equals(endWord))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//标记</span></span><br><span class="line">        HashSet&lt;String&gt; hashset = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//bfs</span></span><br><span class="line">        LinkedList&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        queue.offer(beginWord);</span><br><span class="line">        hashset.add(beginWord);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">while</span>(sz-- != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"><span class="comment">//                if(word.equals(endWord))return res;</span></span><br><span class="line"><span class="comment">//                res++;</span></span><br><span class="line"><span class="comment">//                if(hashset.contains(word))continue;</span></span><br><span class="line">                <span class="keyword">for</span>(String s:wordList)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(judge(word,s) &amp;&amp; !hashset.contains(s))&#123;</span><br><span class="line">                        queue.offer(s);</span><br><span class="line">                        <span class="keyword">if</span>(s.equals(endWord))<span class="keyword">return</span> res;</span><br><span class="line">                        <span class="comment">// System.out.println(word + &quot;-&gt;&quot; +s);</span></span><br><span class="line">                        hashset.add(s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需要写一个方法，来判断两个字符串的差异是否为一个字符</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">judge</span> <span class="params">(String s1, String s2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.length() != s2.length())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s1.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i) != s2.charAt(i))count++;</span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS:"></a>DFS:</h2><p>​从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS 常用来求解这种 <strong>可达性</strong> 问题。</p><p>在程序实现 DFS 时需要考虑以下问题：</p><ul><li><strong>栈</strong>：用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。</li><li><strong>标记</strong>：和 BFS 一样同样需要对已经遍历过的节点进行标记。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//套路格式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> [][] direction =  <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;<span class="comment">//方向，视题目而定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxAreaOfIsland</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                res = Math.max(res, dfs(grid, i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> [][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">      <span class="comment">//出界或者已经到达过</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= grid.length || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">addition</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        grid[i][j] = <span class="number">0</span>;<span class="comment">//到达过的地点全部进行标记(不能再次到达)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; direction.length; k++)&#123;</span><br><span class="line">            addition += dfs(grid, i + direction[k][<span class="number">0</span>], j + direction[k][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> addition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回溯："><a href="#回溯：" class="headerlink" title="回溯："></a>回溯：</h2><p>回溯做题三问：</p><ol><li>当前的操作是什么</li><li>当前操作对应的子问题是什么</li><li>下一个子问题是什么</li></ol><h3 id="子集形回溯："><a href="#子集形回溯：" class="headerlink" title="子集形回溯："></a>子集形回溯：</h3><p>​对每个点进行选择：选 or 不选</p><p>​或者从答案的角度：如果选这个会满足条件再依此继续</p><h3 id="组合型回溯："><a href="#组合型回溯：" class="headerlink" title="组合型回溯："></a>组合型回溯：</h3><p>​有顺序要求可以进行剪枝</p><h3 id="排列型回溯："><a href="#排列型回溯：" class="headerlink" title="排列型回溯："></a>排列型回溯：</h3><p>​</p><p>​Backtracking（回溯）属于 DFS。</p><ul><li>普通 DFS 主要用在 <strong>可达性问题</strong> ，这种问题只需要执行到特点的位置然后返回即可。</li><li>而 Backtracking 主要用于求解 <strong>排列组合</strong> 问题，例如有 { ‘a’,’b’,’c’ } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。</li></ul><p>因为 Backtracking 不是立即返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：</p><ul><li>在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；</li><li>但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对于一定规则下的排列组合问题，我们使用回溯法进行求解</span><br><span class="line">回溯法 = dfs+回溯操作</span><br><span class="line">一般而言void dfs的参数如下(int n, &lt;T&gt;存储当前步骤生成的中间结果的变量,用于存储最终各种情况的变量[一般为一个ArrayList], 待进行操作的元素)；</span><br><span class="line">如：dfs(0,new StringBuilder(),res,s);</span><br><span class="line">dfs中刚开始写上终止条件：n到达指定轮数或不满足其他限制条件，直接return</span><br><span class="line">接下来根据当前存储的中间结果，再·给中间结果添加这轮得到的产物 ··对其进行下一轮dfs ···将这轮的产物删去，并换成这一轮产物的下一种情况！</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回溯模版：</span></span><br><span class="line"><span class="comment">//在回溯时，如果使用ArrayList等引用对象存放你产生的结果，在将其添加至结果集中时需要重新创建一个与其相同的副本，将副本加入结果集，如果不这样做，回溯后删除了元素会导致结果集中元素的改变。。</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   ArrayList&lt;Integer&gt; curNum = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">boolean</span>[] tag = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        dfs(curNum, tag, res, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(ArrayList&lt;Integer&gt; curNum,<span class="type">boolean</span>[] tag, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curNum.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(curNum));<span class="comment">//##############################就说的是这里！！！！</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!tag[i])&#123;</span><br><span class="line">                curNum.add(nums[i]);</span><br><span class="line">                tag[i] = <span class="literal">true</span>;</span><br><span class="line">                dfs(curNum, tag, res, nums);</span><br><span class="line">                curNum.remove(curNum.size() - <span class="number">1</span>);</span><br><span class="line">                tag[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于排列问题：我们只需要遍历并回溯所有的情况并记录即可，</p><p><strong>组合问题</strong>，相对于排列问题而言，不计较一个组合内元素的顺序性（即 [1, 2, 3] 与 [1, 3, 2] 认为是同一个组合），因此很多时候<strong>需要按某种顺序展开搜索</strong>，这样才能做到不重不漏。</p><p>我们需要按照某种顺序(比如大小顺序)进行搜索，也就是“剪枝”</p><p><u>笔记的回溯第11、12、13、14、15题未做！</u></p><h1 id="贪心："><a href="#贪心：" class="headerlink" title="贪心："></a>贪心：</h1><h3 id="适用范围："><a href="#适用范围：" class="headerlink" title="适用范围："></a>适用范围：</h3><p>贪心算法在<strong>有最优子结构</strong>的问题中尤为有效。最优子结构的意思是问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。</p><h2 id="两种常见思路："><a href="#两种常见思路：" class="headerlink" title="两种常见思路："></a>两种常见思路：</h2><h3 id="排序解法"><a href="#排序解法" class="headerlink" title="排序解法"></a>排序解法</h3><p>用排序法常见的情况是输入一个包含几个（一般一到两个）权值的数组，通过排序然后遍历模拟计算的方法求出最优值。</p><h3 id="后悔解法"><a href="#后悔解法" class="headerlink" title="后悔解法"></a>后悔解法</h3><p>思路是无论当前的选项是否最优都接受，然后进行比较，如果选择之后不是最优了，则反悔，舍弃掉这个选项；否则，正式接受。如此往复。</p><h1 id="动态规划！"><a href="#动态规划！" class="headerlink" title="动态规划！"></a>动态规划！</h1><p>​写到0-1背包第三题</p><h1 id="链表："><a href="#链表：" class="headerlink" title="链表："></a>链表：</h1><h3 id="纯链表操作的题目有很多都可以使用-递归-解决！"><a href="#纯链表操作的题目有很多都可以使用-递归-解决！" class="headerlink" title="纯链表操作的题目有很多都可以使用 递归 解决！"></a>纯链表操作的题目有很多都可以使用 <em>递归</em> 解决！</h3><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要求两两交换链表中的节点</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">    head.next = swapPairs(next.next);</span><br><span class="line">    next.next = head;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="除了递归很常见以外，快慢指针的方法-也很常见"><a href="#除了递归很常见以外，快慢指针的方法-也很常见" class="headerlink" title="除了递归很常见以外，快慢指针的方法 也很常见"></a>除了递归很常见以外，<u><em>快慢指针的方法</em></u> 也很常见</h3><p>如判断链表是否回文，可以使用快慢指针找到链表的中间(具体奇偶位再考虑)，再将链表分割位两个子链表，反转其一，如果两个子链表相等则回文！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast != <span class="literal">null</span>) slow = slow.next;  <span class="comment">// 偶数节点，让 slow 指向下一个节点</span></span><br><span class="line">    cut(head, slow);                     <span class="comment">// 切成两个链表</span></span><br><span class="line">    <span class="keyword">return</span> isEqual(head, reverse(slow));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cut</span><span class="params">(ListNode head, ListNode cutNode)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (head.next != cutNode) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nextNode</span> <span class="operator">=</span> head.next;</span><br><span class="line">        head.next = newHead;</span><br><span class="line">        newHead = head;</span><br><span class="line">        head = nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isEqual</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val != l2.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树："><a href="#树：" class="headerlink" title="树："></a>树：</h1><h2 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h2><p>一棵树要么是空树，要么有两个指针，每个指针指向一棵树。树是一种递归结构，很多树的问题可以使用<strong>递归</strong>来处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">对树的操作，一般可以用递归解决：</span><br><span class="line"><span class="comment">//通用格式：</span></span><br><span class="line">functionname ( TreeNode root )&#123;</span><br><span class="line"><span class="keyword">if</span>(root  == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">  &#125;  </span><br><span class="line">  root.left = functionname(xxx);</span><br><span class="line">  root.right = functionname(xxx);</span><br><span class="line">  <span class="keyword">return</span> xxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//例1:</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    depth(root);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">depth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> depth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> depth(root.right);</span><br><span class="line">    max = Math.max(max, leftDepth + rightDepth);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例2:</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;<span class="keyword">return</span> root;&#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = invertTree(root.right);</span><br><span class="line">        root.right = invertTree(temp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//例3:</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root1.val + root2.val);</span><br><span class="line">        res.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">        res.right = mergeTrees(root1.right, root2.right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例4:一种有点妙的格式：</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSubtreeWithRoot(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSubtreeWithRoot</span><span class="params">(TreeNode s, TreeNode t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span> &amp;&amp; s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span> || s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t.val != s.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSubtreeWithRoot(s.left, t.left) &amp;&amp; isSubtreeWithRoot(s.right, t.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续做前中后序遍历!</p><h2 id="层次遍历："><a href="#层次遍历：" class="headerlink" title="层次遍历："></a>层次遍历：</h2><p>广度优先即可</p><h2 id="前中后序遍历："><a href="#前中后序遍历：" class="headerlink" title="前中后序遍历："></a>前中后序遍历：</h2><h2 id="BST："><a href="#BST：" class="headerlink" title="BST："></a>BST：</h2><h2 id="Trie："><a href="#Trie：" class="headerlink" title="Trie："></a>Trie：</h2><h1 id="数组与矩阵："><a href="#数组与矩阵：" class="headerlink" title="数组与矩阵："></a>数组与矩阵：</h1><p>看到：5. 有序矩阵的 Kth Element</p><h1 id="图："><a href="#图：" class="headerlink" title="图："></a>图：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java建图模板</span></span><br><span class="line">g = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[n];</span><br><span class="line">Arrays.setAll(g, e -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;() );</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> e : edges)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> e[<span class="number">0</span>], y = e[<span class="number">1</span>];</span><br><span class="line">    g[x].add(y);</span><br><span class="line">    g[y].add(x);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="二分图："><a href="#二分图：" class="headerlink" title="二分图："></a>二分图：</h2><p>​如果可以用两种颜色对图中的节点进行着色，并且保证相邻的节点颜色不同，那么这个图就是二分图。</p><p>​&#x2F;&#x2F;判断是否是二分图⬇️</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">judge</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBipartite</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">       <span class="comment">//color记录每个节点的颜色，0为还没被染色，1、2分别为两种颜色</span></span><br><span class="line">       <span class="type">int</span> color[] = <span class="keyword">new</span> <span class="title class_">int</span>[graph.length];</span><br><span class="line">       <span class="comment">//我认为应该深度遍历这个图，给遍历过的结点染色，</span></span><br><span class="line">       <span class="comment">//如果遇到已经染色的，看看如果和自己颜色相同，则不是二分图！</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; graph.length; i++)&#123;</span><br><span class="line">           <span class="comment">//对于每棵子树，如果有一个节点被dfs过，那么如果可以构成二分子图的话，这颗子树上的所有节点都不必再进行dfs了，故此处只找还未被涂色的节点进行dfs！</span></span><br><span class="line">           <span class="keyword">if</span>(color[i] == <span class="number">0</span>) &#123;</span><br><span class="line">               dfs(graph, i, <span class="number">1</span>, color);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> judge;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span> i, <span class="type">int</span> thisColor, <span class="type">int</span>[] color)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!judge)<span class="keyword">return</span>;</span><br><span class="line">       color[i] = thisColor;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; graph[i].length; j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(color[graph[i][j]] == <span class="number">0</span>)&#123;</span><br><span class="line">               dfs(graph, graph[i][j], thisColor==<span class="number">1</span>?<span class="number">2</span>:<span class="number">1</span>, color);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(color[i] == color[graph[i][j]])&#123;</span><br><span class="line">                   judge = <span class="literal">false</span>;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="拓扑排序："><a href="#拓扑排序：" class="headerlink" title="拓扑排序："></a>拓扑排序：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将邻接矩阵转换为邻接表：</span></span><br><span class="line"><span class="type">int</span>[][] prerequisites <span class="comment">//邻接矩阵</span></span><br><span class="line">List&lt;Integer&gt;[] graphic = <span class="keyword">new</span> <span class="title class_">List</span>[numCourses];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">    graphic[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] pre : prerequisites) &#123;</span><br><span class="line">    graphic[pre[<span class="number">0</span>]].add(pre[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1: 深度优先</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*定义三种状态：0-&gt;未搜索；1-&gt;搜索中；2-&gt;已完成</span></span><br><span class="line"><span class="comment">*遍历所有结点，对未搜索的结点进行dfs，</span></span><br><span class="line"><span class="comment">*对于dfs：先将该结点置为1状态，遍历所有该结点需要的结点，如果没有依赖的结点或者依赖的结点的状态都为2，则该结点也</span></span><br><span class="line"><span class="comment">*可以标记成2；如果该结点依赖的结点状态为0，则dfs依赖的结点；如果依赖的结点的状态为1，则说明存在环，不满足拓扑排</span></span><br><span class="line"><span class="comment">*序！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//深度优先判断拓扑排序⬇️</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrderByDFS(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="comment">//1.构建图</span></span><br><span class="line">        List&lt;Integer&gt;[] relation = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            relation[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] arr: prerequisites)&#123;</span><br><span class="line">            relation[arr[<span class="number">0</span>]].add(arr[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建数组，存放每门课程的状态0，1，2</span></span><br><span class="line">        <span class="type">int</span>[] status = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//用于存放课程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(status[i] == <span class="number">0</span>)&#123; <span class="comment">//未搜索过，于是对其进行dfs搜索！</span></span><br><span class="line">                dfs(i, relation, status,stack);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(loop)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> numCourses - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            res[i] = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> curCourse, List&lt;Integer&gt;[] relation, <span class="type">int</span>[] status, LinkedList&lt;Integer&gt; stack)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(loop)<span class="keyword">return</span>;</span><br><span class="line">        status[curCourse] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> next: relation[curCourse])&#123;</span><br><span class="line">            <span class="keyword">if</span>(status[next] == <span class="number">0</span>)&#123;</span><br><span class="line">                dfs(next, relation, status,stack);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(status[next] == <span class="number">1</span>)&#123;</span><br><span class="line">                loop = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(curCourse);</span><br><span class="line">        status[curCourse] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2: 广度优先</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*将邻接矩阵转化为邻接表 其中：A需要B == B-&gt;A 因此 任务K入度为0表示K可以直接完成！</span></span><br><span class="line"><span class="comment">  *使用队列，将入度为0的任务添加至队列，遍历这些任务，将它们指向的队列的入度--；将操作后入度为0的再添加进队列</span></span><br><span class="line"><span class="comment">  *直到队列为空(如果从队列弹出的任务总数 &lt; 总任务数，则说明图中有环，不能构成拓扑排序)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">//广度优先判断拓扑排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrderByBFS(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="comment">//1.构建图</span></span><br><span class="line">        <span class="comment">//广度优先，a需要b 则 b-&gt;a</span></span><br><span class="line">        <span class="comment">//每次记录入度为0的课程,因此需要创建数组记录每个课程的入度</span></span><br><span class="line">        List&lt;Integer&gt;[] relation = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[numCourses];</span><br><span class="line">        <span class="type">int</span> []inDegree = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            relation[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] arr: prerequisites)&#123;</span><br><span class="line">            relation[arr[<span class="number">1</span>]].add(arr[<span class="number">0</span>]);</span><br><span class="line">            inDegree[arr[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//队列初始化：将所有入度为0的课程都加入queue</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化完毕，开始常规bfs</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(sz-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">curCourse</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i: relation[curCourse])&#123;</span><br><span class="line">                    inDegree[i]--;</span><br><span class="line">                    <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                        queue.offer(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res[index++] = curCourse;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index == numCourses? res: <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="并查集："><a href="#并查集：" class="headerlink" title="并查集："></a>并查集：</h2><p>并查集可以动态地连通两个点，并且可以非常快速地判断两个点是否连通。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *===============================并查集模板，可直接使用！！！=====================================</span></span><br><span class="line"><span class="comment"> * 数组模拟树，实现并查集。数组内的元素表示父亲的下角表，相当于指针。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> element)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (element != parent[element]) &#123;</span><br><span class="line">            element = parent[element];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> firstElement, <span class="type">int</span> secondElement)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(firstElement) == find(secondElement);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unionElements</span><span class="params">(<span class="type">int</span> firstElement, <span class="type">int</span> secondElement)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">firstRoot</span> <span class="operator">=</span> find(firstElement);</span><br><span class="line">        <span class="type">int</span> <span class="variable">secondRoot</span> <span class="operator">=</span> find(secondElement);</span><br><span class="line">        <span class="keyword">if</span> (firstRoot == secondRoot) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parent[firstRoot] = secondRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//并查集的应用：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findRedundantConnection(<span class="type">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">unionfind</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">UnionFind</span>(edges.length + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge:edges)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!unionfind.isConnected(edge[<span class="number">0</span>],edge[<span class="number">1</span>]))&#123;</span><br><span class="line">                unionfind.unionElements(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="寻找图中的最大环："><a href="#寻找图中的最大环：" class="headerlink" title="寻找图中的最大环："></a>寻找图中的最大环：</h2><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>用于<u><strong>值域较小的大量数字的排序</strong></u>，将各个<strong>数字的值</strong>与<strong>个数</strong>作为一个<strong>数组的下标</strong>和<strong>值</strong>通过遍历数组，累加arr[]的值 &#x3D; k<strong>得到第k小的数字</strong></p><h1 id="桶排序："><a href="#桶排序：" class="headerlink" title="桶排序："></a>桶排序：</h1><p>​设置若干个桶 bucket[i] 存储出现次数为i的数， bucket定义为 ArrayList[ ] 类型</p><h1 id="快速选择："><a href="#快速选择：" class="headerlink" title="快速选择："></a>快速选择：</h1><p>平常人们<strong>选择数据中某个第几大</strong>的数据，往往使用先排序在选择的方法，这种方法的时间复杂度最快为Onlogn（快排时间复杂度），但在数据较大时往往会超出时间限制，故本次介绍时间复杂度为On的快速选择方法</p><p>快速选择算法：算法核心为递归和分治，和快速排序算法有一定的相似度，算法大概过程为<br>1.先判断区间的端点l,r和比较数pivot,pivot可取为arr[l],arr[r],arr[(l + r) &#x2F; 2)]。</p><p>2.进行排序交换，使区间分为两部分，左边部分小于等于pivot，右边部分大于等于pivot。</p><p>3.递归排序左右边，当要求的第K个数,k &gt;&#x3D; sl，则递归排序右边，否则递归排序左边，如果区间只有一个数则返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">quickChoose</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> [] arr,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//如果当前只有一个数存在</span></span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">           <span class="keyword">return</span> arr[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则进行排序和查找</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l - <span class="number">1</span>,j = r + <span class="number">1</span>,pivot = arr[l];</span><br><span class="line">        <span class="comment">//本次返回j,j + 1</span></span><br><span class="line">        <span class="comment">//当前元素区间不止为一个数时</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(arr[++i] &lt; pivot);</span><br><span class="line">            <span class="keyword">while</span>(arr[--j] &gt; pivot);</span><br><span class="line">            <span class="comment">//如果满足区间元素不为1</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[i];</span><br><span class="line">                arr[i] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果在左半部分，直接排序左边求解</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s1</span> <span class="operator">=</span> j - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1 &gt;= k)&#123;</span><br><span class="line">            <span class="keyword">return</span> quickChoose(l,i - <span class="number">1</span>,arr,k);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//否则排序右边数组</span></span><br><span class="line">            k = k - s1;</span><br><span class="line">            <span class="keyword">return</span> quickChoose( i,r,arr,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="匈牙利算法："><a href="#匈牙利算法：" class="headerlink" title="匈牙利算法："></a>匈牙利算法：</h1><ul><li><p><strong>匈牙利算法主要用来解决两个问题：求二分图的最大匹配数和最小点覆盖数</strong>。</p><p>求二分图最大连通数 模版⬇️</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意类名必须为 Main, 不要有任何 package xxx 信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 注意 hasNext 和 hasNextLine 的区别</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        List&lt;Integer&gt; odd = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; even = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(temp % <span class="number">2</span> == <span class="number">0</span>)&#123;even.add(temp);&#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;odd.add(temp);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> [] match = <span class="keyword">new</span> <span class="title class_">int</span> [even.size()];</span><br><span class="line">        <span class="keyword">if</span>(odd.size() == <span class="number">0</span> || even.size() == <span class="number">0</span>)&#123; <span class="comment">//缺少奇数或者偶数无法构成素数</span></span><br><span class="line">            System.out.println(count);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i: odd)&#123;</span><br><span class="line">            <span class="type">boolean</span> [] used = <span class="keyword">new</span> <span class="title class_">boolean</span> [even.size()];</span><br><span class="line">            <span class="keyword">if</span>(find(i,even, match, used))count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i, List&lt;Integer&gt; even, <span class="type">int</span>[] match,<span class="type">boolean</span> [] used)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; even.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrime(i + even.get(j)) &amp;&amp; !used[j])&#123;</span><br><span class="line">                used[j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(match[j] == <span class="number">0</span> || find(match[j], even, match,used))&#123;</span><br><span class="line">                    match[j] = i;  </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n % i == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="多路归并："><a href="#多路归并：" class="headerlink" title="多路归并："></a>多路归并：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lfool.github.io/LFool-Notes/algorithm/多路归并技巧总结.html</span><br></pre></td></tr></table></figure><ul><li><p>21.合并两个有序链表(简单)</p></li><li><p>23.合并K个升序链表(<strong>困难</strong>)</p><p>每次从所有链表头中选择数值最小的值加入结果链表中即可。自己做时只使用了遍历的方法，但是发现大神们<strong>使用小根堆</strong>来获取最小的链表头部！</p><ul><li>还可以使用归并的方法，(合并n个链表—–分半分半再分半—–&gt;合并2个链表)，针对合并2个链表编写代码</li><li>还可以使用PriorityQueue<ListNode>优先队列，它自动将队列内的元素按照提供的重写的compare方法来排序，每次poll出最小的，再把它的next(如果有)放入队列</li></ul></li></ul><h1 id="单调栈："><a href="#单调栈：" class="headerlink" title="单调栈："></a>单调栈：</h1><p>​<strong>用于处理 获取递增子序列之类的题目</strong></p><p>​遍历所给的数据，并维护一个栈，</p><p>​比如现在需要找出长度为n的最小字典序子字符串</p><p>​如果获得的数据比栈顶的小，则弹出栈顶，直到栈为空 或 栈顶元素小于所持元素， (这里还注意：因为我们需要的是长度为n的子序列，所以在我们每次想要pop的时候都需要判断：栈中元素以及未遍历的元素总数是否达到了了n，若&gt;n，则允许pop)</p><p>最后将栈中的数据依次pop，再reverse一下即可</p><h1 id="TreeSet的使用："><a href="#TreeSet的使用：" class="headerlink" title="TreeSet的使用："></a>TreeSet的使用：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        in.next();</span><br><span class="line">        <span class="keyword">while</span> (in.hasNextInt()) &#123; <span class="comment">// 注意 while 处理多个 case</span></span><br><span class="line">            treeSet.add(in.nextInt());           </span><br><span class="line">        &#125;</span><br><span class="line">        Iterator&lt;Integer&gt; tree = treeSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (tree.hasNext())&#123;</span><br><span class="line">            System.out.println(tree.next());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="System-arraycopy-的使用"><a href="#System-arraycopy-的使用" class="headerlink" title="System.arraycopy()的使用"></a>System.arraycopy()的使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>      src      the source array. 源数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>      srcPos   starting position in the source array. 源数组的起始位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>      dest     the destination array. 目标数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>      destPos  starting position in the destination data. 目标数组的起始位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>      length   the number of array elements to be copied. 复制的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">arraycopy(Object src,<span class="type">int</span> srcPos,Object dest, <span class="type">int</span> destPos, <span class="type">int</span> length)；</span><br></pre></td></tr></table></figure><h1 id="动态规划："><a href="#动态规划：" class="headerlink" title="动态规划："></a>动态规划：</h1><h4 id="1031-两个非重叠子数组的最大和"><a href="#1031-两个非重叠子数组的最大和" class="headerlink" title="1031. 两个非重叠子数组的最大和"></a><a href="https://leetcode.cn/problems/maximum-sum-of-two-non-overlapping-subarrays/">1031. 两个非重叠子数组的最大和</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums 和两个整数 firstLen 和 secondLen，请你找出并返回两个非重叠 子数组 中元素的最大和，长度分别为 firstLen 和 secondLen 。</span><br><span class="line">长度为 firstLen 的子数组可以出现在长为 secondLen 的子数组之前或之后，但二者必须是不重叠的。</span><br><span class="line">子数组是数组的一个 连续 部分。</span><br></pre></td></tr></table></figure><p>使用动态规划 ：</p><ul><li><p>dp1[ i ]表示前i个数中长度为firstLen的子数组的最大值 (若 i &lt; firstLen)则dp1[ i ] &#x3D; 前i个数之和</p></li><li><p>dp2[ i ]表示前i个数中长度为secondLen的子数组的最大值</p><p>我们得到dp1[ ]与dp2[ ]数组后，对于每个i，我们可以让res &#x3D; Max{res, 数组1(firstLen)包含了最新的第i位，数组2(secondLen)包含了最新的第i位}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumTwoNoOverlap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> firstLen, <span class="type">int</span> secondLen)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] += nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        arr1[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        arr2[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            arr1[i] = firstLen&gt;i?nums[i]: Math.max(nums[i] - nums[i - firstLen],arr1[i - <span class="number">1</span>]);</span><br><span class="line">            arr2[i] = secondLen&gt;i?nums[i]: Math.max(nums[i] - nums[i - secondLen],arr2[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (firstLen + secondLen &gt; i)&#123;</span><br><span class="line">                res = nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res = Math.max(res, nums[i] - nums[i - firstLen] + arr2[i - firstLen]);</span><br><span class="line">                res = Math.max(res, nums[i] - nums[i - secondLen] + arr1[i - secondLen]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>**1606自己做的超时了，答案的数据结构有点复杂，不知道什么时候有空再看看～</p><p>**2151 二进制枚举，有空来复盘！</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
