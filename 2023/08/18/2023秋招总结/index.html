<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>2023秋招总结 | donn的博客</title><meta name="author" content="donn"><meta name="copyright" content="donn"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="共汇总了3次面试被问到的题目 大厂校招面试问题汇总(八股汇总)：数据结构：1.讲一下平衡二叉树1231. 是一种特殊的二叉搜索树2. 每个节点的左子树和右子树的高度差不超过1插入、删除节点时，会通过左旋、右旋等操作维持平衡    2.了解红黑树吗   红黑树是一种自平衡的二叉搜索树，类似于平衡二叉树 3.从数据结构角度，除了链表法还有什么解决Hash冲突的方式？   (❌)，这里搞错题意了 123">
<meta property="og:type" content="article">
<meta property="og:title" content="2023秋招总结">
<meta property="og:url" content="https://tangjiayang.github.io/2023/08/18/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="donn的博客">
<meta property="og:description" content="共汇总了3次面试被问到的题目 大厂校招面试问题汇总(八股汇总)：数据结构：1.讲一下平衡二叉树1231. 是一种特殊的二叉搜索树2. 每个节点的左子树和右子树的高度差不超过1插入、删除节点时，会通过左旋、右旋等操作维持平衡    2.了解红黑树吗   红黑树是一种自平衡的二叉搜索树，类似于平衡二叉树 3.从数据结构角度，除了链表法还有什么解决Hash冲突的方式？   (❌)，这里搞错题意了 123">
<meta property="og:locale">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-08-18T07:55:02.000Z">
<meta property="article:modified_time" content="2023-08-30T08:34:26.652Z">
<meta property="article:author" content="donn">
<meta property="article:tag" content="面经">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://tangjiayang.github.io/2023/08/18/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":30,"languages":{"author":"Author: donn","link":"Link: ","source":"Source: donn的博客","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '2023秋招总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-30 16:34:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/bg.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="donn的博客"><span class="site-name">donn的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">2023秋招总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-08-18T07:55:02.000Z" title="Created 2023-08-18 15:55:02">2023-08-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-08-30T08:34:26.652Z" title="Updated 2023-08-30 16:34:26">2023-08-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E7%BB%8F/">面经</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">21k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>64min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="2023秋招总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>共汇总了<code>3</code>次面试被问到的题目</p>
<h1 id="大厂校招面试问题汇总-八股汇总-："><a href="#大厂校招面试问题汇总-八股汇总-：" class="headerlink" title="大厂校招面试问题汇总(八股汇总)："></a>大厂校招面试问题汇总(八股汇总)：</h1><h2 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h2><h3 id="1-讲一下平衡二叉树"><a href="#1-讲一下平衡二叉树" class="headerlink" title="1.讲一下平衡二叉树"></a>1.讲一下平衡二叉树</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 是一种特殊的二叉搜索树</span><br><span class="line">2. 每个节点的左子树和右子树的高度差不超过1</span><br><span class="line">插入、删除节点时，会通过左旋、右旋等操作维持平衡</span><br></pre></td></tr></table></figure>



<h3 id="2-了解红黑树吗"><a href="#2-了解红黑树吗" class="headerlink" title="2.了解红黑树吗"></a>2.了解红黑树吗</h3><p>   红黑树是一种自平衡的二叉搜索树，类似于平衡二叉树</p>
<h3 id="3-从数据结构角度，除了链表法还有什么解决Hash冲突的方式？"><a href="#3-从数据结构角度，除了链表法还有什么解决Hash冲突的方式？" class="headerlink" title="3.从数据结构角度，除了链表法还有什么解决Hash冲突的方式？"></a>3.从数据结构角度，除了链表法还有什么解决Hash冲突的方式？</h3><p>   (❌)，这里搞错题意了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.开放定址法（Open Addressing）：在桶的索引位置发生冲突时，该方法通过探测其他空桶来解决冲突。具体有以下几种探测方式：</span><br><span class="line"></span><br><span class="line">​    线性探测（Linear Probing）：在发生冲突的位置后依次检查下一个位置，直到找到空桶。</span><br><span class="line"></span><br><span class="line">​    二次探测（Quadratic Probing）：根据一个探测序列公式，依次探测下一个位置，直到找到空桶。</span><br><span class="line"></span><br><span class="line">​    双重哈希（Double Hashing）：使用第二个哈希函数来计算下一个位置的偏移量，直到找到空桶。</span><br><span class="line"></span><br><span class="line">开放定址法的优点是可以充分利用桶的空间，没有额外的链表开销，但它也容易引发聚簇（Clustering）现象，导致性能下降。</span><br><span class="line"></span><br><span class="line">2.再哈希法（Rehashing）：在桶的索引位置发生冲突时，该方法通过再次应用哈希函数来计算新的索引位置，直到找到空桶为止。通常会使用一个不同的哈希函数，以减少冲突的可能性。</span><br><span class="line"></span><br><span class="line">再哈希法的优点是可以在不同的哈希函数之间切换，以克服某个哈希函数的缺点。但它也需要维护多个哈希函数，并且可能增加插入和查找操作的时间。</span><br><span class="line"></span><br><span class="line">🌟总结来说，再哈希法是在发生冲突时使用不同的哈希函数重新计算索引位置，而二重哈希是使用第二个哈希函数计算下一个位置的偏移量。</span><br></pre></td></tr></table></figure>





<h2 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a>操作系统：</h2><h3 id="1-线程和进程有什么关系，有什么区别？-3次"><a href="#1-线程和进程有什么关系，有什么区别？-3次" class="headerlink" title="1.线程和进程有什么关系，有什么区别？(3次)"></a>1.线程和进程有什么关系，有什么区别？(3次)</h3><ul>
<li><p><strong>定义</strong>：进程是一个正在执行的程序实例，具有独立的内存空间和资源。线程是进程的一部分，用于执行进程内的具体任务。</p>
</li>
<li><p><strong>资源占用</strong>：每个进程都有自己独立的内存空间和资源，包括文件、网络线程、内核数据结构等。线程共享进程的资源，包括内存空间、文件描述符等。</p>
</li>
<li><p><strong>调度和执行</strong>：进程在操作系统中被调度为可执行状态，并行或交替执行。线程在进程内被调度执行，共享进程的执行环境。</p>
</li>
<li><p><strong>交互和通信</strong>：进程之间通常通过进程间通信（IPC）进行交互和通信，如管道、消息队列、共享内存等。线程之间由于共享相同的内存空间，可以直接访问和修改共享变量，实现线程间的通信和同步。</p>
</li>
<li><p><strong>异常和崩溃</strong>：进程之间具有强隔离性，一个进程的崩溃不会影响其他进程。线程共享同一个进程的资源，一个线程的崩溃可能会影响整个进程的稳定性。</p>
</li>
<li><p><strong>创建和销毁</strong>：创建和销毁进程需要操作系统的调用，涉及加载和卸载程序、分配和释放内存等操作。线程的创建和销毁更轻量级，通常由程序代码直接调用线程库函数进行操作。</p>
</li>
</ul>
<h3 id="2-什么是虚页？"><a href="#2-什么是虚页？" class="headerlink" title="2.什么是虚页？"></a>2.什么是虚页？</h3><ul>
<li><p>在现代计算机系统中，使用了虚拟内存技术来更好地管理和利用系统的内存资源。虚拟内存通过将物理内存和磁盘空间结合起来，为每个进程提供一个逻辑上连续的地址空间，称为虚拟地址空间。</p>
</li>
<li><p>虚拟页和物理页（也称为页框）之间存在映射关系。操作系统利用页表（Page Table）来维护虚拟页与物理页之间的映射关系。页表的每个表项记录了一个虚拟页与一个物理页之间的映射关系。</p>
</li>
<li><p>当程序访问虚拟地址空间中的某个虚拟页时，操作系统首先在页表中查找对应的物理页。如果映射存在，操作系统将虚拟页映射到物理页并将该页加载到主存中，然后将虚拟地址转换为物理地址，程序就可以在主存中访问该虚拟页所对应的物理页了。</p>
</li>
</ul>
<h3 id="3-OS中有一个轻量级进程-LWP-的概念，你有了解吗？"><a href="#3-OS中有一个轻量级进程-LWP-的概念，你有了解吗？" class="headerlink" title="3.OS中有一个轻量级进程(LWP)的概念，你有了解吗？"></a>3.OS中有一个轻量级进程(LWP)的概念，你有了解吗？</h3><p>   (❌，不了解，赶紧了解一下)</p>
<p>在用户空间层面上模拟了传统操作系统中的进程，但在内核态中<strong>每个LWP都与一个特定的内核<u>线</u>程</strong>关联</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">轻量级进程是一种在操作系统中实现的并发执行的方式。它是在用户空间层面上模拟了传统操作系统中的进程，具有自己的执行上下文、栈、寄存器集等，但在内核层面上实际上共享了同一个真实的操作系统线程。</span><br><span class="line"></span><br><span class="line">LWP的主要优势在于它比传统的进程更轻量级，创建和销毁一个LWP的成本要低于创建和销毁一个完整的进程。由于LWP共享了操作系统线程，它们之间的切换成本也更低。这使得创建和切换LWP的开销较小，且在并发执行和并行执行方面具有更高的效率。</span><br></pre></td></tr></table></figure>



<h3 id="4-解释一下零拷贝是什么。"><a href="#4-解释一下零拷贝是什么。" class="headerlink" title="4.解释一下零拷贝是什么。"></a>4.解释一下零拷贝是什么。</h3><p>   (❌，不会)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">零拷贝是指计算机执行IO操作时，CPU不需要将数据从一个存储区域复制到另一个存储区域，进而减少上下文切换以及CPU的拷贝时间。它是一种IO操作优化技术。</span><br><span class="line"></span><br><span class="line">进行网络传输时，需要将待传输文件从磁盘读出，经过一系列拷贝，到达网卡，进行传输。</span><br><span class="line"></span><br><span class="line">传统：硬件设备(磁盘)-&gt;内核缓冲区-&gt;用户缓冲区-&gt;socket缓冲区-&gt;网卡设备       这样的拷贝操作会占用CPU时间和内存带宽，降低系统性能。</span><br><span class="line"></span><br><span class="line">而零拷贝技术通过减少或消除不必要的数据拷贝，提高了数据传输的效率。它通过直接在内核空间中进行数据传输，避免了在用户空间和内核空间之间拷贝数据的过程。</span><br><span class="line"></span><br><span class="line">零拷贝的实现方式：</span><br><span class="line">	1.mmap：硬件设备(磁盘)-&gt;内核缓冲区-&gt;socket缓冲区-&gt;网卡设备 </span><br><span class="line">	2.sendfile：硬件设备(磁盘)-&gt;内核缓冲区-&gt;socket缓冲区-&gt;网卡设备 </span><br><span class="line">	3.sendfile +DMA scatter/gather：硬件设备(磁盘)-&gt;内核缓冲区--&gt;网卡设备 </span><br><span class="line">					⬆️其中CPU把内核缓冲区中的文件描述符信息（包括内核缓冲区的内存地址和偏移量）直接发送到socket缓冲区</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">具体来说，零拷贝的实现可以通过以下方式之一：</span><br><span class="line">DMA（Direct Memory Access）技术：使用DMA控制器将数据直接从存储设备传输到网络适配器，或者从网络适配器直接传输到存储设备，避免了数据在内存中的中间拷贝。</span><br><span class="line"></span><br><span class="line">内核缓冲区直接传输：在系统调用期间，将数据从内核缓冲区传输到网络适配器，或者从网络适配器传输到内核缓冲区，避免了在用户空间和内核空间之间的数据拷贝。</span><br><span class="line"></span><br><span class="line">内核空间到用户空间的零拷贝：通过使用mmap（内存映射）或其他技术，将内核空间的数据直接映射到用户空间，而不需要数据在内存中的额外拷贝。</span><br><span class="line"></span><br><span class="line">零拷贝技术可以在高速数据传输、存储系统和网络应用等场景中发挥作用。它能够减少数据拷贝带来的CPU负载和内存带宽的消耗，提高数据传输的效率和性能。</span><br></pre></td></tr></table></figure>



<h3 id="5-I-x2F-O多路复用你了解多少"><a href="#5-I-x2F-O多路复用你了解多少" class="headerlink" title="5.I&#x2F;O多路复用你了解多少"></a>5.I&#x2F;O多路复用你了解多少</h3><p>   (❌，乱讲一通 &#x3D; 不了解)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I/O多路复用是一种高效的I/O处理机制，它允许单个线程或进程同时监听多个I/O事件，从而实现对多个I/O操作的并发处理。在I/O多路复用模式下，可以在一个线程中同时处理多个客户端请求而无需创建额外的线程。</span><br></pre></td></tr></table></figure>

<p><strong>追问</strong>：有几种I&#x2F;O模式，有什么区别？</p>
<p>   同步异步</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    阻塞式I/O（Blocking I/O）：在阻塞式I/O中，当应用程序发起一个I/O操作后，它会一直阻塞等待直到操作完成。这意味着应用程序无法继续执行其他任务，直到I/O操作完成。阻塞式I/O适用于简单的应用场景，但在面对并发处理需求或高负载情况下，可能会导致性能瓶颈。</span><br><span class="line"></span><br><span class="line">    非阻塞式I/O（Non-Blocking I/O）：在非阻塞式I/O中，当应用程序发起一个I/O操作后，它可以立即返回而不需等待操作完成。应用程序可以继续执行其他任务，然后通过轮询或其他方式来检查I/O操作是否完成。非阻塞式I/O可以提高应用程序的并发性能，但需要应用程序频繁轮询I/O状态，可能会导致CPU资源浪费。</span><br><span class="line">    非阻塞式I/O：不管I/O有没有完成，都要去轮询，查找是否有I/O完成</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    I/O多路复用（I/O Multiplexing）：I/O多路复用允许单个线程或进程同时监听多个I/O事件的就绪状态。通过select或poll或epoll等机制，应用程序可以同时监听多个I/O操作，当有就绪的I/O事件时，再进行实际的读写操作。I/O多路复用可以提高并发处理能力，减少线程或进程的使用，适用于处理大量并发连接的场景。</span><br><span class="line">    </span><br><span class="line">    select或poll：当有I/O完成时，会收到一个通知，但是不知道是哪个线程I/O完毕，所以要轮询查找(这种方式相比非阻塞式I/O避免了空转，网卡通过DMA写入指定内存后，发送一个中断信号告诉CPU有数据包到来了，内核线程就检查是否有I/O完毕了)</span><br><span class="line">		epoll：当有I/O完成时，会收到一个通知，并且会告诉你哪个线程完成了I/O，不需要轮询！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    信号驱动式I/O（Signal-Driven I/O）：信号驱动式I/O允许应用程序在I/O操作完成时接收一个信号通知。应用程序可以在发起I/O操作前设置信号处理器，并在操作完成后通过信号通知来处理相应逻辑。信号驱动式I/O兼具非阻塞和异步I/O的特性，可以提高并发性能。</span><br><span class="line"></span><br><span class="line">    异步I/O（Asynchronous I/O）：在异步I/O中，应用程序发起一个I/O操作后，可以立即返回继续执行其他任务，而无需等待操作完成。当I/O操作完成时，系统会通知应用程序，执行相应的回调处理。异步I/O将I/O操作的处理逻辑分离，可以有效地避免阻塞和轮询带来的性能问题，适用于高并发和高吞吐量的应用场景。异步I/O需要操作系统和应用程序的支持。</span><br><span class="line">信号驱动式I/O和异步I/O的区别：</span><br><span class="line">    ✦技术实现：信号驱动式I/O基于信号和信号处理器的机制实现，而异步I/O基于系统调用和回调函数实现。</span><br><span class="line">    ✦通知方式：信号驱动式I/O通过发送信号来通知应用程序，而异步I/O通过回调函数来通知应用程序。</span><br><span class="line">    ✦应用程序接口：信号驱动式I/O需要应用程序显式地设置信号处理器和关联到特定的I/O操作上，而异步I/O需要应用程序设置回调函数，并通过注册到操作系统的事件机制来进行回调通知。</span><br><span class="line">    ✦可控性：信号驱动式I/O具有更低一级的控制，应用程序可以在信号处理器中自行处理操作完成的事件和结果。而异步I/O的控制由操作系统来处理，应用程序只需要定义回调函数来处理已完成的操作。</span><br></pre></td></tr></table></figure>









<h2 id="计算机网络："><a href="#计算机网络：" class="headerlink" title="计算机网络："></a>计算机网络：</h2><h3 id="1-为什么视频传输的时候要用UDP，除了握手挥手，TCP还差在哪里？"><a href="#1-为什么视频传输的时候要用UDP，除了握手挥手，TCP还差在哪里？" class="headerlink" title="1.为什么视频传输的时候要用UDP，除了握手挥手，TCP还差在哪里？"></a>1.为什么视频传输的时候要用UDP，除了握手挥手，TCP还差在哪里？</h3><ul>
<li>实时性: UDP是一种无连接的协议，没有TCP那样的握手、确认和重传机制，使得数据包能够以更快的速度被发送到目标地址。在实时应用中，如视频传输，低延迟和实时性非常重要，UDP能够满足这些需求。</li>
<li>较小的开销: 由于UDP没有TCP那样的拥塞控制和流量控制机制，以及对可靠性的需求，它的数据包头部相对较小，因此传输效率更高。这对于带宽受限的场景，如视频传输等，非常有利。</li>
<li>灵活性和自定义性: UDP协议相对简单，它只负责数据的传输，不负责数据的可靠性和有序性，因此更加灵活。这样可以让开发人员根据具体需求自定义传输协议和处理机制，满足特定的实时性要求，如直播、视频通话等。</li>
<li>减轻服务器负担: 当一个视频服务需要同时处理大量的客户端请求时，使用UDP可以减轻服务器的负担。因为UDP的无连接特性，服务器不需要为每个客户端维护连接状态，也不需要进行复杂的管理和调度。</li>
</ul>
<h3 id="2-描述一下TCP建立连接的过程。"><a href="#2-描述一下TCP建立连接的过程。" class="headerlink" title="2.描述一下TCP建立连接的过程。"></a>2.描述一下TCP建立连接的过程。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TCP（Transmission Control Protocol）是一种面向连接的可靠传输协议。下面是 TCP 建立连接的过程：</span><br><span class="line"></span><br><span class="line">客户端发送 SYN（同步）报文：当客户端要与服务器建立 TCP 连接时，它会发送一个 SYN 报文给服务器。这个报文包含一个序列号（Seq）用于标识发送的数据段。</span><br><span class="line"></span><br><span class="line">服务器回复 SYN-ACK（同步-确认）报文：服务器接收到客户端的 SYN 报文后，会向客户端返回一个 SYN-ACK 报文。这个报文中，服务器的序列号被设置为服务器初始序列号，确认号（Ack）被设置为客户端的序列号加 1，表示服务器已经收到了客户端的 SYN 报文。</span><br><span class="line"></span><br><span class="line">客户端发送 ACK（确认）报文：客户端接收到服务器的 SYN-ACK 报文后，会向服务器发送一个 ACK 报文。该报文的序列号被设置为客户端的初始序列号，确认号被设置为服务器的序列号加 1，表示客户端已经收到了服务器的 SYN-ACK 报文。</span><br><span class="line"></span><br><span class="line">连接建立：服务器接收到客户端的 ACK 报文后，双方成功建立了 TCP 连接。双方现在可以开始交换数据。</span><br><span class="line"></span><br><span class="line">这个过程通常被称为三次握手，因为它包含了三个主要步骤，分别是客户端发送 SYN、服务器回复 SYN-ACK、客户端发送 ACK。三次握手的目的是确保双方都能够收发数据，并同步初始化序列号。</span><br><span class="line"></span><br><span class="line">在 TCP 连接的过程中，每个报文都有对方的确认号和序列号，用于保证可靠性和顺序性。三次握手过程中，服务器和客户端都会分配初始序列号，以确保连接的唯一性和安全性。</span><br></pre></td></tr></table></figure>



<h3 id="3-在一台主机的一个端口同时建立TCP和UDP协议，能建立起来吗？"><a href="#3-在一台主机的一个端口同时建立TCP和UDP协议，能建立起来吗？" class="headerlink" title="3.在一台主机的一个端口同时建立TCP和UDP协议，能建立起来吗？"></a>3.在一台主机的一个端口同时建立TCP和UDP协议，能建立起来吗？</h3><p>   (❌，计网还没看，说得七七八八的，太差了)   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TCP 和 UDP 是基于不同协议的传输层协议，它们在传输方式和连接管理上有所区别。 TCP 是一种面向连接的、可靠的传输协议，而 UDP 则是无连接和不可靠的传输协议。虽然它们使用相同的端口号来标识应用程序，但它们是独立的协议栈。</span><br><span class="line"></span><br><span class="line">当使用一个端口号时，操作系统根据协议类型（TCP 或 UDP）来区分接收到的数据。因此，在同一台主机的同一端口上，可以同时建立 TCP 和 UDP 连接，只要你将每个连接区分为 TCP 连接或 UDP 连接即可。</span><br></pre></td></tr></table></figure>



<h3 id="4-HTTP协议的格式能描述一下吗？比如请求和响应头的格式。"><a href="#4-HTTP协议的格式能描述一下吗？比如请求和响应头的格式。" class="headerlink" title="4.HTTP协议的格式能描述一下吗？比如请求和响应头的格式。"></a>4.HTTP协议的格式能描述一下吗？比如请求和响应头的格式。</h3><p>   (❌)说得七七八八</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">HTTP 请求的格式：</span><br><span class="line">✦请求行（Request Line）：</span><br><span class="line">        &lt;请求方法&gt; &lt;目标资源路径&gt; &lt;协议版本&gt;</span><br><span class="line">✦请求头（Request Headers）：包含了关于请求的一些附加信息，格式为键值对，每个键值对占据一行。</span><br><span class="line">        &lt;键1&gt;: &lt;值1&gt;</span><br><span class="line">        &lt;键2&gt;: &lt;值2&gt;</span><br><span class="line">        ...</span><br><span class="line">✦空行（空格 + 回车换行）：</span><br><span class="line">        用于分隔请求头和请求体。</span><br><span class="line">✦请求体（Request Body）：</span><br><span class="line">        可选的，适用于一些特定的请求，如 POST 请求，用于传输用户提交的数据。</span><br><span class="line"></span><br><span class="line">HTTP 响应的格式：</span><br><span class="line">✦状态行（Status Line）：</span><br><span class="line">        &lt;协议版本&gt; &lt;状态码&gt; &lt;状态信息&gt;</span><br><span class="line">✦响应头（Response Headers）：</span><br><span class="line">        包含了关于响应的一些附加信息，格式为键值对，每个键值对占据一行。</span><br><span class="line">        &lt;键1&gt;: &lt;值1&gt;</span><br><span class="line">        &lt;键2&gt;: &lt;值2&gt;</span><br><span class="line">        ...</span><br><span class="line">✦空行（空格 + 回车换行）：</span><br><span class="line">        用于分隔响应头和响应体。</span><br><span class="line">✦响应体（Response Body）：</span><br><span class="line">        包含了服务器响应的数据。</span><br></pre></td></tr></table></figure>



<h3 id="5-GET和POST两种请求的区别是什么？"><a href="#5-GET和POST两种请求的区别是什么？" class="headerlink" title="5.GET和POST两种请求的区别是什么？"></a>5.GET和POST两种请求的区别是什么？</h3><p>   只说了1(⚠️)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.参数传递位置：GET请求将参数附加在URL的末尾，形成URL参数，即在请求行中传递参数；而POST请求将参数包含在请求的消息体中，通过请求体传递参数。</span><br><span class="line"></span><br><span class="line">2.安全性：GET请求以明文形式传输参数，将参数添加在URL中，可以在浏览器的地址栏直接看到；POST请求则使用消息体传输参数，对参数进行了封装，不会直接暴露在URL中，相对较为安全。</span><br><span class="line"></span><br><span class="line">3.请求长度限制：GET请求对URL的长度有限制，一般在浏览器中限制为2048个字符；而POST请求没有严格的长度限制，可以传输更大的数据量。</span><br><span class="line"></span><br><span class="line">4.缓存机制：GET请求可以被缓存：如果请求的是静态资源，则会缓存，如果是数据，则不会缓存; 而POST请求默认不会被缓存。</span><br><span class="line"></span><br><span class="line">5.请求语义：GET请求主要用于获取资源，操作不应带来副作用，例如查询数据；POST请求主要用于向服务器提交数据，可能会对服务器产生影响，例如提交表单或创建新资源。</span><br><span class="line"></span><br><span class="line">6.get请求产生一个TCP数据包；post请求产生两个TCP数据包（get请求，浏览器会把http header和data一并发送出去，服务器响应200返回数据；post请求，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 返回数据）</span><br></pre></td></tr></table></figure>



<h3 id="6-说几个常见的HTTP相应码"><a href="#6-说几个常见的HTTP相应码" class="headerlink" title="6.说几个常见的HTTP相应码"></a>6.说几个常见的HTTP相应码</h3><p>   (⚠️)只答了几个，并且不太熟悉</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">200 OK：表示请求成功，服务器成功处理了请求。</span><br><span class="line"></span><br><span class="line">301 Moved Permanently：永久重定向，表示请求的资源已经被移动到了新的URL。</span><br><span class="line"></span><br><span class="line">302 Found：临时重定向，表示请求的资源暂时被移动到了新的URL。</span><br><span class="line"></span><br><span class="line">400 Bad Request：表示客户端的请求语法错误或无效，服务器无法理解。</span><br><span class="line"></span><br><span class="line">401 Unauthorized：表示请求需要身份验证，客户端需要提供有效的凭据。</span><br><span class="line"></span><br><span class="line">403 Forbidden：表示服务器理解请求，但拒绝执行，客户端没有访问权限。</span><br><span class="line"></span><br><span class="line">404 Not Found：表示服务器无法找到请求的资源。</span><br><span class="line"></span><br><span class="line">500 Internal Server Error：表示服务器内部错误，无法完成请求。</span><br><span class="line"></span><br><span class="line">502 Bad Gateway是指作为代理或网关的服务器从上游服务器接收到一个无效的响应，导致无法完成请求。</span><br><span class="line"></span><br><span class="line">503 Service Unavailable：表示服务器暂时无法处理请求，通常是由于服务器过载或维护。</span><br><span class="line"></span><br><span class="line">401 vs 403</span><br><span class="line">总结起来，401 Unauthorized表示客户端未提供有效的身份验证信息，需要进行身份验证；而403 Forbidden表示客户端已提供有效的身份验证，但是被服务器拒绝访问该资源。</span><br></pre></td></tr></table></figure>



<h3 id="7-比如你遇到了502错误，你该怎么去排查错误呢？"><a href="#7-比如你遇到了502错误，你该怎么去排查错误呢？" class="headerlink" title="7.比如你遇到了502错误，你该怎么去排查错误呢？"></a>7.比如你遇到了502错误，你该怎么去排查错误呢？</h3><p>   首先因为5开头，确定是服务器方面的错误，然后去服务器查看报错信息以及日志信息。</p>
<p>(⚠️)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">了解错误码：首先阅读错误信息，确切了解错误的类型和含义。不同的错误码代表不同的问题，了解错误码可以帮助你更快定位问题。</span><br><span class="line"></span><br><span class="line">检查网络连接：确保你的网络连接正常。尝试访问其他网站或服务，以确认是否只有特定的网站或服务受到影响。</span><br><span class="line"></span><br><span class="line">刷新页面或重试：有时候错误可能只是暂时的，尝试刷新页面或重新执行操作，看看错误是否会消失。</span><br><span class="line"></span><br><span class="line">检查URL和请求参数：确保URL和请求参数正确无误。可能是由于请求的URL或参数不正确导致服务器返回错误。</span><br><span class="line"></span><br><span class="line">检查服务器状态：如果错误是与特定的网站或服务相关，可以尝试访问其他网站或服务来确认是服务器端的问题还是客户端的问题。</span><br><span class="line"></span><br><span class="line">查看服务器日志：如果你有服务器的访问权限，可以查看服务器的日志来获取更多的错误信息。服务器日志通常可以提供有关错误发生的具体细节，帮助你定位问题。</span><br><span class="line"></span><br><span class="line">联系网站管理员或技术支持：如果你已经尝试过以上的排查步骤但问题仍然存在，建议联系网站的管理员或技术支持人员。他们可能具有更深入的技术知识和工具来帮助你解决问题。</span><br></pre></td></tr></table></figure>



<h3 id="8-https-的原理是什么？"><a href="#8-https-的原理是什么？" class="headerlink" title="8.https 的原理是什么？"></a>8.https 的原理是什么？</h3><p>  就知道这是http的一种安全的形式(❌，不会)</p>
<p><strong>追问：</strong>安全是怎么实现的呢？</p>
<p>  应该是对传输进行了加密</p>
<p><strong>追问：</strong>怎么加密的呢？</p>
<p>  不是很清楚</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qh1112/article/details/125137337?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169331657916800180681936%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169331657916800180681936&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-125137337-null-null.142%5Ev93%5EchatsearchT3_2&utm_term=https%20%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F&spm=1018.2226.3001.4187">https介绍</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTPS是一种通过加密传输数据的网络协议，它的原理如下：</span><br><span class="line"></span><br><span class="line">1.加密通信：HTTPS 使用了加密算法来保护数据的机密性。在客户端与服务器之间建立连接时，首先会进行一次称为SSL/TLS握手的过程，通过该握手过程来协商加密算法和密钥等信息。然后，通过使用协商的密钥对传输的数据进行加密，确保数据在传输过程中不容易被窃听或篡改。</span><br><span class="line"></span><br><span class="line">2.数字证书验证：HTTPS 使用数字证书来验证服务器的身份。数字证书由第三方机构（证书颁发机构，Certificate Authority，CA）签发，包含了服务器的公钥和相关信息。在握手过程中，客户端会检查服务器返回的证书，并验证其有效性和合法性。如果验证通过，客户端会使用证书中的公钥加密传输的数据。</span><br><span class="line"></span><br><span class="line">3.对称加密与非对称加密结合：HTTPS 使用对称加密和非对称加密结合的方式来进行加密传输。非对称加密算法用于在握手过程中协商对称加密算法和密钥，这样可以确保密钥在传输过程中不被泄露。对称加密算法用于加密实际传输的数据，对称加密算法的加解密速度更快，保证了性能。</span><br><span class="line"></span><br><span class="line">4.安全标识：HTTPS 使用 URL 地址中的 &quot;https://&quot; 来表示当前使用的是安全的加密连接。</span><br><span class="line"></span><br><span class="line">总结来说，HTTPS 通过加密通信、数字证书验证、对称加密与非对称加密结合等措施，实现了对传输数据的机密性和完整性的保护。这使得客户端与服务器之间的通信更加安全，可以有效地防止数据被窃听和篡改。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="9-你知道使用http协议通信的客户端和服务器之间是怎么建立连接的、报文是怎么发送的？"><a href="#9-你知道使用http协议通信的客户端和服务器之间是怎么建立连接的、报文是怎么发送的？" class="headerlink" title="9.你知道使用http协议通信的客户端和服务器之间是怎么建立连接的、报文是怎么发送的？"></a>9.你知道使用http协议通信的客户端和服务器之间是怎么建立连接的、报文是怎么发送的？</h3><p>  http是基于TCP协议进行连接，消息传输的……三次握手四次挥手</p>
<p>  (❌,偏题了啊。。。)……三次握手很熟练，but四次挥手没看，一下就露出了马脚，被追着问四次挥手</p>
<p><strong>追问：</strong>三次挥手不行吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">原问题的回答：</span><br><span class="line">当客户端与服务器之间使用HTTP协议进行通信时，建立连接和报文的发送可以分为以下步骤：</span><br><span class="line"></span><br><span class="line">1. 建立连接：</span><br><span class="line">   - 客户端发送一个连接请求给服务器，这通常是通过向服务器的IP地址和端口发送连接请求的方式实现的。</span><br><span class="line">   - 服务器接收到这个连接请求后，会进行一系列的握手过程来建立连接。这个过程通常是使用TCP协议来完成的。</span><br><span class="line">   - 一旦握手成功，客户端和服务器之间就建立了一个持久的连接，可以进行通信。</span><br><span class="line"></span><br><span class="line">2. 报文的发送：</span><br><span class="line">   - 客户端构建HTTP请求报文，包括请求行、请求头和请求体。</span><br><span class="line">   - 客户端将构建好的请求报文通过已建立的连接发送给服务器。</span><br><span class="line">   - 服务器接收到请求报文后，会解析其中的内容，包括请求方法、URL、请求头和请求体等。</span><br><span class="line">   - 服务器根据请求的内容进行相应的处理，可能是读取数据库、执行业务逻辑等。</span><br><span class="line">   - 服务器构建HTTP响应报文，包括响应行、响应头和响应体。</span><br><span class="line">   - 服务器将构建好的响应报文通过已建立的连接发送给客户端。</span><br><span class="line">   - 客户端接收到响应报文后，会解析其中的内容，包括响应状态码、响应头和响应体等。</span><br><span class="line">   - 客户端根据响应的内容进行相应的处理，可能是展示页面、执行下一步操作等。</span><br><span class="line"></span><br><span class="line">需要注意的是，HTTP是无状态的协议，每个请求和响应都是独立的，服务器不会记住之前的请求，因此需要使用一些机制（如Cookie、Session等）来维护状态信息。</span><br><span class="line"></span><br><span class="line">以上就是使用HTTP协议通信时客户端和服务器之间建立连接和报文的发送过程。具体的实现和细节可能会有所不同，但总体流程相似。</span><br><span class="line"></span><br><span class="line">追问的回答：</span><br><span class="line">四次挥手把同意对方请求跟自身请求分离开。是因为在客户端请求断开时（客户端发送端-&gt;服务器接收端），服务器可能还有数据未发完，所以需要分开操作：</span><br><span class="line">   ✦先同意对方关闭连接，对方无法传输数据；（第二次挥手）</span><br><span class="line">   ✦自己若还有数据未发送完，接着发送直至全部发送完毕；</span><br><span class="line">   ✦请求自身关闭连接；（第三次挥手）</span><br><span class="line">也就是说，三次握手、四次挥手差别就在第二次，有没有把同意对方请求跟自身请求拆分开。</span><br></pre></td></tr></table></figure>



<h3 id="10-为什么客户端要等2个时长后关闭呢？就是2ML问题？"><a href="#10-为什么客户端要等2个时长后关闭呢？就是2ML问题？" class="headerlink" title="10.为什么客户端要等2个时长后关闭呢？就是2ML问题？"></a>10.为什么客户端要等2个时长后关闭呢？就是2ML问题？</h3><p>  不清楚(❌)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">避免网络不稳定带来的问题, 假如在最后发送ACK请求后直接关闭, 此时由于网络原因Server端没收到, Server就会重试FIN请求 但是此时连接已经关闭了,Server端将无法正常发送报文 或者 发送到错误的地方;</span><br></pre></td></tr></table></figure>



<h3 id="11-了解http的滑动窗口是什么吗？"><a href="#11-了解http的滑动窗口是什么吗？" class="headerlink" title="11.了解http的滑动窗口是什么吗？"></a>11.了解http的滑动窗口是什么吗？</h3><p>  (❌很模糊，答了个大意—一次传输多个数据块—记错了)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">滑动窗口本质上是描述接受方的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据。如果发送方收到接受方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接受方发送窗口大小不为0的数据报的到来。</span><br></pre></td></tr></table></figure>





<h2 id="Java基础："><a href="#Java基础：" class="headerlink" title="Java基础："></a>Java基础：</h2><h3 id="1-java中有几个基本的数据类型？"><a href="#1-java中有几个基本的数据类型？" class="headerlink" title="1.java中有几个基本的数据类型？"></a>1.java中有几个基本的数据类型？</h3><p>byte、short、int、long、float、double、char、boolean(⚠️)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一次没答出来boolean，忘记了，反思一下</span><br></pre></td></tr></table></figure>



<h3 id="2-一个byte是几个字节？"><a href="#2-一个byte是几个字节？" class="headerlink" title="2.一个byte是几个字节？"></a>2.一个byte是几个字节？</h3><p>1字节，8bit</p>
<h3 id="3-一个char类型数据可以转成什么类型？"><a href="#3-一个char类型数据可以转成什么类型？" class="headerlink" title="3.一个char类型数据可以转成什么类型？"></a>3.一个char类型数据可以转成什么类型？</h3><p>int</p>
<p><strong>追问</strong>：可以转换成byte吗？</p>
<p>   不行(❌）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果字符的Unicode码值在0到127之间，可以将char类型强制转换为byte类型)</span><br></pre></td></tr></table></figure>



<h3 id="4-如何创建float类型的变量"><a href="#4-如何创建float类型的变量" class="headerlink" title="4.如何创建float类型的变量"></a>4.如何创建float类型的变量</h3><p>数字后面加f</p>
<h3 id="5-float与double类型进行混合运算结果会准确吗？"><a href="#5-float与double类型进行混合运算结果会准确吗？" class="headerlink" title="5.float与double类型进行混合运算结果会准确吗？"></a>5.float与double类型进行混合运算结果会准确吗？</h3><p>不会，混合运算时会将float转换为double后再进行运算，转换时会产生舍入误差，尤其是在运算小数部分时。</p>
<h3 id="8-java中-double类型数据的组织形式是怎么样的？"><a href="#8-java中-double类型数据的组织形式是怎么样的？" class="headerlink" title="8.java中 double类型数据的组织形式是怎么样的？"></a>8.java中 double类型数据的组织形式是怎么样的？</h3><p>有几位是表示数值部分，有几位表示它是2的几次方</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过IEEE标准组织：具体来说：</span><br><span class="line">| 符号位（1 bit）| 指数位（11 bits）| 尾数位（52 bits）|</span><br></pre></td></tr></table></figure>



<h3 id="7-java中如何准确地表达数据的加减运算？"><a href="#7-java中如何准确地表达数据的加减运算？" class="headerlink" title="7.java中如何准确地表达数据的加减运算？"></a>7.java中如何准确地表达数据的加减运算？</h3><p>使用BigDecimal类</p>
<h3 id="10-你在你的项目中有用过这个数据类型吗？"><a href="#10-你在你的项目中有用过这个数据类型吗？" class="headerlink" title="10.你在你的项目中有用过这个数据类型吗？"></a>10.你在你的项目中有用过这个数据类型吗？</h3><p>没有用过(⚠️)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">随便举个例子不就行了。。。</span><br><span class="line">财务计算：BigDecimal可用于进行精确的货币计算，避免因浮点数运算引起的舍入误差。</span><br><span class="line">    例如，在购物网站中，计算订单总金额、折扣、税费等涉及货币计算的地方都可以使用BigDecimal来进行精确计算。</span><br></pre></td></tr></table></figure>



<h3 id="11-java中一般用什么数据类型来接收-定义在数据库中的主键"><a href="#11-java中一般用什么数据类型来接收-定义在数据库中的主键" class="headerlink" title="11.java中一般用什么数据类型来接收 定义在数据库中的主键"></a>11.java中一般用什么数据类型来接收 定义在数据库中的主键</h3><p>Integer(❌）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">踩大雷！！！！！！！！！！</span><br><span class="line"></span><br><span class="line">在Java中，一般使用long或者Long数据类型来接收和定义数据库中的主键。</span><br><span class="line"></span><br><span class="line">如果主键是自增长的整数类型，例如在MySQL中使用AUTO_INCREMENT属性，那么大部分情况下使用long类型是适合的。</span><br><span class="line"></span><br><span class="line">如果主键可能为空或者允许为空，那么可以使用Long类型。Long是long的包装类，可以接受null值，而long类型无法直接接受null。</span><br></pre></td></tr></table></figure>



<h3 id="10-刚才说到Integer是一种包装类型，如果我定义一个Integer-a-x3D-1；在定义-int-b-x3D-1；我进行if-a-x3D-x3D-b-判断条件会成立吗？"><a href="#10-刚才说到Integer是一种包装类型，如果我定义一个Integer-a-x3D-1；在定义-int-b-x3D-1；我进行if-a-x3D-x3D-b-判断条件会成立吗？" class="headerlink" title="10.刚才说到Integer是一种包装类型，如果我定义一个Integer a &#x3D; 1；在定义 int b &#x3D; 1；我进行if(a &#x3D;&#x3D; b)判断条件会成立吗？"></a>10.刚才说到Integer是一种包装类型，如果我定义一个Integer a &#x3D; 1；在定义 int b &#x3D; 1；我进行if(a &#x3D;&#x3D; b)判断条件会成立吗？</h3><p>   会成立，因为1是有缓存的(⚠️虽然实际原理和我想得不一样，但是说出这句话是对的，属于运气好)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">只要有一个是int，用==比较时就会自动拆箱，比较数值</span><br><span class="line">如果是[-128,127]的包装类，那么他们的对象地址相同，不在这个范围内，对象地址不同</span><br></pre></td></tr></table></figure>



<h3 id="11-加入-Integer-a-x3D-new-Integer-1-int-b-x3D-1-那么if-a-x3D-x3D-b-是否相等？"><a href="#11-加入-Integer-a-x3D-new-Integer-1-int-b-x3D-1-那么if-a-x3D-x3D-b-是否相等？" class="headerlink" title="11.加入 Integer a &#x3D; new Integer(1); int b &#x3D; 1; 那么if(a &#x3D;&#x3D; b)是否相等？"></a>11.加入 Integer a &#x3D; new Integer(1); int b &#x3D; 1; 那么if(a &#x3D;&#x3D; b)是否相等？</h3><p>   不会相等，因为a这边在堆中创建了一个新的对象(❌，会比较数值，只有&#x3D;&#x3D;两边都是Integer时，才会比较对象地址)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比较值，相等</span><br></pre></td></tr></table></figure>



<h3 id="12-刚才说的等号两边一边是Integer，一边是int，为什么能这样判断，你了解吗？"><a href="#12-刚才说的等号两边一边是Integer，一边是int，为什么能这样判断，你了解吗？" class="headerlink" title="12.刚才说的等号两边一边是Integer，一边是int，为什么能这样判断，你了解吗？"></a>12.刚才说的等号两边一边是Integer，一边是int，为什么能这样判断，你了解吗？</h3><p>   因为java有自动装箱、自动拆箱的功能，像刚才的情况会自动把Integer拆箱成int进行比较！</p>
<h3 id="13-java中-boolean类型可以转换成int类型吗？"><a href="#13-java中-boolean类型可以转换成int类型吗？" class="headerlink" title="13.java中 boolean类型可以转换成int类型吗？"></a>13.java中 boolean类型可以转换成int类型吗？</h3><p>   不行(❌)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">寄！刚知道！</span><br><span class="line">☄️当将 boolean 类型的值转换为 int 类型时，true 转换为 1，false 转换为 0。这是因为 boolean 类型只有两个可能的取值：true 和 false。</span><br><span class="line">boolean 类型转换为 int 类型是隐式的，可以直接赋值或使用条件运算符进行转换。在此过程中，Java会自动将其转换为对应的整数值。</span><br></pre></td></tr></table></figure>



<h3 id="14-java集合类中，线性方式存储的有哪些？"><a href="#14-java集合类中，线性方式存储的有哪些？" class="headerlink" title="14.java集合类中，线性方式存储的有哪些？"></a>14.java集合类中，线性方式存储的有哪些？</h3><p>   ArrayList、LinkedList (⚠️)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">还有</span><br><span class="line">Vector：Vector 是传统的动态数组，与 ArrayList 类似，但是被设计为线程安全的，它支持同步操作。</span><br><span class="line">Stack：Stack 是堆栈数据结构的 Java 实现，它基于动态数组。它使用后进先出 (LIFO) 的方式存储和访问元素。</span><br></pre></td></tr></table></figure>

<p><strong>追问</strong>：ArrayList、LinkedList底层的实现是什么？</p>
<p>   ArrayList底层是数组，LinkedList底层是链表</p>
<p><strong>追问</strong>：(ArrayList)数组的大小是怎么确定的呢？</p>
<p>   在构造函数中，如果没给值就按默认大小创建，如果给了并且合法就按提供的值来创建</p>
<p><strong>追问</strong>：假设ArrayList容量为5，add到第几个数据的时候扩容？</p>
<p>   满了就扩容(❌)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始容量为5的 ArrayList 可以容纳5个元素，它会一直使用这个固定的容量直到添加第6个元素。</span><br></pre></td></tr></table></figure>

<p><strong>追问</strong>：ArrayList、LinkedList的使用场景是什么？</p>
<p>   ArrayList频繁查询、LinkedList频繁增删</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果需要频繁机访问或在末尾进行添加/删除操作，可以使用 ArrayList(因为在末尾操作避免了数据的移动)；</span><br><span class="line">如果需要频繁在中间位置进行插入/删除操作或实现栈/队列相关功能，可以使用 LinkedList</span><br></pre></td></tr></table></figure>

<p><strong>追问</strong>：LinkedList底层如何删除一个数据？</p>
<p>就是链表的节点删除</p>
<h3 id="15-Map的实现类有哪些，介绍一下它们："><a href="#15-Map的实现类有哪些，介绍一下它们：" class="headerlink" title="15.Map的实现类有哪些，介绍一下它们："></a>15.Map的实现类有哪些，介绍一下它们：</h3><ul>
<li><p><strong>HashMap</strong>：HashMap是最常用的Map实现类之一。它基于哈希表实现，可以提供快速的插入、删除和查找操作。HashMap允许存储键值对，其中键是唯一的，值可以重复。它不保证元素的顺序，也不是线程安全的。</p>
</li>
<li><p><strong>TreeMap</strong>：TreeMap是基于红黑树实现的有序Map。它会根据键的自然顺序或者自定义比较器对键进行排序。TreeMap的插入、删除和查找操作的时间复杂度为O(logN)。由于它<u>对键进行排序</u>，因此遍历时会按照键的顺序输出。TreeMap不是线程安全的。</p>
</li>
<li><p><strong>LinkedHashMap</strong>：LinkedHashMap是HashMap的子类，它保持了插入顺序或者访问顺序（通过构造函数指定）。LinkedHashMap使用哈希表和双向链表实现，因此可以在常数时间内维护键的顺序。LinkedHashMap也不是线程安全的。</p>
</li>
<li><p><strong>ConcurrentHashMap</strong>：ConcurrentHashMap是线程安全的HashMap实现。它通过将整个Map分成多个段（Segment）来提高并发访问的性能。这样，在大多数情况下，不同的线程可以同时访问Map，从而提高性能。ConcurrentHashMap不保证元素的顺序。</p>
</li>
<li><p><strong>Hashtable</strong>：Hashtable是早期的哈希表实现，它是线程安全的。虽然Hashtable的使用已经不那么常见，但由于它是线程安全的，因此在多线程环境中仍然可以使用。</p>
</li>
</ul>
<h3 id="16-HashMap的应用场景是什么？"><a href="#16-HashMap的应用场景是什么？" class="headerlink" title="16.HashMap的应用场景是什么？"></a>16.HashMap的应用场景是什么？</h3><ul>
<li>HashMap是一种常用的Map实现类，适用于以下场景：<ol>
<li><strong>快速查找</strong>：由于HashMap基于哈希表实现，可以快速进行查找操作。如果需要根据键快速查找对应的值，HashMap是一个很好的选择。</li>
<li><strong>键值唯一</strong>：HashMap的键是唯一的，不允许重复。这对于需要存储唯一键值对的场景非常适用，例如存储用户ID和对应的用户信息。</li>
<li><strong>无需排序</strong>：HashMap不保证元素的顺序，插入和删除操作的顺序也不会影响其内部结构。如果不需要对键进行排序，只需要快速存储和查找键值对，那么HashMap是一个很好的选择。</li>
<li><strong>非线程安全环境</strong>：HashMap不是线程安全的，适用于在单线程环境下使用。如果需要在多线程环境中使用Map，可以考虑使用ConcurrentHashMap。</li>
</ol>
</li>
</ul>
<h3 id="17-HashMap的实现方式是什么样的？"><a href="#17-HashMap的实现方式是什么样的？" class="headerlink" title="17.HashMap的实现方式是什么样的？"></a>17.HashMap的实现方式是什么样的？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.首先，计算键的哈希值。哈希函数（Hash Function）负责将键转换成一个整数值，一般情况下会根据键的特征进行计算，目的是使哈希值尽可能均匀地分布在桶的范围内。</span><br><span class="line"></span><br><span class="line">2.根据哈希值计算出桶的索引位置。通常使用一个取模运算将哈希值映射到桶的范围内，得到桶的索引位置。</span><br><span class="line"></span><br><span class="line">3.在桶的索引位置上进行操作。如果桶为空，表示没有冲突，直接将键值对存储在该位置上；如果桶不为空，表示发生了冲突，可能有多个键值对哈希值映射到同一个桶上。</span><br></pre></td></tr></table></figure>





<h2 id="MySQL："><a href="#MySQL：" class="headerlink" title="MySQL："></a>MySQL：</h2><h3 id="1-数据库中的id用的什么数据类型？"><a href="#1-数据库中的id用的什么数据类型？" class="headerlink" title="1.数据库中的id用的什么数据类型？"></a>1.数据库中的id用的什么数据类型？</h3><p>   int(⚠️)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">⚠️一般常见的id数据类型选择：</span><br><span class="line"></span><br><span class="line">整数类型（Integer Types）：在大多数情况下，整数类型是用来存储主键 id 的常见选择。例如，在MySQL中可以使用 INT、BIGINT、SERIAL 等数据类型来存储主键。在Oracle数据库中，可以使用 NUMBER 数据类型。</span><br><span class="line"></span><br><span class="line">字符串类型（String Types）：有时候也会使用字符串类型来存储主键 id。例如，使用 VARCHAR 或 CHAR 数据类型。这种情况下，一般是由于主键的值并不是自增长的整数，而是具有特定的格式或需要满足一定的业务需求。</span><br><span class="line"></span><br><span class="line">全局唯一标识符（GUID）或通用唯一标识符（UUID）：在某些情况下，可以使用全局唯一标识符或通用唯一标识符来作为主键 id。这些标识符是全局唯一的，并且可在不同系统之间保持唯一性。在数据库中可以使用 UNIQUEIDENTIFIER 类型来存储这样的主键。</span><br></pre></td></tr></table></figure>



<h3 id="2-mysql索引是什么结构？"><a href="#2-mysql索引是什么结构？" class="headerlink" title="2.mysql索引是什么结构？"></a>2.mysql索引是什么结构？</h3><p>   B+树</p>
<p><strong>追问</strong>：描述一下B+树</p>
<p>   叶子节点存放数据，非叶子节点存放引用，底层叶子结点间用双向链表连接……</p>
<p><strong>追问</strong>：底层双向链表的作用是什么？</p>
<p>   方便顺序访问，查询一片区域是效率比较高，减少了随机I&#x2F;O(⚠️感觉说得不是很好，看看下面的补充吧)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">✦顺序访问：双向链表使得数据页可以按照索引顺序进行顺序访问。这对于一些范围查询或者顺序扫描操作很重要，因为它可以减少磁盘 I/O 的次数，提高查询性能。</span><br><span class="line">✦快速查找：在双向链表中，每个数据页都有指向前一个和后一个数据页的指针。这样可以通过两个方向进行查询，即根据索引的顺序可以迅速找到下一个数据页或者前一个数据页。这对于快速定位到指定数据页并获取相应的数据非常重要，减少了查询的时间复杂度。</span><br><span class="line">✦索引维护：当进行数据插入或删除操作时，双向链表可以快速定位到叶子节点，并调整链表指针来保持索引的有序性。例如，插入操作会将新的数据插入到正确的位置，并更新相邻叶子节点的链表指针。这样可以保持索引的有效性，并减少维护索引的开销。</span><br></pre></td></tr></table></figure>



<h3 id="3-讲一下聚簇索引"><a href="#3-讲一下聚簇索引" class="headerlink" title="3.讲一下聚簇索引"></a>3.讲一下聚簇索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在聚簇索引中，数据行按照索引的顺序存储在磁盘上。</span><br><span class="line">以下是关于聚簇索引的一些重要特点和优势：</span><br><span class="line">    ✦数据和索引的结合：聚簇索引将索引行和实际数据行映射到同一块存储空间上。这样，在查询时可以通过索引快速定位到符合条件的数据行，减少了磁盘 I/O 操作的次数，提高了查询的效率。</span><br><span class="line">    ✦数据的物理有序性：由于聚簇索引定义了物理数据存储的顺序，因此相邻的数据行通常在磁盘上也是相邻存储的。这种有序性可以提高查询范围和顺序访问的性能，因为可以减少磁盘 I/O 操作和随机访问的次数。</span><br><span class="line">    ✦压缩优势：聚簇索引可以获得更好的数据压缩效果。由于相邻的数据行通常具有相似的值，所以利用聚簇索引可以实现更高的数据压缩率。这对于占用大量存储空间的大表尤为重要，可以减少存储和 I/O 开销，并提高整体数据库性能。</span><br></pre></td></tr></table></figure>

<h3 id="4-表里有主键id列，name列，我建立-id-name-的联合索引会起作用吗？有必要吗？"><a href="#4-表里有主键id列，name列，我建立-id-name-的联合索引会起作用吗？有必要吗？" class="headerlink" title="4. 表里有主键id列，name列，我建立(id, name)的联合索引会起作用吗？有必要吗？"></a>4. 表里有主键id列，name列，我建立(id, name)的联合索引会起作用吗？有必要吗？</h3><h3 id="5-mysql事务有几种隔离级别，你了解过吗？"><a href="#5-mysql事务有几种隔离级别，你了解过吗？" class="headerlink" title="5.mysql事务有几种隔离级别，你了解过吗？"></a>5.mysql事务有几种隔离级别，你了解过吗？</h3><p>   (❌，非常低级的失误，这个问题我答的很差，就是没背下来，下次不能再背不出来了)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.读未提交（Read Uncommitted）：最低的隔离级别，它允许一个事务读取另一个事务未提交的数据。这种隔离级别可能会导致脏读（Dirty Read），即读取到未提交的数据。</span><br><span class="line">2.读已提交（Read Committed）：在该隔离级别下，一个事务只能读取到已经提交的数据。这可以避免脏读情况的发生，但可能会导致不可重复读（Non-repeatable Read），即在同一个事务内两次读取同一个数据得到不同的结果。</span><br><span class="line">3.可重复读（Repeatable Read）：在该隔离级别下，保证了同一个事务内多次读取同一数据的结果是一致的。其他事务对该数据的修改只能在当前事务提交后才能看到。这可以避免脏读和不可重复读，但可能会导致幻读（Phantom Read），即在同一个事务内两次查询得到不同的结果。</span><br><span class="line">4.串型化（Serializable）：最高的隔离级别，它通过强制事务串行执行来避免脏读、不可重复读和幻读的情况。在此隔离级别下，事务之间的并发性大大降低，可能会对系统的性能产生较大的影响。</span><br></pre></td></tr></table></figure>



<h3 id="6-innodb怎么实现可重复读？-2次"><a href="#6-innodb怎么实现可重复读？-2次" class="headerlink" title="6.innodb怎么实现可重复读？(2次)"></a>6.innodb怎么实现可重复读？(2次)</h3><p>   通过快照实现(MVCC都忘了说了，获取五个事务相关的状态码也忘说了。。。获取最小事务id，当前活跃事务id列表、创建下一个的事务会使用到的id、、、)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">生成读视图：在每个事务启动时，InnoDB 会为该事务生成一个唯一的读视图（Read View）。读视图中包含了该事务在开始时所有活跃的事务ID（有可能会修改到的数据行）。读视图决定了事务在执行期间看到的数据版本。</span><br><span class="line">读取快照数据：在事务的执行期间，InnoDB 通过对比读视图和数据行的版本信息来确定哪个数据版本是可见的。对于未提交的事务，InnoDB 不会将其修改的数据行对当前事务可见。相反，InnoDB 使用数据行的旧版本来提供一个可重复读的视图。</span><br><span class="line">锁定被修改的数据：为了保证每个事务的修改不会被其他事务读取，InnoDB 在可重复读隔离级别下会为 SELECT 查询语句下的读操作（如 SELECT...FOR UPDATE）设置锁。这样，其他事务无法修改或读取被锁定的数据，从而保证了可重复读。</span><br></pre></td></tr></table></figure>

<p><strong>mvcc 的原理是什么？</strong>—相似的问题</p>
<p>  mvcc其实是可重复读的实现方式，它是对数据库进行快照的一个操作。具体的实现方式为……(就那四个字段，然后说清楚逻辑即可，详细请看<a href="https://tangjiayang.github.io/2023/07/27/MySQL%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/">mysql原理学习</a></p>
<h3 id="7-加入给你一个sql语句，你会从哪几个方面考虑优化呢？-2次"><a href="#7-加入给你一个sql语句，你会从哪几个方面考虑优化呢？-2次" class="headerlink" title="7.加入给你一个sql语句，你会从哪几个方面考虑优化呢？(2次)"></a>7.加入给你一个sql语句，你会从哪几个方面考虑优化呢？(2次)</h3><p>   (❌)我直接说用explain查看索引使用情况，，，然后explain里的参数还不熟悉，，，挺打脸的，抓紧背！ </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">✧查看索引是否合理：考虑查询语句中使用的字段是否都有合适的索引。缺乏索引或者索引不合理可能导致全表扫描或者临时表的创建，从而导致性能下降。</span><br><span class="line"></span><br><span class="line">✧优化查询条件：检查查询语句中的 WHERE 条件是否能够有效地过滤掉不符合条件的数据，从而减少扫描的数据量。可以考虑对查询条件进行索引覆盖，使用合适的索引来加快查询。</span><br><span class="line"></span><br><span class="line">✧避免使用通配符：%和_ 通配符会导致索引的失效，可以考虑使用前缀索引或者全文索引来代替。</span><br><span class="line"></span><br><span class="line">✧优化 JOIN 操作：如果查询语句中包含 JOIN 操作，需要确保关联的字段上都有索引，并且 JOIN 条件尽可能简单。可以考虑使用合适的 JOIN 类型，例如 INNER JOIN、LEFT JOIN 或者使用 EXISTS 子查询来优化。</span><br><span class="line"></span><br><span class="line">✧避免使用子查询：子查询可能会导致性能问题，可以考虑使用 JOIN 或者其他方式来重写查询语句，减少子查询的使用。</span><br><span class="line"></span><br><span class="line">✧减少数据传输量：只选择所需的字段，避免返回不必要的数据。可以使用 SELECT 子句的列名列表，而不是使用通配符。</span><br><span class="line"></span><br><span class="line">✧分页查询优化：对于分页查询，可以使用 LIMIT 和 OFFSET 进行控制。对于大数据量的分页查询，可以考虑使用游标（cursor）方式，避免一次性加载所有数据。</span><br><span class="line"></span><br><span class="line">✧配置合理的缓存和缓冲区：根据具体情况，调整 MySQL 的缓存大小和缓冲区的配置，以提升查询性能。</span><br><span class="line"></span><br><span class="line">✧定期进行表的统计和优化：使用 ANALYZE TABLE 或者 OPTIMIZE TABLE 命令，以及常规的表维护工作，保持表的性能。</span><br><span class="line"></span><br><span class="line">注意，具体的优化策略需要根据具体的情况来确定，可以通过查看执行计划、使用 Explain 命令、分析慢查询日志等手段来定位性能瓶颈，然后针对性地进行优化。</span><br><span class="line"></span><br><span class="line">查看执行计划 explain</span><br><span class="line">如果有告警信息，查看告警信息 show warnings;</span><br><span class="line">查看SQL涉及的表结构和索引信息</span><br><span class="line">根据执行计划，思考可能的优化点</span><br><span class="line">按照可能的优化点执行表结构变更、增加索引、SQL改写等操作</span><br><span class="line">查看优化后的执行时间和执行计划</span><br><span class="line">如果优化效果不明显，重复第四步操作</span><br></pre></td></tr></table></figure>



<h3 id="8-在explian报告中，有哪些常见的索引使用方式？举几个例子"><a href="#8-在explian报告中，有哪些常见的索引使用方式？举几个例子" class="headerlink" title="8.在explian报告中，有哪些常见的索引使用方式？举几个例子"></a>8.在explian报告中，有哪些常见的索引使用方式？举几个例子</h3><p>   (❌)没背，说的中文，巨尬</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type 列：表示查询访问方法，常见的类型有 const、eq_ref、ref、range、index、all 等。其中，const 表示常量查询，eq_ref 表示使用唯一索引查询，ref 表示非唯一索引查询，range 表示范围查询，index 表示索引覆盖查询，all 表示全表扫描。</span><br></pre></td></tr></table></figure>



<h3 id="9-索引覆盖是什么？-2次"><a href="#9-索引覆盖是什么？-2次" class="headerlink" title="9.索引覆盖是什么？(2次)"></a>9.索引覆盖是什么？(2次)</h3><p>   通过索引覆盖，查询可以在索引中直接定位到所需的数据，避免了额外的磁盘IO和内存操作，因此可以显著降低查询的消耗。</p>
<h3 id="10-什么叫回表？"><a href="#10-什么叫回表？" class="headerlink" title="10.什么叫回表？"></a>10.什么叫回表？</h3><p>  正常情况下(即根据普通索引进行查询时，先查询该记录对应的主键值，再去主键所在的B+树中寻找其数据信息)</p>
<h3 id="🌟11-where条件是如何过滤掉数据的？在哪一层？"><a href="#🌟11-where条件是如何过滤掉数据的？在哪一层？" class="headerlink" title="🌟11.where条件是如何过滤掉数据的？在哪一层？"></a>🌟11.where条件是如何过滤掉数据的？在哪一层？</h3><p>(❌)这个真不太懂，需要事后了解一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">分情况看：</span><br><span class="line">如果 where 条件的记录在二级索引(普通索引)上，这时候过滤，就索引下推到 inndob 引擎过滤。</span><br><span class="line">如果where 条件是非索引字段，就在 server 层过滤。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">where条件中索引失效---&gt;innodb中进行全表扫描，返回数据后，会在server层进行过滤</span><br><span class="line">where条件中索引未失效-&gt;innodb层就会根据索引进行过滤(普通索引还可以是索引下推，根据可用的索引过滤一部分)</span><br></pre></td></tr></table></figure>



<h3 id="12-A列-建有索引-B列没有-查询where-A-x3D-1-and-B-x3D-1时底层发生了什么？"><a href="#12-A列-建有索引-B列没有-查询where-A-x3D-1-and-B-x3D-1时底层发生了什么？" class="headerlink" title="12.A列 建有索引 B列没有 查询where A &#x3D; 1 and B &#x3D; 1时底层发生了什么？"></a>12.A列 建有索引 B列没有 查询where A &#x3D; 1 and B &#x3D; 1时底层发生了什么？</h3><ol>
<li><p>MySQL 会首先检查 A 列的索引，通过索引的 B+树结构迅速定位到满足条件 A &#x3D; 1 的数据行。 </p>
</li>
<li><p>对于满足条件 A &#x3D; 1 的数据行，MySQL 将进一步检查每一行的 B 列的值是否等于 1。由于 B 列没有索引，MySQL 需要对A&#x3D;1的数据进行全表扫描来验证 B 列的值是否满足条件 B &#x3D; 1。</p>
</li>
</ol>
<h3 id="13-一条SQL的执行过程是什么？"><a href="#13-一条SQL的执行过程是什么？" class="headerlink" title="13.一条SQL的执行过程是什么？"></a>13.一条SQL的执行过程是什么？</h3><p>​	    MySQL5.8(❌，woc说错了！！寄！！！)之前有缓冲区，缓冲区会根据sql语句进行缓存、5.8之后移除了；之后会到解析器中进行词法、语法分析，这一阶段还会把 * 换成表中对应实际的列；之后会进入优化器，这里会产生sql语句的执行方案，最后进入存储引擎进行查询。(⚠️补一下，见<a href="https://tangjiayang.github.io/2023/07/27/MySQL%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/">mysql原理学习</a>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">连接器：建立连接，管理连接、校验用户身份；</span><br><span class="line">查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</span><br><span class="line">解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</span><br><span class="line">执行 SQL：执行 SQL 共有三个阶段：</span><br><span class="line">	预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。</span><br><span class="line">	优化阶段：基于查询成本的考虑，选择查询成本最小的执行计划；</span><br><span class="line">	执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</span><br></pre></td></tr></table></figure>



<h2 id="Java并发编程："><a href="#Java并发编程：" class="headerlink" title="Java并发编程："></a>Java并发编程：</h2><h3 id="1-为什么要用线程池？"><a href="#1-为什么要用线程池？" class="headerlink" title="1.为什么要用线程池？"></a>1.为什么要用线程池？</h3><p>   - <strong>降低线程创建和销毁的开销</strong>：线程的创建和销毁是相对昂贵的操作，涉及到分配内存、初始化上下文等耗时操作。如果每次需要执行任务时都创建一个新的线程，会造成大量的系统资源消耗和额外的开销。线程池通过预先创建一组可复用的线程，避免了频繁的线程创建和销毁操作，降低了系统的开销。</p>
<p>   - <strong>控制并发度和资源消耗，避免系统崩溃</strong>：线程池可以控制并发执行的任务数量，通过限制线程池的大小和配置线程的数量，可以合理地控制并发度，避免过多的任务同时执行导致系统资源耗尽，系统崩溃。同时，线程池可以对任务进行排队和调度，合理利用系统资源，避免资源的浪费。</p>
<p>   - <strong>提供线程管理和监控功能</strong>：线程池可以对线程进行统一的管理和调度，包括线程的创建、销毁、复用、暂停、恢复等操作。线程池还可以监控线程的状态、执行情况和资源使用情况等，提供了对线程池的可控和可视化管理。</p>
<h3 id="2-怎么创建线程池？"><a href="#2-怎么创建线程池？" class="headerlink" title="2.怎么创建线程池？"></a>2.怎么创建线程池？</h3><ul>
<li><p>创建一个ThreadPoolExecutor对象，可以使用ThreadPoolExecutor的构造方法或者Executors类提供的工厂方法来创建。</p>
<ul>
<li><p>具体：</p>
</li>
<li><p><strong>创建一个ThreadPoolExecutor对象</strong>，可以使用ThreadPoolExecutor的构造方法或者Executors类提供的工厂方法来创建。</p>
</li>
<li><p><strong>设置线程池的核心线程数（corePoolSize），最大线程数（maximumPoolSize），线程空闲回收时间（keepAliveTime）</strong>等参数。这些参数决定了线程池的大小和行为。</p>
</li>
<li><p>可选地<strong>设置任务队列</strong>，可以选择使用ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue等不同类型的队列，根据实际情况来选择最合适的。</p>
</li>
<li><p><strong>提交任务给线程池执行</strong>，可以使用execute()方法提交一个Runnable任务，或者使用submit()方法提交一个Callable任务，可以获取任务的执行结果。</p>
</li>
<li><p><strong>关闭线程池</strong>，当不再需要使用线程池时，应该调用线程池的shutdown()方法来关闭线程池。</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-线程池有什么运行机制，有什么参数？"><a href="#3-线程池有什么运行机制，有什么参数？" class="headerlink" title="3.线程池有什么运行机制，有什么参数？"></a>3.线程池有什么运行机制，有什么参数？</h3><ul>
<li>启核心线程—&gt;入队列—&gt;启非核心线程—&gt;异常</li>
<li><strong><u>连接池线程处理不过来，有哪些处理方式？</u></strong><ul>
<li>抛出异常：当任务被提交到线程池中，但无法处理时，线程池会抛出异常。例如，当线程池的队列已满且无法接受更多任务时，线程池可以抛出 <strong>RejectedExecutionException</strong> 异常。在捕获异常时，可以选择记录日志、发送警报或执行其他适当的操作。</li>
<li>丢弃任务：当线程池无法处理任务时，可以选择丢弃该任务。这样可以减轻线程池的负担，但需要注意确保任务的丢失不会对系统造成重大影响。可以使用 DiscardPolicy 或者 <strong>DiscardOldestPolicy</strong> 策略来实现任务丢弃。</li>
<li>阻塞任务：当线程池无法处理任务时，可以选择将任务阻塞等待。这样可以保持任务的有序执行，直到有可用的线程来处理任务。可以使用 <strong>ArrayBlockingQueue</strong> 作为任务队列，通过设置队列的容量来控制线程池的负载。</li>
<li>调用者运行：当线程池无法处理任务时，可以选择由调用者自行处理任务。也就是说，任务由调用线程直接执行，而不是交给线程池处理。这样可以避免线程池负担过大，但也需要注意调用线程是否能够处理任务。</li>
</ul>
</li>
</ul>
<h3 id="4-说一下volatile关键字的作用"><a href="#4-说一下volatile关键字的作用" class="headerlink" title="4.说一下volatile关键字的作用"></a>4.说一下volatile关键字的作用</h3><p>   只说了1、2(⚠️)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、可见性（Visibility）：在多线程环境下，对于被 volatile 关键字修饰的变量，当一个线程修改了该变量的值，其他线程能够立即看到这个变化。这是因为通过 volatile 关键字修饰的变量会直接在主内存中进行读取和写入，而不会使用线程的本地缓存。因此，volatile 变量可以保证线程之间的变量值一致性。</span><br><span class="line"></span><br><span class="line">2、禁止指令重排序（Prevent Instruction Reordering）：在编译器和处理器的优化过程中，会对指令进行重排序，以获得更好的性能。然而，在某些情况下，指令重排序可能会导致多线程程序的运行结果出现错误。通过将变量声明为 volatile，可以禁止编译器和处理器在对该变量操作的时候进行重排序，保证指令的顺序性。</span><br><span class="line"></span><br><span class="line">3、部分原子性（Partial Atomicity）：虽然 volatile 关键字不能保证所有操作的原子性，但是对于简单的读取和写入操作是原子的。也就是说，对于 volatile 变量的读取和写入，可以保证其操作具有原子性。但是对于复合操作，如 volatileCount++ 这样的自增操作，并不能保证原子性，需要额外的同步手段，如使用 synchronized 关键字或使用原子类来实现。</span><br></pre></td></tr></table></figure>



<h3 id="5-你对synchronize的理解是怎么样的呢？"><a href="#5-你对synchronize的理解是怎么样的呢？" class="headerlink" title="5.你对synchronize的理解是怎么样的呢？"></a>5.你对synchronize的理解是怎么样的呢？</h3><p>   可以给代码块或者方法上锁</p>
<p><strong>追问</strong>：可以对哪些结构加锁？</p>
<p>   方法和代码块</p>
<p><strong>追问</strong>：synchronize是怎么锁住一个对象的？</p>
<p>   通过获取对象的锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Java 中的对象锁是通过对象头中的一些字段来实现的。每个对象在内存中都有一个对象头，在 HotSpot 虚拟机中，对象头包含了两部分内容：Mark Word 和 Class Metadata Address。其中，Mark Word 中的一些位用于存储锁的相关信息。</span><br><span class="line">在 HotSpot 虚拟机中，对象锁有两种状态：无锁状态和重量级锁状态。</span><br><span class="line">对于无锁状态的对象，Mark Word 中的锁信息部分是空的，可以被任意线程访问，不存在互斥。</span><br><span class="line">当第一个线程访问一个无锁状态的对象时，它会尝试使用 CAS（Compare And Swap）操作来将对象的 Mark Word 修改为自己的线程 ID，同时将锁标志位设置为 1，表示获取锁成功。</span><br><span class="line">如果 CAS 操作失败，说明有其他线程已经获取了锁，此时当前线程会进入自旋（Spin）等待，不断尝试 CAS 操作获取锁，而不是让线程进入阻塞状态。</span><br><span class="line">当自旋次数达到一定阈值，或者其他线程释放了锁，当前线程成功获取到了锁，它将会将锁的标志位置为 0，表示无锁状态。</span><br><span class="line">当多个线程竞争同一个对象的锁时，如果尝试获取锁的线程较少，自旋等待的方式可以减少线程切换的开销，提高运行效率。但如果竞争线程较多，自旋等待会占用大量的 CPU 时间，造成资源浪费。</span><br><span class="line">当一个线程多次自旋仍然无法获取锁时，系统会自动升级为重量级锁，即使用悲观锁的方式进行实现。</span><br><span class="line">重量级锁是一种在内核层面实现的锁，在锁的竞争激烈时，没有获取到锁的线程会进入阻塞状态，让出 CPU 给其他线程使用。当锁释放时，被阻塞的线程会被唤醒，重新竞争锁。</span><br><span class="line">「总结来说，Java 中的对象锁是通过对象头中的字段来实现的，通过 CAS 操作和自旋等待实现轻量级锁，当竞争激烈时升级为重量级锁，通过阻塞线程实现同步。不同的锁状态带来的开销和性能表现也不同，需要根据具体的场景选择合适的锁机制。」</span><br></pre></td></tr></table></figure>



<h3 id="6-了解偏向锁吗？"><a href="#6-了解偏向锁吗？" class="headerlink" title="6.了解偏向锁吗？"></a>6.了解偏向锁吗？</h3><p>   不了解(❌，真看过，但真忘了)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">偏向锁（Biased Locking）是 Java 中锁优化的一种技术，旨在减少无竞争情况下的锁操作的开销。</span><br><span class="line">在没有线程竞争的情况下，偏向锁能够帮助提高程序的性能。</span><br><span class="line">    它的核心思想是：如果一个线程获得了对象的锁，并且在后续的执行过程中没有其他线程来竞争锁资源，那么该线程可以一直保持对该对象的偏向。</span><br><span class="line">    这样，下次该线程再次请求锁资源时，就不需要再进行同步操作，直接获取即可。这样就避免了无竞争情况下的不必要的锁操作，提升了程序的性能。</span><br><span class="line">    </span><br><span class="line">*偏向锁的实现机制是：</span><br><span class="line">    在对象头中的 Mark Word 中的某个标志位记录了线程 ID，表示当前对象的锁已经被偏向于该线程。当第一个线程访问一个对象时，它会尝试将对象头的 Mark Word 修改为自己的线程 ID，并将偏向锁标识位设置为 1，表示获取锁成功。</span><br><span class="line">如果 CAS 操作成功，那么该线程就获得了对象的偏向锁，并且进入偏向状态。之后，如果该线程再次请求锁资源，只需要检查一下 Mark Word 的线程 ID 是否与自己相同即可，非常高效。这个过程不需要释放锁资源。</span><br><span class="line">但如果有其他线程竞争同一个对象的锁，偏向锁就会失效。当出现竞争情况时，偏向锁会自动升级为轻量级锁或重量级锁，取决于竞争的情况。</span><br><span class="line">总结来说，偏向锁是一种针对无竞争情况下的锁优化技术，能够减少不必要的锁操作，提高程序的性能。它通过在对象头中记录线程 ID，避免了重复获取锁的同步操作。但在有竞争的情况下，偏向锁会自动失效，升级为其他类型的锁来保证线程安全。</span><br><span class="line">👍看完后就明白了，短期内绝对忘不了！</span><br></pre></td></tr></table></figure>



<h3 id="7-java你比较了解是吧，synchronize和Reentlock的底层实现上有啥区别？"><a href="#7-java你比较了解是吧，synchronize和Reentlock的底层实现上有啥区别？" class="headerlink" title="7.java你比较了解是吧，synchronize和Reentlock的底层实现上有啥区别？"></a>7.java你比较了解是吧，synchronize和Reentlock的底层实现上有啥区别？</h3><p>  synchronize用了对象的内部锁，作为对象信息头部中的一个字段，没加锁为空，加锁被设为线程id</p>
<p>  Reentlock维护了一个变量，加锁+1 ，解锁-1，为0说明没加锁。(⚠️)</p>
<p>⬆️而且有个队列(AQS队列)保存在等待的线程，根据公平、非公平，在一个线程释放锁后选出新的线程来占用</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_33836223/article/details/91647965?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169337903316800192255289%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=169337903316800192255289&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-91647965-null-null.142%5Ev93%5EchatsearchT3_2&utm_term=reetrantlock%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0&spm=1018.2226.3001.4187">这里讲得比较浅显易懂</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Synchronized 和 ReentrantLock 是 Java 中实现线程同步的两种机制，它们在底层实现上有以下区别：</span><br><span class="line"></span><br><span class="line">1. 可重入性（Reentrancy）：</span><br><span class="line">   - Synchronized 是 Java 内置的关键字，具有可重入性（也称为递归性）。这意味着如果一个线程已经获得了某个对象的锁，在释放锁之前，可以多次进入被锁保护的代码块。</span><br><span class="line">   - ReentrantLock 是 `Lock` 接口的实现类，也具有可重入性。要使用 ReentrantLock 的可重入特性，需要显式地调用 `lock()` 和 `unlock()` 方法。</span><br><span class="line"></span><br><span class="line">2. 获取锁的方式：</span><br><span class="line">   - Synchronized 是隐式锁，当线程进入同步代码块时，会自动获取锁，并在代码块结束后自动释放锁。无法手动控制锁的获取和释放。</span><br><span class="line">   - ReentrantLock 是显式锁，需要手动调用 `lock()` 方法来获取锁，在合适的地方调用 `unlock()` 方法来释放锁。</span><br><span class="line"></span><br><span class="line">3. 可中断性：</span><br><span class="line">   - Synchronized 在获取锁的过程中，如果线程被阻塞，无法被中断，只能等待获取锁的机会。</span><br><span class="line">   - ReentrantLock 提供了可中断的获取锁的方式。通过调用 `lockInterruptibly()` 方法，如果线程被阻塞，可以通过调用 `interrupt()` 方法中断线程。</span><br><span class="line"></span><br><span class="line">4. 公平性：</span><br><span class="line">   - Synchronized 是非公平锁，线程在竞争锁时，无法保证获取锁的顺序。</span><br><span class="line">   - ReentrantLock 默认是非公平锁，但可以通过构造函数参数设置为公平锁，在锁的竞争中，会按照请求锁的顺序分配锁。</span><br><span class="line"></span><br><span class="line">5. 性能：</span><br><span class="line">   - 在低级别的锁竞争情况下，Synchronized 的性能优于 ReentrantLock。这是因为 Synchronized 是 JVM 内置的锁机制，可以进行一些优化操作。</span><br><span class="line">   - 在高度竞争的情况下，ReentrantLock 的性能可能优于 Synchronized，因为 ReentrantLock 提供了更多的灵活性，例如可中断锁、非块结构的锁等。</span><br><span class="line"></span><br><span class="line">综上，Synchronized 和 ReentrantLock 在可重入性、获取锁方式、可中断性、公平性和性能等方面有所区别。在选择使用哪种机制时，需要根据具体的情况综合考虑。一般而言，对于简单的同步需求，使用 Synchronized 更为方便；而对于更复杂的同步需求，可以考虑使用 ReentrantLock 提供的额外功能。</span><br></pre></td></tr></table></figure>



<h3 id="8-Reentlock的底层实现和AQS有啥关系？"><a href="#8-Reentlock的底层实现和AQS有啥关系？" class="headerlink" title="8.Reentlock的底层实现和AQS有啥关系？"></a>8.Reentlock的底层实现和AQS有啥关系？</h3><p>  答了乐观锁，我的无知再次暴露无遗(❌，我不知道AQS是啥啊。。)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AQS（AbstractQueuedSynchronizer），抽象队列同步器</span><br><span class="line">核心思想：</span><br><span class="line">如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</span><br></pre></td></tr></table></figure>







<h2 id="JVM："><a href="#JVM：" class="headerlink" title="JVM："></a>JVM：</h2><h3 id="1-java常见垃圾回收算法"><a href="#1-java常见垃圾回收算法" class="headerlink" title="1.java常见垃圾回收算法"></a>1.java常见垃圾回收算法</h3><ul>
<li><strong>标记-清除算法（Mark-and-Sweep）</strong>：这是最基本的垃圾回收算法。它的过程分为两个阶段：标记阶段和清除阶段。首先从根节点开始，标记所有能够被访问到的对象，然后清除未标记的对象。标记-清除算法存在碎片问题，即内存空间会变得不连续，影响后续对象的分配。</li>
<li><strong>复制算法（Copying）</strong>：复制算法将内存一分为二，每次只使用其中一半。当一半空间被用满后，将存活的对象复制到另一半空闲空间中，然后清除已使用的空间。复制算法解决了碎片问题，但是需要一倍的内存空间，且对象的复制会影响性能。</li>
<li><strong>标记-压缩算法（Mark-and-Compact）</strong>：标记-压缩算法结合了标记-清除算法和复制算法的优点。它先标记存活对象，然后将存活对象紧凑地放置在内存的一端，然后对整个堆进行压缩，使得存活对象占用连续的内存空间。标记-压缩算法可以解决碎片问题，并且不需要额外的内存空间，但是需要移动存活对象，也会有一定的性能开销。</li>
<li><strong>分代算法（Generational）</strong>：分代算法基于对象的存活时间进行划分，一般将堆分为新生代和老年代。新生代通常使用复制算法，因为大多数对象在短时间内就会变成垃圾。老年代则使用标记-清除或标记-压缩算法，因为老年代中的对象通常存活时间较长。</li>
</ul>
<h3 id="2-你了解哪些垃圾收集器？"><a href="#2-你了解哪些垃圾收集器？" class="headerlink" title="2.你了解哪些垃圾收集器？"></a>2.你了解哪些垃圾收集器？</h3><p>—-这里限于篇幅，只是简要说明，强烈建议读者移步<a href="https://tangjiayang.github.io/2023/05/26/java%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/">此处</a>更详细地了解各个收集器原理(见章节：1.7.GC 垃圾收集器)</p>
<ul>
<li><strong>Serial收集器</strong>：Serial收集器是最基本的垃圾回收器，它使用单线程进行垃圾回收。在进行垃圾回收时，会暂停所有的用户线程。Serial收集器适用于小型应用和客户端环境，它的特点是简单、高效，适用于单核处理器。</li>
<li><strong>Parallel收集器</strong>：Parallel收集器使用多线程进行垃圾回收。Parallel收集器通过并行处理来提高垃圾回收的吞吐量，适用于多核处理器和数据量较大的应用。</li>
<li><strong>CMS收集器</strong>：CMS（Concurrent Mark Sweep）收集器是一种并发垃圾回收器。它使用多线程和并发处理来最小化垃圾回收对应用程序暂停时间的影响。CMS收集器适用于对响应时间有较高要求的应用，但由于并发执行的特性，可能会增加垃圾回收器本身的开销。</li>
<li><strong>G1收集器</strong>：G1（Garbage-First）收集器是一种面向服务器的垃圾回收器。它具有高吞吐量和可预测停顿时间的特点。G1收集器将内存分为多个小区域，并基于优先级进行垃圾回收。它可以通过调整停顿时间目标来平衡吞吐量和停顿时间。G1收集器适用于大内存容量和对停顿时间有较高要求的应用。</li>
</ul>
<h3 id="3-G1垃圾回收器相比CMS的优势在哪？"><a href="#3-G1垃圾回收器相比CMS的优势在哪？" class="headerlink" title="3.G1垃圾回收器相比CMS的优势在哪？"></a>3.G1垃圾回收器相比CMS的优势在哪？</h3><ol>
<li><strong>可预测的停顿时间</strong>：G1收集器通过将堆内存划分为多个区域（Region），实现了增量式的垃圾回收。它能够根据用户指定的目标停顿时间（Pause Time）来制定优化策略，从而在可控的时间范围内完成垃圾回收，减少应用程序的停顿时间。</li>
<li><strong>堆内存的分区管理</strong>：G1收集器将整个堆划分为多个大小相等的区域，每个区域都可以是Eden区、Survivor区或者老年代区域。这种分区管理方式使得G1收集器能够更加灵活地进行垃圾回收，<strong>只处理其中的一部分区域，避免了全局性的停顿。</strong></li>
<li>并发标记和部分回收：G1收集器采用了并发标记的方式，在并发标记过程中，应用程序可以继续运行。同时，G1收集器在每次收集时只回收一部分区域，即<u>根据垃圾的产生情况选择垃圾最多的区域进行回收，避免了全堆的扫描和清理操作，提高了垃圾收集的效率。</u></li>
<li>空间整理的效率：G1收集器在标记垃圾后，会选择垃圾最多的区域进行回收。此时，只会回收该区域中的垃圾对象，而不会进行全堆的压缩式整理。这种增量式的回收方式可以减少停顿时间，同时也降低了空间整理的开销。</li>
<li>高可扩展性：<strong>G1收集器具备较高的可扩展性，可以适应不同大小的堆和多核处理器的环境。通过合理调整分区数量和大小，可以更好地平衡内存占用和垃圾回收的效率。</strong></li>
</ol>
<p>总的来说，G1收集器相较于CMS垃圾收集器在停顿<strong>时间可控性、分区管理、并发标记和部分回收、空间整理效率和可扩展性</strong>等方面具有优势，适用于需要较低停顿时间和更好内存利用率的场景。</p>
<h3 id="4-解释一下JVM内存模型-分区情况，然后再讲一下垃圾回收情况-2次"><a href="#4-解释一下JVM内存模型-分区情况，然后再讲一下垃圾回收情况-2次" class="headerlink" title="4.解释一下JVM内存模型(分区情况，然后再讲一下垃圾回收情况)  (2次)"></a>4.解释一下JVM内存模型(分区情况，然后再讲一下垃圾回收情况)  (2次)</h3><ul>
<li>程序计数器</li>
<li>Java 虚拟机栈</li>
<li>本地方法栈   </li>
<li>Java 堆</li>
<li>元数据区</li>
</ul>
<p>🌟<strong>追问</strong>：我们创建一个对象，可能会在哪些区域分配内存？</p>
<p>   堆</p>
<p>🌟<strong>追问</strong>：一定吗？</p>
<p>   (❌)这块确实原本不知道，乱说一通</p>
<p>追问：你有了解过栈上分配吗？(这不是明显的提示吗？奈何我真不会)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">☄️栈上分配（Stack Allocation）。栈上分配是一种优化技术，它将对象分配到栈内存而不是堆内存中，以提高程序的性能。</span><br><span class="line"></span><br><span class="line">在传统的 Java 内存模型中，对象的分配发生在堆内存中，需要进行动态内存分配和垃圾回收。然而，栈上分配通过将对象分配到栈帧中，即方法调用栈，来减少内存管理的开销。</span><br><span class="line"></span><br><span class="line">栈上分配适用于满足以下条件的对象：</span><br><span class="line">✦对象是线程私有的，即不会被其他线程访问或共享。</span><br><span class="line">✦对象的生命周期在方法内部，即对象的引用不会逃逸出方法（不会被方法外部的代码所引用）。</span><br><span class="line">✦对象是值对象（Value Object），即对象在存储和使用上与原生数据类型类似，没有复杂的生命周期或引用关系。</span><br><span class="line"></span><br><span class="line">栈上分配的好处包括：</span><br><span class="line">✦分配和回收对象的开销更低：栈上分配不需要进行堆内存的动态分配和垃圾回收，因此可以减少运行时的开销。</span><br><span class="line">✦对象可以更快地释放：当方法调用结束时，栈帧中的对象会随着栈帧的弹出而自动释放，无需等待垃圾回收。</span><br><span class="line"></span><br><span class="line">需要注意的是，栈上分配对于大部分对象来说并不适用，因为大部分对象的生命周期比一个方法调用更长，并且可能被多个线程访问。栈上分配通常用于创建小型、临时的对象，例如局部变量或方法参数。</span><br><span class="line"></span><br><span class="line">总而言之，栈上分配是一种优化技术，在满足特定条件下，将对象分配到栈内存中，以减少内存管理的开销和提高程序性能。</span><br></pre></td></tr></table></figure>



<h3 id="5-堆中有新生代和老年代，什么样的对象会在新生代，什么样的对象会在老年代呢？"><a href="#5-堆中有新生代和老年代，什么样的对象会在新生代，什么样的对象会在老年代呢？" class="headerlink" title="5.堆中有新生代和老年代，什么样的对象会在新生代，什么样的对象会在老年代呢？"></a>5.堆中有新生代和老年代，什么样的对象会在新生代，什么样的对象会在老年代呢？</h3><p>   我回答的原话是：频繁创建销毁的对象会在新生代中(⚠️这样表达非常不准确，下次思考2秒再张嘴说话！！)</p>
<p>   新创建的对象在新生代，新生代中年龄到达设定值或者放不下的情况下会放到老年代中</p>
<h3 id="6-哪些对象能够被回收，回收的机制是什么？"><a href="#6-哪些对象能够被回收，回收的机制是什么？" class="headerlink" title="6.哪些对象能够被回收，回收的机制是什么？"></a>6.哪些对象能够被回收，回收的机制是什么？</h3><p>   首先找到GC Roots，再找他们与他们有直接引用的对象，这些是不会被回收的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可达性分析</span><br></pre></td></tr></table></figure>

<p>🌟<strong>追问</strong>：你刚提到了GC Root， 哪些对象能够作为GC Root？</p>
<p>   (❌，真看过！也真忘了！😡)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在 Java 中，以下几种对象可以作为 GC Roots：</span><br><span class="line"></span><br><span class="line">✦虚拟机栈（栈帧中的本地变量表）中引用的对象；</span><br><span class="line"></span><br><span class="line">✦方法区中类静态属性引用的对象；</span><br><span class="line"></span><br><span class="line">✦方法区中常量引用的对象；</span><br><span class="line"></span><br><span class="line">✦被 JNI（Java Native Interface，即 Java 本地接口）引用的对象；</span><br><span class="line"></span><br><span class="line">✦线程中正在执行的方法的局部变量或输入参数引用的对象。</span><br></pre></td></tr></table></figure>



<h3 id="7-元数据区存的是什么？"><a href="#7-元数据区存的是什么？" class="headerlink" title="7.元数据区存的是什么？"></a>7.元数据区存的是什么？</h3><p>  元空间中有常量池、类的配置信息(⚠️说得好像有问题，复盘)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">元空间的实现称为常量池</span><br><span class="line">常量池中存储了以下几种元数据：</span><br><span class="line">1.类信息（Class Information）：包括类的名称、父类、接口、访问修饰符等。</span><br><span class="line">2.字段信息（Field Information）：包括字段的名称、类型、访问修饰符等。</span><br><span class="line">3.方法信息（Method Information）：包括方法的名称、参数类型、返回类型、访问修饰符等。</span><br><span class="line">4.字符串常量（String Constants）：包括字符串字面值，例如 &quot;Hello, World!&quot;。</span><br><span class="line">5.字面常量（Literal Constants）：包括整数、浮点数、布尔值等字面常量。</span><br></pre></td></tr></table></figure>



<h3 id="8-类加载机制是怎么样的？"><a href="#8-类加载机制是怎么样的？" class="headerlink" title="8.类加载机制是怎么样的？"></a>8.类加载机制是怎么样的？</h3><p>(不太熟练)</p>
<p>首先读取类的信息</p>
<p>再进行安全性检查</p>
<p>开辟虚拟内存空间，进行静态变量的初始化</p>
<p>将虚拟地址变为物理地址</p>
<p>再执行构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">加载</span><br><span class="line">验证</span><br><span class="line">准备</span><br><span class="line">解析</span><br><span class="line">初始化</span><br><span class="line">使用</span><br></pre></td></tr></table></figure>



<h3 id="9-双亲委派是什么？"><a href="#9-双亲委派是什么？" class="headerlink" title="9. 双亲委派是什么？"></a>9. 双亲委派是什么？</h3><p>从最早的祖先开始判断能否加载需要的类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">子类加载器如果没有加载过该目标类，就先委托父类加载器加载该目标类，只有在父类加载器找不到字节码文件的情况下才从自己的类路径中查找并装载目标类。</span><br><span class="line"></span><br><span class="line">保证Java程序的稳定运行，避免类的重复加载：JVM区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类</span><br></pre></td></tr></table></figure>

<p><strong>追问：</strong>类加载器怎么知道他能不能加载需要的类？</p>
<p>(❌，不了解，一个比较好的问题)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">其实很简单：</span><br><span class="line">始祖类加载器判断是否加载过该Class，如果已加载，则返回Class对象</span><br><span class="line">   如果没有则尝试从其对应的类路径下寻找class字节码文件并载入</span><br><span class="line">   如果载入成功，则返回Class对象；如果载入失败，则委托给始祖类加载器的子类加载器</span><br><span class="line"></span><br><span class="line">具体怎么知道，暂时差不到，留个坑，目前我认为HashMap就比较合适，通过看看自己的hashmap中是否有需要载入类的信息判断</span><br></pre></td></tr></table></figure>





<h2 id="网络编程："><a href="#网络编程：" class="headerlink" title="网络编程："></a>网络编程：</h2><h3 id="1-网络编程你有实践过吗？如何保持一个连接是活跃的"><a href="#1-网络编程你有实践过吗？如何保持一个连接是活跃的" class="headerlink" title="1.网络编程你有实践过吗？如何保持一个连接是活跃的"></a>1.网络编程你有实践过吗？如何保持一个连接是活跃的</h3><p>   (❌，不了解)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">心跳机制（Heartbeat Mechanism）：通过定期发送心跳包，可以保持连接的活跃性。心跳包是一种特殊的数据包，用于向对方发送信号以表明连接依然有效。接收方收到心跳包后可以回复一个确认包，或者通过超时或其他机制来判断连接是否仍然可用。</span><br><span class="line">  1.传输层心跳机制： </span><br><span class="line">  ✦TCP保活定时器（TCP Keepalive Timer）：TCP协议提供了一种保活定时器机制，可以在连接空闲一段时间后发送探测数据包来检测连接的活跃性。这个定时器可以通过设置TCP的SO_KEEPALIVE选项来启用，并设置相关的参数，如探测间隔、探测次数等。</span><br><span class="line">  2.应用层心跳机制：</span><br><span class="line">  ✦应用层心跳检测：在应用层中定义心跳检测机制，通过定期发送特定的应用层控制消息，来检测连接的活跃性。接收方可以根据接收到的消息来判断连接是否仍然可用，以及执行相应的处理逻辑。</span><br></pre></td></tr></table></figure>



<h2 id="设计模式："><a href="#设计模式：" class="headerlink" title="设计模式："></a>设计模式：</h2><h3 id="1-说三个设计模式，分别是什么意思？-你平时分别在什么情况下用到这三种设计模式？"><a href="#1-说三个设计模式，分别是什么意思？-你平时分别在什么情况下用到这三种设计模式？" class="headerlink" title="1.说三个设计模式，分别是什么意思？ 你平时分别在什么情况下用到这三种设计模式？"></a>1.说三个设计模式，分别是什么意思？ 你平时分别在什么情况下用到这三种设计模式？</h3><ul>
<li><p>单例模式</p>
<ul>
<li><p>单例模式（Singleton Pattern）是一种创建型设计模式，用于保证一个类只有一个实例，并提供全局访问点。它的核心思想是通过限制类的实例化次数，保证在程序运行期间只存在一个实例。</p>
<p>实现单例模式的常用方法是使用一个私有的静态变量来存储实例对象，同时提供一个公共的静态方法来获取该实例。常见的实现方式有饿汉式（在类加载时即创建实例）和懒汉式（在使用时才创建实例）。</p>
<ul>
<li>日志管理器：在一个应用程序中，通常只需要一个日志管理器来记录日志，单例模式可以确保只有一个实例用于记录日志。</li>
<li>数据库连接池：在多线程环境下，需要保证数据库连接池的全局唯一性，单例模式可以确保只有一个连接池实例。</li>
</ul>
</li>
</ul>
</li>
<li><p>工厂模式</p>
<ul>
<li>工厂模式（Factory Pattern）是一种创建型设计模式，用于创建对象的统一接口。工厂模式通过将对象的实例化过程封装到一个工厂类中来解耦客户端与创建对象的过程。<ul>
<li>数据库驱动管理器：在一个数据库操作的应用程序中，可以使用工厂模式来创建各种数据库驱动的实例。</li>
</ul>
</li>
</ul>
</li>
<li><p>代理模式</p>
<ul>
<li>目标对象、代理对象和客户端。代理对象实现与目标对象相同的接口，并持有目标对象的引用。客户端通过代理对象来访问目标对象。<ul>
<li>代理模式常见的应用场景是在访问对象的前后做一些额外处理，例如权限校验、延迟加载、远程访问等。使用代理模式可以增强目标对象的功能，同时对客户端屏蔽了目标对象的具体实现，增加了代码的灵活性和可维护性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-如何写一个单例模式？"><a href="#2-如何写一个单例模式？" class="headerlink" title="2. 如何写一个单例模式？"></a>2. 如何写一个单例模式？</h3><p><strong>追问</strong>：多线程创建单例，会不会不问题，怎么解决？</p>
<p>(❌)这里我没有说清楚，就记得两次判断null了。。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">用双重检查法：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">          🌟<span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis:"></a>Redis:</h2><h3 id="1-redis中有几种数据类型？你在你的项目中用过哪几种数据结构？-2次"><a href="#1-redis中有几种数据类型？你在你的项目中用过哪几种数据结构？-2次" class="headerlink" title="1.redis中有几种数据类型？你在你的项目中用过哪几种数据结构？(2次)"></a>1.redis中有几种数据类型？你在你的项目中用过哪几种数据结构？(2次)</h3><p>   (❌，没背，不会)</p>
<p>   分布式锁就用到了String类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">常见的：⬇️</span><br><span class="line">字符串 (String)：存储一个字符串值。可以存储任何类型的数据，包括数字、文本、二进制数据等。</span><br><span class="line"></span><br><span class="line">列表 (List)：按照插入顺序存储一个有序的元素集合。可以在列表的两端进行插入和删除操作。</span><br><span class="line"></span><br><span class="line">集合 (Set)：存储一个无序的、不重复的元素集合。可以对集合进行交集、并集、差集等常见集合操作。</span><br><span class="line"></span><br><span class="line">有序集合 (Sorted Set)：类似于集合，但每个元素都关联了一个分数，被用来按照分数的顺序存储和获取元素。可以根据分数范围或成员来获取元素。</span><br><span class="line"></span><br><span class="line">哈希表 (Hash)：存储键值对的无序散列表。适用于存储对象的相关字段，可以针对单个字段进行读取和更新操作。</span><br></pre></td></tr></table></figure>



<h3 id="2-redis-分布式锁是怎么实现的？原理是什么？-2次"><a href="#2-redis-分布式锁是怎么实现的？原理是什么？-2次" class="headerlink" title="2.redis 分布式锁是怎么实现的？原理是什么？(2次)"></a>2.redis 分布式锁是怎么实现的？原理是什么？(2次)</h3><p>   (⚠️)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">分布式锁的实现原理如下：</span><br><span class="line">    ✦使用 SETNX (set if not exist) 命令来尝试将一个唯一的标识（如锁的名字）作为 key，获取锁的资源。</span><br><span class="line">        ✦当 key 不存在时， SETNX 命令会将该 key 设置为指定的值，并返回 1，表示获取锁成功。</span><br><span class="line">        ✦当 key 已经存在时， SETNX 命令不会对 key 进行任何操作，直接返回 0，表示获取锁失败。</span><br><span class="line">    ✦在获取锁成功后，为了避免锁永久占用，可以设置一个合适的过期时间 (expire)。可以使用 EXPIRE 命令或者 SET 命令配合 NX（仅在 key 不存在时设置）选项来设定过期时间。</span><br><span class="line">    ✦在对锁进行解锁操作时，需要使用 DEL (delete) 命令来删除该锁的 key。</span><br><span class="line"></span><br><span class="line">分布式锁保证原子性：</span><br><span class="line">    ✦分布式锁是通过 Redis 单线程的特点来保证原子性操作的，保证同一时刻只有一个客户端能够获取到锁。</span><br><span class="line">    ✦可以使用 SETNX+EXPIRE 命令的组合来实现基本的分布式锁。</span><br><span class="line">    ✦获取到锁后，执行具体的业务逻辑，然后再进行解锁操作，避免锁被长时间占用。</span><br><span class="line">    ✦避免获取锁的客户端执行时间过长，导致锁过期后其他客户端获取到锁执行相同的操作。可以根据业务情况合理调整锁的过期时间。</span><br></pre></td></tr></table></figure>



<h3 id="3-你有研究过String底层是怎么实现的呢？"><a href="#3-你有研究过String底层是怎么实现的呢？" class="headerlink" title="3.你有研究过String底层是怎么实现的呢？"></a>3.你有研究过String底层是怎么实现的呢？</h3><p>  不太了解(❌，redis底层得系统地学一下，老是不会太伤了)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">留个坑，系统学完redis底层后来填</span><br></pre></td></tr></table></figure>



<h2 id="Spring："><a href="#Spring：" class="headerlink" title="Spring："></a>Spring：</h2><h3 id="1-spring中的拦截器和过滤器有什么区别？"><a href="#1-spring中的拦截器和过滤器有什么区别？" class="headerlink" title="1.spring中的拦截器和过滤器有什么区别？"></a>1.spring中的拦截器和过滤器有什么区别？</h3><ul>
<li>触发时机：<ul>
<li>过滤器：在Servlet容器中，过滤器是在请求进入Servlet容器之前和响应离开Servlet容器之前进行处理的，即在请求和响应的前后都触发执行。</li>
<li>拦截器：在Spring MVC框架中，拦截器是在请求进入Controller之前和离开Controller之后进行处理的，即只在请求处理的前后触发执行。</li>
</ul>
</li>
<li>使用范围：<ul>
<li>过滤器：过滤器可以用于所有的Web应用程序，无论是基于Spring的还是其他任何框架。它可以在应用程序的整个生命周期中使用。</li>
<li>拦截器：拦截器是Spring MVC框架特有的功能，只能用于使用了Spring MVC框架的应用程序中。</li>
</ul>
</li>
<li>配置方式：<ul>
<li>过滤器：过滤器的配置是在Web应用程序的web.xml文件中进行的，通过配置URL匹配模式来指定要拦截的请求。</li>
<li>拦截器：拦截器的配置是通过实现HandlerInterceptor接口，并在Spring配置文件中进行声明的，可以根据具体的请求路径等条件进行配置。</li>
</ul>
</li>
<li>功能：<ul>
<li>过滤器：过滤器可以对请求的参数进行处理、请求的编码进行转换、对响应结果进行过滤等。</li>
<li>拦截器：拦截器可以在请求进入Controller之前和离开Controller之后进行处理，可以进行权限验证、日志记录、性能监控等。</li>
</ul>
</li>
</ul>
<h2 id="手撕算法部分："><a href="#手撕算法部分：" class="headerlink" title="手撕算法部分："></a>手撕算法部分：</h2><ol>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://Tangjiayang.github.io">donn</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://tangjiayang.github.io/2023/08/18/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/">https://tangjiayang.github.io/2023/08/18/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E7%BB%8F/">面经</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/08/15/Redis%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/" title="Redis原理学习"><img class="cover" src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727134719639.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Redis原理学习</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81ODUzNy8zNTAwMA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/bg.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">donn</div><div class="author-info__description">欢迎访问donn的博客!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Tangjiayang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Tangjiayang" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">小站成立于2023-5-27！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E5%8E%82%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB-%E5%85%AB%E8%82%A1%E6%B1%87%E6%80%BB-%EF%BC%9A"><span class="toc-text">大厂校招面试问题汇总(八股汇总)：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-text">数据结构：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">1.讲一下平衡二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%86%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91%E5%90%97"><span class="toc-text">2.了解红黑树吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%92%E5%BA%A6%EF%BC%8C%E9%99%A4%E4%BA%86%E9%93%BE%E8%A1%A8%E6%B3%95%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3Hash%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">3.从数据结构角度，除了链表法还有什么解决Hash冲突的方式？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A"><span class="toc-text">操作系统：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-3%E6%AC%A1"><span class="toc-text">1.线程和进程有什么关系，有什么区别？(3次)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E9%A1%B5%EF%BC%9F"><span class="toc-text">2.什么是虚页？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-OS%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%BF%9B%E7%A8%8B-LWP-%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E4%BD%A0%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">3.OS中有一个轻量级进程(LWP)的概念，你有了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%98%AF%E4%BB%80%E4%B9%88%E3%80%82"><span class="toc-text">4.解释一下零拷贝是什么。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-I-x2F-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91"><span class="toc-text">5.I&#x2F;O多路复用你了解多少</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A"><span class="toc-text">计算机网络：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E7%9A%84%E6%97%B6%E5%80%99%E8%A6%81%E7%94%A8UDP%EF%BC%8C%E9%99%A4%E4%BA%86%E6%8F%A1%E6%89%8B%E6%8C%A5%E6%89%8B%EF%BC%8CTCP%E8%BF%98%E5%B7%AE%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-text">1.为什么视频传输的时候要用UDP，除了握手挥手，TCP还差在哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BTCP%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82"><span class="toc-text">2.描述一下TCP建立连接的过程。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9C%A8%E4%B8%80%E5%8F%B0%E4%B8%BB%E6%9C%BA%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%90%8C%E6%97%B6%E5%BB%BA%E7%AB%8BTCP%E5%92%8CUDP%E5%8D%8F%E8%AE%AE%EF%BC%8C%E8%83%BD%E5%BB%BA%E7%AB%8B%E8%B5%B7%E6%9D%A5%E5%90%97%EF%BC%9F"><span class="toc-text">3.在一台主机的一个端口同时建立TCP和UDP协议，能建立起来吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A0%BC%E5%BC%8F%E8%83%BD%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%90%97%EF%BC%9F%E6%AF%94%E5%A6%82%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%B4%E7%9A%84%E6%A0%BC%E5%BC%8F%E3%80%82"><span class="toc-text">4.HTTP协议的格式能描述一下吗？比如请求和响应头的格式。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-GET%E5%92%8CPOST%E4%B8%A4%E7%A7%8D%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">5.GET和POST两种请求的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%AF%B4%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%9B%B8%E5%BA%94%E7%A0%81"><span class="toc-text">6.说几个常见的HTTP相应码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%AF%94%E5%A6%82%E4%BD%A0%E9%81%87%E5%88%B0%E4%BA%86502%E9%94%99%E8%AF%AF%EF%BC%8C%E4%BD%A0%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8E%BB%E6%8E%92%E6%9F%A5%E9%94%99%E8%AF%AF%E5%91%A2%EF%BC%9F"><span class="toc-text">7.比如你遇到了502错误，你该怎么去排查错误呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-https-%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">8.https 的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BD%A0%E7%9F%A5%E9%81%93%E4%BD%BF%E7%94%A8http%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E3%80%81%E6%8A%A5%E6%96%87%E6%98%AF%E6%80%8E%E4%B9%88%E5%8F%91%E9%80%81%E7%9A%84%EF%BC%9F"><span class="toc-text">9.你知道使用http协议通信的客户端和服务器之间是怎么建立连接的、报文是怎么发送的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%A6%81%E7%AD%892%E4%B8%AA%E6%97%B6%E9%95%BF%E5%90%8E%E5%85%B3%E9%97%AD%E5%91%A2%EF%BC%9F%E5%B0%B1%E6%98%AF2ML%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">10.为什么客户端要等2个时长后关闭呢？就是2ML问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%BA%86%E8%A7%A3http%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%98%AF%E4%BB%80%E4%B9%88%E5%90%97%EF%BC%9F"><span class="toc-text">11.了解http的滑动窗口是什么吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80%EF%BC%9A"><span class="toc-text">Java基础：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-java%E4%B8%AD%E6%9C%89%E5%87%A0%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">1.java中有几个基本的数据类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%80%E4%B8%AAbyte%E6%98%AF%E5%87%A0%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%9F"><span class="toc-text">2.一个byte是几个字节？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%80%E4%B8%AAchar%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%8F%AF%E4%BB%A5%E8%BD%AC%E6%88%90%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">3.一个char类型数据可以转成什么类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAfloat%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-text">4.如何创建float类型的变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-float%E4%B8%8Edouble%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E6%B7%B7%E5%90%88%E8%BF%90%E7%AE%97%E7%BB%93%E6%9E%9C%E4%BC%9A%E5%87%86%E7%A1%AE%E5%90%97%EF%BC%9F"><span class="toc-text">5.float与double类型进行混合运算结果会准确吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-java%E4%B8%AD-double%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">8.java中 double类型数据的组织形式是怎么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-java%E4%B8%AD%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E5%9C%B0%E8%A1%A8%E8%BE%BE%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%EF%BC%9F"><span class="toc-text">7.java中如何准确地表达数据的加减运算？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%BD%A0%E5%9C%A8%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E7%94%A8%E8%BF%87%E8%BF%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97%EF%BC%9F"><span class="toc-text">10.你在你的项目中有用过这个数据类型吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-java%E4%B8%AD%E4%B8%80%E8%88%AC%E7%94%A8%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9D%A5%E6%8E%A5%E6%94%B6-%E5%AE%9A%E4%B9%89%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E4%B8%BB%E9%94%AE"><span class="toc-text">11.java中一般用什么数据类型来接收 定义在数据库中的主键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%88%9A%E6%89%8D%E8%AF%B4%E5%88%B0Integer%E6%98%AF%E4%B8%80%E7%A7%8D%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%88%91%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAInteger-a-x3D-1%EF%BC%9B%E5%9C%A8%E5%AE%9A%E4%B9%89-int-b-x3D-1%EF%BC%9B%E6%88%91%E8%BF%9B%E8%A1%8Cif-a-x3D-x3D-b-%E5%88%A4%E6%96%AD%E6%9D%A1%E4%BB%B6%E4%BC%9A%E6%88%90%E7%AB%8B%E5%90%97%EF%BC%9F"><span class="toc-text">10.刚才说到Integer是一种包装类型，如果我定义一个Integer a &#x3D; 1；在定义 int b &#x3D; 1；我进行if(a &#x3D;&#x3D; b)判断条件会成立吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%8A%A0%E5%85%A5-Integer-a-x3D-new-Integer-1-int-b-x3D-1-%E9%82%A3%E4%B9%88if-a-x3D-x3D-b-%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89%EF%BC%9F"><span class="toc-text">11.加入 Integer a &#x3D; new Integer(1); int b &#x3D; 1; 那么if(a &#x3D;&#x3D; b)是否相等？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%88%9A%E6%89%8D%E8%AF%B4%E7%9A%84%E7%AD%89%E5%8F%B7%E4%B8%A4%E8%BE%B9%E4%B8%80%E8%BE%B9%E6%98%AFInteger%EF%BC%8C%E4%B8%80%E8%BE%B9%E6%98%AFint%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E8%BF%99%E6%A0%B7%E5%88%A4%E6%96%AD%EF%BC%8C%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">12.刚才说的等号两边一边是Integer，一边是int，为什么能这样判断，你了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-java%E4%B8%AD-boolean%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E8%BD%AC%E6%8D%A2%E6%88%90int%E7%B1%BB%E5%9E%8B%E5%90%97%EF%BC%9F"><span class="toc-text">13.java中 boolean类型可以转换成int类型吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-java%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%AD%EF%BC%8C%E7%BA%BF%E6%80%A7%E6%96%B9%E5%BC%8F%E5%AD%98%E5%82%A8%E7%9A%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">14.java集合类中，线性方式存储的有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Map%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%AE%83%E4%BB%AC%EF%BC%9A"><span class="toc-text">15.Map的实现类有哪些，介绍一下它们：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-HashMap%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">16.HashMap的应用场景是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-HashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">17.HashMap的实现方式是什么样的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%EF%BC%9A"><span class="toc-text">MySQL：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84id%E7%94%A8%E7%9A%84%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">1.数据库中的id用的什么数据类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-mysql%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">2.mysql索引是什么结构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%B2%E4%B8%80%E4%B8%8B%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-text">3.讲一下聚簇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%A1%A8%E9%87%8C%E6%9C%89%E4%B8%BB%E9%94%AEid%E5%88%97%EF%BC%8Cname%E5%88%97%EF%BC%8C%E6%88%91%E5%BB%BA%E7%AB%8B-id-name-%E7%9A%84%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%BC%9A%E8%B5%B7%E4%BD%9C%E7%94%A8%E5%90%97%EF%BC%9F%E6%9C%89%E5%BF%85%E8%A6%81%E5%90%97%EF%BC%9F"><span class="toc-text">4. 表里有主键id列，name列，我建立(id, name)的联合索引会起作用吗？有必要吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-mysql%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%87%A0%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%8C%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-text">5.mysql事务有几种隔离级别，你了解过吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-innodb%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%9F-2%E6%AC%A1"><span class="toc-text">6.innodb怎么实现可重复读？(2次)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%8A%A0%E5%85%A5%E7%BB%99%E4%BD%A0%E4%B8%80%E4%B8%AAsql%E8%AF%AD%E5%8F%A5%EF%BC%8C%E4%BD%A0%E4%BC%9A%E4%BB%8E%E5%93%AA%E5%87%A0%E4%B8%AA%E6%96%B9%E9%9D%A2%E8%80%83%E8%99%91%E4%BC%98%E5%8C%96%E5%91%A2%EF%BC%9F-2%E6%AC%A1"><span class="toc-text">7.加入给你一个sql语句，你会从哪几个方面考虑优化呢？(2次)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%9C%A8explian%E6%8A%A5%E5%91%8A%E4%B8%AD%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9F%E4%B8%BE%E5%87%A0%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-text">8.在explian报告中，有哪些常见的索引使用方式？举几个例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-2%E6%AC%A1"><span class="toc-text">9.索引覆盖是什么？(2次)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%BB%80%E4%B9%88%E5%8F%AB%E5%9B%9E%E8%A1%A8%EF%BC%9F"><span class="toc-text">10.什么叫回表？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%9F11-where%E6%9D%A1%E4%BB%B6%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%87%E6%BB%A4%E6%8E%89%E6%95%B0%E6%8D%AE%E7%9A%84%EF%BC%9F%E5%9C%A8%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F"><span class="toc-text">🌟11.where条件是如何过滤掉数据的？在哪一层？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-A%E5%88%97-%E5%BB%BA%E6%9C%89%E7%B4%A2%E5%BC%95-B%E5%88%97%E6%B2%A1%E6%9C%89-%E6%9F%A5%E8%AF%A2where-A-x3D-1-and-B-x3D-1%E6%97%B6%E5%BA%95%E5%B1%82%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">12.A列 建有索引 B列没有 查询where A &#x3D; 1 and B &#x3D; 1时底层发生了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%B8%80%E6%9D%A1SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">13.一条SQL的执行过程是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A"><span class="toc-text">Java并发编程：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-text">1.为什么要用线程池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-text">2.怎么创建线程池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-text">3.线程池有什么运行机制，有什么参数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AF%B4%E4%B8%80%E4%B8%8Bvolatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">4.说一下volatile关键字的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BD%A0%E5%AF%B9synchronize%E7%9A%84%E7%90%86%E8%A7%A3%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-text">5.你对synchronize的理解是怎么样的呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BA%86%E8%A7%A3%E5%81%8F%E5%90%91%E9%94%81%E5%90%97%EF%BC%9F"><span class="toc-text">6.了解偏向锁吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-java%E4%BD%A0%E6%AF%94%E8%BE%83%E4%BA%86%E8%A7%A3%E6%98%AF%E5%90%A7%EF%BC%8Csynchronize%E5%92%8CReentlock%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%B8%8A%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">7.java你比较了解是吧，synchronize和Reentlock的底层实现上有啥区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Reentlock%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%92%8CAQS%E6%9C%89%E5%95%A5%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-text">8.Reentlock的底层实现和AQS有啥关系？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%EF%BC%9A"><span class="toc-text">JVM：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-java%E5%B8%B8%E8%A7%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-text">1.java常见垃圾回收算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9F"><span class="toc-text">2.你了解哪些垃圾收集器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9B%B8%E6%AF%94CMS%E7%9A%84%E4%BC%98%E5%8A%BF%E5%9C%A8%E5%93%AA%EF%BC%9F"><span class="toc-text">3.G1垃圾回收器相比CMS的优势在哪？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E5%88%86%E5%8C%BA%E6%83%85%E5%86%B5%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%83%85%E5%86%B5-2%E6%AC%A1"><span class="toc-text">4.解释一下JVM内存模型(分区情况，然后再讲一下垃圾回收情况)  (2次)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A0%86%E4%B8%AD%E6%9C%89%E6%96%B0%E7%94%9F%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%8C%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%BC%9A%E5%9C%A8%E6%96%B0%E7%94%9F%E4%BB%A3%EF%BC%8C%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%BC%9A%E5%9C%A8%E8%80%81%E5%B9%B4%E4%BB%A3%E5%91%A2%EF%BC%9F"><span class="toc-text">5.堆中有新生代和老年代，什么样的对象会在新生代，什么样的对象会在老年代呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E8%83%BD%E5%A4%9F%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%8C%E5%9B%9E%E6%94%B6%E7%9A%84%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">6.哪些对象能够被回收，回收的机制是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%85%83%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%AD%98%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">7.元数据区存的是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">8.类加载机制是怎么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">9. 双亲委派是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9A"><span class="toc-text">网络编程：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%BD%A0%E6%9C%89%E5%AE%9E%E8%B7%B5%E8%BF%87%E5%90%97%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E4%B8%80%E4%B8%AA%E8%BF%9E%E6%8E%A5%E6%98%AF%E6%B4%BB%E8%B7%83%E7%9A%84"><span class="toc-text">1.网络编程你有实践过吗？如何保持一个连接是活跃的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-text">设计模式：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AF%B4%E4%B8%89%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F-%E4%BD%A0%E5%B9%B3%E6%97%B6%E5%88%86%E5%88%AB%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E7%94%A8%E5%88%B0%E8%BF%99%E4%B8%89%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">1.说三个设计模式，分别是什么意思？ 你平时分别在什么情况下用到这三种设计模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">2. 如何写一个单例模式？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-text">Redis:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-redis%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F%E4%BD%A0%E5%9C%A8%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E8%BF%87%E5%93%AA%E5%87%A0%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F-2%E6%AC%A1"><span class="toc-text">1.redis中有几种数据类型？你在你的项目中用过哪几种数据结构？(2次)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-2%E6%AC%A1"><span class="toc-text">2.redis 分布式锁是怎么实现的？原理是什么？(2次)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%A0%E6%9C%89%E7%A0%94%E7%A9%B6%E8%BF%87String%E5%BA%95%E5%B1%82%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-text">3.你有研究过String底层是怎么实现的呢？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%EF%BC%9A"><span class="toc-text">Spring：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-spring%E4%B8%AD%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1.spring中的拦截器和过滤器有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86%EF%BC%9A"><span class="toc-text">手撕算法部分：</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/18/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/" title="2023秋招总结"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2023秋招总结"/></a><div class="content"><a class="title" href="/2023/08/18/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/" title="2023秋招总结">2023秋招总结</a><time datetime="2023-08-18T07:55:02.000Z" title="Created 2023-08-18 15:55:02">2023-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/15/Redis%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/" title="Redis原理学习"><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727134719639.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis原理学习"/></a><div class="content"><a class="title" href="/2023/08/15/Redis%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/" title="Redis原理学习">Redis原理学习</a><time datetime="2023-08-15T08:10:37.000Z" title="Created 2023-08-15 16:10:37">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/10/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/" title="java基础复习"><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230810141014749.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java基础复习"/></a><div class="content"><a class="title" href="/2023/08/10/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/" title="java基础复习">java基础复习</a><time datetime="2023-08-10T06:08:10.000Z" title="Created 2023-08-10 14:08:10">2023-08-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/2023/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a><time datetime="2023-07-27T14:37:02.000Z" title="Created 2023-07-27 22:37:02">2023-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/27/MySQL%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/" title="MySQL原理学习"><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727223615031.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL原理学习"/></a><div class="content"><a class="title" href="/2023/07/27/MySQL%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/" title="MySQL原理学习">MySQL原理学习</a><time datetime="2023-07-27T14:32:58.000Z" title="Created 2023-07-27 22:32:58">2023-07-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 By donn</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">很高兴认识你🤪</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>