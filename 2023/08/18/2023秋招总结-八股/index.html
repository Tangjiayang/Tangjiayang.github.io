<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>2023秋招总结-八股 | donn的博客</title><meta name="author" content="donn"><meta name="copyright" content="donn"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="共汇总了5次面试被问到的题目 大厂校招面试八股问题汇总：数据结构：1.讲一下平衡二叉树1231. 是一种特殊的二叉搜索树2. 每个节点的左子树和右子树的高度差不超过1插入、删除节点时，会通过左旋、右旋等操作维持平衡    2.了解红黑树吗   红黑树是一种自平衡的二叉搜索树，类似于平衡二叉树 3.从数据结构角度，除了链表法还有什么解决Hash冲突的方式？   (❌)，这里搞错题意了 1234567">
<meta property="og:type" content="article">
<meta property="og:title" content="2023秋招总结-八股">
<meta property="og:url" content="https://tangjiayang.github.io/2023/08/18/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93-%E5%85%AB%E8%82%A1/index.html">
<meta property="og:site_name" content="donn的博客">
<meta property="og:description" content="共汇总了5次面试被问到的题目 大厂校招面试八股问题汇总：数据结构：1.讲一下平衡二叉树1231. 是一种特殊的二叉搜索树2. 每个节点的左子树和右子树的高度差不超过1插入、删除节点时，会通过左旋、右旋等操作维持平衡    2.了解红黑树吗   红黑树是一种自平衡的二叉搜索树，类似于平衡二叉树 3.从数据结构角度，除了链表法还有什么解决Hash冲突的方式？   (❌)，这里搞错题意了 1234567">
<meta property="og:locale">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-08-18T07:55:02.000Z">
<meta property="article:modified_time" content="2023-09-04T08:25:57.220Z">
<meta property="article:author" content="donn">
<meta property="article:tag" content="面经">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://tangjiayang.github.io/2023/08/18/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93-%E5%85%AB%E8%82%A1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":30,"languages":{"author":"Author: donn","link":"Link: ","source":"Source: donn的博客","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '2023秋招总结-八股',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-04 16:25:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/bg.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="donn的博客"><span class="site-name">donn的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">2023秋招总结-八股</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-08-18T07:55:02.000Z" title="Created 2023-08-18 15:55:02">2023-08-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-09-04T08:25:57.220Z" title="Updated 2023-09-04 16:25:57">2023-09-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E7%BB%8F/">面经</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">29.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>89min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="2023秋招总结-八股"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>共汇总了<code>5</code>次面试被问到的题目</p>
<h1 id="大厂校招面试八股问题汇总："><a href="#大厂校招面试八股问题汇总：" class="headerlink" title="大厂校招面试八股问题汇总："></a>大厂校招面试八股问题汇总：</h1><h2 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h2><h3 id="1-讲一下平衡二叉树"><a href="#1-讲一下平衡二叉树" class="headerlink" title="1.讲一下平衡二叉树"></a>1.讲一下平衡二叉树</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 是一种特殊的二叉搜索树</span><br><span class="line">2. 每个节点的左子树和右子树的高度差不超过1</span><br><span class="line">插入、删除节点时，会通过左旋、右旋等操作维持平衡</span><br></pre></td></tr></table></figure>



<h3 id="2-了解红黑树吗"><a href="#2-了解红黑树吗" class="headerlink" title="2.了解红黑树吗"></a>2.了解红黑树吗</h3><p>   红黑树是一种自平衡的二叉搜索树，类似于平衡二叉树</p>
<h3 id="3-从数据结构角度，除了链表法还有什么解决Hash冲突的方式？"><a href="#3-从数据结构角度，除了链表法还有什么解决Hash冲突的方式？" class="headerlink" title="3.从数据结构角度，除了链表法还有什么解决Hash冲突的方式？"></a>3.从数据结构角度，除了链表法还有什么解决Hash冲突的方式？</h3><p>   (❌)，这里搞错题意了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.开放定址法（Open Addressing）：在桶的索引位置发生冲突时，该方法通过探测其他空桶来解决冲突。具体有以下几种探测方式：</span><br><span class="line"></span><br><span class="line">​    线性探测（Linear Probing）：在发生冲突的位置后依次检查下一个位置，直到找到空桶。</span><br><span class="line"></span><br><span class="line">​    二次探测（Quadratic Probing）：根据一个探测序列公式，依次探测下一个位置，直到找到空桶。</span><br><span class="line"></span><br><span class="line">​    双重哈希（Double Hashing）：使用第二个哈希函数来计算下一个位置的偏移量，直到找到空桶。</span><br><span class="line"></span><br><span class="line">开放定址法的优点是可以充分利用桶的空间，没有额外的链表开销，但它也容易引发聚簇（Clustering）现象，导致性能下降。</span><br><span class="line"></span><br><span class="line">2.再哈希法（Rehashing）：在桶的索引位置发生冲突时，该方法通过再次应用哈希函数来计算新的索引位置，直到找到空桶为止。通常会使用一个不同的哈希函数，以减少冲突的可能性。</span><br><span class="line"></span><br><span class="line">再哈希法的优点是可以在不同的哈希函数之间切换，以克服某个哈希函数的缺点。但它也需要维护多个哈希函数，并且可能增加插入和查找操作的时间。</span><br><span class="line"></span><br><span class="line">🌟总结来说，再哈希法是在发生冲突时使用不同的哈希函数重新计算索引位置，而二重哈希是使用第二个哈希函数计算下一个位置的偏移量。</span><br></pre></td></tr></table></figure>





<h2 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a>操作系统：</h2><h3 id="1-线程和进程有什么关系，有什么区别？-3次"><a href="#1-线程和进程有什么关系，有什么区别？-3次" class="headerlink" title="1.线程和进程有什么关系，有什么区别？(3次)"></a>1.线程和进程有什么关系，有什么区别？(3次)</h3><ul>
<li><p><strong>定义</strong>：进程是一个正在执行的程序实例，具有独立的内存空间和资源。线程是进程的一部分，用于执行进程内的具体任务。</p>
</li>
<li><p><strong>资源占用</strong>：每个进程都有自己独立的内存空间和资源，包括文件、网络线程、内核数据结构等。线程共享进程的资源，包括内存空间、文件描述符等。</p>
</li>
<li><p><strong>调度和执行</strong>：进程在操作系统中被调度为可执行状态，并行或交替执行。线程在进程内被调度执行，共享进程的执行环境。</p>
</li>
<li><p><strong>交互和通信</strong>：进程之间通常通过进程间通信（IPC）进行交互和通信，如管道、消息队列、共享内存等。线程之间由于共享相同的内存空间，可以直接访问和修改共享变量，实现线程间的通信和同步。</p>
</li>
<li><p><strong>异常和崩溃</strong>：进程之间具有强隔离性，一个进程的崩溃不会影响其他进程。线程共享同一个进程的资源，一个线程的崩溃可能会影响整个进程的稳定性。</p>
</li>
<li><p><strong>创建和销毁</strong>：创建和销毁进程需要操作系统的调用，涉及加载和卸载程序、分配和释放内存等操作。线程的创建和销毁更轻量级，通常由程序代码直接调用线程库函数进行操作。</p>
</li>
</ul>
<h3 id="2-什么是虚页？"><a href="#2-什么是虚页？" class="headerlink" title="2.什么是虚页？"></a>2.什么是虚页？</h3><ul>
<li><p>在现代计算机系统中，使用了虚拟内存技术来更好地管理和利用系统的内存资源。虚拟内存通过将物理内存和磁盘空间结合起来，为每个进程提供一个逻辑上连续的地址空间，称为虚拟地址空间。</p>
</li>
<li><p>虚拟页和物理页（也称为页框）之间存在映射关系。操作系统利用页表（Page Table）来维护虚拟页与物理页之间的映射关系。页表的每个表项记录了一个虚拟页与一个物理页之间的映射关系。</p>
</li>
<li><p>当程序访问虚拟地址空间中的某个虚拟页时，操作系统首先在页表中查找对应的物理页。如果映射存在，操作系统将虚拟页映射到物理页并将该页加载到主存中，然后将虚拟地址转换为物理地址，程序就可以在主存中访问该虚拟页所对应的物理页了。</p>
</li>
</ul>
<h3 id="3-OS中有一个轻量级进程-LWP-的概念，你有了解吗？"><a href="#3-OS中有一个轻量级进程-LWP-的概念，你有了解吗？" class="headerlink" title="3.OS中有一个轻量级进程(LWP)的概念，你有了解吗？"></a>3.OS中有一个轻量级进程(LWP)的概念，你有了解吗？</h3><p>   (❌，不了解，赶紧了解一下)</p>
<p>在用户空间层面上模拟了传统操作系统中的进程，但在内核态中<strong>每个LWP都与一个特定的内核<u>线</u>程</strong>关联</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">轻量级进程是一种在操作系统中实现的并发执行的方式。它是在用户空间层面上模拟了传统操作系统中的进程，具有自己的执行上下文、栈、寄存器集等，但在内核层面上实际上共享了同一个真实的操作系统线程。</span><br><span class="line"></span><br><span class="line">LWP的主要优势在于它比传统的进程更轻量级，创建和销毁一个LWP的成本要低于创建和销毁一个完整的进程。由于LWP共享了操作系统线程，它们之间的切换成本也更低。这使得创建和切换LWP的开销较小，且在并发执行和并行执行方面具有更高的效率。</span><br></pre></td></tr></table></figure>



<h3 id="4-解释一下零拷贝是什么。"><a href="#4-解释一下零拷贝是什么。" class="headerlink" title="4.解释一下零拷贝是什么。"></a>4.解释一下零拷贝是什么。</h3><p>   (❌，不会)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">零拷贝是指计算机执行IO操作时，CPU不需要将数据从一个存储区域复制到另一个存储区域，进而减少上下文切换以及CPU的拷贝时间。它是一种IO操作优化技术。</span><br><span class="line"></span><br><span class="line">进行网络传输时，需要将待传输文件从磁盘读出，经过一系列拷贝，到达网卡，进行传输。</span><br><span class="line"></span><br><span class="line">传统：硬件设备(磁盘)-&gt;内核缓冲区-&gt;用户缓冲区-&gt;socket缓冲区-&gt;网卡设备       这样的拷贝操作会占用CPU时间和内存带宽，降低系统性能。</span><br><span class="line"></span><br><span class="line">而零拷贝技术通过减少或消除不必要的数据拷贝，提高了数据传输的效率。它通过直接在内核空间中进行数据传输，避免了在用户空间和内核空间之间拷贝数据的过程。</span><br><span class="line"></span><br><span class="line">零拷贝的实现方式：</span><br><span class="line">	1.mmap：硬件设备(磁盘)-&gt;内核缓冲区-&gt;socket缓冲区-&gt;网卡设备 </span><br><span class="line">	2.sendfile：硬件设备(磁盘)-&gt;内核缓冲区-&gt;socket缓冲区-&gt;网卡设备 </span><br><span class="line">	3.sendfile +DMA scatter/gather：硬件设备(磁盘)-&gt;内核缓冲区--&gt;网卡设备 </span><br><span class="line">					⬆️其中CPU把内核缓冲区中的文件描述符信息（包括内核缓冲区的内存地址和偏移量）直接发送到socket缓冲区</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">具体来说，零拷贝的实现可以通过以下方式之一：</span><br><span class="line">DMA（Direct Memory Access）技术：使用DMA控制器将数据直接从存储设备传输到网络适配器，或者从网络适配器直接传输到存储设备，避免了数据在内存中的中间拷贝。</span><br><span class="line"></span><br><span class="line">内核缓冲区直接传输：在系统调用期间，将数据从内核缓冲区传输到网络适配器，或者从网络适配器传输到内核缓冲区，避免了在用户空间和内核空间之间的数据拷贝。</span><br><span class="line"></span><br><span class="line">内核空间到用户空间的零拷贝：通过使用mmap（内存映射）或其他技术，将内核空间的数据直接映射到用户空间，而不需要数据在内存中的额外拷贝。</span><br><span class="line"></span><br><span class="line">零拷贝技术可以在高速数据传输、存储系统和网络应用等场景中发挥作用。它能够减少数据拷贝带来的CPU负载和内存带宽的消耗，提高数据传输的效率和性能。</span><br></pre></td></tr></table></figure>



<h3 id="5-I-x2F-O多路复用你了解多少"><a href="#5-I-x2F-O多路复用你了解多少" class="headerlink" title="5.I&#x2F;O多路复用你了解多少"></a>5.I&#x2F;O多路复用你了解多少</h3><p>   (❌，乱讲一通 &#x3D; 不了解)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I/O多路复用是一种高效的I/O处理机制，它允许单个线程或进程同时监听多个I/O事件，从而实现对多个I/O操作的并发处理。在I/O多路复用模式下，可以在一个线程中同时处理多个客户端请求而无需创建额外的线程。</span><br></pre></td></tr></table></figure>

<p><strong>追问</strong>：有几种I&#x2F;O模式，有什么区别？</p>
<p>   同步异步</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    阻塞式I/O（Blocking I/O）：在阻塞式I/O中，当应用程序发起一个I/O操作后，它会一直阻塞等待直到操作完成。这意味着应用程序无法继续执行其他任务，直到I/O操作完成。阻塞式I/O适用于简单的应用场景，但在面对并发处理需求或高负载情况下，可能会导致性能瓶颈。</span><br><span class="line"></span><br><span class="line">    非阻塞式I/O（Non-Blocking I/O）：在非阻塞式I/O中，当应用程序发起一个I/O操作后，它可以立即返回而不需等待操作完成。应用程序可以继续执行其他任务，然后通过轮询或其他方式来检查I/O操作是否完成。非阻塞式I/O可以提高应用程序的并发性能，但需要应用程序频繁轮询I/O状态，可能会导致CPU资源浪费。</span><br><span class="line">    非阻塞式I/O：不管I/O有没有完成，都要去轮询，查找是否有I/O完成</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    I/O多路复用（I/O Multiplexing）：I/O多路复用允许单个线程或进程同时监听多个I/O事件的就绪状态。通过select或poll或epoll等机制，应用程序可以同时监听多个I/O操作，当有就绪的I/O事件时，再进行实际的读写操作。I/O多路复用可以提高并发处理能力，减少线程或进程的使用，适用于处理大量并发连接的场景。</span><br><span class="line">    </span><br><span class="line">    select或poll：当有I/O完成时，会收到一个通知，但是不知道是哪个线程I/O完毕，所以要轮询查找(这种方式相比非阻塞式I/O避免了空转，网卡通过DMA写入指定内存后，发送一个中断信号告诉CPU有数据包到来了，内核线程就检查是否有I/O完毕了)</span><br><span class="line">		epoll：当有I/O完成时，会收到一个通知，并且会告诉你哪个线程完成了I/O，不需要轮询！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    信号驱动式I/O（Signal-Driven I/O）：信号驱动式I/O允许应用程序在I/O操作完成时接收一个信号通知。应用程序可以在发起I/O操作前设置信号处理器，并在操作完成后通过信号通知来处理相应逻辑。信号驱动式I/O兼具非阻塞和异步I/O的特性，可以提高并发性能。</span><br><span class="line"></span><br><span class="line">    异步I/O（Asynchronous I/O）：在异步I/O中，应用程序发起一个I/O操作后，可以立即返回继续执行其他任务，而无需等待操作完成。当I/O操作完成时，系统会通知应用程序，执行相应的回调处理。异步I/O将I/O操作的处理逻辑分离，可以有效地避免阻塞和轮询带来的性能问题，适用于高并发和高吞吐量的应用场景。异步I/O需要操作系统和应用程序的支持。</span><br><span class="line">信号驱动式I/O和异步I/O的区别：</span><br><span class="line">    ✦技术实现：信号驱动式I/O基于信号和信号处理器的机制实现，而异步I/O基于系统调用和回调函数实现。</span><br><span class="line">    ✦通知方式：信号驱动式I/O通过发送信号来通知应用程序，而异步I/O通过回调函数来通知应用程序。</span><br><span class="line">    ✦应用程序接口：信号驱动式I/O需要应用程序显式地设置信号处理器和关联到特定的I/O操作上，而异步I/O需要应用程序设置回调函数，并通过注册到操作系统的事件机制来进行回调通知。</span><br><span class="line">    ✦可控性：信号驱动式I/O具有更低一级的控制，应用程序可以在信号处理器中自行处理操作完成的事件和结果。而异步I/O的控制由操作系统来处理，应用程序只需要定义回调函数来处理已完成的操作。</span><br></pre></td></tr></table></figure>



<h3 id="6-简单说一下CAS是怎么实现的"><a href="#6-简单说一下CAS是怎么实现的" class="headerlink" title="6.简单说一下CAS是怎么实现的"></a>6.简单说一下CAS是怎么实现的</h3><p>​	compare and swap，修改前记录预期值，修改时先检查值是否是预期值，不是的话说明中途被其他线程修改了，于是重做整个过程</p>
<p><strong>可能会产生ABA问题</strong>，可以使用添加序号、时间戳的方式解决。</p>
<h3 id="7-线程的sleep-方法和Object的wait-方法有什么区别？"><a href="#7-线程的sleep-方法和Object的wait-方法有什么区别？" class="headerlink" title="7.线程的sleep( )方法和Object的wait( )方法有什么区别？"></a>7.线程的sleep( )方法和Object的wait( )方法有什么区别？</h3><p>​	都会让出CPU，sleep不会让出它锁定的资源</p>
<h3 id="8-对线程之间常见的通信的工具类有了解吗？"><a href="#8-对线程之间常见的通信的工具类有了解吗？" class="headerlink" title="8.对线程之间常见的通信的工具类有了解吗？"></a>8.对线程之间常见的通信的工具类有了解吗？</h3><p>(❌，学过，但不了解，好好记一下！)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wait() 和 notify()/notifyAll()：这些方法是基于对象监视器的机制，用于实现线程之间的等待和唤醒。wait() 方法使线程进入等待状态，直到其他线程通过 notify() 或 notifyAll() 方法唤醒它。这种机制通常用于实现线程间的协作。</span><br><span class="line"></span><br><span class="line">Lock 和 Condition：Lock 接口提供了比 synchronized 更灵活、更强大的锁机制。Condition 接口是与 Lock 相关联的条件等待的机制，它使得线程可以在某个条件满足时等待，或者在其他线程满足条件时通知。</span><br><span class="line"></span><br><span class="line">CountDownLatch：CountDownLatch 是一个用于等待其他线程完成操作的计数器，它允许一个或多个线程等待其他线程完成指定数量的操作。在所有需要等待的操作完成之前，调用 await() 方法的线程都会被阻塞。</span><br><span class="line"></span><br><span class="line">CyclicBarrier：CyclicBarrier 是一种同步辅助类，它允许一组线程等待彼此达到某个共同点，然后再继续执行。当所有线程都到达同一个点时，它可以选择执行一个指定的任务。</span><br><span class="line"></span><br><span class="line">Semaphore：Semaphore 是一种计数信号量，用于控制同时访问特定资源的线程数量。它通过 acquire() 方法获取信号量，表示占用一个资源；通过 release() 方法释放信号量，表示释放一个资源。</span><br><span class="line"></span><br><span class="line">BlockingQueue：BlockingQueue 是一种线程安全的队列，它支持在队列为空时等待获取元素或在队列满时等待插入元素。常见的实现类有 ArrayBlockingQueue 和 LinkedBlockingQueue。</span><br><span class="line"></span><br><span class="line">需要注意的是，以上的通信工具类并不是完整的列表，还有其他更多的工具类可以用于线程之间的通信和同步。选择适当的工具类取决于具体的需求和场景。</span><br></pre></td></tr></table></figure>



<h2 id="计算机网络："><a href="#计算机网络：" class="headerlink" title="计算机网络："></a>计算机网络：</h2><h3 id="1-为什么视频传输的时候要用UDP，除了握手挥手，TCP还差在哪里？"><a href="#1-为什么视频传输的时候要用UDP，除了握手挥手，TCP还差在哪里？" class="headerlink" title="1.为什么视频传输的时候要用UDP，除了握手挥手，TCP还差在哪里？"></a>1.为什么视频传输的时候要用UDP，除了握手挥手，TCP还差在哪里？</h3><ul>
<li>实时性: UDP是一种无连接的协议，没有TCP那样的握手、确认和重传机制，使得数据包能够以更快的速度被发送到目标地址。在实时应用中，如视频传输，低延迟和实时性非常重要，UDP能够满足这些需求。</li>
<li>较小的开销: 由于UDP没有TCP那样的拥塞控制和流量控制机制，以及对可靠性的需求，它的数据包头部相对较小，因此传输效率更高。这对于带宽受限的场景，如视频传输等，非常有利。</li>
<li>灵活性和自定义性: UDP协议相对简单，它只负责数据的传输，不负责数据的可靠性和有序性，因此更加灵活。这样可以让开发人员根据具体需求自定义传输协议和处理机制，满足特定的实时性要求，如直播、视频通话等。</li>
<li>减轻服务器负担: 当一个视频服务需要同时处理大量的客户端请求时，使用UDP可以减轻服务器的负担。因为UDP的无连接特性，服务器不需要为每个客户端维护连接状态，也不需要进行复杂的管理和调度。</li>
</ul>
<h3 id="2-描述一下TCP建立连接的过程。"><a href="#2-描述一下TCP建立连接的过程。" class="headerlink" title="2.描述一下TCP建立连接的过程。"></a>2.描述一下TCP建立连接的过程。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TCP（Transmission Control Protocol）是一种面向连接的可靠传输协议。下面是 TCP 建立连接的过程：</span><br><span class="line"></span><br><span class="line">客户端发送 SYN（同步）报文：当客户端要与服务器建立 TCP 连接时，它会发送一个 SYN 报文给服务器。这个报文包含一个序列号（Seq）用于标识发送的数据段。</span><br><span class="line"></span><br><span class="line">服务器回复 SYN-ACK（同步-确认）报文：服务器接收到客户端的 SYN 报文后，会向客户端返回一个 SYN-ACK 报文。这个报文中，服务器的序列号被设置为服务器初始序列号，确认号（Ack）被设置为客户端的序列号加 1，表示服务器已经收到了客户端的 SYN 报文。</span><br><span class="line"></span><br><span class="line">客户端发送 ACK（确认）报文：客户端接收到服务器的 SYN-ACK 报文后，会向服务器发送一个 ACK 报文。该报文的序列号被设置为客户端的初始序列号，确认号被设置为服务器的序列号加 1，表示客户端已经收到了服务器的 SYN-ACK 报文。</span><br><span class="line"></span><br><span class="line">连接建立：服务器接收到客户端的 ACK 报文后，双方成功建立了 TCP 连接。双方现在可以开始交换数据。</span><br><span class="line"></span><br><span class="line">这个过程通常被称为三次握手，因为它包含了三个主要步骤，分别是客户端发送 SYN、服务器回复 SYN-ACK、客户端发送 ACK。三次握手的目的是确保双方都能够收发数据，并同步初始化序列号。</span><br><span class="line"></span><br><span class="line">在 TCP 连接的过程中，每个报文都有对方的确认号和序列号，用于保证可靠性和顺序性。三次握手过程中，服务器和客户端都会分配初始序列号，以确保连接的唯一性和安全性。</span><br></pre></td></tr></table></figure>



<h3 id="3-在一台主机的一个端口同时建立TCP和UDP协议，能建立起来吗？"><a href="#3-在一台主机的一个端口同时建立TCP和UDP协议，能建立起来吗？" class="headerlink" title="3.在一台主机的一个端口同时建立TCP和UDP协议，能建立起来吗？"></a>3.在一台主机的一个端口同时建立TCP和UDP协议，能建立起来吗？</h3><p>   (❌，计网还没看，说得七七八八的，太差了)   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TCP 和 UDP 是基于不同协议的传输层协议，它们在传输方式和连接管理上有所区别。 TCP 是一种面向连接的、可靠的传输协议，而 UDP 则是无连接和不可靠的传输协议。虽然它们使用相同的端口号来标识应用程序，但它们是独立的协议栈。</span><br><span class="line"></span><br><span class="line">当使用一个端口号时，操作系统根据协议类型（TCP 或 UDP）来区分接收到的数据。因此，在同一台主机的同一端口上，可以同时建立 TCP 和 UDP 连接，只要你将每个连接区分为 TCP 连接或 UDP 连接即可。</span><br></pre></td></tr></table></figure>



<h3 id="4-HTTP协议的格式能描述一下吗？比如请求和响应头的格式。"><a href="#4-HTTP协议的格式能描述一下吗？比如请求和响应头的格式。" class="headerlink" title="4.HTTP协议的格式能描述一下吗？比如请求和响应头的格式。"></a>4.HTTP协议的格式能描述一下吗？比如请求和响应头的格式。</h3><p>   (❌)说得七七八八</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">HTTP 请求的格式：</span><br><span class="line">✦请求行（Request Line）：</span><br><span class="line">        &lt;请求方法&gt; &lt;目标资源路径&gt; &lt;协议版本&gt;</span><br><span class="line">✦请求头（Request Headers）：包含了关于请求的一些附加信息，格式为键值对，每个键值对占据一行。</span><br><span class="line">        &lt;键1&gt;: &lt;值1&gt;</span><br><span class="line">        &lt;键2&gt;: &lt;值2&gt;</span><br><span class="line">        ...</span><br><span class="line">✦空行（空格 + 回车换行）：</span><br><span class="line">        用于分隔请求头和请求体。</span><br><span class="line">✦请求体（Request Body）：</span><br><span class="line">        可选的，适用于一些特定的请求，如 POST 请求，用于传输用户提交的数据。</span><br><span class="line"></span><br><span class="line">HTTP 响应的格式：</span><br><span class="line">✦状态行（Status Line）：</span><br><span class="line">        &lt;协议版本&gt; &lt;状态码&gt; &lt;状态信息&gt;</span><br><span class="line">✦响应头（Response Headers）：</span><br><span class="line">        包含了关于响应的一些附加信息，格式为键值对，每个键值对占据一行。</span><br><span class="line">        &lt;键1&gt;: &lt;值1&gt;</span><br><span class="line">        &lt;键2&gt;: &lt;值2&gt;</span><br><span class="line">        ...</span><br><span class="line">✦空行（空格 + 回车换行）：</span><br><span class="line">        用于分隔响应头和响应体。</span><br><span class="line">✦响应体（Response Body）：</span><br><span class="line">        包含了服务器响应的数据。</span><br></pre></td></tr></table></figure>



<h3 id="5-GET和POST两种请求的区别是什么？"><a href="#5-GET和POST两种请求的区别是什么？" class="headerlink" title="5.GET和POST两种请求的区别是什么？"></a>5.GET和POST两种请求的区别是什么？</h3><p>   只说了1(⚠️)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.参数传递位置：GET请求将参数附加在URL的末尾，形成URL参数，即在请求行中传递参数；而POST请求将参数包含在请求的消息体中，通过请求体传递参数。</span><br><span class="line"></span><br><span class="line">2.安全性：GET请求以明文形式传输参数，将参数添加在URL中，可以在浏览器的地址栏直接看到；POST请求则使用消息体传输参数，对参数进行了封装，不会直接暴露在URL中，相对较为安全。</span><br><span class="line"></span><br><span class="line">3.请求长度限制：GET请求对URL的长度有限制，一般在浏览器中限制为2048个字符；而POST请求没有严格的长度限制，可以传输更大的数据量。</span><br><span class="line"></span><br><span class="line">4.缓存机制：GET请求可以被缓存：如果请求的是静态资源，则会缓存，如果是数据，则不会缓存; 而POST请求默认不会被缓存。</span><br><span class="line"></span><br><span class="line">5.请求语义：GET请求主要用于获取资源，操作不应带来副作用，例如查询数据；POST请求主要用于向服务器提交数据，可能会对服务器产生影响，例如提交表单或创建新资源。</span><br><span class="line"></span><br><span class="line">6.get请求产生一个TCP数据包；post请求产生两个TCP数据包（get请求，浏览器会把http header和data一并发送出去，服务器响应200返回数据；post请求，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 返回数据）</span><br></pre></td></tr></table></figure>



<h3 id="6-说几个常见的HTTP相应码"><a href="#6-说几个常见的HTTP相应码" class="headerlink" title="6.说几个常见的HTTP相应码"></a>6.说几个常见的HTTP相应码</h3><p>   (⚠️)只答了几个，并且不太熟悉</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">200 OK：表示请求成功，服务器成功处理了请求。</span><br><span class="line"></span><br><span class="line">301 Moved Permanently：永久重定向，表示请求的资源已经被移动到了新的URL。</span><br><span class="line"></span><br><span class="line">302 Found：临时重定向，表示请求的资源暂时被移动到了新的URL。</span><br><span class="line"></span><br><span class="line">400 Bad Request：表示客户端的请求语法错误或无效，服务器无法理解。</span><br><span class="line"></span><br><span class="line">401 Unauthorized：表示请求需要身份验证，客户端需要提供有效的凭据。</span><br><span class="line"></span><br><span class="line">403 Forbidden：表示服务器理解请求，但拒绝执行，客户端没有访问权限。</span><br><span class="line"></span><br><span class="line">404 Not Found：表示服务器无法找到请求的资源。</span><br><span class="line"></span><br><span class="line">500 Internal Server Error：表示服务器内部错误，无法完成请求。</span><br><span class="line"></span><br><span class="line">502 Bad Gateway是指作为代理或网关的服务器从上游服务器接收到一个无效的响应，导致无法完成请求。</span><br><span class="line"></span><br><span class="line">503 Service Unavailable：表示服务器暂时无法处理请求，通常是由于服务器过载或维护。</span><br><span class="line"></span><br><span class="line">401 vs 403</span><br><span class="line">总结起来，401 Unauthorized表示客户端未提供有效的身份验证信息，需要进行身份验证；而403 Forbidden表示客户端已提供有效的身份验证，但是被服务器拒绝访问该资源。</span><br></pre></td></tr></table></figure>



<h3 id="7-比如你遇到了502错误，你该怎么去排查错误呢？"><a href="#7-比如你遇到了502错误，你该怎么去排查错误呢？" class="headerlink" title="7.比如你遇到了502错误，你该怎么去排查错误呢？"></a>7.比如你遇到了502错误，你该怎么去排查错误呢？</h3><p>   首先因为5开头，确定是服务器方面的错误，然后去服务器查看报错信息以及日志信息。</p>
<p>(⚠️)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">了解错误码：首先阅读错误信息，确切了解错误的类型和含义。不同的错误码代表不同的问题，了解错误码可以帮助你更快定位问题。</span><br><span class="line"></span><br><span class="line">检查网络连接：确保你的网络连接正常。尝试访问其他网站或服务，以确认是否只有特定的网站或服务受到影响。</span><br><span class="line"></span><br><span class="line">刷新页面或重试：有时候错误可能只是暂时的，尝试刷新页面或重新执行操作，看看错误是否会消失。</span><br><span class="line"></span><br><span class="line">检查URL和请求参数：确保URL和请求参数正确无误。可能是由于请求的URL或参数不正确导致服务器返回错误。</span><br><span class="line"></span><br><span class="line">检查服务器状态：如果错误是与特定的网站或服务相关，可以尝试访问其他网站或服务来确认是服务器端的问题还是客户端的问题。</span><br><span class="line"></span><br><span class="line">查看服务器日志：如果你有服务器的访问权限，可以查看服务器的日志来获取更多的错误信息。服务器日志通常可以提供有关错误发生的具体细节，帮助你定位问题。</span><br><span class="line"></span><br><span class="line">联系网站管理员或技术支持：如果你已经尝试过以上的排查步骤但问题仍然存在，建议联系网站的管理员或技术支持人员。他们可能具有更深入的技术知识和工具来帮助你解决问题。</span><br></pre></td></tr></table></figure>



<h3 id="8-https-的原理是什么？"><a href="#8-https-的原理是什么？" class="headerlink" title="8.https 的原理是什么？"></a>8.https 的原理是什么？</h3><p>  就知道这是http的一种安全的形式(❌，不会)</p>
<p><strong>追问：</strong>安全是怎么实现的呢？</p>
<p>  应该是对传输进行了加密</p>
<p><strong>追问：</strong>怎么加密的呢？</p>
<p>  不是很清楚</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qh1112/article/details/125137337?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169331657916800180681936%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169331657916800180681936&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-125137337-null-null.142%5Ev93%5EchatsearchT3_2&utm_term=https%20%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F&spm=1018.2226.3001.4187">https介绍</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTPS是一种通过加密传输数据的网络协议，它的原理如下：</span><br><span class="line"></span><br><span class="line">1.加密通信：HTTPS 使用了加密算法来保护数据的机密性。在客户端与服务器之间建立连接时，首先会进行一次称为SSL/TLS握手的过程，通过该握手过程来协商加密算法和密钥等信息。然后，通过使用协商的密钥对传输的数据进行加密，确保数据在传输过程中不容易被窃听或篡改。</span><br><span class="line"></span><br><span class="line">2.数字证书验证：HTTPS 使用数字证书来验证服务器的身份。数字证书由第三方机构（证书颁发机构，Certificate Authority，CA）签发，包含了服务器的公钥和相关信息。在握手过程中，客户端会检查服务器返回的证书，并验证其有效性和合法性。如果验证通过，客户端会使用证书中的公钥加密传输的数据。</span><br><span class="line"></span><br><span class="line">3.对称加密与非对称加密结合：HTTPS 使用对称加密和非对称加密结合的方式来进行加密传输。非对称加密算法用于在握手过程中协商对称加密算法和密钥，这样可以确保密钥在传输过程中不被泄露。对称加密算法用于加密实际传输的数据，对称加密算法的加解密速度更快，保证了性能。</span><br><span class="line"></span><br><span class="line">4.安全标识：HTTPS 使用 URL 地址中的 &quot;https://&quot; 来表示当前使用的是安全的加密连接。</span><br><span class="line"></span><br><span class="line">总结来说，HTTPS 通过加密通信、数字证书验证、对称加密与非对称加密结合等措施，实现了对传输数据的机密性和完整性的保护。这使得客户端与服务器之间的通信更加安全，可以有效地防止数据被窃听和篡改。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="9-你知道使用http协议通信的客户端和服务器之间是怎么建立连接的、报文是怎么发送的？"><a href="#9-你知道使用http协议通信的客户端和服务器之间是怎么建立连接的、报文是怎么发送的？" class="headerlink" title="9.你知道使用http协议通信的客户端和服务器之间是怎么建立连接的、报文是怎么发送的？"></a>9.你知道使用http协议通信的客户端和服务器之间是怎么建立连接的、报文是怎么发送的？</h3><p>  http是基于TCP协议进行连接，消息传输的……三次握手四次挥手</p>
<p>  (❌,偏题了啊。。。)……三次握手很熟练，but四次挥手没看，一下就露出了马脚，被追着问四次挥手</p>
<p><strong>追问：</strong>三次挥手不行吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">原问题的回答：</span><br><span class="line">当客户端与服务器之间使用HTTP协议进行通信时，建立连接和报文的发送可以分为以下步骤：</span><br><span class="line"></span><br><span class="line">1. 建立连接：</span><br><span class="line">   - 客户端发送一个连接请求给服务器，这通常是通过向服务器的IP地址和端口发送连接请求的方式实现的。</span><br><span class="line">   - 服务器接收到这个连接请求后，会进行一系列的握手过程来建立连接。这个过程通常是使用TCP协议来完成的。</span><br><span class="line">   - 一旦握手成功，客户端和服务器之间就建立了一个持久的连接，可以进行通信。</span><br><span class="line"></span><br><span class="line">2. 报文的发送：</span><br><span class="line">   - 客户端构建HTTP请求报文，包括请求行、请求头和请求体。</span><br><span class="line">   - 客户端将构建好的请求报文通过已建立的连接发送给服务器。</span><br><span class="line">   - 服务器接收到请求报文后，会解析其中的内容，包括请求方法、URL、请求头和请求体等。</span><br><span class="line">   - 服务器根据请求的内容进行相应的处理，可能是读取数据库、执行业务逻辑等。</span><br><span class="line">   - 服务器构建HTTP响应报文，包括响应行、响应头和响应体。</span><br><span class="line">   - 服务器将构建好的响应报文通过已建立的连接发送给客户端。</span><br><span class="line">   - 客户端接收到响应报文后，会解析其中的内容，包括响应状态码、响应头和响应体等。</span><br><span class="line">   - 客户端根据响应的内容进行相应的处理，可能是展示页面、执行下一步操作等。</span><br><span class="line"></span><br><span class="line">需要注意的是，HTTP是无状态的协议，每个请求和响应都是独立的，服务器不会记住之前的请求，因此需要使用一些机制（如Cookie、Session等）来维护状态信息。</span><br><span class="line"></span><br><span class="line">以上就是使用HTTP协议通信时客户端和服务器之间建立连接和报文的发送过程。具体的实现和细节可能会有所不同，但总体流程相似。</span><br><span class="line"></span><br><span class="line">追问的回答：</span><br><span class="line">四次挥手把同意对方请求跟自身请求分离开。是因为在客户端请求断开时（客户端发送端-&gt;服务器接收端），服务器可能还有数据未发完，所以需要分开操作：</span><br><span class="line">   ✦先同意对方关闭连接，对方无法传输数据；（第二次挥手）</span><br><span class="line">   ✦自己若还有数据未发送完，接着发送直至全部发送完毕；</span><br><span class="line">   ✦请求自身关闭连接；（第三次挥手）</span><br><span class="line">也就是说，三次握手、四次挥手差别就在第二次，有没有把同意对方请求跟自身请求拆分开。</span><br></pre></td></tr></table></figure>



<h3 id="10-为什么客户端要等2个时长后关闭呢？就是2ML问题？"><a href="#10-为什么客户端要等2个时长后关闭呢？就是2ML问题？" class="headerlink" title="10.为什么客户端要等2个时长后关闭呢？就是2ML问题？"></a>10.为什么客户端要等2个时长后关闭呢？就是2ML问题？</h3><p>  不清楚(❌)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">避免网络不稳定带来的问题, 假如在最后发送ACK请求后直接关闭, 此时由于网络原因Server端没收到, Server就会重试FIN请求 但是此时连接已经关闭了,Server端将无法正常发送报文 或者 发送到错误的地方;</span><br></pre></td></tr></table></figure>



<h3 id="11-了解http的滑动窗口是什么吗？"><a href="#11-了解http的滑动窗口是什么吗？" class="headerlink" title="11.了解http的滑动窗口是什么吗？"></a>11.了解http的滑动窗口是什么吗？</h3><p>  (❌很模糊，答了个大意—一次传输多个数据块—记错了)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">滑动窗口本质上是描述接受方的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据。如果发送方收到接受方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接受方发送窗口大小不为0的数据报的到来。</span><br></pre></td></tr></table></figure>



<h3 id="12-TCP里面有个粘包拆包，你了解过吗？"><a href="#12-TCP里面有个粘包拆包，你了解过吗？" class="headerlink" title="12.TCP里面有个粘包拆包，你了解过吗？"></a>12.TCP里面有个粘包拆包，你了解过吗？</h3><p>TCP面向流，没有边界，而操作系统在发送TCP数据时，会通过缓冲区来进行优化，例如缓冲区为1024个字节大小。</p>
<ul>
<li><p>如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题。</p>
</li>
<li><p>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包。</p>
</li>
</ul>
<h4 id="常见解决方案："><a href="#常见解决方案：" class="headerlink" title="常见解决方案："></a>常见解决方案：</h4><ul>
<li>发送端将每个包都封装成固定的长度，比如100字节大小。如果不足100字节可通过补0或空等进行填充到指定长度；</li>
<li>发送端在每个包的末尾使用固定的分隔符，例如\r\n。如果发生拆包需等待多个包发送过来之后再找到其中的\r\n进行合并；例如，FTP协议；</li>
<li>将消息分为头部和消息体，头部中保存整个消息的长度，只有读取到足够长度的消息之后才算是读到了一个完整的消息；</li>
<li>通过自定义协议进行粘包和拆包的处理。</li>
</ul>
<h2 id="Java基础："><a href="#Java基础：" class="headerlink" title="Java基础："></a>Java基础：</h2><h3 id="1-java中有几个基本的数据类型？"><a href="#1-java中有几个基本的数据类型？" class="headerlink" title="1.java中有几个基本的数据类型？"></a>1.java中有几个基本的数据类型？</h3><p>byte、short、int、long、float、double、char、boolean(⚠️)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一次没答出来boolean，忘记了，反思一下</span><br></pre></td></tr></table></figure>



<h3 id="2-一个byte是几个字节？"><a href="#2-一个byte是几个字节？" class="headerlink" title="2.一个byte是几个字节？"></a>2.一个byte是几个字节？</h3><p>1字节，8bit</p>
<h3 id="3-一个char类型数据可以转成什么类型？"><a href="#3-一个char类型数据可以转成什么类型？" class="headerlink" title="3.一个char类型数据可以转成什么类型？"></a>3.一个char类型数据可以转成什么类型？</h3><p>int</p>
<p><strong>追问</strong>：可以转换成byte吗？</p>
<p>   不行(❌）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果字符的Unicode码值在0到127之间，可以将char类型强制转换为byte类型)</span><br></pre></td></tr></table></figure>



<h3 id="4-如何创建float类型的变量"><a href="#4-如何创建float类型的变量" class="headerlink" title="4.如何创建float类型的变量"></a>4.如何创建float类型的变量</h3><p>数字后面加f</p>
<h3 id="5-float与double类型进行混合运算结果会准确吗？"><a href="#5-float与double类型进行混合运算结果会准确吗？" class="headerlink" title="5.float与double类型进行混合运算结果会准确吗？"></a>5.float与double类型进行混合运算结果会准确吗？</h3><p>不会，混合运算时会将float转换为double后再进行运算，转换时会产生舍入误差，尤其是在运算小数部分时。</p>
<h3 id="6-java中-double类型数据的组织形式是怎么样的？"><a href="#6-java中-double类型数据的组织形式是怎么样的？" class="headerlink" title="6.java中 double类型数据的组织形式是怎么样的？"></a>6.java中 double类型数据的组织形式是怎么样的？</h3><p>有几位是表示数值部分，有几位表示它是2的几次方</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过IEEE标准组织：具体来说：</span><br><span class="line">| 符号位（1 bit）| 指数位（11 bits）| 尾数位（52 bits）|</span><br></pre></td></tr></table></figure>



<h3 id="7-java中如何准确地表达数据的加减运算？"><a href="#7-java中如何准确地表达数据的加减运算？" class="headerlink" title="7.java中如何准确地表达数据的加减运算？"></a>7.java中如何准确地表达数据的加减运算？</h3><p>使用BigDecimal类</p>
<h3 id="8-你在你的项目中有用过这个数据类型吗？"><a href="#8-你在你的项目中有用过这个数据类型吗？" class="headerlink" title="8.你在你的项目中有用过这个数据类型吗？"></a>8.你在你的项目中有用过这个数据类型吗？</h3><p>没有用过(⚠️)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">随便举个例子不就行了。。。</span><br><span class="line">财务计算：BigDecimal可用于进行精确的货币计算，避免因浮点数运算引起的舍入误差。</span><br><span class="line">    例如，在购物网站中，计算订单总金额、折扣、税费等涉及货币计算的地方都可以使用BigDecimal来进行精确计算。</span><br></pre></td></tr></table></figure>



<h3 id="9-java中一般用什么数据类型来接收-定义在数据库中的主键"><a href="#9-java中一般用什么数据类型来接收-定义在数据库中的主键" class="headerlink" title="9.java中一般用什么数据类型来接收 定义在数据库中的主键"></a>9.java中一般用什么数据类型来接收 定义在数据库中的主键</h3><p>Integer(❌）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">踩大雷！！！！！！！！！！</span><br><span class="line"></span><br><span class="line">在Java中，一般使用long或者Long数据类型来接收和定义数据库中的主键。</span><br><span class="line"></span><br><span class="line">如果主键是自增长的整数类型，例如在MySQL中使用AUTO_INCREMENT属性，那么大部分情况下使用long类型是适合的。</span><br><span class="line"></span><br><span class="line">如果主键可能为空或者允许为空，那么可以使用Long类型。Long是long的包装类，可以接受null值，而long类型无法直接接受null。</span><br></pre></td></tr></table></figure>



<h3 id="10-刚才说到Integer是一种包装类型，如果我定义一个Integer-a-x3D-1；在定义-int-b-x3D-1；我进行if-a-x3D-x3D-b-判断条件会成立吗？"><a href="#10-刚才说到Integer是一种包装类型，如果我定义一个Integer-a-x3D-1；在定义-int-b-x3D-1；我进行if-a-x3D-x3D-b-判断条件会成立吗？" class="headerlink" title="10.刚才说到Integer是一种包装类型，如果我定义一个Integer a &#x3D; 1；在定义 int b &#x3D; 1；我进行if(a &#x3D;&#x3D; b)判断条件会成立吗？"></a>10.刚才说到Integer是一种包装类型，如果我定义一个Integer a &#x3D; 1；在定义 int b &#x3D; 1；我进行if(a &#x3D;&#x3D; b)判断条件会成立吗？</h3><p>   会成立，因为1是有缓存的(⚠️虽然实际原理和我想得不一样，但是说出这句话是对的，属于运气好)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">只要有一个是int，用==比较时就会自动拆箱，比较数值</span><br><span class="line">如果是[-128,127]的包装类，那么他们的对象地址相同，不在这个范围内，对象地址不同</span><br></pre></td></tr></table></figure>



<h3 id="11-加入-Integer-a-x3D-new-Integer-1-int-b-x3D-1-那么if-a-x3D-x3D-b-是否相等？"><a href="#11-加入-Integer-a-x3D-new-Integer-1-int-b-x3D-1-那么if-a-x3D-x3D-b-是否相等？" class="headerlink" title="11.加入 Integer a &#x3D; new Integer(1); int b &#x3D; 1; 那么if(a &#x3D;&#x3D; b)是否相等？"></a>11.加入 Integer a &#x3D; new Integer(1); int b &#x3D; 1; 那么if(a &#x3D;&#x3D; b)是否相等？</h3><p>   不会相等，因为a这边在堆中创建了一个新的对象(❌，会比较数值，只有&#x3D;&#x3D;两边都是Integer时，才会比较对象地址)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比较值，相等</span><br></pre></td></tr></table></figure>



<h3 id="12-刚才说的等号两边一边是Integer，一边是int，为什么能这样判断，你了解吗？"><a href="#12-刚才说的等号两边一边是Integer，一边是int，为什么能这样判断，你了解吗？" class="headerlink" title="12.刚才说的等号两边一边是Integer，一边是int，为什么能这样判断，你了解吗？"></a>12.刚才说的等号两边一边是Integer，一边是int，为什么能这样判断，你了解吗？</h3><p>   因为java有自动装箱、自动拆箱的功能，像刚才的情况会自动把Integer拆箱成int进行比较！</p>
<h3 id="13-java中-boolean类型可以转换成int类型吗？"><a href="#13-java中-boolean类型可以转换成int类型吗？" class="headerlink" title="13.java中 boolean类型可以转换成int类型吗？"></a>13.java中 boolean类型可以转换成int类型吗？</h3><p>   不行(❌)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">寄！刚知道！</span><br><span class="line">☄️当将 boolean 类型的值转换为 int 类型时，true 转换为 1，false 转换为 0。这是因为 boolean 类型只有两个可能的取值：true 和 false。</span><br><span class="line">boolean 类型转换为 int 类型是隐式的，可以直接赋值或使用条件运算符进行转换。在此过程中，Java会自动将其转换为对应的整数值。</span><br></pre></td></tr></table></figure>



<h3 id="14-java集合类中，线性方式存储的有哪些？"><a href="#14-java集合类中，线性方式存储的有哪些？" class="headerlink" title="14.java集合类中，线性方式存储的有哪些？"></a>14.java集合类中，线性方式存储的有哪些？</h3><p>   ArrayList、LinkedList (⚠️)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">还有</span><br><span class="line">Vector：Vector 是传统的动态数组，与 ArrayList 类似，但是被设计为线程安全的，它支持同步操作。</span><br><span class="line">Stack：Stack 是堆栈数据结构的 Java 实现，它基于动态数组。它使用后进先出 (LIFO) 的方式存储和访问元素。</span><br></pre></td></tr></table></figure>

<p><strong>追问</strong>：ArrayList、LinkedList底层的实现是什么？</p>
<p>   ArrayList底层是数组，LinkedList底层是链表</p>
<p><strong>追问</strong>：(ArrayList)数组的大小是怎么确定的呢？</p>
<p>   在构造函数中，如果没给值就按默认大小创建，如果给了并且合法就按提供的值来创建</p>
<p><strong>追问</strong>：假设ArrayList容量为5，add到第几个数据的时候扩容？</p>
<p>   满了就扩容(❌)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始容量为5的 ArrayList 可以容纳5个元素，它会一直使用这个固定的容量直到添加第6个元素。</span><br></pre></td></tr></table></figure>

<p><strong>追问</strong>：ArrayList、LinkedList的使用场景是什么？</p>
<p>   ArrayList频繁查询、LinkedList频繁增删</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果需要频繁机访问或在末尾进行添加/删除操作，可以使用 ArrayList(因为在末尾操作避免了数据的移动)；</span><br><span class="line">如果需要频繁在中间位置进行插入/删除操作或实现栈/队列相关功能，可以使用 LinkedList</span><br></pre></td></tr></table></figure>

<p><strong>追问</strong>：LinkedList底层如何删除一个数据？</p>
<p>就是链表的节点删除</p>
<h3 id="15-Map的实现类有哪些，介绍一下它们："><a href="#15-Map的实现类有哪些，介绍一下它们：" class="headerlink" title="15.Map的实现类有哪些，介绍一下它们："></a>15.Map的实现类有哪些，介绍一下它们：</h3><ul>
<li><p><strong>HashMap</strong>：HashMap是最常用的Map实现类之一。它基于哈希表实现，可以提供快速的插入、删除和查找操作。HashMap允许存储键值对，其中键是唯一的，值可以重复。它不保证元素的顺序，也不是线程安全的。</p>
</li>
<li><p><strong>TreeMap</strong>：TreeMap是基于红黑树实现的有序Map。它会根据键的自然顺序或者自定义比较器对键进行排序。TreeMap的插入、删除和查找操作的时间复杂度为O(logN)。由于它<u>对键进行排序</u>，因此遍历时会按照键的顺序输出。TreeMap不是线程安全的。</p>
</li>
<li><p><strong>LinkedHashMap</strong>：LinkedHashMap是HashMap的子类，它保持了插入顺序或者访问顺序（通过构造函数指定）。LinkedHashMap使用哈希表和双向链表实现，因此可以在常数时间内维护键的顺序。LinkedHashMap也不是线程安全的。</p>
</li>
<li><p><strong>ConcurrentHashMap</strong>：ConcurrentHashMap是线程安全的HashMap实现。它<strong>使用了分段锁</strong>，通过将整个Map分成多个段（Segment）来提高并发访问的性能。这样，在大多数情况下，不同的线程可以同时访问Map，从而提高性能。ConcurrentHashMap不保证元素的顺序。</p>
</li>
<li><p><strong>Hashtable</strong>：Hashtable是早期的哈希表实现，它是线程安全的。虽然Hashtable的使用已经不那么常见，但由于它是线程安全的，因此在多线程环境中仍然可以使用。(使用Synchronize来加锁实现线程安全，但是它锁住了整个表，会导致效率低下)</p>
</li>
</ul>
<h3 id="16-HashMap的应用场景是什么？"><a href="#16-HashMap的应用场景是什么？" class="headerlink" title="16.HashMap的应用场景是什么？"></a>16.HashMap的应用场景是什么？</h3><ul>
<li>HashMap是一种常用的Map实现类，适用于以下场景：<ol>
<li><strong>快速查找</strong>：由于HashMap基于哈希表实现，可以快速进行查找操作。如果需要根据键快速查找对应的值，HashMap是一个很好的选择。</li>
<li><strong>键值唯一</strong>：HashMap的键是唯一的，不允许重复。这对于需要存储唯一键值对的场景非常适用，例如存储用户ID和对应的用户信息。</li>
<li><strong>无需排序</strong>：HashMap不保证元素的顺序，插入和删除操作的顺序也不会影响其内部结构。如果不需要对键进行排序，只需要快速存储和查找键值对，那么HashMap是一个很好的选择。</li>
<li><strong>非线程安全环境</strong>：HashMap不是线程安全的，适用于在单线程环境下使用。如果需要在多线程环境中使用Map，可以考虑使用ConcurrentHashMap。</li>
</ol>
</li>
</ul>
<h3 id="17-HashMap的实现方式是什么样的？-2次"><a href="#17-HashMap的实现方式是什么样的？-2次" class="headerlink" title="17.HashMap的实现方式是什么样的？  (2次)"></a>17.HashMap的实现方式是什么样的？  (2次)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.首先，计算键的哈希值。哈希函数（Hash Function）负责将键转换成一个整数值，一般情况下会根据键的特征进行计算，目的是使哈希值尽可能均匀地分布在桶的范围内。</span><br><span class="line"></span><br><span class="line">2.根据哈希值计算出桶的索引位置。通常使用一个取模运算将哈希值映射到桶的范围内，得到桶的索引位置。</span><br><span class="line"></span><br><span class="line">3.在桶的索引位置上进行操作。如果桶为空，表示没有冲突，直接将键值对存储在该位置上；如果桶不为空，表示发生了冲突，可能有多个键值对哈希值映射到同一个桶上。</span><br></pre></td></tr></table></figure>





<h2 id="MySQL："><a href="#MySQL：" class="headerlink" title="MySQL："></a>MySQL：</h2><h3 id="1-数据库中的id用的什么数据类型？"><a href="#1-数据库中的id用的什么数据类型？" class="headerlink" title="1.数据库中的id用的什么数据类型？"></a>1.数据库中的id用的什么数据类型？</h3><p>   int(⚠️)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">⚠️一般常见的id数据类型选择：</span><br><span class="line"></span><br><span class="line">整数类型（Integer Types）：在大多数情况下，整数类型是用来存储主键 id 的常见选择。例如，在MySQL中可以使用 INT、BIGINT、SERIAL 等数据类型来存储主键。在Oracle数据库中，可以使用 NUMBER 数据类型。</span><br><span class="line"></span><br><span class="line">字符串类型（String Types）：有时候也会使用字符串类型来存储主键 id。例如，使用 VARCHAR 或 CHAR 数据类型。这种情况下，一般是由于主键的值并不是自增长的整数，而是具有特定的格式或需要满足一定的业务需求。</span><br><span class="line"></span><br><span class="line">全局唯一标识符（GUID）或通用唯一标识符（UUID）：在某些情况下，可以使用全局唯一标识符或通用唯一标识符来作为主键 id。这些标识符是全局唯一的，并且可在不同系统之间保持唯一性。在数据库中可以使用 UNIQUEIDENTIFIER 类型来存储这样的主键。</span><br></pre></td></tr></table></figure>



<h3 id="2-mysql索引是什么结构？"><a href="#2-mysql索引是什么结构？" class="headerlink" title="2.mysql索引是什么结构？"></a>2.mysql索引是什么结构？</h3><p>   B+树</p>
<p><strong>追问</strong>：描述一下B+树</p>
<p>   叶子节点存放数据，非叶子节点存放引用，底层叶子结点间用双向链表连接……</p>
<p><strong>追问</strong>：底层双向链表的作用是什么？</p>
<p>   方便顺序访问，查询一片区域是效率比较高，减少了随机I&#x2F;O(⚠️感觉说得不是很好，看看下面的补充吧)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">✦顺序访问：双向链表使得数据页可以按照索引顺序进行顺序访问。这对于一些范围查询或者顺序扫描操作很重要，因为它可以减少磁盘 I/O 的次数，提高查询性能。</span><br><span class="line">✦快速查找：在双向链表中，每个数据页都有指向前一个和后一个数据页的指针。这样可以通过两个方向进行查询，即根据索引的顺序可以迅速找到下一个数据页或者前一个数据页。这对于快速定位到指定数据页并获取相应的数据非常重要，减少了查询的时间复杂度。</span><br><span class="line">✦索引维护：当进行数据插入或删除操作时，双向链表可以快速定位到叶子节点，并调整链表指针来保持索引的有序性。例如，插入操作会将新的数据插入到正确的位置，并更新相邻叶子节点的链表指针。这样可以保持索引的有效性，并减少维护索引的开销。</span><br></pre></td></tr></table></figure>



<h3 id="3-讲一下聚簇索引"><a href="#3-讲一下聚簇索引" class="headerlink" title="3.讲一下聚簇索引"></a>3.讲一下聚簇索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在聚簇索引中，数据行按照索引的顺序存储在磁盘上。</span><br><span class="line">以下是关于聚簇索引的一些重要特点和优势：</span><br><span class="line">    ✦数据和索引的结合：聚簇索引将索引行和实际数据行映射到同一块存储空间上。这样，在查询时可以通过索引快速定位到符合条件的数据行，减少了磁盘 I/O 操作的次数，提高了查询的效率。</span><br><span class="line">    ✦数据的物理有序性：由于聚簇索引定义了物理数据存储的顺序，因此相邻的数据行通常在磁盘上也是相邻存储的。这种有序性可以提高查询范围和顺序访问的性能，因为可以减少磁盘 I/O 操作和随机访问的次数。</span><br><span class="line">    ✦压缩优势：聚簇索引可以获得更好的数据压缩效果。由于相邻的数据行通常具有相似的值，所以利用聚簇索引可以实现更高的数据压缩率。这对于占用大量存储空间的大表尤为重要，可以减少存储和 I/O 开销，并提高整体数据库性能。</span><br></pre></td></tr></table></figure>

<h3 id="4-表里有主键id列，name列，我建立-id-name-的联合索引会起作用吗？有必要吗？"><a href="#4-表里有主键id列，name列，我建立-id-name-的联合索引会起作用吗？有必要吗？" class="headerlink" title="4. 表里有主键id列，name列，我建立(id, name)的联合索引会起作用吗？有必要吗？"></a>4. 表里有主键id列，name列，我建立(id, name)的联合索引会起作用吗？有必要吗？</h3><h3 id="5-mysql事务有几种隔离级别，你了解过吗？-2次"><a href="#5-mysql事务有几种隔离级别，你了解过吗？-2次" class="headerlink" title="5.mysql事务有几种隔离级别，你了解过吗？(2次)"></a>5.mysql事务有几种隔离级别，你了解过吗？(2次)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.读未提交（Read Uncommitted）：最低的隔离级别，它允许一个事务读取另一个事务未提交的数据。这种隔离级别可能会导致脏读（Dirty Read），即读取到未提交的数据。</span><br><span class="line">2.读已提交（Read Committed）：在该隔离级别下，一个事务只能读取到已经提交的数据。这可以避免脏读情况的发生，但可能会导致不可重复读（Non-repeatable Read），即在同一个事务内两次读取同一个数据得到不同的结果。</span><br><span class="line">3.可重复读（Repeatable Read）：在该隔离级别下，保证了同一个事务内多次读取同一数据的结果是一致的。其他事务对该数据的修改只能在当前事务提交后才能看到。这可以避免脏读和不可重复读，但可能会导致幻读（Phantom Read），即在同一个事务内两次查询得到不同的结果。</span><br><span class="line">4.串型化（Serializable）：最高的隔离级别，它通过强制事务串行执行来避免脏读、不可重复读和幻读的情况。在此隔离级别下，事务之间的并发性大大降低，可能会对系统的性能产生较大的影响。</span><br></pre></td></tr></table></figure>



<h3 id="6-innodb怎么实现可重复读？-3次"><a href="#6-innodb怎么实现可重复读？-3次" class="headerlink" title="6.innodb怎么实现可重复读？(3次)"></a>6.innodb怎么实现可重复读？(3次)</h3><p>MVCC(多版本并发控制协议)。。(最小事务id、当前事务id、当前活跃事务列表、下一个要创建的事务id，理清逻辑还是蛮简单的)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以下是 InnoDB 实现可重复读的主要步骤：</span><br><span class="line">版本号(事务id)（Transaction ID）：每个数据行都有一个版本号，用于标识该数据行的最新版本。当一个事务开始时，它会被赋予一个唯一的事务 ID，称为版本号。</span><br><span class="line">快照读取：当一个事务开始时，InnoDB 会为该事务创建一个一致性视图，也称为快照。这个快照能够确保事务读取的所有数据都是在事务开始时可见的状态。</span><br><span class="line">读取并发控制：在可重复读级别下，InnoDB 使用多版本并发控制（MVCC）来控制读取操作的并发访问。当一个事务进行读取操作时，它只能看到比它开始前已提交的事务所做出的修改。</span><br><span class="line">间隙锁（Gap Locks）：为了保证一致性读取，InnoDB 还使用了间隙锁。间隙锁用于锁定一个范围内的数据行，以防止其他事务在该范围内插入新的行。</span><br></pre></td></tr></table></figure>

<p><strong>mvcc 的原理是什么？</strong>—相似的问题</p>
<p>  mvcc其实是可重复读的实现方式，它是对数据库进行快照的一个操作。具体的实现方式为……(就那四个字段，然后说清楚逻辑即可，详细请看<a href="https://tangjiayang.github.io/2023/07/27/MySQL%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/">mysql原理学习</a></p>
<h3 id="7-🌟加入给你一个sql语句，你会从哪几个方面考虑优化呢？-3次"><a href="#7-🌟加入给你一个sql语句，你会从哪几个方面考虑优化呢？-3次" class="headerlink" title="7.🌟加入给你一个sql语句，你会从哪几个方面考虑优化呢？(3次)"></a>7.🌟加入给你一个sql语句，你会从哪几个方面考虑优化呢？(3次)</h3><p>   (❌)我直接说用explain查看索引使用情况，，，然后explain里的参数还不熟悉，，，挺打脸的，抓紧背！ </p>
<p>（❌）这个不会，答得不好，就说了优化索引、select的 * 变为具体的每个列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">✧查看索引是否合理：考虑查询语句中使用的字段是否都有合适的索引。缺乏索引或者索引不合理可能导致全表扫描或者临时表的创建，从而导致性能下降。</span><br><span class="line"></span><br><span class="line">✧优化查询条件：检查查询语句中的 WHERE 条件是否能够有效地过滤掉不符合条件的数据，从而减少扫描的数据量。可以考虑对查询条件进行索引覆盖，使用合适的索引来加快查询。</span><br><span class="line"></span><br><span class="line">✧避免使用通配符：%和_ 通配符会导致索引的失效，可以考虑使用前缀索引或者全文索引来代替。</span><br><span class="line"></span><br><span class="line">✧优化 JOIN 操作：如果查询语句中包含 JOIN 操作，需要确保关联的字段上都有索引，并且 JOIN 条件尽可能简单。可以考虑使用合适的 JOIN 类型，例如 INNER JOIN、LEFT JOIN 或者使用 EXISTS 子查询来优化。</span><br><span class="line"></span><br><span class="line">✧避免使用子查询：子查询可能会导致性能问题，可以考虑使用 JOIN 或者其他方式来重写查询语句，减少子查询的使用。</span><br><span class="line"></span><br><span class="line">✧减少数据传输量：只选择所需的字段，避免返回不必要的数据。可以使用 SELECT 子句的列名列表，而不是使用通配符。</span><br><span class="line"></span><br><span class="line">✧分页查询优化：对于分页查询，可以使用 LIMIT 和 OFFSET 进行控制。对于大数据量的分页查询，可以考虑使用游标（cursor）方式，避免一次性加载所有数据。</span><br><span class="line"></span><br><span class="line">✧配置合理的缓存和缓冲区：根据具体情况，调整 MySQL 的缓存大小和缓冲区的配置，以提升查询性能。</span><br><span class="line"></span><br><span class="line">✧定期进行表的统计和优化：使用 ANALYZE TABLE 或者 OPTIMIZE TABLE 命令，以及常规的表维护工作，保持表的性能。</span><br><span class="line"></span><br><span class="line">注意，具体的优化策略需要根据具体的情况来确定，可以通过查看执行计划、使用 Explain 命令、分析慢查询日志等手段来定位性能瓶颈，然后针对性地进行优化。</span><br><span class="line"></span><br><span class="line">查看执行计划 explain</span><br><span class="line">如果有告警信息，查看告警信息 show warnings;</span><br><span class="line">查看SQL涉及的表结构和索引信息</span><br><span class="line">根据执行计划，思考可能的优化点</span><br><span class="line">按照可能的优化点执行表结构变更、增加索引、SQL改写等操作</span><br><span class="line">查看优化后的执行时间和执行计划</span><br><span class="line">如果优化效果不明显，重复第四步操作</span><br></pre></td></tr></table></figure>



<h3 id="8-在explian报告中，有哪些常见的索引使用方式？举几个例子"><a href="#8-在explian报告中，有哪些常见的索引使用方式？举几个例子" class="headerlink" title="8.在explian报告中，有哪些常见的索引使用方式？举几个例子"></a>8.在explian报告中，有哪些常见的索引使用方式？举几个例子</h3><p>   (❌)没背，说的中文，巨尬</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type 列：表示查询访问方法，常见的类型有 const、eq_ref、ref、range、index、all 等。其中，const 表示常量查询，eq_ref 表示使用唯一索引查询，ref 表示非唯一索引查询，range 表示范围查询，index 表示索引覆盖查询，all 表示全表扫描。</span><br></pre></td></tr></table></figure>



<h3 id="9-索引覆盖是什么？-2次"><a href="#9-索引覆盖是什么？-2次" class="headerlink" title="9.索引覆盖是什么？(2次)"></a>9.索引覆盖是什么？(2次)</h3><p>   通过索引覆盖，查询可以在索引中直接定位到所需的数据，避免了额外的磁盘IO和内存操作，因此可以显著降低查询的消耗。</p>
<h3 id="10-什么叫回表？"><a href="#10-什么叫回表？" class="headerlink" title="10.什么叫回表？"></a>10.什么叫回表？</h3><p>  正常情况下(即根据普通索引进行查询时，先查询该记录对应的主键值，再去主键所在的B+树中寻找其数据信息)</p>
<h3 id="🌟11-where条件是如何过滤掉数据的？在哪一层？"><a href="#🌟11-where条件是如何过滤掉数据的？在哪一层？" class="headerlink" title="🌟11.where条件是如何过滤掉数据的？在哪一层？"></a>🌟11.where条件是如何过滤掉数据的？在哪一层？</h3><p>(❌)这个真不太懂，需要事后了解一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">分情况看：</span><br><span class="line">如果 where 条件的记录在二级索引(普通索引)上，这时候过滤，就索引下推到 inndob 引擎过滤。</span><br><span class="line">如果where 条件是非索引字段，就在 server 层过滤。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">where条件中索引失效---&gt;innodb中进行全表扫描，返回数据后，会在server层进行过滤</span><br><span class="line">where条件中索引未失效-&gt;innodb层就会根据索引进行过滤(普通索引还可以是索引下推，根据可用的索引过滤一部分)</span><br></pre></td></tr></table></figure>



<h3 id="12-A列-建有索引-B列没有-查询where-A-x3D-1-and-B-x3D-1时底层发生了什么？"><a href="#12-A列-建有索引-B列没有-查询where-A-x3D-1-and-B-x3D-1时底层发生了什么？" class="headerlink" title="12.A列 建有索引 B列没有 查询where A &#x3D; 1 and B &#x3D; 1时底层发生了什么？"></a>12.A列 建有索引 B列没有 查询where A &#x3D; 1 and B &#x3D; 1时底层发生了什么？</h3><ol>
<li><p>MySQL 会首先检查 A 列的索引，通过索引的 B+树结构迅速定位到满足条件 A &#x3D; 1 的数据行。 </p>
</li>
<li><p>对于满足条件 A &#x3D; 1 的数据行，MySQL 将进一步检查每一行的 B 列的值是否等于 1。由于 B 列没有索引，MySQL 需要对A&#x3D;1的数据进行全表扫描来验证 B 列的值是否满足条件 B &#x3D; 1。</p>
</li>
</ol>
<h3 id="13-一条SQL的执行过程是什么？"><a href="#13-一条SQL的执行过程是什么？" class="headerlink" title="13.一条SQL的执行过程是什么？"></a>13.一条SQL的执行过程是什么？</h3><p>​	    MySQL5.8(❌，woc说错了！！寄！！！)之前有缓冲区，缓冲区会根据sql语句进行缓存、5.8之后移除了；之后会到解析器中进行词法、语法分析，这一阶段还会把 * 换成表中对应实际的列；之后会进入优化器，这里会产生sql语句的执行方案，最后进入存储引擎进行查询。(⚠️补一下，见<a href="https://tangjiayang.github.io/2023/07/27/MySQL%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/">mysql原理学习</a>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">连接器：建立连接，管理连接、校验用户身份；</span><br><span class="line">查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</span><br><span class="line">解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</span><br><span class="line">执行 SQL：执行 SQL 共有三个阶段：</span><br><span class="line">	预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。</span><br><span class="line">	优化阶段：基于查询成本的考虑，选择查询成本最小的执行计划；</span><br><span class="line">	执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</span><br></pre></td></tr></table></figure>



<h3 id="14-mysql中主键、唯一索引、联合索引它们的区别是什么？"><a href="#14-mysql中主键、唯一索引、联合索引它们的区别是什么？" class="headerlink" title="14.mysql中主键、唯一索引、联合索引它们的区别是什么？"></a>14.mysql中主键、唯一索引、联合索引它们的区别是什么？</h3><ol>
<li>主键（Primary Key）：主键是一列或一组列，用于唯一标识表中的每一行数据。主键的值必须是唯一且非空的。每个表只能有一个主键，如果没有显式定义主键，则系统会自动创建一个主键。主键通常用于快速查找和引用表中的特定行。</li>
<li>唯一索引（Unique Index）：唯一索引也用于确保索引的列或列组的值是唯一的。与主键不同的是，一个表可以有多个唯一索引。唯一索引可以用于快速查找和确保数据完整性，但在引用外键时不会自动创建关联关系。</li>
<li>联合索引（Composite Index）：联合索引是一个包含多个列的索引。它可以加速多个列的组合查询，也可以用于确保索引列组合的唯一性。联合索引的顺序很重要，它对查询的效率有影响。在联合索引中，左边的列具有更高的优先级。</li>
</ol>
<h3 id="15-数据库分库分表你了解吗？"><a href="#15-数据库分库分表你了解吗？" class="headerlink" title="15.数据库分库分表你了解吗？"></a>15.数据库分库分表你了解吗？</h3><p>⚠️面试的时候答得不好。</p>
<p>数据库分库分表是一种数据库水平扩展（Horizontal Scaling）的策略，用于解决大规模数据存储和高并发访问的问题。它将一个大型数据库拆分为多个小型数据库，每个数据库称为一个分片（Shard），并且可以进一步将每个分片拆分为多个表。每个分片和表可以独立地存储和处理数据，从而提高了数据库的性能和扩展性。</p>
<p>数据库分库分表的主要优势包括：</p>
<ol>
<li>高并发处理能力：通过拆分数据库，可以将数据分散到多个数据库服务器上，从而提高并发处理能力。</li>
<li>存储容量的扩展：随着数据量的增长，通过分片可以将数据分布到多个数据库中，从而扩展存储容量。</li>
<li>降低单个数据库的负载：通过分片将数据分散到多个数据库中，可以减轻单个数据库的负载，提高数据库的响应速度。</li>
</ol>
<p>然而，数据库分库分表也带来了一些挑战：</p>
<ol>
<li>数据一致性：拆分数据库后，跨分片的事务管理和数据一致性变得复杂。</li>
<li>跨分片查询：跨分片查询会增加查询的复杂性和开销。</li>
<li>数据迁移和重平衡：当需要增加或减少分片时，需要进行数据迁移和重新平衡的操作，可能会导致系统停机或性能下降。</li>
</ol>
<p><strong>追问：分表情况下，你是怎么查询的？</strong></p>
<p>跨表查询：如果查询的条件涉及到多个表，或者涉及到的表分布在不同的分片上，你需要进行跨表查询。这可以通过以下几种方式来实现：</p>
<ul>
<li>手动跨分片查询：在应用层面，你可以指定需要查询的目标表或分片，并将查询合并或拆分为多个单表查询，最后在应用层面进行结果的合并。</li>
<li>分片路由查询：你可以自定义分片路由策略，在查询时确定目标分片，然后只在目标分片上执行查询操作，然后将结果返回给应用层进行合并。</li>
<li>使用分布式查询引擎：如Apache Hadoop，有些分布式数据库或工具提供了查询分布的能力，可以将查询分发到不同的分片上并将结果合并返回。</li>
</ul>
<h3 id="🌟16-mysql中，innodb做数据存储的时候为什么用了B-树，而不是B树或者跳表？"><a href="#🌟16-mysql中，innodb做数据存储的时候为什么用了B-树，而不是B树或者跳表？" class="headerlink" title="🌟16.mysql中，innodb做数据存储的时候为什么用了B+树，而不是B树或者跳表？"></a>🌟16.mysql中，innodb做数据存储的时候为什么用了B+树，而不是B树或者跳表？</h3><h4 id="1-为什么用B-树而不用B树："><a href="#1-为什么用B-树而不用B树：" class="headerlink" title="1.为什么用B+树而不用B树："></a>1.为什么用B+树而不用B树：</h4><ul>
<li>B+树中每个非叶节点没有指向某个关键字具体信息的指针，所以每一个节点可以存放更多的关键字数量，即一性读入内存所需要查找的关键字也就越多，减少了I&#x2F;O操作。</li>
<li>B+树的叶子节点之间建立了双向链表，可以很好<strong>提高增删效率</strong>，<strong>基于范围查询、顺序遍历效率高</strong>。</li>
<li>B+树，查询效率更加稳定(体现在，单次查询只需找到叶子结点、范围查询也是找到叶子结点后根据链表顺序查找即可)</li>
</ul>
<h4 id="2-为什么用B-树而不用跳表："><a href="#2-为什么用B-树而不用跳表：" class="headerlink" title="2.为什么用B+树而不用跳表："></a>2.为什么用B+树而不用跳表：</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Edwin_Hu/article/details/125074736">参考文章</a></p>
<ul>
<li>写入的效率：</li>
</ul>
<p>总结一下跳表写入与B+Tree写入，其实方式上有点类似</p>
<p>都是最底层存放数据，上层存索引。</p>
<p>写入数据时，都有可能会更新索引层，甚至增大层高。</p>
<p>在写入时，由于B+Tree需要分裂合并索引数据页，以及调整二叉树，维持平衡；</p>
<p>跳表却是独立插入，且根据随机函数确定层数，没有旋转和维持平衡的开销，因此跳表的写入性能会比B+树要好。</p>
<ul>
<li>查询的效率：</li>
</ul>
<p>在之前的《单表最大2000W行数据》文中解释了三层的B+Tree就可以存储2000W的数据，查找数据最多只需要三次磁盘IO即可。</p>
<p>跳表是链表结构，并且通过二分查找的方式去查找数据，当存储2000W数据并且满足二分查找时，需要24层索引，24层索引分散在不同的数据页中，查找数据最多会有24次磁盘IO。</p>
<ul>
<li>结论：</li>
</ul>
<p>磁盘IO是非常慢的，3次IO的效率远远高于24次，<u>也就是说B+Tree的查找效率远远高于跳表，虽然跳表写入的效率比B+Tree高，但是根据【二八原则】，系统写入的频率远低于读取，因此InnoDB最终选择使用B+树而不是跳表。</u></p>
<p>上面的【二八原则】可能不一定准确，但是当我们真的有系统的写频率超过读的频率的时候，也可以不用InnoDB引擎，使用其他的存储引擎也是一样的，具体还是要看应用场景。<br>跳表写入效率比B+Tree高。而读取效率主要受限于磁盘IO的效率，因此Redis的有序集合Zset就是基于链表实现的，因为Redis 是纯内存数据库,压根就不需要操作磁盘，B+Tree的低层级、仅3次IO的优势就体现不出来了。</p>
<h2 id="Java并发编程："><a href="#Java并发编程：" class="headerlink" title="Java并发编程："></a>Java并发编程：</h2><h3 id="1-为什么要用线程池？"><a href="#1-为什么要用线程池？" class="headerlink" title="1.为什么要用线程池？"></a>1.为什么要用线程池？</h3><p>   - <strong>降低线程创建和销毁的开销</strong>：线程的创建和销毁是相对昂贵的操作，涉及到分配内存、初始化上下文等耗时操作。如果每次需要执行任务时都创建一个新的线程，会造成大量的系统资源消耗和额外的开销。线程池通过预先创建一组可复用的线程，避免了频繁的线程创建和销毁操作，降低了系统的开销。</p>
<p>   - <strong>控制并发度和资源消耗，避免系统崩溃</strong>：线程池可以控制并发执行的任务数量，通过限制线程池的大小和配置线程的数量，可以合理地控制并发度，避免过多的任务同时执行导致系统资源耗尽，系统崩溃。同时，线程池可以对任务进行排队和调度，合理利用系统资源，避免资源的浪费。</p>
<p>   - <strong>提供线程管理和监控功能</strong>：线程池可以对线程进行统一的管理和调度，包括线程的创建、销毁、复用、暂停、恢复等操作。线程池还可以监控线程的状态、执行情况和资源使用情况等，提供了对线程池的可控和可视化管理。</p>
<h3 id="2-怎么创建线程池？"><a href="#2-怎么创建线程池？" class="headerlink" title="2.怎么创建线程池？"></a>2.怎么创建线程池？</h3><ul>
<li><p>创建一个ThreadPoolExecutor对象，可以使用ThreadPoolExecutor的构造方法或者Executors类提供的工厂方法来创建。</p>
<ul>
<li><p>具体：</p>
</li>
<li><p><strong>创建一个ThreadPoolExecutor对象</strong>，可以使用ThreadPoolExecutor的构造方法或者Executors类提供的工厂方法来创建。</p>
</li>
<li><p><strong>设置线程池的核心线程数（corePoolSize），最大线程数（maximumPoolSize），线程空闲回收时间（keepAliveTime）</strong>等参数。这些参数决定了线程池的大小和行为。</p>
</li>
<li><p>可选地<strong>设置任务队列</strong>，可以选择使用ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue等不同类型的队列，根据实际情况来选择最合适的。</p>
</li>
<li><p><strong>提交任务给线程池执行</strong>，可以使用execute()方法提交一个Runnable任务，或者使用submit()方法提交一个Callable任务，可以获取任务的执行结果。</p>
</li>
<li><p><strong>关闭线程池</strong>，当不再需要使用线程池时，应该调用线程池的shutdown()方法来关闭线程池。</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-线程池有什么运行机制，有什么参数？-3次"><a href="#3-线程池有什么运行机制，有什么参数？-3次" class="headerlink" title="3.线程池有什么运行机制，有什么参数？(3次)"></a>3.线程池有什么运行机制，有什么参数？(3次)</h3><ul>
<li>🌟**<u>线程池创建后就马上，启核心线程，不论有没有需求</u>**—&gt;入队列—&gt;启非核心线程—&gt;异常</li>
</ul>
<ol>
<li>corePoolSize（核心线程数）：核心线程数是线程池中最小的数量，无论线程是否空闲，它们始终保持存活。核心线程数通常用于处理任务的流入量，保证线程池能够及时处理任务。</li>
<li>maximumPoolSize（最大线程数）：最大线程数是线程池中允许拥有的最大线程数量。当任务的数量超过核心线程数时，线程池可以创建新的线程，直到达到最大线程数。当线程池中的线程数达到最大值时，新的任务将按照指定的拒绝策略进行处理。</li>
<li>keepAliveTime（线程空闲时间）：当线程池中的线程数量超过核心线程数，并且空闲时间达到了keepAliveTime时，多余的线程将会被终止并从线程池中移除。这个参数配合下一个参数使用。</li>
<li>workQueue（阻塞队列）：用于存储待执行的任务的阻塞队列。线程池中的线程从队列中取任务来执行。不同的阻塞队列实现方式对应不同的选择策略，例如有界队列、无界队列、优先级队列等。</li>
<li>handler（拒绝策略）：当线程池中的线程已经达到最大值，并且队列已满时，新的任务将按照指定的拒绝策略进行处理。常见的拒绝策略有丢弃任务、抛出异常、阻塞等待和调用者运行等。</li>
<li>threadFactory（线程工厂）：用于创建线程的工厂。线程池通过线程工厂创建新的线程对象。</li>
<li>unit（时间单位）：用于指定keepAliveTime的时间单位，可以是秒、毫秒、微秒等。</li>
</ol>
<h3 id="4-线程池常见的拒绝策略有哪些？-3次"><a href="#4-线程池常见的拒绝策略有哪些？-3次" class="headerlink" title="4.线程池常见的拒绝策略有哪些？(3次)"></a>4.线程池常见的拒绝策略有哪些？(3次)</h3><ul>
<li>第一种拒绝策略是 AbortPolicy，这种拒绝策略在拒绝任务时，会直接<u><strong>抛出一个类型为 RejectedExecutionException 的 RuntimeException，让你感知到任务被拒绝了，于是你便可以根据业务逻辑选择重试或者放弃提交等策略。</strong></u></li>
<li>第二种拒绝策略是 DiscardPolicy，这种拒绝策略正如它的名字所描述的一样，<u><strong>当新任务被提交后直接被丢弃掉，也不会给你任何的通知，相对而言存在一定的风险，因为我们提交的时候根本不知道这个任务会被丢弃，可能造成数据丢失</strong></u>。</li>
<li>第三种拒绝策略是 DiscardOldestPolicy，如果线程池没被关闭且没有能力执行，则会<u><strong>丢弃任务队列中的头结点，通常是存活时间最长的任务</strong></u>，这种策略与第二种不同之处在于它丢弃的不是最新提交的，而是队列中存活时间最长的，这样就可以腾出空间给新提交的任务，但同理它也存在一定的数据丢失风险。</li>
<li>第四种拒绝策略是 CallerRunsPolicy，调用者执行，相对而言它就比较完善了，当有新任务提交后，如果线程池没被关闭且没有能力执行，则<u><strong>把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务</strong></u>。这样做主要有两点好处。<ul>
<li>第一点新提交的任务不会被丢弃，这样也就不会造成业务损失。</li>
<li>第二点好处是，由于谁提交任务谁就要负责执行任务，这样提交任务的线程就得负责执行任务，而执行任务又是比较耗时的，在这段期间，提交任务的线程被占用，也就不会再提交新的任务，减缓了任务提交的速度，相当于是一个负反馈。在此期间，线程池中的线程也可以充分利用这段时间来执行掉一部分任务，腾出一定的空间，相当于是给了线程池一定的缓冲期。</li>
</ul>
</li>
</ul>
<h3 id="5-线程池中的阻塞队列怎么实现的？"><a href="#5-线程池中的阻塞队列怎么实现的？" class="headerlink" title="5.线程池中的阻塞队列怎么实现的？"></a>5.线程池中的阻塞队列怎么实现的？</h3><p>阻塞队列是一种特殊的队列，它在插入和移除元素时具有阻塞的特性，即当队列满时插入操作会被阻塞，当队列为空时移除操作会被阻塞。</p>
<p>阻塞队列的实现原理主要依赖于底层的同步器（如AQS）和线程的阻塞和唤醒机制。</p>
<ol>
<li>插入元素时：<ul>
<li>当队列未满时，线程可以直接插入元素，并更新队列的状态。</li>
<li>当队列已满时，插入操作会被阻塞，通过调用同步器的同步方法（如acquire()）将线程阻塞，并将其加入到阻塞队列中等待唤醒的状态。</li>
</ul>
</li>
<li>移除元素时：<ul>
<li>当队列非空时，线程可以直接移除元素，并更新队列的状态。</li>
<li>当队列为空时，移除操作会被阻塞，通过同步器的同步方法（如acquire()）将线程阻塞，并将其加入到阻塞队列中等待唤醒的状态。</li>
</ul>
</li>
<li>阻塞和唤醒机制：<ul>
<li>当队列中的某个条件满足时（如队列有空间、队列有元素），可以通过调用同步器的同步方法（如release()）来唤醒等待队列中的线程，使其从阻塞状态转为可运行状态。</li>
<li>唤醒机制可以通过notify()方法或者其他方式来实现，具体由阻塞队列的实现类决定。</li>
</ul>
</li>
</ol>
<p>通过上述机制，阻塞队列可以在多线程环境下安全地进行元素的插入和移除操作，并实现线程的阻塞和唤醒，从而保证队列的正确性和线程的协作。具体的实现原理和细节可能会因具体的阻塞队列实现类而有所差异。</p>
<h3 id="6-说一下volatile关键字的作用"><a href="#6-说一下volatile关键字的作用" class="headerlink" title="6.说一下volatile关键字的作用"></a>6.说一下volatile关键字的作用</h3><p>   只说了1、2(⚠️)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、可见性（Visibility）：在多线程环境下，对于被 volatile 关键字修饰的变量，当一个线程修改了该变量的值，其他线程能够立即看到这个变化。这是因为通过 volatile 关键字修饰的变量会直接在主内存中进行读取和写入，而不会使用线程的本地缓存。因此，volatile 变量可以保证线程之间的变量值一致性。</span><br><span class="line"></span><br><span class="line">2、禁止指令重排序（Prevent Instruction Reordering）：在编译器和处理器的优化过程中，会对指令进行重排序，以获得更好的性能。然而，在某些情况下，指令重排序可能会导致多线程程序的运行结果出现错误。通过将变量声明为 volatile，可以禁止编译器和处理器在对该变量操作的时候进行重排序，保证指令的顺序性。</span><br><span class="line"></span><br><span class="line">3、部分原子性（Partial Atomicity）：虽然 volatile 关键字不能保证所有操作的原子性，但是对于简单的读取和写入操作是原子的。也就是说，对于 volatile 变量的读取和写入，可以保证其操作具有原子性。但是对于复合操作，如 volatileCount++ 这样的自增操作，并不能保证原子性，需要额外的同步手段，如使用 synchronized 关键字或使用原子类来实现。</span><br></pre></td></tr></table></figure>



<h3 id="7-你对synchronize的理解是怎么样的呢？"><a href="#7-你对synchronize的理解是怎么样的呢？" class="headerlink" title="7.你对synchronize的理解是怎么样的呢？"></a>7.你对synchronize的理解是怎么样的呢？</h3><p>   可以给代码块或者方法上锁</p>
<p><strong>追问</strong>：可以对哪些结构加锁？</p>
<p>   方法和代码块</p>
<p><strong>追问</strong>：synchronize是怎么锁住一个对象的？</p>
<p>   通过获取对象的锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Java 中的对象锁是通过对象头中的一些字段来实现的。每个对象在内存中都有一个对象头，在 HotSpot 虚拟机中，对象头包含了两部分内容：Mark Word 和 Class Metadata Address。其中，Mark Word 中的一些位用于存储锁的相关信息。</span><br><span class="line">在 HotSpot 虚拟机中，对象锁有两种状态：无锁状态和重量级锁状态。</span><br><span class="line">对于无锁状态的对象，Mark Word 中的锁信息部分是空的，可以被任意线程访问，不存在互斥。</span><br><span class="line">当第一个线程访问一个无锁状态的对象时，它会尝试使用 CAS（Compare And Swap）操作来将对象的 Mark Word 修改为自己的线程 ID，同时将锁标志位设置为 1，表示获取锁成功。</span><br><span class="line">如果 CAS 操作失败，说明有其他线程已经获取了锁，此时当前线程会进入自旋（Spin）等待，不断尝试 CAS 操作获取锁，而不是让线程进入阻塞状态。</span><br><span class="line">当自旋次数达到一定阈值，或者其他线程释放了锁，当前线程成功获取到了锁，它将会将锁的标志位置为 0，表示无锁状态。</span><br><span class="line">当多个线程竞争同一个对象的锁时，如果尝试获取锁的线程较少，自旋等待的方式可以减少线程切换的开销，提高运行效率。但如果竞争线程较多，自旋等待会占用大量的 CPU 时间，造成资源浪费。</span><br><span class="line">当一个线程多次自旋仍然无法获取锁时，系统会自动升级为重量级锁，即使用悲观锁的方式进行实现。</span><br><span class="line">重量级锁是一种在内核层面实现的锁，在锁的竞争激烈时，没有获取到锁的线程会进入阻塞状态，让出 CPU 给其他线程使用。当锁释放时，被阻塞的线程会被唤醒，重新竞争锁。</span><br><span class="line">「总结来说，Java 中的对象锁是通过对象头中的字段来实现的，通过 CAS 操作和自旋等待实现轻量级锁，当竞争激烈时升级为重量级锁，通过阻塞线程实现同步。不同的锁状态带来的开销和性能表现也不同，需要根据具体的场景选择合适的锁机制。」</span><br></pre></td></tr></table></figure>



<h3 id="8-了解偏向锁吗？"><a href="#8-了解偏向锁吗？" class="headerlink" title="8.了解偏向锁吗？"></a>8.了解偏向锁吗？</h3><p>   不了解(❌，真看过，但真忘了)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">偏向锁（Biased Locking）是 Java 中锁优化的一种技术，旨在减少无竞争情况下的锁操作的开销。</span><br><span class="line">在没有线程竞争的情况下，偏向锁能够帮助提高程序的性能。</span><br><span class="line">    它的核心思想是：如果一个线程获得了对象的锁，并且在后续的执行过程中没有其他线程来竞争锁资源，那么该线程可以一直保持对该对象的偏向。</span><br><span class="line">    这样，下次该线程再次请求锁资源时，就不需要再进行同步操作，直接获取即可。这样就避免了无竞争情况下的不必要的锁操作，提升了程序的性能。</span><br><span class="line">    </span><br><span class="line">*偏向锁的实现机制是：</span><br><span class="line">    在对象头中的 Mark Word 中的某个标志位记录了线程 ID，表示当前对象的锁已经被偏向于该线程。当第一个线程访问一个对象时，它会尝试将对象头的 Mark Word 修改为自己的线程 ID，并将偏向锁标识位设置为 1，表示获取锁成功。</span><br><span class="line">如果 CAS 操作成功，那么该线程就获得了对象的偏向锁，并且进入偏向状态。之后，如果该线程再次请求锁资源，只需要检查一下 Mark Word 的线程 ID 是否与自己相同即可，非常高效。这个过程不需要释放锁资源。</span><br><span class="line">但如果有其他线程竞争同一个对象的锁，偏向锁就会失效。当出现竞争情况时，偏向锁会自动升级为轻量级锁或重量级锁，取决于竞争的情况。</span><br><span class="line">总结来说，偏向锁是一种针对无竞争情况下的锁优化技术，能够减少不必要的锁操作，提高程序的性能。它通过在对象头中记录线程 ID，避免了重复获取锁的同步操作。但在有竞争的情况下，偏向锁会自动失效，升级为其他类型的锁来保证线程安全。</span><br><span class="line">👍看完后就明白了，短期内绝对忘不了！</span><br></pre></td></tr></table></figure>



<h3 id="9-java你比较了解是吧，synchronize和ReentrantLock的有什么区别？-3次"><a href="#9-java你比较了解是吧，synchronize和ReentrantLock的有什么区别？-3次" class="headerlink" title="9.java你比较了解是吧，synchronize和ReentrantLock的有什么区别？(3次)"></a>9.java你比较了解是吧，synchronize和ReentrantLock的有什么区别？(3次)</h3><p>  synchronize用了对象的内部锁，作为对象信息头部中的一个字段，没加锁为空，加锁被设为线程id</p>
<p>  ReentrantLock维护了一个变量，加锁+1 ，解锁-1，为0说明没加锁。(⚠️)</p>
<p>⬆️而且有个队列(AQS队列)保存在等待的线程，根据公平、非公平，在一个线程释放锁后选出新的线程来占用</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_33836223/article/details/91647965?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169337903316800192255289%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=169337903316800192255289&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-91647965-null-null.142%5Ev93%5EchatsearchT3_2&utm_term=reetrantlock%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0&spm=1018.2226.3001.4187">这里讲得比较浅显易懂</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Synchronized 和 ReentrantLock 是 Java 中实现线程同步的两种机制，它们在底层实现上有以下区别：</span><br><span class="line"></span><br><span class="line">底层实现区别：</span><br><span class="line">Synchronized通过CAS方式修改对象头部信息中的Mark Word字段(改为调用者的线程id)来占用对象锁。(⚠️结合本文java并发编程部分第五点来看！)</span><br><span class="line">ReentrantLock底层是AQS队列+state(volatile修饰)</span><br><span class="line"></span><br><span class="line">特性区别：</span><br><span class="line">1. 可重入性（Reentrancy）：</span><br><span class="line">   - Synchronized 是 Java 内置的关键字，具有可重入性。这意味着如果一个线程已经获得了某个对象的锁，在释放锁之前，可以多次进入被锁保护的代码块。</span><br><span class="line">   - ReentrantLock 是 `Lock` 接口的实现类，也具有可重入性。要使用 ReentrantLock 的可重入特性，需要显式地调用 `lock()` 和 `unlock()` 方法。</span><br><span class="line"></span><br><span class="line">2. 获取锁的方式：</span><br><span class="line">   - Synchronized 是隐式锁，当线程进入同步代码块时，会自动获取锁，并在代码块结束后自动释放锁。无法手动控制锁的获取和释放。</span><br><span class="line">   - ReentrantLock 是显式锁，需要手动调用 `lock()` 方法来获取锁，在合适的地方调用 `unlock()` 方法来释放锁。</span><br><span class="line"></span><br><span class="line">3. 可中断性：</span><br><span class="line">   - Synchronized 在获取锁的过程中，如果线程被阻塞，无法被中断，只能等待获取锁的机会。</span><br><span class="line">   - ReentrantLock 提供了可中断的获取锁的方式。通过调用 `lockInterruptibly()` 方法，如果线程被阻塞，可以通过调用 `interrupt()` 方法中断线程。</span><br><span class="line"></span><br><span class="line">4. 公平性：</span><br><span class="line">   - Synchronized 是非公平锁，线程在竞争锁时，无法保证获取锁的顺序。</span><br><span class="line">   - ReentrantLock 默认是非公平锁，但可以通过构造函数参数设置为公平锁，在锁的竞争中，会按照请求锁的顺序分配锁。</span><br><span class="line"></span><br><span class="line">5. 性能：</span><br><span class="line">   - 在低级别的锁竞争情况下，Synchronized 的性能优于 ReentrantLock。这是因为 Synchronized 是 JVM 内置的锁机制，可以进行一些优化操作。</span><br><span class="line">   - 在高度竞争的情况下，ReentrantLock 的性能可能优于 Synchronized，因为 ReentrantLock 提供了更多的灵活性，例如可中断锁、非块结构的锁等。</span><br><span class="line"></span><br><span class="line">综上，Synchronized 和 ReentrantLock 在可重入性、获取锁方式、可中断性、公平性和性能等方面有所区别。在选择使用哪种机制时，需要根据具体的情况综合考虑。一般而言，对于简单的同步需求，使用 Synchronized 更为方便；而对于更复杂的同步需求，可以考虑使用 ReentrantLock 提供的额外功能。</span><br></pre></td></tr></table></figure>



<h3 id="10-ReentrantLock的底层实现和AQS有啥关系？"><a href="#10-ReentrantLock的底层实现和AQS有啥关系？" class="headerlink" title="10.ReentrantLock的底层实现和AQS有啥关系？"></a>10.ReentrantLock的底层实现和AQS有啥关系？</h3><p>  答了乐观锁，我的无知再次暴露无遗(❌，我不知道AQS是啥啊。。)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AQS（AbstractQueuedSynchronizer），抽象队列同步器</span><br><span class="line">核心思想：</span><br><span class="line">如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</span><br><span class="line"></span><br><span class="line">AQS队列：使用链表，每个节点自旋，不断轮询前驱的状态，若前驱释放则自己尝试去占用！</span><br></pre></td></tr></table></figure>

<p>🌟<strong>追问：AQS队列中为什么使用了双向队列？</strong></p>
<p>​	AQS使用单向队列也能实现任务队列，为什么还要使用到双向队列，通过head指针和tail指针就可以方便节点的移除和增加，但是在很多场合，对当前节点的操作，需要知道前一个节点的状态，为了节省访问上一个节点的时间复杂度，使用了双向队列，查询当前节点上一个节点的时间复杂度为O(1)。</p>
<h3 id="11-怎么解决线程安全问题，有哪些方案？"><a href="#11-怎么解决线程安全问题，有哪些方案？" class="headerlink" title="11.怎么解决线程安全问题，有哪些方案？"></a>11.怎么解决线程安全问题，有哪些方案？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.同步代码块和同步方法：使用synchronized关键字对关键代码块或方法进行同步，确保同一时间只有一个线程可以进入临界区进行操作。通过互斥锁的方式来保证线程安全。</span><br><span class="line"></span><br><span class="line">2.使用锁机制：使用Java提供的Lock接口及其实现类（如ReentrantLock），它提供了更灵活的锁操作，可以手动控制锁的获取和释放，并支持更细粒度的锁定。</span><br><span class="line"></span><br><span class="line">3.使用原子类：Java提供了一些原子类（如AtomicInteger、AtomicLong等），它们提供了以原子方式执行常见的操作，避免竞态条件。</span><br><span class="line"></span><br><span class="line">4.使用并发容器：Java提供了一些线程安全的容器类，如ConcurrentHashMap、CopyOnWriteArrayList等，它们在内部实现上采用了一些策略来确保线程安全。</span><br><span class="line"></span><br><span class="line">5.使用ThreadLocal：ThreadLocal是一个线程本地变量，每个线程都有自己的 ThreadLocal 实例，对其进行读写操作不会影响其他线程。它可以用来解决线程间数据隔离的问题。</span><br><span class="line"></span><br><span class="line">6.使用并发工具类：Java提供了一些高级的并发工具类，如CountDownLatch、Semaphore、CyclicBarrier等，它们能够方便地实现线程间的协作和同步，从而避免竞态条件。</span><br><span class="line"></span><br><span class="line">7.避免共享状态：尽量避免多个线程共享可变的状态，通过将状态封装在单个线程中或使用不可变对象来避免线程安全问题。</span><br><span class="line"></span><br><span class="line">8.使用线程安全的第三方库：如果使用第三方库，可以选择那些经过良好测试并被证明是线程安全的库，以减少线程安全问题的风险。</span><br></pre></td></tr></table></figure>



<h2 id="JVM："><a href="#JVM：" class="headerlink" title="JVM："></a>JVM：</h2><h3 id="1-java常见垃圾回收算法"><a href="#1-java常见垃圾回收算法" class="headerlink" title="1.java常见垃圾回收算法"></a>1.java常见垃圾回收算法</h3><ul>
<li><strong>标记-清除算法（Mark-and-Sweep）</strong>：这是最基本的垃圾回收算法。它的过程分为两个阶段：标记阶段和清除阶段。首先从根节点开始，标记所有能够被访问到的对象，然后清除未标记的对象。标记-清除算法存在碎片问题，即内存空间会变得不连续，影响后续对象的分配。</li>
<li><strong>复制算法（Copying）</strong>：复制算法将内存一分为二，每次只使用其中一半。当一半空间被用满后，将存活的对象复制到另一半空闲空间中，然后清除已使用的空间。复制算法解决了碎片问题，但是需要一倍的内存空间，且对象的复制会影响性能。</li>
<li><strong>标记-压缩算法（Mark-and-Compact）</strong>：标记-压缩算法结合了标记-清除算法和复制算法的优点。它先标记存活对象，然后将存活对象紧凑地放置在内存的一端，然后对整个堆进行压缩，使得存活对象占用连续的内存空间。标记-压缩算法可以解决碎片问题，并且不需要额外的内存空间，但是需要移动存活对象，也会有一定的性能开销。</li>
<li><strong>分代算法（Generational）</strong>：分代算法基于对象的存活时间进行划分，一般将堆分为新生代和老年代。新生代通常使用复制算法，因为大多数对象在短时间内就会变成垃圾。老年代则使用标记-清除或标记-压缩算法，因为老年代中的对象通常存活时间较长。</li>
</ul>
<h3 id="2-你了解哪些垃圾收集器？"><a href="#2-你了解哪些垃圾收集器？" class="headerlink" title="2.你了解哪些垃圾收集器？"></a>2.你了解哪些垃圾收集器？</h3><p>—-这里限于篇幅，只是简要说明，强烈建议读者移步<a href="https://tangjiayang.github.io/2023/05/26/java%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/">此处</a>更详细地了解各个收集器原理(见章节：1.7.GC 垃圾收集器)</p>
<ul>
<li><strong>Serial收集器</strong>：Serial收集器是最基本的垃圾回收器，它使用单线程进行垃圾回收。在进行垃圾回收时，会暂停所有的用户线程。Serial收集器适用于小型应用和客户端环境，它的特点是简单、高效，适用于单核处理器。</li>
<li><strong>Parallel收集器</strong>：Parallel收集器使用多线程进行垃圾回收。Parallel收集器通过并行处理来提高垃圾回收的吞吐量，适用于多核处理器和数据量较大的应用。</li>
<li><strong>CMS收集器</strong>：CMS（Concurrent Mark Sweep）收集器是一种并发垃圾回收器。它使用多线程和并发处理来最小化垃圾回收对应用程序暂停时间的影响。CMS收集器适用于对响应时间有较高要求的应用，但由于并发执行的特性，可能会增加垃圾回收器本身的开销。</li>
<li><strong>G1收集器</strong>：G1（Garbage-First）收集器是一种面向服务器的垃圾回收器。它具有高吞吐量和可预测停顿时间的特点。G1收集器将内存分为多个小区域，并基于优先级进行垃圾回收。它可以通过调整停顿时间目标来平衡吞吐量和停顿时间。G1收集器适用于大内存容量和对停顿时间有较高要求的应用。</li>
</ul>
<h3 id="3-G1垃圾回收器相比CMS的优势在哪？"><a href="#3-G1垃圾回收器相比CMS的优势在哪？" class="headerlink" title="3.G1垃圾回收器相比CMS的优势在哪？"></a>3.G1垃圾回收器相比CMS的优势在哪？</h3><ol>
<li><strong>可预测的停顿时间</strong>：G1收集器通过将堆内存划分为多个区域（Region），实现了增量式的垃圾回收。它能够根据用户指定的目标停顿时间（Pause Time）来制定优化策略，从而在可控的时间范围内完成垃圾回收，减少应用程序的停顿时间。</li>
<li><strong>堆内存的分区管理</strong>：G1收集器将整个堆划分为多个大小相等的区域，每个区域都可以是Eden区、Survivor区或者老年代区域。这种分区管理方式使得G1收集器能够更加灵活地进行垃圾回收，<strong>只处理其中的一部分区域，避免了全局性的停顿。</strong></li>
<li>并发标记和部分回收：G1收集器采用了并发标记的方式，在并发标记过程中，应用程序可以继续运行。同时，G1收集器在每次收集时只回收一部分区域，即<u>根据垃圾的产生情况选择垃圾最多的区域进行回收，避免了全堆的扫描和清理操作，提高了垃圾收集的效率。</u></li>
<li>空间整理的效率：G1收集器在标记垃圾后，会选择垃圾最多的区域进行回收。此时，只会回收该区域中的垃圾对象，而不会进行全堆的压缩式整理。这种增量式的回收方式可以减少停顿时间，同时也降低了空间整理的开销。</li>
<li>高可扩展性：<strong>G1收集器具备较高的可扩展性，可以适应不同大小的堆和多核处理器的环境。通过合理调整分区数量和大小，可以更好地平衡内存占用和垃圾回收的效率。</strong></li>
</ol>
<p>总的来说，G1收集器相较于CMS垃圾收集器在停顿<strong>时间可控性、分区管理、并发标记和部分回收、空间整理效率和可扩展性</strong>等方面具有优势，适用于需要较低停顿时间和更好内存利用率的场景。</p>
<h3 id="4-解释一下JVM内存模型-分区情况，然后再讲一下垃圾回收情况-2次"><a href="#4-解释一下JVM内存模型-分区情况，然后再讲一下垃圾回收情况-2次" class="headerlink" title="4.解释一下JVM内存模型(分区情况，然后再讲一下垃圾回收情况)  (2次)"></a>4.解释一下JVM内存模型(分区情况，然后再讲一下垃圾回收情况)  (2次)</h3><ul>
<li>程序计数器</li>
<li>Java 虚拟机栈</li>
<li>本地方法栈   </li>
<li>Java 堆</li>
<li>元数据区</li>
</ul>
<p>🌟<strong>追问</strong>：我们创建一个对象，可能会在哪些区域分配内存？</p>
<p>   堆</p>
<p>🌟<strong>追问</strong>：一定吗？</p>
<p>   (❌)这块确实原本不知道，乱说一通</p>
<p>追问：你有了解过栈上分配吗？(这不是明显的提示吗？奈何我真不会)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">☄️栈上分配（Stack Allocation）。栈上分配是一种优化技术，它将对象分配到栈内存而不是堆内存中，以提高程序的性能。</span><br><span class="line"></span><br><span class="line">在传统的 Java 内存模型中，对象的分配发生在堆内存中，需要进行动态内存分配和垃圾回收。然而，栈上分配通过将对象分配到栈帧中，即方法调用栈，来减少内存管理的开销。</span><br><span class="line"></span><br><span class="line">栈上分配适用于满足以下条件的对象：</span><br><span class="line">✦对象是线程私有的，即不会被其他线程访问或共享。</span><br><span class="line">✦对象的生命周期在方法内部，即对象的引用不会逃逸出方法（不会被方法外部的代码所引用）。</span><br><span class="line">✦对象是值对象（Value Object），即对象在存储和使用上与原生数据类型类似，没有复杂的生命周期或引用关系。</span><br><span class="line"></span><br><span class="line">栈上分配的好处包括：</span><br><span class="line">✦分配和回收对象的开销更低：栈上分配不需要进行堆内存的动态分配和垃圾回收，因此可以减少运行时的开销。</span><br><span class="line">✦对象可以更快地释放：当方法调用结束时，栈帧中的对象会随着栈帧的弹出而自动释放，无需等待垃圾回收。</span><br><span class="line"></span><br><span class="line">需要注意的是，栈上分配对于大部分对象来说并不适用，因为大部分对象的生命周期比一个方法调用更长，并且可能被多个线程访问。栈上分配通常用于创建小型、临时的对象，例如局部变量或方法参数。</span><br><span class="line"></span><br><span class="line">总而言之，栈上分配是一种优化技术，在满足特定条件下，将对象分配到栈内存中，以减少内存管理的开销和提高程序性能。</span><br></pre></td></tr></table></figure>



<h3 id="5-堆中有新生代和老年代，什么样的对象会在新生代，什么样的对象会在老年代呢？"><a href="#5-堆中有新生代和老年代，什么样的对象会在新生代，什么样的对象会在老年代呢？" class="headerlink" title="5.堆中有新生代和老年代，什么样的对象会在新生代，什么样的对象会在老年代呢？"></a>5.堆中有新生代和老年代，什么样的对象会在新生代，什么样的对象会在老年代呢？</h3><p>   我回答的原话是：频繁创建销毁的对象会在新生代中(⚠️这样表达非常不准确，下次思考2秒再张嘴说话！！)</p>
<p>   新创建的对象在新生代，新生代中年龄到达设定值或者放不下的情况下会放到老年代中</p>
<h3 id="6-哪些对象能够被回收，回收的机制是什么？"><a href="#6-哪些对象能够被回收，回收的机制是什么？" class="headerlink" title="6.哪些对象能够被回收，回收的机制是什么？"></a>6.哪些对象能够被回收，回收的机制是什么？</h3><p>   首先找到GC Roots，再找他们与他们有直接引用的对象，这些是不会被回收的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可达性分析</span><br></pre></td></tr></table></figure>

<p>🌟<strong>追问</strong>：你刚提到了GC Root， 哪些对象能够作为GC Root？</p>
<p>   (❌，真看过！也真忘了！😡)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在 Java 中，以下几种对象可以作为 GC Roots：</span><br><span class="line"></span><br><span class="line">✦虚拟机栈（栈帧中的本地变量表）中引用的对象；</span><br><span class="line"></span><br><span class="line">✦方法区中类静态属性引用的对象；</span><br><span class="line"></span><br><span class="line">✦方法区中常量引用的对象；</span><br><span class="line"></span><br><span class="line">✦被 JNI（Java Native Interface，即 Java 本地接口）引用的对象；</span><br><span class="line"></span><br><span class="line">✦线程中正在执行的方法的局部变量或输入参数引用的对象。</span><br></pre></td></tr></table></figure>



<h3 id="7-元数据区存的是什么？"><a href="#7-元数据区存的是什么？" class="headerlink" title="7.元数据区存的是什么？"></a>7.元数据区存的是什么？</h3><p>  元空间中有常量池、类的配置信息(⚠️说得好像有问题，复盘)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">元空间的实现称为常量池</span><br><span class="line">常量池中存储了以下几种元数据：</span><br><span class="line">1.类信息（Class Information）：包括类的名称、父类、接口、访问修饰符等。</span><br><span class="line">2.字段信息（Field Information）：包括字段的名称、类型、访问修饰符等。</span><br><span class="line">3.方法信息（Method Information）：包括方法的名称、参数类型、返回类型、访问修饰符等。</span><br><span class="line">4.字符串常量（String Constants）：包括字符串字面值，例如 &quot;Hello, World!&quot;。</span><br><span class="line">5.字面常量（Literal Constants）：包括整数、浮点数、布尔值等字面常量。</span><br></pre></td></tr></table></figure>



<h3 id="8-类加载机制是怎么样的？"><a href="#8-类加载机制是怎么样的？" class="headerlink" title="8.类加载机制是怎么样的？"></a>8.类加载机制是怎么样的？</h3><p>(不太熟练)</p>
<p>首先读取类的信息</p>
<p>再进行安全性检查</p>
<p>开辟虚拟内存空间，进行静态变量的初始化</p>
<p>将虚拟地址变为物理地址</p>
<p>再执行构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">加载</span><br><span class="line">验证</span><br><span class="line">准备</span><br><span class="line">解析</span><br><span class="line">初始化</span><br><span class="line">使用</span><br></pre></td></tr></table></figure>



<h3 id="9-双亲委派是什么？"><a href="#9-双亲委派是什么？" class="headerlink" title="9. 双亲委派是什么？"></a>9. 双亲委派是什么？</h3><p>从最早的祖先开始判断能否加载需要的类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">子类加载器如果没有加载过该目标类，就先委托父类加载器加载该目标类，只有在父类加载器找不到字节码文件的情况下才从自己的类路径中查找并装载目标类。</span><br><span class="line"></span><br><span class="line">保证Java程序的稳定运行，避免类的重复加载：JVM区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类</span><br></pre></td></tr></table></figure>

<p><strong>追问：</strong>类加载器怎么知道他能不能加载需要的类？</p>
<p>(❌，不了解，一个比较好的问题)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">其实很简单：</span><br><span class="line">始祖类加载器判断是否加载过该Class，如果已加载，则返回Class对象</span><br><span class="line">   如果没有则尝试从其对应的类路径下寻找class字节码文件并载入</span><br><span class="line">   如果载入成功，则返回Class对象；如果载入失败，则委托给始祖类加载器的子类加载器</span><br><span class="line"></span><br><span class="line">具体怎么知道，暂时差不到，留个坑，目前我认为HashMap就比较合适，通过看看自己的hashmap中是否有需要载入类的信息判断</span><br></pre></td></tr></table></figure>



<h3 id="🌟10-类分配内存的过程会有一些线程安全的问题，你了解吗？"><a href="#🌟10-类分配内存的过程会有一些线程安全的问题，你了解吗？" class="headerlink" title="🌟10. 类分配内存的过程会有一些线程安全的问题，你了解吗？"></a>🌟10. 类分配内存的过程会有一些线程安全的问题，你了解吗？</h3><p>比如：<strong>在并发场景中，如何内存分配过程的线程安全性？如果两个线程先后把对象引用指向了同一个内存区域，怎么办。</strong></p>
<p>​	采用TLAB分配，即Thread Local Allocation Buffer，每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块”私有”内存中分配，当这部分区域用完之后，再分配新的”私有”内存。</p>
<h2 id="网络编程："><a href="#网络编程：" class="headerlink" title="网络编程："></a>网络编程：</h2><h3 id="1-网络编程你有实践过吗？如何保持一个连接是活跃的"><a href="#1-网络编程你有实践过吗？如何保持一个连接是活跃的" class="headerlink" title="1.网络编程你有实践过吗？如何保持一个连接是活跃的"></a>1.网络编程你有实践过吗？如何保持一个连接是活跃的</h3><p>   (❌，不了解)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">心跳机制（Heartbeat Mechanism）：通过定期发送心跳包，可以保持连接的活跃性。心跳包是一种特殊的数据包，用于向对方发送信号以表明连接依然有效。接收方收到心跳包后可以回复一个确认包，或者通过超时或其他机制来判断连接是否仍然可用。</span><br><span class="line">  1.传输层心跳机制： </span><br><span class="line">  ✦TCP保活定时器（TCP Keepalive Timer）：TCP协议提供了一种保活定时器机制，可以在连接空闲一段时间后发送探测数据包来检测连接的活跃性。这个定时器可以通过设置TCP的SO_KEEPALIVE选项来启用，并设置相关的参数，如探测间隔、探测次数等。</span><br><span class="line">  2.应用层心跳机制：</span><br><span class="line">  ✦应用层心跳检测：在应用层中定义心跳检测机制，通过定期发送特定的应用层控制消息，来检测连接的活跃性。接收方可以根据接收到的消息来判断连接是否仍然可用，以及执行相应的处理逻辑。</span><br></pre></td></tr></table></figure>











<h2 id="设计模式："><a href="#设计模式：" class="headerlink" title="设计模式："></a>设计模式：</h2><h3 id="1-说三个设计模式，分别是什么意思？-你平时分别在什么情况下用到这三种设计模式？"><a href="#1-说三个设计模式，分别是什么意思？-你平时分别在什么情况下用到这三种设计模式？" class="headerlink" title="1.说三个设计模式，分别是什么意思？ 你平时分别在什么情况下用到这三种设计模式？"></a>1.说三个设计模式，分别是什么意思？ 你平时分别在什么情况下用到这三种设计模式？</h3><ul>
<li><p>单例模式</p>
<ul>
<li><p>单例模式（Singleton Pattern）是一种创建型设计模式，用于保证一个类只有一个实例，并提供全局访问点。它的核心思想是通过限制类的实例化次数，保证在程序运行期间只存在一个实例。</p>
<p>实现单例模式的常用方法是使用一个私有的静态变量来存储实例对象，同时提供一个公共的静态方法来获取该实例。常见的实现方式有饿汉式（在类加载时即创建实例）和懒汉式（在使用时才创建实例）。</p>
<ul>
<li>日志管理器：在一个应用程序中，通常只需要一个日志管理器来记录日志，单例模式可以确保只有一个实例用于记录日志。</li>
<li>数据库连接池：在多线程环境下，需要保证数据库连接池的全局唯一性，单例模式可以确保只有一个连接池实例。</li>
</ul>
</li>
</ul>
</li>
<li><p>工厂模式</p>
<ul>
<li>工厂模式（Factory Pattern）是一种创建型设计模式，用于创建对象的统一接口。工厂模式通过将对象的实例化过程封装到一个工厂类中来解耦客户端与创建对象的过程。<ul>
<li>数据库驱动管理器：在一个数据库操作的应用程序中，可以使用工厂模式来创建各种数据库驱动的实例。</li>
</ul>
</li>
</ul>
</li>
<li><p>代理模式</p>
<ul>
<li>目标对象、代理对象和客户端。代理对象实现与目标对象相同的接口，并持有目标对象的引用。客户端通过代理对象来访问目标对象。<ul>
<li>代理模式常见的应用场景是在访问对象的前后做一些额外处理，例如权限校验、延迟加载、远程访问等。使用代理模式可以增强目标对象的功能，同时对客户端屏蔽了目标对象的具体实现，增加了代码的灵活性和可维护性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-如何写一个单例模式？"><a href="#2-如何写一个单例模式？" class="headerlink" title="2. 如何写一个单例模式？"></a>2. 如何写一个单例模式？</h3><p><strong>追问</strong>：多线程创建单例，会不会不问题，怎么解决？</p>
<p>(❌)这里我没有说清楚，就记得两次判断null了。。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">用双重检查法：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">          🌟<span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis:"></a>Redis:</h2><h3 id="1-redis中有几种数据类型？你在你的项目中用过哪几种数据结构？-2次"><a href="#1-redis中有几种数据类型？你在你的项目中用过哪几种数据结构？-2次" class="headerlink" title="1.redis中有几种数据类型？你在你的项目中用过哪几种数据结构？(2次)"></a>1.redis中有几种数据类型？你在你的项目中用过哪几种数据结构？(2次)</h3><p>   (❌，没背，不会)</p>
<p>   分布式锁就用到了String类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">常见的：⬇️</span><br><span class="line">字符串 (String)：存储一个字符串值。可以存储任何类型的数据，包括数字、文本、二进制数据等。</span><br><span class="line"></span><br><span class="line">列表 (List)：按照插入顺序存储一个有序的元素集合。可以在列表的两端进行插入和删除操作。</span><br><span class="line"></span><br><span class="line">集合 (Set)：存储一个无序的、不重复的元素集合。可以对集合进行交集、并集、差集等常见集合操作。</span><br><span class="line"></span><br><span class="line">有序集合 (Sorted Set)：类似于集合，但每个元素都关联了一个分数，被用来按照分数的顺序存储和获取元素。可以根据分数范围或成员来获取元素。</span><br><span class="line"></span><br><span class="line">哈希表 (Hash)：存储键值对的无序散列表。适用于存储对象的相关字段，可以针对单个字段进行读取和更新操作。</span><br></pre></td></tr></table></figure>



<h3 id="2-redis-分布式锁是怎么实现的？原理是什么？-3次"><a href="#2-redis-分布式锁是怎么实现的？原理是什么？-3次" class="headerlink" title="2.redis 分布式锁是怎么实现的？原理是什么？(3次)"></a>2.redis 分布式锁是怎么实现的？原理是什么？(3次)</h3><p>   (⚠️)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">分布式锁的实现原理如下：</span><br><span class="line">    ✦使用 SETNX (set if not exist) 命令来尝试将一个唯一的标识（如锁的名字）作为 key，获取锁的资源。</span><br><span class="line">        ✦当 key 不存在时， SETNX 命令会将该 key 设置为指定的值，并返回 1，表示获取锁成功。</span><br><span class="line">        ✦当 key 已经存在时， SETNX 命令不会对 key 进行任何操作，直接返回 0，表示获取锁失败。</span><br><span class="line">    ✦在获取锁成功后，为了避免锁永久占用，可以设置一个合适的过期时间 (expire)。可以使用 EXPIRE 命令或者 SET 命令配合 NX（仅在 key 不存在时设置）选项来设定过期时间。</span><br><span class="line">    ✦在对锁进行解锁操作时，需要使用 DEL (delete) 命令来删除该锁的 key。</span><br><span class="line"></span><br><span class="line">分布式锁保证原子性：</span><br><span class="line">    ✦分布式锁是通过 Redis 单线程的特点来保证原子性操作的，保证同一时刻只有一个客户端能够获取到锁。</span><br><span class="line">    ✦可以使用 SETNX+EXPIRE 命令的组合来实现基本的分布式锁。</span><br><span class="line">    ✦获取到锁后，执行具体的业务逻辑，然后再进行解锁操作，避免锁被长时间占用。</span><br><span class="line">    ✦避免获取锁的客户端执行时间过长，导致锁过期后其他客户端获取到锁执行相同的操作。可以根据业务情况合理调整锁的过期时间。</span><br></pre></td></tr></table></figure>



<h3 id="3-在redis使用分布式锁的时候，如果有多个线程来抢占锁，redis是怎么控制只有一个线程能拿到锁的？-2次"><a href="#3-在redis使用分布式锁的时候，如果有多个线程来抢占锁，redis是怎么控制只有一个线程能拿到锁的？-2次" class="headerlink" title="3.在redis使用分布式锁的时候，如果有多个线程来抢占锁，redis是怎么控制只有一个线程能拿到锁的？(2次)"></a>3.在redis使用分布式锁的时候，如果有多个线程来抢占锁，redis是怎么控制只有一个线程能拿到锁的？(2次)</h3><p>​	由Redis的单线程模型和命令的原子性特性所保证的</p>
<h3 id="4-setnx这个命令其实是有一些问题的，可能会导致死锁，你了解过吗？-2次"><a href="#4-setnx这个命令其实是有一些问题的，可能会导致死锁，你了解过吗？-2次" class="headerlink" title="4.setnx这个命令其实是有一些问题的，可能会导致死锁，你了解过吗？(2次)"></a>4.setnx这个命令其实是有一些问题的，可能会导致死锁，你了解过吗？(2次)</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230904143338832.png" alt="image-20230904143338832"></p>
<ol>
<li><p>客户端A 从master拿到锁lock01</p>
</li>
<li><p>master正要把lock01同步(Redis的主从同步通常是异步的）给slave时，突然宕机了，导致lock01没同步到 slave</p>
</li>
<li><p>主从切换，slave节点被晋级为master节点</p>
</li>
<li><p>客户端B到master拿lock01照样能拿到。这样必将导致同一把锁被多人使用。</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/INGNIGHT/article/details/106918732">参考文章</a></p>
<h3 id="5-你有研究过String底层是怎么实现的呢？-2次"><a href="#5-你有研究过String底层是怎么实现的呢？-2次" class="headerlink" title="5.你有研究过String底层是怎么实现的呢？(2次)"></a>5.你有研究过String底层是怎么实现的呢？(2次)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">留个坑，系统学完redis底层后来填</span><br></pre></td></tr></table></figure>



<h3 id="6-在redis中执行一个事务操作，他可以保证原子性吗？"><a href="#6-在redis中执行一个事务操作，他可以保证原子性吗？" class="headerlink" title="6.在redis中执行一个事务操作，他可以保证原子性吗？"></a>6.在redis中执行一个事务操作，他可以保证原子性吗？</h3><p> 不能，但可以用lua脚本实现</p>
<p><strong>追问：为什么lua脚本可以保证，它是怎么实现的？</strong></p>
<p>Lua脚本的执行方式：当执行Lua脚本时，Redis会将脚本的内容发送给服务器端的Lua解释器执行。<u>在执行期间，Redis会将该脚本锁住，保证其他客户端无法在同一时刻修改或执行脚本的相同部分。</u>这样，Lua脚本可以在Redis服务器端以原子方式执行一系列的命令，确保在脚本执行期间不会被其他操作打断或篡改。</p>
<p>通过将Lua脚本作为一个单独的操作在Redis服务器端执行，并且在执行期间锁住脚本，Redis保证了脚本的原子性。<u>当脚本执行期间发生异常或错误时，Redis会回滚或中断脚本的执行，确保数据不会处于一个不一致的状态。</u></p>
<p>  需要注意的是，虽然Lua脚本能够保证内部一系列命令的原子性，但并不能保证与外部命令的原子性或整个Redis事务的原子性。在使用Lua脚本时，仍然需要考虑其他操作和业务逻辑的影响，并结合具体场景来设计和实现原子操作。</p>
<h2 id="Spring："><a href="#Spring：" class="headerlink" title="Spring："></a>Spring：</h2><h3 id="1-spring中的拦截器和过滤器有什么区别？"><a href="#1-spring中的拦截器和过滤器有什么区别？" class="headerlink" title="1.spring中的拦截器和过滤器有什么区别？"></a>1.spring中的拦截器和过滤器有什么区别？</h3><ul>
<li>触发时机：<ul>
<li>过滤器：在Servlet容器中，过滤器是在请求进入Servlet容器之前和响应离开Servlet容器之前进行处理的，即在请求和响应的前后都触发执行。</li>
<li>拦截器：在Spring MVC框架中，拦截器是在请求进入Controller之前和离开Controller之后进行处理的，即只在请求处理的前后触发执行。</li>
</ul>
</li>
<li>使用范围：<ul>
<li>过滤器：过滤器可以用于所有的Web应用程序，无论是基于Spring的还是其他任何框架。它可以在应用程序的整个生命周期中使用。</li>
<li>拦截器：拦截器是Spring MVC框架特有的功能，只能用于使用了Spring MVC框架的应用程序中。</li>
</ul>
</li>
<li>配置方式：<ul>
<li>过滤器：过滤器的配置是在Web应用程序的web.xml文件中进行的，通过配置URL匹配模式来指定要拦截的请求。</li>
<li>拦截器：拦截器的配置是通过实现HandlerInterceptor接口，并在Spring配置文件中进行声明的，可以根据具体的请求路径等条件进行配置。</li>
</ul>
</li>
<li>功能：<ul>
<li>过滤器：过滤器可以对请求的参数进行处理、请求的编码进行转换、对响应结果进行过滤等。</li>
<li>拦截器：拦截器可以在请求进入Controller之前和离开Controller之后进行处理，可以进行权限验证、日志记录、性能监控等。</li>
</ul>
</li>
</ul>
<h3 id="2-Spring中循环依赖的问题你有了解过吗？"><a href="#2-Spring中循环依赖的问题你有了解过吗？" class="headerlink" title="2. Spring中循环依赖的问题你有了解过吗？"></a>2. Spring中循环依赖的问题你有了解过吗？</h3><p>​	使用<u>三级缓存+提前曝光的机制</u>应对</p>
<p>​	总结下Spring解决循环依赖的思路：</p>
<ul>
<li>在创建单例bean时，会把该bean的工厂函数的匿名类对象放入三级缓存中的singletonFactories中；</li>
</ul>
<p>然后在填充属性时，如果出现循环依赖依赖本 bean，必然执行之前放入的工厂函数的匿名实现，如果该bean无需 AOP的话，工厂函数返回的就是原bean对象；如果该bean有 AOP 的话，也有可能是被某些BBP处理AOP 之后的代理对象，会放入二级缓存中的earlySingletonObjects中；</p>
<p>接着bean开始初始化，如果该bean无需 AOP的话，结果返回的原来创建的bean对象；如果该bean有 AOP 的话，检查AOP织入逻辑是否已经在提前曝光时已经执行了，如果已经执行AOP则返回提前曝光的代理bean对象；如果AOP织入逻辑未执行过，则进行后续的 BeanPostProcessor后置处理器进行AOP织入，生成AOP代理bean对象，并返回。</p>
<p>最后对于提前曝光的单例，就会去检查初始化后的bean对象与二级缓存中提前曝光的bean是不是同一个对象，只有不是的情况下才可能抛出异常。</p>
<p>深入阅读我们应用本身代码，发现项目中出现Bean的循环依赖，本质原因是代码架构设计不合理，某些facade类实现了本应在serivce层的业务逻辑，导致其他业务依赖地方反复应用facade层对象。SpringBoot 2.6.x以上的版本官方已经不推荐使用循环依赖，说不定今后某个最新版本的Spring会强制不能出现Bean循环依赖，因此需要我们开发者在平时编码时要重视代码架构设计。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230904102538032.png" alt="image-20230904102538032"></p>
<h3 id="3-一般在使用Spring事务的时候，事务失效一般有哪些原因？"><a href="#3-一般在使用Spring事务的时候，事务失效一般有哪些原因？" class="headerlink" title="3.一般在使用Spring事务的时候，事务失效一般有哪些原因？"></a>3.一般在使用Spring事务的时候，事务失效一般有哪些原因？</h3><p>不太熟悉，需要系统地学一下</p>
<h3 id="4-Spring中注解事务具体是怎么实现事务的，内部是怎么实现的？"><a href="#4-Spring中注解事务具体是怎么实现事务的，内部是怎么实现的？" class="headerlink" title="4.Spring中注解事务具体是怎么实现事务的，内部是怎么实现的？"></a>4.Spring中注解事务具体是怎么实现事务的，内部是怎么实现的？</h3><p>在Spring中，使用注解来实现事务的方式是通过AOP（面向切面编程）和代理对象来实现的。Spring利用事务代理拦截需要事务处理的方法，在方法执行前开启事务，在方法执行后根据执行结果进行事务提交或回滚。</p>
<p>具体实现的步骤如下：</p>
<ol>
<li><p>配置事务管理器：在Spring配置文件中配置事务管理器（如DataSourceTransactionManager），用于管理事务的开启、提交和回滚。</p>
</li>
<li><p>开启Spring事务注解：在Spring配置文件中开启事务注解支持，通过<code>&lt;tx:annotation-driven/&gt;</code>标签或<code>@EnableTransactionManagement</code>注解来激活Spring对事务注解的支持。</p>
</li>
<li><p>定义事务边界：在需要事务管理的方法上添加@Transactional注解，用于标识该方法需要进行事务管理。</p>
</li>
<li><p>创建事务通知切面：Spring会为使用了@Transactional注解的方法创建一个事务通知切面。该切面定义了在方法执行前开启事务、在方法执行后根据执行结果进行事务提交或回滚的逻辑。</p>
</li>
<li><p>创建代理对象：当Spring容器初始化时，对标注了@Transactional注解的Bean对象进行扫描，如果发现被代理的Bean需要事务处理，Spring会为这些Bean创建代理对象。代理对象通过Java动态代理或CGLIB生成，用于拦截目标方法的调用，实现事务的管理。</p>
</li>
<li><p>事务处理：当调用被代理对象的方法时，代理对象会在方法执行前后进行拦截。在方法执行前，代理对象会根据@Transactional注解的属性设置开启事务。在方法执行后，代理对象会根据方法的执行结果，判断是提交事务还是回滚事务。</p>
</li>
</ol>
<p>在事务处理过程中，Spring会利用事务管理器在合适的时机进行事务的开启、提交、回滚等操作。同时，Spring还提供了多种属性和注解来控制事务的传播行为、隔离级别、超时等特性。</p>
<p>总结来说，Spring通过AOP和代理对象实现了基于注解的事务管理。通过在需要事务管理的方法上添加@Transactional注解，Spring会为这些方法生成代理对象，并在代理对象中完成事务管理相关的操作。</p>
<h2 id="分布式、微服务："><a href="#分布式、微服务：" class="headerlink" title="分布式、微服务："></a>分布式、微服务：</h2><h3 id="1-对于微服务中常见的RPC框架都知道哪些？"><a href="#1-对于微服务中常见的RPC框架都知道哪些？" class="headerlink" title="1.对于微服务中常见的RPC框架都知道哪些？"></a>1.对于微服务中常见的RPC框架都知道哪些？</h3><ol>
<li>gRPC：gRPC是由Google开源的高性能、通用的RPC框架，可以使用多种编程语言进行开发。它使用Google Protocol Buffers作为接口定义语言（IDL），使用HTTP&#x2F;2作为传输协议，具有跨语言、高性能、双向流等特点。</li>
<li>Apache Dubbo：Dubbo是阿里巴巴开源的一款高性能的Java RPC框架，支持面向接口的远程方法调用。它提供负载均衡、服务发现、容错机制等功能，可以很方便地构建微服务架构。</li>
<li>Apache Thrift：Thrift是Apache基金会开源的一款跨语言的RPC框架，支持多种语言，如Java、Python、C++等。它采用自定义的IDL语言，可以生成不同语言的客户端和服务端代码，并支持多种传输协议和序列化格式。</li>
<li>Spring Cloud：Spring Cloud是基于Spring Boot开发的一套微服务框架，它提供了丰富的功能和组件来支持微服务架构，包括服务发现与注册、负载均衡、断路器、配置中心等。在RPC调用方面，Spring Cloud使用了Ribbon作为负载均衡组件，并可以结合Feign进行声明式的RPC调用。</li>
<li>Thrift：Thrift是Facebook开源的一套高效的跨语言的服务框架，支持多种语言，如Java、Python、C++等。它采用自定义的IDL语言，生成不同语言的代码，提供了方便的服务定义和远程调用。</li>
</ol>
<h3 id="2-springcloud中的熔断策略了解吗？比如一个微服务出现了异常，怎么处理？"><a href="#2-springcloud中的熔断策略了解吗？比如一个微服务出现了异常，怎么处理？" class="headerlink" title="2.springcloud中的熔断策略了解吗？比如一个微服务出现了异常，怎么处理？"></a>2.springcloud中的熔断策略了解吗？比如一个微服务出现了异常，怎么处理？</h3><p>在Spring Cloud中，常用的熔断策略是使用Netflix开源的Hystrix库。Hystrix提供了线程隔离、断路器、舱壁模式等熔断机制来控制服务的调用。当某个微服务出现异常或超时时，Hystrix可以采取以下几种处理方式：</p>
<ol>
<li>直接返回默认值：当发生调用失败或超时时，Hystrix可以直接返回一个默认值，避免将异常传递给调用方，保证调用方的正常业务流程继续进行。</li>
<li>抛出异常：Hystrix也可以选择抛出自定义的异常，并在调用方进行相应的异常处理。通过抛出异常，可以提供更多的调用失败的详细信息，帮助开发人员进行问题排查和处理。</li>
<li>执行降级逻辑：当某个微服务出现异常或超时时，Hystrix可以通过执行事先定义的降级逻辑来返回备选响应结果。这样即使服务不可用或响应时间过长，也可以以一种有限的功能继续提供服务，而不是完全失败。</li>
<li>断路器模式：Hystrix可以根据服务调用的失败率或错误率来触发断路器，断开对该服务的调用，防止对不稳定的服务进行过多的尝试。一旦断路器打开，可以阻止额外的调用，快速失败，并通过一个事先定义好的回退逻辑来返回响应结果。</li>
</ol>
<h3 id="3-分布式锁的实现方案有哪些？"><a href="#3-分布式锁的实现方案有哪些？" class="headerlink" title="3.分布式锁的实现方案有哪些？"></a>3.分布式锁的实现方案有哪些？</h3><ol>
<li>基于数据库的实现：可以利用数据库的唯一索引来实现分布式锁。当一个节点需要获取锁时，在数据库中插入一条唯一索引的记录，插入成功表示获取到锁，其他节点在插入时会失败，从而保证了锁的唯一性。但需要注意的是，数据库的性能可能会受到影响，并且当锁的粒度较小时，可能会产生大量的数据库操作。</li>
<li>基于缓存的实现：可以利用分布式缓存如Redis或ZooKeeper等来实现分布式锁。通过在缓存中设置一个键值对，当一个节点需要获取锁时，尝试在缓存中设置该键值对，设置成功表示获取到锁，其他节点在设置时会失败。这种实现方式的好处是速度较快且可扩展性高，但在某些情况下可能会发生死锁或锁失效的问题，需要进行额外的处理。</li>
<li>基于乐观锁的实现：可以使用数据库的乐观锁机制实现分布式锁。每个节点在访问共享资源之前，先读取资源的版本号，然后在更新时检查版本号是否一致，如果一致则更新，否则表示有其他节点已经修改了资源。这种方式适用于高并发的场景，但需要保证数据库的事务隔离级别为可重复读。</li>
<li>基于ZooKeeper的实现：ZooKeeper是一个高可用的分布式协调服务，可以用来实现分布式锁。每个节点在获取锁时创建一个临时有序节点，按照节点创建的顺序来确定获取锁的顺序。节点创建成功后，通过监听前一个节点的变化来判断是否获取到锁。这种实现方式具有可靠性和高可用性，但依赖于ZooKeeper的稳定性和性能。</li>
</ol>
<h3 id="4-分布式id有哪几种生成的策略？"><a href="#4-分布式id有哪几种生成的策略？" class="headerlink" title="4.分布式id有哪几种生成的策略？"></a>4.分布式id有哪几种生成的策略？</h3><ol>
<li>自增ID：每个节点或数据库独立生成自增序列，然后将序列组合成分布式ID。这种方法简单，但可能存在单点故障和性能瓶颈问题。</li>
<li>UUID（通用唯一标识符）：使用算法生成的128位的全局唯一标识符。UUID是基于时间戳、机器标识和随机数等信息生成，理论上保证全局唯一性。但它的长度较长，不利于存储，且无序性可能导致索引性能下降。</li>
<li>雪花算法（Snowflake）：Twitter开源的一种分布式唯一ID生成算法。通过使用时间戳、机器ID和序列号组合生成64位的唯一ID，保证了一定程度上的有序性和全局唯一性。</li>
<li>数据库的自增ID：使用数据库的自增ID机制（如MySQL的自增主键）生成分布式ID。需要将ID生成的工作放在数据库层面处理，确保ID的唯一性。但这也会有数据库写入性能和单点故障的问题。</li>
<li>集群全局唯一ID生成器：使用分布式ID生成器（如Twitter的Snowflake、百度的UIDGenerator）来生成全局唯一ID。这些生成器使用多个节点协同工作，通过分配不同的区域ID和机器ID来实现高可用和全局唯一的ID生成。</li>
</ol>
<h2 id="消息队列："><a href="#消息队列：" class="headerlink" title="消息队列："></a>消息队列：</h2><h3 id="1-消息中间件比如kafka了解吗，有用过吗？"><a href="#1-消息中间件比如kafka了解吗，有用过吗？" class="headerlink" title="1.消息中间件比如kafka了解吗，有用过吗？"></a>1.消息中间件比如kafka了解吗，有用过吗？</h3><p>​	准备用😅</p>
<h2 id="Spring-Security："><a href="#Spring-Security：" class="headerlink" title="Spring Security："></a>Spring Security：</h2><h3 id="1-那对于安全登录认证这一块熟悉吗？就是你现在有很多微服务，通过网关把请求转到微服务模块中，怎么识别身份？"><a href="#1-那对于安全登录认证这一块熟悉吗？就是你现在有很多微服务，通过网关把请求转到微服务模块中，怎么识别身份？" class="headerlink" title="1.那对于安全登录认证这一块熟悉吗？就是你现在有很多微服务，通过网关把请求转到微服务模块中，怎么识别身份？"></a>1.那对于安全登录认证这一块熟悉吗？就是你现在有很多微服务，通过网关把请求转到微服务模块中，怎么识别身份？</h3><p>在微服务架构中，通过网关将请求转发到不同的微服务模块中，需要一种方法来识别用户身份并进行安全登录认证。以下是一些常用的身份识别和认证方法：</p>
<ol>
<li>令牌（Token）认证：在用户登录成功后，网关会生成一个包含用户身份信息和其他权限信息的令牌。之后，用户在每次请求时将该令牌作为身份识别凭证发送给网关，网关会验证令牌的有效性并校验用户的访问权限。</li>
<li>JWT（JSON Web Token）：JWT是一种轻量级的身份认证和授权机制。用户在登录成功后，网关会生成一个包含用户身份信息和签名的JWT令牌，并将其返回给用户。用户在每次请求时，将JWT令牌通过请求头或请求参数发送给网关，网关验证JWT令牌的有效性和完整性，并解析其中的用户信息。</li>
<li>OAuth2：OAuth2是一种授权机制，可以用于第三方应用程序向用户授权访问资源。在OAuth2中，用户在登录成功后，网关通过授权服务器获取访问令牌（Access Token），用户将该令牌在每次请求时发送给网关，网关验证令牌的有效性并校验用户的访问权限。</li>
</ol>
<p>以上只是一些常见的身份识别和认证方法，实际使用时，还需要结合具体的场景和业务需求来选择合适的认证方式。此外，还需要考虑安全性方面的问题，例如令牌的安全传输和存储，令牌的过期和刷新机制，以及用户权限的管理和控制等。</p>
<p>最好的实践是借助成熟的认证和授权框架，如Spring Security、Keycloak等，来实现安全登录认证，以确保系统的可靠性和安全性。</p>
<h2 id="手撕算法部分："><a href="#手撕算法部分：" class="headerlink" title="手撕算法部分："></a>手撕算法部分：</h2><ol>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://Tangjiayang.github.io">donn</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://tangjiayang.github.io/2023/08/18/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93-%E5%85%AB%E8%82%A1/">https://tangjiayang.github.io/2023/08/18/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93-%E5%85%AB%E8%82%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E7%BB%8F/">面经</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/02/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93-%E5%9C%BA%E6%99%AF%E9%A2%98/" title="2023秋招总结-场景题"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">2023秋招总结-场景题</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/15/Redis%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/" title="Redis原理学习"><img class="cover" src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727134719639.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Redis原理学习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/09/02/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93-%E4%B8%BB%E7%AE%A1%E9%9D%A2%E9%97%AE%E9%A2%98/" title="2023秋招总结-主管面问题"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-02</div><div class="title">2023秋招总结-主管面问题</div></div></a></div><div><a href="/2023/09/02/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93-%E5%9C%BA%E6%99%AF%E9%A2%98/" title="2023秋招总结-场景题"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-02</div><div class="title">2023秋招总结-场景题</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81ODUzNy8zNTAwMA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/bg.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">donn</div><div class="author-info__description">欢迎访问donn的博客!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Tangjiayang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Tangjiayang" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">小站成立于2023-5-27！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E5%8E%82%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%9A"><span class="toc-text">大厂校招面试八股问题汇总：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-text">数据结构：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">1.讲一下平衡二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%86%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91%E5%90%97"><span class="toc-text">2.了解红黑树吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%92%E5%BA%A6%EF%BC%8C%E9%99%A4%E4%BA%86%E9%93%BE%E8%A1%A8%E6%B3%95%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3Hash%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">3.从数据结构角度，除了链表法还有什么解决Hash冲突的方式？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A"><span class="toc-text">操作系统：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-3%E6%AC%A1"><span class="toc-text">1.线程和进程有什么关系，有什么区别？(3次)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E9%A1%B5%EF%BC%9F"><span class="toc-text">2.什么是虚页？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-OS%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%BF%9B%E7%A8%8B-LWP-%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E4%BD%A0%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">3.OS中有一个轻量级进程(LWP)的概念，你有了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%98%AF%E4%BB%80%E4%B9%88%E3%80%82"><span class="toc-text">4.解释一下零拷贝是什么。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-I-x2F-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91"><span class="toc-text">5.I&#x2F;O多路复用你了解多少</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8BCAS%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-text">6.简单说一下CAS是怎么实现的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%BA%BF%E7%A8%8B%E7%9A%84sleep-%E6%96%B9%E6%B3%95%E5%92%8CObject%E7%9A%84wait-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">7.线程的sleep( )方法和Object的wait( )方法有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%AF%B9%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%B8%B8%E8%A7%81%E7%9A%84%E9%80%9A%E4%BF%A1%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">8.对线程之间常见的通信的工具类有了解吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A"><span class="toc-text">计算机网络：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E7%9A%84%E6%97%B6%E5%80%99%E8%A6%81%E7%94%A8UDP%EF%BC%8C%E9%99%A4%E4%BA%86%E6%8F%A1%E6%89%8B%E6%8C%A5%E6%89%8B%EF%BC%8CTCP%E8%BF%98%E5%B7%AE%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-text">1.为什么视频传输的时候要用UDP，除了握手挥手，TCP还差在哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BTCP%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82"><span class="toc-text">2.描述一下TCP建立连接的过程。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9C%A8%E4%B8%80%E5%8F%B0%E4%B8%BB%E6%9C%BA%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%90%8C%E6%97%B6%E5%BB%BA%E7%AB%8BTCP%E5%92%8CUDP%E5%8D%8F%E8%AE%AE%EF%BC%8C%E8%83%BD%E5%BB%BA%E7%AB%8B%E8%B5%B7%E6%9D%A5%E5%90%97%EF%BC%9F"><span class="toc-text">3.在一台主机的一个端口同时建立TCP和UDP协议，能建立起来吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A0%BC%E5%BC%8F%E8%83%BD%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%90%97%EF%BC%9F%E6%AF%94%E5%A6%82%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%B4%E7%9A%84%E6%A0%BC%E5%BC%8F%E3%80%82"><span class="toc-text">4.HTTP协议的格式能描述一下吗？比如请求和响应头的格式。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-GET%E5%92%8CPOST%E4%B8%A4%E7%A7%8D%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">5.GET和POST两种请求的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%AF%B4%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%9B%B8%E5%BA%94%E7%A0%81"><span class="toc-text">6.说几个常见的HTTP相应码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%AF%94%E5%A6%82%E4%BD%A0%E9%81%87%E5%88%B0%E4%BA%86502%E9%94%99%E8%AF%AF%EF%BC%8C%E4%BD%A0%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8E%BB%E6%8E%92%E6%9F%A5%E9%94%99%E8%AF%AF%E5%91%A2%EF%BC%9F"><span class="toc-text">7.比如你遇到了502错误，你该怎么去排查错误呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-https-%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">8.https 的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BD%A0%E7%9F%A5%E9%81%93%E4%BD%BF%E7%94%A8http%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E3%80%81%E6%8A%A5%E6%96%87%E6%98%AF%E6%80%8E%E4%B9%88%E5%8F%91%E9%80%81%E7%9A%84%EF%BC%9F"><span class="toc-text">9.你知道使用http协议通信的客户端和服务器之间是怎么建立连接的、报文是怎么发送的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%A6%81%E7%AD%892%E4%B8%AA%E6%97%B6%E9%95%BF%E5%90%8E%E5%85%B3%E9%97%AD%E5%91%A2%EF%BC%9F%E5%B0%B1%E6%98%AF2ML%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">10.为什么客户端要等2个时长后关闭呢？就是2ML问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%BA%86%E8%A7%A3http%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%98%AF%E4%BB%80%E4%B9%88%E5%90%97%EF%BC%9F"><span class="toc-text">11.了解http的滑动窗口是什么吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-TCP%E9%87%8C%E9%9D%A2%E6%9C%89%E4%B8%AA%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%EF%BC%8C%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-text">12.TCP里面有个粘包拆包，你了解过吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-text">常见解决方案：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80%EF%BC%9A"><span class="toc-text">Java基础：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-java%E4%B8%AD%E6%9C%89%E5%87%A0%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">1.java中有几个基本的数据类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%80%E4%B8%AAbyte%E6%98%AF%E5%87%A0%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%9F"><span class="toc-text">2.一个byte是几个字节？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%80%E4%B8%AAchar%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%8F%AF%E4%BB%A5%E8%BD%AC%E6%88%90%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">3.一个char类型数据可以转成什么类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAfloat%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-text">4.如何创建float类型的变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-float%E4%B8%8Edouble%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E6%B7%B7%E5%90%88%E8%BF%90%E7%AE%97%E7%BB%93%E6%9E%9C%E4%BC%9A%E5%87%86%E7%A1%AE%E5%90%97%EF%BC%9F"><span class="toc-text">5.float与double类型进行混合运算结果会准确吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-java%E4%B8%AD-double%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">6.java中 double类型数据的组织形式是怎么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-java%E4%B8%AD%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E5%9C%B0%E8%A1%A8%E8%BE%BE%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%EF%BC%9F"><span class="toc-text">7.java中如何准确地表达数据的加减运算？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BD%A0%E5%9C%A8%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E7%94%A8%E8%BF%87%E8%BF%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97%EF%BC%9F"><span class="toc-text">8.你在你的项目中有用过这个数据类型吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-java%E4%B8%AD%E4%B8%80%E8%88%AC%E7%94%A8%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9D%A5%E6%8E%A5%E6%94%B6-%E5%AE%9A%E4%B9%89%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E4%B8%BB%E9%94%AE"><span class="toc-text">9.java中一般用什么数据类型来接收 定义在数据库中的主键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%88%9A%E6%89%8D%E8%AF%B4%E5%88%B0Integer%E6%98%AF%E4%B8%80%E7%A7%8D%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%88%91%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAInteger-a-x3D-1%EF%BC%9B%E5%9C%A8%E5%AE%9A%E4%B9%89-int-b-x3D-1%EF%BC%9B%E6%88%91%E8%BF%9B%E8%A1%8Cif-a-x3D-x3D-b-%E5%88%A4%E6%96%AD%E6%9D%A1%E4%BB%B6%E4%BC%9A%E6%88%90%E7%AB%8B%E5%90%97%EF%BC%9F"><span class="toc-text">10.刚才说到Integer是一种包装类型，如果我定义一个Integer a &#x3D; 1；在定义 int b &#x3D; 1；我进行if(a &#x3D;&#x3D; b)判断条件会成立吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%8A%A0%E5%85%A5-Integer-a-x3D-new-Integer-1-int-b-x3D-1-%E9%82%A3%E4%B9%88if-a-x3D-x3D-b-%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89%EF%BC%9F"><span class="toc-text">11.加入 Integer a &#x3D; new Integer(1); int b &#x3D; 1; 那么if(a &#x3D;&#x3D; b)是否相等？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%88%9A%E6%89%8D%E8%AF%B4%E7%9A%84%E7%AD%89%E5%8F%B7%E4%B8%A4%E8%BE%B9%E4%B8%80%E8%BE%B9%E6%98%AFInteger%EF%BC%8C%E4%B8%80%E8%BE%B9%E6%98%AFint%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E8%BF%99%E6%A0%B7%E5%88%A4%E6%96%AD%EF%BC%8C%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">12.刚才说的等号两边一边是Integer，一边是int，为什么能这样判断，你了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-java%E4%B8%AD-boolean%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E8%BD%AC%E6%8D%A2%E6%88%90int%E7%B1%BB%E5%9E%8B%E5%90%97%EF%BC%9F"><span class="toc-text">13.java中 boolean类型可以转换成int类型吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-java%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%AD%EF%BC%8C%E7%BA%BF%E6%80%A7%E6%96%B9%E5%BC%8F%E5%AD%98%E5%82%A8%E7%9A%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">14.java集合类中，线性方式存储的有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Map%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%AE%83%E4%BB%AC%EF%BC%9A"><span class="toc-text">15.Map的实现类有哪些，介绍一下它们：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-HashMap%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">16.HashMap的应用场景是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-HashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F-2%E6%AC%A1"><span class="toc-text">17.HashMap的实现方式是什么样的？  (2次)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%EF%BC%9A"><span class="toc-text">MySQL：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84id%E7%94%A8%E7%9A%84%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">1.数据库中的id用的什么数据类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-mysql%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">2.mysql索引是什么结构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%B2%E4%B8%80%E4%B8%8B%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-text">3.讲一下聚簇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%A1%A8%E9%87%8C%E6%9C%89%E4%B8%BB%E9%94%AEid%E5%88%97%EF%BC%8Cname%E5%88%97%EF%BC%8C%E6%88%91%E5%BB%BA%E7%AB%8B-id-name-%E7%9A%84%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%BC%9A%E8%B5%B7%E4%BD%9C%E7%94%A8%E5%90%97%EF%BC%9F%E6%9C%89%E5%BF%85%E8%A6%81%E5%90%97%EF%BC%9F"><span class="toc-text">4. 表里有主键id列，name列，我建立(id, name)的联合索引会起作用吗？有必要吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-mysql%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%87%A0%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%8C%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F-2%E6%AC%A1"><span class="toc-text">5.mysql事务有几种隔离级别，你了解过吗？(2次)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-innodb%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%9F-3%E6%AC%A1"><span class="toc-text">6.innodb怎么实现可重复读？(3次)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%F0%9F%8C%9F%E5%8A%A0%E5%85%A5%E7%BB%99%E4%BD%A0%E4%B8%80%E4%B8%AAsql%E8%AF%AD%E5%8F%A5%EF%BC%8C%E4%BD%A0%E4%BC%9A%E4%BB%8E%E5%93%AA%E5%87%A0%E4%B8%AA%E6%96%B9%E9%9D%A2%E8%80%83%E8%99%91%E4%BC%98%E5%8C%96%E5%91%A2%EF%BC%9F-3%E6%AC%A1"><span class="toc-text">7.🌟加入给你一个sql语句，你会从哪几个方面考虑优化呢？(3次)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%9C%A8explian%E6%8A%A5%E5%91%8A%E4%B8%AD%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9F%E4%B8%BE%E5%87%A0%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-text">8.在explian报告中，有哪些常见的索引使用方式？举几个例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-2%E6%AC%A1"><span class="toc-text">9.索引覆盖是什么？(2次)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%BB%80%E4%B9%88%E5%8F%AB%E5%9B%9E%E8%A1%A8%EF%BC%9F"><span class="toc-text">10.什么叫回表？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%9F11-where%E6%9D%A1%E4%BB%B6%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%87%E6%BB%A4%E6%8E%89%E6%95%B0%E6%8D%AE%E7%9A%84%EF%BC%9F%E5%9C%A8%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F"><span class="toc-text">🌟11.where条件是如何过滤掉数据的？在哪一层？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-A%E5%88%97-%E5%BB%BA%E6%9C%89%E7%B4%A2%E5%BC%95-B%E5%88%97%E6%B2%A1%E6%9C%89-%E6%9F%A5%E8%AF%A2where-A-x3D-1-and-B-x3D-1%E6%97%B6%E5%BA%95%E5%B1%82%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">12.A列 建有索引 B列没有 查询where A &#x3D; 1 and B &#x3D; 1时底层发生了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%B8%80%E6%9D%A1SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">13.一条SQL的执行过程是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-mysql%E4%B8%AD%E4%B8%BB%E9%94%AE%E3%80%81%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E3%80%81%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">14.mysql中主键、唯一索引、联合索引它们的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">15.数据库分库分表你了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%9F16-mysql%E4%B8%AD%EF%BC%8Cinnodb%E5%81%9A%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E4%BA%86B-%E6%A0%91%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AFB%E6%A0%91%E6%88%96%E8%80%85%E8%B7%B3%E8%A1%A8%EF%BC%9F"><span class="toc-text">🌟16.mysql中，innodb做数据存储的时候为什么用了B+树，而不是B树或者跳表？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B-%E6%A0%91%E8%80%8C%E4%B8%8D%E7%94%A8B%E6%A0%91%EF%BC%9A"><span class="toc-text">1.为什么用B+树而不用B树：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B-%E6%A0%91%E8%80%8C%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8%EF%BC%9A"><span class="toc-text">2.为什么用B+树而不用跳表：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A"><span class="toc-text">Java并发编程：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-text">1.为什么要用线程池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-text">2.怎么创建线程池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8F%82%E6%95%B0%EF%BC%9F-3%E6%AC%A1"><span class="toc-text">3.线程池有什么运行机制，有什么参数？(3次)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-3%E6%AC%A1"><span class="toc-text">4.线程池常见的拒绝策略有哪些？(3次)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">5.线程池中的阻塞队列怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%AF%B4%E4%B8%80%E4%B8%8Bvolatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">6.说一下volatile关键字的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BD%A0%E5%AF%B9synchronize%E7%9A%84%E7%90%86%E8%A7%A3%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-text">7.你对synchronize的理解是怎么样的呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BA%86%E8%A7%A3%E5%81%8F%E5%90%91%E9%94%81%E5%90%97%EF%BC%9F"><span class="toc-text">8.了解偏向锁吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-java%E4%BD%A0%E6%AF%94%E8%BE%83%E4%BA%86%E8%A7%A3%E6%98%AF%E5%90%A7%EF%BC%8Csynchronize%E5%92%8CReentrantLock%E7%9A%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-3%E6%AC%A1"><span class="toc-text">9.java你比较了解是吧，synchronize和ReentrantLock的有什么区别？(3次)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-ReentrantLock%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%92%8CAQS%E6%9C%89%E5%95%A5%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-text">10.ReentrantLock的底层实现和AQS有啥关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-text">11.怎么解决线程安全问题，有哪些方案？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%EF%BC%9A"><span class="toc-text">JVM：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-java%E5%B8%B8%E8%A7%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-text">1.java常见垃圾回收算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9F"><span class="toc-text">2.你了解哪些垃圾收集器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9B%B8%E6%AF%94CMS%E7%9A%84%E4%BC%98%E5%8A%BF%E5%9C%A8%E5%93%AA%EF%BC%9F"><span class="toc-text">3.G1垃圾回收器相比CMS的优势在哪？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E5%88%86%E5%8C%BA%E6%83%85%E5%86%B5%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%83%85%E5%86%B5-2%E6%AC%A1"><span class="toc-text">4.解释一下JVM内存模型(分区情况，然后再讲一下垃圾回收情况)  (2次)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A0%86%E4%B8%AD%E6%9C%89%E6%96%B0%E7%94%9F%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%8C%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%BC%9A%E5%9C%A8%E6%96%B0%E7%94%9F%E4%BB%A3%EF%BC%8C%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%BC%9A%E5%9C%A8%E8%80%81%E5%B9%B4%E4%BB%A3%E5%91%A2%EF%BC%9F"><span class="toc-text">5.堆中有新生代和老年代，什么样的对象会在新生代，什么样的对象会在老年代呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E8%83%BD%E5%A4%9F%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%8C%E5%9B%9E%E6%94%B6%E7%9A%84%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">6.哪些对象能够被回收，回收的机制是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%85%83%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%AD%98%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">7.元数据区存的是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">8.类加载机制是怎么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">9. 双亲委派是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%9F10-%E7%B1%BB%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%E8%BF%87%E7%A8%8B%E4%BC%9A%E6%9C%89%E4%B8%80%E4%BA%9B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">🌟10. 类分配内存的过程会有一些线程安全的问题，你了解吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9A"><span class="toc-text">网络编程：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%BD%A0%E6%9C%89%E5%AE%9E%E8%B7%B5%E8%BF%87%E5%90%97%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E4%B8%80%E4%B8%AA%E8%BF%9E%E6%8E%A5%E6%98%AF%E6%B4%BB%E8%B7%83%E7%9A%84"><span class="toc-text">1.网络编程你有实践过吗？如何保持一个连接是活跃的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-text">设计模式：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AF%B4%E4%B8%89%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F-%E4%BD%A0%E5%B9%B3%E6%97%B6%E5%88%86%E5%88%AB%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E7%94%A8%E5%88%B0%E8%BF%99%E4%B8%89%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">1.说三个设计模式，分别是什么意思？ 你平时分别在什么情况下用到这三种设计模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">2. 如何写一个单例模式？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-text">Redis:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-redis%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F%E4%BD%A0%E5%9C%A8%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E8%BF%87%E5%93%AA%E5%87%A0%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F-2%E6%AC%A1"><span class="toc-text">1.redis中有几种数据类型？你在你的项目中用过哪几种数据结构？(2次)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-3%E6%AC%A1"><span class="toc-text">2.redis 分布式锁是怎么实现的？原理是什么？(3次)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9C%A8redis%E4%BD%BF%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%9D%A5%E6%8A%A2%E5%8D%A0%E9%94%81%EF%BC%8Credis%E6%98%AF%E6%80%8E%E4%B9%88%E6%8E%A7%E5%88%B6%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%83%BD%E6%8B%BF%E5%88%B0%E9%94%81%E7%9A%84%EF%BC%9F-2%E6%AC%A1"><span class="toc-text">3.在redis使用分布式锁的时候，如果有多个线程来抢占锁，redis是怎么控制只有一个线程能拿到锁的？(2次)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-setnx%E8%BF%99%E4%B8%AA%E5%91%BD%E4%BB%A4%E5%85%B6%E5%AE%9E%E6%98%AF%E6%9C%89%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%8C%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81%EF%BC%8C%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F-2%E6%AC%A1"><span class="toc-text">4.setnx这个命令其实是有一些问题的，可能会导致死锁，你了解过吗？(2次)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BD%A0%E6%9C%89%E7%A0%94%E7%A9%B6%E8%BF%87String%E5%BA%95%E5%B1%82%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%91%A2%EF%BC%9F-2%E6%AC%A1"><span class="toc-text">5.你有研究过String底层是怎么实现的呢？(2次)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%9C%A8redis%E4%B8%AD%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%BB%96%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%90%97%EF%BC%9F"><span class="toc-text">6.在redis中执行一个事务操作，他可以保证原子性吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%EF%BC%9A"><span class="toc-text">Spring：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-spring%E4%B8%AD%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1.spring中的拦截器和过滤器有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Spring%E4%B8%AD%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98%E4%BD%A0%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-text">2. Spring中循环依赖的问题你有了解过吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%80%E8%88%AC%E5%9C%A8%E4%BD%BF%E7%94%A8Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E4%B8%80%E8%88%AC%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-text">3.一般在使用Spring事务的时候，事务失效一般有哪些原因？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Spring%E4%B8%AD%E6%B3%A8%E8%A7%A3%E4%BA%8B%E5%8A%A1%E5%85%B7%E4%BD%93%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%E7%9A%84%EF%BC%8C%E5%86%85%E9%83%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">4.Spring中注解事务具体是怎么实现事务的，内部是怎么实现的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%9A"><span class="toc-text">分布式、微服务：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%B9%E4%BA%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84RPC%E6%A1%86%E6%9E%B6%E9%83%BD%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">1.对于微服务中常见的RPC框架都知道哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-springcloud%E4%B8%AD%E7%9A%84%E7%86%94%E6%96%AD%E7%AD%96%E7%95%A5%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E6%AF%94%E5%A6%82%E4%B8%80%E4%B8%AA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%87%BA%E7%8E%B0%E4%BA%86%E5%BC%82%E5%B8%B8%EF%BC%8C%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-text">2.springcloud中的熔断策略了解吗？比如一个微服务出现了异常，怎么处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">3.分布式锁的实现方案有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%88%86%E5%B8%83%E5%BC%8Fid%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%94%9F%E6%88%90%E7%9A%84%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-text">4.分布式id有哪几种生成的策略？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A"><span class="toc-text">消息队列：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E5%A6%82kafka%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%8C%E6%9C%89%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-text">1.消息中间件比如kafka了解吗，有用过吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Security%EF%BC%9A"><span class="toc-text">Spring Security：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%82%A3%E5%AF%B9%E4%BA%8E%E5%AE%89%E5%85%A8%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E8%BF%99%E4%B8%80%E5%9D%97%E7%86%9F%E6%82%89%E5%90%97%EF%BC%9F%E5%B0%B1%E6%98%AF%E4%BD%A0%E7%8E%B0%E5%9C%A8%E6%9C%89%E5%BE%88%E5%A4%9A%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%8C%E9%80%9A%E8%BF%87%E7%BD%91%E5%85%B3%E6%8A%8A%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%88%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9D%97%E4%B8%AD%EF%BC%8C%E6%80%8E%E4%B9%88%E8%AF%86%E5%88%AB%E8%BA%AB%E4%BB%BD%EF%BC%9F"><span class="toc-text">1.那对于安全登录认证这一块熟悉吗？就是你现在有很多微服务，通过网关把请求转到微服务模块中，怎么识别身份？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86%EF%BC%9A"><span class="toc-text">手撕算法部分：</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/09/02/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93-%E4%B8%BB%E7%AE%A1%E9%9D%A2%E9%97%AE%E9%A2%98/" title="2023秋招总结-主管面问题"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2023秋招总结-主管面问题"/></a><div class="content"><a class="title" href="/2023/09/02/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93-%E4%B8%BB%E7%AE%A1%E9%9D%A2%E9%97%AE%E9%A2%98/" title="2023秋招总结-主管面问题">2023秋招总结-主管面问题</a><time datetime="2023-09-02T02:58:52.000Z" title="Created 2023-09-02 10:58:52">2023-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/02/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93-%E5%9C%BA%E6%99%AF%E9%A2%98/" title="2023秋招总结-场景题"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2023秋招总结-场景题"/></a><div class="content"><a class="title" href="/2023/09/02/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93-%E5%9C%BA%E6%99%AF%E9%A2%98/" title="2023秋招总结-场景题">2023秋招总结-场景题</a><time datetime="2023-09-02T02:58:18.000Z" title="Created 2023-09-02 10:58:18">2023-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/18/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93-%E5%85%AB%E8%82%A1/" title="2023秋招总结-八股"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2023秋招总结-八股"/></a><div class="content"><a class="title" href="/2023/08/18/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93-%E5%85%AB%E8%82%A1/" title="2023秋招总结-八股">2023秋招总结-八股</a><time datetime="2023-08-18T07:55:02.000Z" title="Created 2023-08-18 15:55:02">2023-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/15/Redis%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/" title="Redis原理学习"><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727134719639.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis原理学习"/></a><div class="content"><a class="title" href="/2023/08/15/Redis%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/" title="Redis原理学习">Redis原理学习</a><time datetime="2023-08-15T08:10:37.000Z" title="Created 2023-08-15 16:10:37">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/10/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/" title="java基础复习"><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230810141014749.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java基础复习"/></a><div class="content"><a class="title" href="/2023/08/10/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/" title="java基础复习">java基础复习</a><time datetime="2023-08-10T06:08:10.000Z" title="Created 2023-08-10 14:08:10">2023-08-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 By donn</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">很高兴认识你🤪</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>