<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>java基础复习 | donn的博客</title><meta name="author" content="donn"><meta name="copyright" content="donn"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文根据作者对java基础的掌握程度而写，只记录了我自己容易遗忘的点，可能并不适合java新手学习😵‍💫 1.深拷贝、浅拷贝以及引用拷贝： 2.Object类中的常见方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344&#x2F;** * native 方法，用于返回当前运行时对象的 Clas">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础复习">
<meta property="og:url" content="https://tangjiayang.github.io/2023/08/10/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="donn的博客">
<meta property="og:description" content="本文根据作者对java基础的掌握程度而写，只记录了我自己容易遗忘的点，可能并不适合java新手学习😵‍💫 1.深拷贝、浅拷贝以及引用拷贝： 2.Object类中的常见方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344&#x2F;** * native 方法，用于返回当前运行时对象的 Clas">
<meta property="og:locale">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230810141014749.png">
<meta property="article:published_time" content="2023-08-10T06:08:10.000Z">
<meta property="article:modified_time" content="2023-12-12T13:43:45.853Z">
<meta property="article:author" content="donn">
<meta property="article:tag" content="java">
<meta property="article:tag" content="语言基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230810141014749.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://tangjiayang.github.io/2023/08/10/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":30,"languages":{"author":"Author: donn","link":"Link: ","source":"Source: donn的博客","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java基础复习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-12 21:43:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/bg.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">13</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230810141014749.png')"><nav id="nav"><span id="blog-info"><a href="/" title="donn的博客"><span class="site-name">donn的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java基础复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-08-10T06:08:10.000Z" title="Created 2023-08-10 14:08:10">2023-08-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-12-12T13:43:45.853Z" title="Updated 2023-12-12 21:43:45">2023-12-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java%E5%9F%BA%E7%A1%80/">java基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">6.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>20min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java基础复习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本文根据作者对java基础的掌握程度而写，只记录了我自己容易遗忘的点，可能并不适合java新手学习😵‍💫</p>
<h3 id="1-深拷贝、浅拷贝以及引用拷贝："><a href="#1-深拷贝、浅拷贝以及引用拷贝：" class="headerlink" title="1.深拷贝、浅拷贝以及引用拷贝："></a>1.深拷贝、浅拷贝以及引用拷贝：</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230810141303963.png" alt="image-20230810141303963"></p>
<h3 id="2-Object类中的常见方法："><a href="#2-Object类中的常见方法：" class="headerlink" title="2.Object类中的常见方法："></a>2.Object类中的常见方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * naitive 方法，用于创建并返回当前对象的一份拷贝。 ⚠️浅拷贝</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-hashCode-和-equals"><a href="#3-hashCode-和-equals" class="headerlink" title="3.hashCode() 和 equals()"></a>3.hashCode() 和 equals()</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/skywang12345/p/3324958.html">Java hashCode() 和 equals()的若干问题解答</a></p>
<h3 id="4-字符串相关"><a href="#4-字符串相关" class="headerlink" title="4.字符串相关"></a>4.字符串相关</h3><p>​	</p>
<h4 id="String-不可变"><a href="#String-不可变" class="headerlink" title="String:不可变"></a>String:不可变</h4><p>​	原因是	String底层使用private、final修饰一个char[]，而且并不把修改该char[]的方法暴露，因此不可变</p>
<p>​	java9之后，String使用 byte[] 存储内容 ——原因是：</p>
<ul>
<li>byte的存储空间为1B；char为2B<ul>
<li>大多数情况下 1B的空间能表示我们使用的字符—-使用Latin-1编码方式</li>
<li>当我们使用到一些特殊字符时，才会用2个byte存储一个字符(此时存储效率与使用char一样)</li>
</ul>
</li>
</ul>
<p>​	</p>
<h4 id="字符串拼接："><a href="#字符串拼接：" class="headerlink" title="字符串拼接："></a>字符串拼接：</h4><p>Java 语言本身并不支持运算符重载，“+”和“+&#x3D;”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。</p>
<p>​	🌟String 对象通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<p>​	🌟不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个</strong> <strong><code>StringBuilder</code></strong> <strong>以复用，会导致创建过多的</strong> <strong><code>StringBuilder</code></strong> <strong>对象</strong>。</p>
<h4 id="字符串常量池的作用了解吗？"><a href="#字符串常量池的作用了解吗？" class="headerlink" title="字符串常量池的作用了解吗？"></a>字符串常量池的作用了解吗？</h4><p>JDK1.7后，字符串常量池在堆中</p>
<p>​	<strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了<u>避免字符串的重复创建。</u></p>
<p>🍓<strong>字符串常量池保存的是</strong>：<u>字符串（key）</u>和 <u>字符串对象的引用（value）</u>的映射关系(维护了一个HashMap)，字符串对象的引用指向堆中的字符串对象。</p>
<p>因此如果在常量池中找不到某字符串，会<u>在堆中创建以该字符串生成的String对象，再将其地址存储到常量池HashMap的Value中</u>！</p>
<p>至此，常量池中增加了一个字符串常量。</p>
<p>因此面对问题：String s1 &#x3D; new String(“abc”);创建了几个String对象？</p>
<p>—1.为s1创建一个空的String对象，</p>
<ul>
<li>如果常量池中没有“abc”，那么首先还需要在堆中创建一个存储了“abc”的String对象，将该对象的引用存入常量池，再为 为s1创建的对象 赋值，因此创建了2个String对象</li>
<li>如果常量池中有“abc”，那么直接为 为s1创建的对象 赋值即可，只创建了一个对象。</li>
</ul>
<h4 id="intern-方法有什么作用"><a href="#intern-方法有什么作用" class="headerlink" title="intern 方法有什么作用?"></a>intern 方法有什么作用?</h4><p>​	<code>String.intern()</code> 是一个 native（本地）方法，其作用是**<u>将指定的字符串对象的引用保存在字符串常量池中</u>**，可以简单分为两种情况：</p>
<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li>
<li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”Java“</span></span><br><span class="line"><span class="comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="comment">// 会在堆中在单独创建一个字符串对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s3.intern();</span><br><span class="line"><span class="comment">// s1 和 s2 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s2); </span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// s3 和 s4 指向的是堆中不同的对象</span></span><br><span class="line">System.out.println(s3 == s4); </span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// s1 和 s4 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s4); </span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>





<h3 id="5-包装类型的缓存机制了解么？"><a href="#5-包装类型的缓存机制了解么？" class="headerlink" title="5.包装类型的缓存机制了解么？"></a>5.包装类型的缓存机制了解么？</h3><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<h4 id="⚠️包装类等值比较的注意点："><a href="#⚠️包装类等值比较的注意点：" class="headerlink" title="⚠️包装类等值比较的注意点："></a>⚠️包装类等值比较的注意点：<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230811093744235.png" alt="image-20230811093744235"></h4><h3 id="6-为什么浮点数运算的时候会有精度丢失的风险？"><a href="#6-为什么浮点数运算的时候会有精度丢失的风险？" class="headerlink" title="6.为什么浮点数运算的时候会有精度丢失的风险？"></a>6.为什么浮点数运算的时候会有精度丢失的风险？</h3><p>浮点数运算精度丢失代码演示：</p>
<p>float a &#x3D; 2.0f - 1.9f; float b &#x3D; 1.8f - 1.7f;</p>
<p>System.out.println(a);		&#x2F;&#x2F; 0.100000024 </p>
<p>System.out.println(b);		&#x2F;&#x2F; 0.099999905 </p>
<p>System.out.println(a &#x3D;&#x3D; b);		&#x2F;&#x2F; false</p>
<p>为什么会出现这个问题呢？</p>
<p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p>
<h3 id="7-如何解决浮点数运算的精度丢失问题？"><a href="#7-如何解决浮点数运算的精度丢失问题？" class="headerlink" title="7.如何解决浮点数运算的精度丢失问题？"></a>7.如何解决浮点数运算的精度丢失问题？</h3><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b); </span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c); </span><br><span class="line"></span><br><span class="line">System.out.println(x);				   <span class="comment">//0.1</span></span><br><span class="line"></span><br><span class="line">System.out.println(y); 				  <span class="comment">//0.1</span></span><br><span class="line"></span><br><span class="line">System.out.println(Objects.equals(x, y));  	<span class="comment">//true </span></span><br></pre></td></tr></table></figure>



<h3 id="8-如何实现数组和-List-之间的转换？"><a href="#8-如何实现数组和-List-之间的转换？" class="headerlink" title="8.如何实现数组和 List 之间的转换？"></a>8.如何实现数组和 List 之间的转换？</h3><ul>
<li>数组转 List：使用 Arrays. asList(array) 进行转换。</li>
<li>List 转数组：使用 List 自带的 toArray() 方法。</li>
</ul>
<h3 id="9-CAS原理"><a href="#9-CAS原理" class="headerlink" title="9.CAS原理"></a>9.CAS原理</h3><p>内存中：</p>
<ul>
<li>待修改的值</li>
</ul>
<p>线程持有：</p>
<ul>
<li>预期值</li>
<li>新值</li>
</ul>
<p>工作方式：线程想要修改内存中的一个值，那么该线程先**<u>从内存中读取该值，作为预期值</u><strong>，在进行业务流程后</strong><u>生成新值</u>**，在修改内存中值之前进行判断：</p>
<p><em>1.如果预期值 &#x3D;&#x3D; 待修改的值</em>，说明在此期间该‘值’未发生改变，线程便可以将内存中的旧值替换为新值。</p>
<p><em>2.如果预期值 !&#x3D; 待修改的值</em>，说明在此期间值发生了改变，线程不能进行修改，常见的应对措施是：<u>重新获取预期值和计算新值，再次进行判断。。</u></p>
<p>​	⚠️在*1.*中，在此期间该‘值’未发生改变的情况下 可能发生ABA问题，这种情况下本应重试，不允许修改，但是CAS却检测不出来</p>
<p>解决方案：添加一个序号(或 时间戳)</p>
<h1 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h1><h3 id="ArrayList源码学习"><a href="#ArrayList源码学习" class="headerlink" title="ArrayList源码学习"></a>ArrayList源码学习</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7056709563860385822?searchId=20230913151916438B638FBB6D1628A413">参考文章</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化 ID</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认初始容量大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空数组，用于空实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于默认大小空实例的共享空数组实例。</span></span><br><span class="line"><span class="comment">// 我们把它从 EMPTY_ELEMENTDATA 数组中区分出来，以知道在添加第一个元素时容量需要增加多少</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存数据的数组，所以说 ArrayList 的底层是数组，只不过能动态增长而已</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure>

<h4 id="ArrayList-中的elementData对象被transient修饰，原因是："><a href="#ArrayList-中的elementData对象被transient修饰，原因是：" class="headerlink" title="ArrayList 中的elementData对象被transient修饰，原因是："></a>ArrayList 中的elementData对象被transient修饰，原因是：</h4><ul>
<li>transient修饰的变量不会被序列化，但是ArrayList底层在序列化时，会调用自己重新实现的 <code>writeObject()</code> 和 <code>readObject()</code> 这两个方法来序列化数组元素，<u>目的是防止ArrayList中开辟了空间但是没有被使用的空间也被序列化</u></li>
<li>ArrayList底层重新实现的 <code>writeObject()</code> 和 <code>readObject()</code> 中，序列化elementData时是读取了size然后一个一个进行序列化传输的。即：**<u>ArrayList 重写了 JDK 序列化的逻辑，只把 elementData 数组中有效元素的部分序列化，而不会序列化整个数组。</u>**</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素方法</span></span><br><span class="line"><span class="comment"> * 在添加元素前会先调用 ensureCapacityInternal() 方法判断是否需要扩容</span></span><br><span class="line"><span class="comment"> * 然后再将元素添加到数组的尾部</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否需要扩容方法，注意这里传的参数是 元素个数 + 1</span></span><br><span class="line">    <span class="comment">// 1 代表的是新添加的元素</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 追加的数组的尾部</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先调用 calculateCapacity 判断是否是空数组！</span></span><br><span class="line"><span class="comment"> * 再调用 ensureExplicitCapacity() 方法进行进一步处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是空数组，如果是空数组，则比较默认容量 10 和 元素个数 + 1 的大小</span></span><br><span class="line"><span class="comment"> * 二者取最大值，然后返回</span></span><br><span class="line"><span class="comment"> * 得到最小扩容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ArrayList扩容机制："><a href="#ArrayList扩容机制：" class="headerlink" title="ArrayList扩容机制："></a>ArrayList扩容机制：</h4><p>ArrayList通过空构造方法时并不会创建默认大小的elementData，而是让elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA这个空数组，<strong>在添加元素时，ArrayList会先看看elementData是否为空数组，是的话就给他赋值为默认大小的数组，再使用ensureCapacityInternal(size + 1) 来判断现在elementData的大小是否能放入size + 1个元素，如果不行则扩容。</strong></p>
<h4 id="🌟ArrayList源码中有个参数叫做-modCount，它有什么用？"><a href="#🌟ArrayList源码中有个参数叫做-modCount，它有什么用？" class="headerlink" title="🌟ArrayList源码中有个参数叫做 modCount，它有什么用？"></a>🌟ArrayList源码中有个参数叫做 modCount，它有什么用？</h4><p>​	它很像乐观锁的版本检测的过程</p>
<ul>
<li><p>modcount（modification count）是一种用于记录数据结构变化状态的计数器，通常用于在迭代器中实现快速失败（fail-fast）机制。</p>
</li>
<li><p>在一些数据结构（如ArrayList、HashMap等）中，当数据结构发生变化（如增删元素）时，会增加modcount的值。<strong>当迭代器开始遍历数据结构时，会将当前的modcount值保存下来。在每次迭代器执行操作时，会检查当前的modcount值是否与保存的值相等。</strong>如果不相等，就表示数据结构发生了变化，迭代器会立即抛出ConcurrentModificationException异常，实现了快速失败。</p>
</li>
<li><p>modcount的作用是在并发环境中，保证多个线程之间不会产生隐患的访问竞态条件。通过检查modcount值，可以检测到其他线程对数据结构的修改，从而及时发现并防止遍历过程中的异常情况发生。</p>
</li>
<li><p>需要注意的是，modcount并不提供线程安全性。在并发环境中操作modcount和数据结构仍然需要使用适当的同步机制来保证线程安全性。modcount的主要作用是实现快速失败机制，及时检测并发修改，而不是作为线程同步的方法。</p>
</li>
</ul>
<h3 id="ConcurrentHashMap："><a href="#ConcurrentHashMap：" class="headerlink" title="ConcurrentHashMap："></a>ConcurrentHashMap：</h3><h4 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7:"></a>JDK1.7:</h4><h5 id="1-Segment-段："><a href="#1-Segment-段：" class="headerlink" title="1.Segment 段："></a>1.Segment 段：</h5><p>​	ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。</p>
<p>​	整个 ConcurrentHashMap 由一个个 Segment 组成， Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为<strong>分段锁</strong>。注意，行文中，我很多地方用了“槽”来代表一个segment。</p>
<h5 id="2-线程安全（Segment-继承-ReentrantLock-加锁）："><a href="#2-线程安全（Segment-继承-ReentrantLock-加锁）：" class="headerlink" title="2.线程安全（Segment 继承 ReentrantLock 加锁）："></a>2.线程安全（Segment 继承 ReentrantLock 加锁）：</h5><p>​	简单理解就是， <u>ConcurrentHashMap 是一个 Segment 数组， Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</u></p>
<h5 id="3-并行度（默认-16）："><a href="#3-并行度（默认-16）：" class="headerlink" title="3.并行度（默认 16）："></a>3.并行度（默认 16）：</h5><p>​	concurrencyLevel：并行级别、并发数、 Segment 数，默认是 16，</p>
<p>​	即 <strong>ConcurrentHashMap 有 16 个 Segments</strong>，所以理论上，<u>最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上</u>。这个值可以在初始化的时候设置为其他值<u>，但是一旦初始化以后，它是不可以扩容的</u>。再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</p>
<h5 id="🌟segment-数量在-ConcurrentHashMap-初始化后就不可改变"><a href="#🌟segment-数量在-ConcurrentHashMap-初始化后就不可改变" class="headerlink" title="🌟segment 数量在 ConcurrentHashMap 初始化后就不可改变"></a>🌟segment 数量在 ConcurrentHashMap 初始化后就不可改变</h5><h5 id="🌟每个-segment-中的hashmap大小可扩容，类似HashMap"><a href="#🌟每个-segment-中的hashmap大小可扩容，类似HashMap" class="headerlink" title="🌟每个 segment 中的hashmap大小可扩容，类似HashMap"></a>🌟每个 segment 中的hashmap大小可扩容，类似HashMap</h5><p>​	线程<strong>写</strong>一个segment时，需要获取该segment代表的ReentrantLock，**<u>读取数据并不需要获取锁</u>**，因此<u>只有多个线程同时在写一个segment时才会发生冲突，这时未抢到锁的线程将被阻塞！！！</u></p>
<h4 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8:"></a>JDK1.8:</h4><p>​	由于JDK1.7中segment使用拉链法解决hash冲突，链表过长会导致性能下降。</p>
<p>​	JDK1.8中当链表长度&gt;8时，会自动转换成红黑树存储</p>
<p>并且使用 <strong>CAS + synchronized</strong> 来保证并发的安全性，**<u>只锁定当前链表或红黑二叉树的首节点</u>**，只要节点 hash 不冲突，就不会产生并发，相比 JDK1.7 的 ConcurrentHashMap 效率又提升了 N 倍！</p>
<p><a href="https://security.feishu.cn/link/safety?target=https://pdai.tech/md/java/thread/java-thread-x-juc-collection-ConcurrentHashMap.html%23juc%E9%9B%86%E5%90%88-concurrenthashmap%E8%AF%A6%E8%A7%A3&scene=ccm&logParams=%7B%22location%22:%22ccm_default%22%7D&lang=zh-CN">JUC集合: ConcurrentHashMap详解</a></p>
<h1 id="枚举类："><a href="#枚举类：" class="headerlink" title="枚举类："></a>枚举类：</h1><p>demo Code:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">DemoEnum</span> &#123;</span><br><span class="line">    RED(<span class="string">&quot;r&quot;</span>, <span class="string">&quot;🌹&quot;</span>),</span><br><span class="line">    BLUE(<span class="string">&quot;g&quot;</span>, <span class="string">&quot;wdwd&quot;</span>),</span><br><span class="line">    GREEN(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;ewdwdwdadw&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    DemoEnum(String color, String desc) &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(DemoEnum.RED.color);</span><br><span class="line">        System.out.println(DemoEnum.RED.desc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">  r</span><br><span class="line">  🌹</span><br></pre></td></tr></table></figure>



<p>其中：Red、Blue、Green被称为**<u>枚举常量</u>**</p>
<p>枚举常量可以对应有多个属性，如上述枚举类中的“color”，“desc”</p>
<p>⚠️：在外部类想要访问如<code>DemoEnum.Red.color</code>的话，由于color、desc都是private属性，我们需要在DemoEnum中自定义有关私有属性的访问方法。</p>
<ul>
<li>枚举常量：RED、BLUE、GREEN  是枚举类 DemoEnum 的三个实例化对象，它们是唯一的、已命名的常量。( 而(“r”, “🌹”) 就是构造RED这个实例化对象的初始变量 )</li>
<li>构造方法：枚举类的构造方法<strong>默认是私有</strong>的，只能在枚举类内部使用。在这个示例中，使用私有构造方法来为每个枚举常量设置对应的颜色和原始值。</li>
<li>values() 方法：这个示例在 main() 方法中使用 TestEnum.values() 方法<strong>获取 DemoEnum 枚举类中的所有枚举常量，</strong>并进行遍历输出。</li>
<li>valueOf(String name) 方法：通过 TestEnum.valueOf(“RED”) 可以获取枚举常量名为 “RED” 的<strong>枚举对象</strong>。</li>
<li>ordinal() 方法：枚举常量的 ordinal() 方法返回它们在枚举类型中定义的顺序值（<strong>下标</strong>，从0开始）。</li>
<li>compareTo() 方法：通过 RED.compareTo(BLACK) 和 BLACK.compareTo(GREEN) 可以比较两个枚举常量的顺序，返回一个整数值。</li>
</ul>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li><p>易读性和可维护性：枚举类型中的常量是有意义的、自描述的，使得代码更易读、易理解和易于维护。枚举常量具有唯一的名称，提供了更好的文档和注释。</p>
</li>
<li><p>类型安全：枚举类型在编译时进行静态类型检查，这意味着编译器可以确保只使用有效的枚举常量，提供了更高的类型安全性。</p>
</li>
<li><p>可限定的值集合：枚举类型定义了一个有限的值集合，限定了有效的取值范围。这可以帮助避免程序中出现无效或意外的取值。</p>
</li>
<li><p>避免魔法数值：使用枚举类型可以避免使用硬编码的魔法数值，提供了更好的代码可读性和可维护性。</p>
</li>
<li><p>增强的编译器支持：枚举类型在编译器层面提供了一些额外的支持，如自动添加常用方法（如values()、valueOf()）、枚举常量的顺序等。</p>
</li>
<li><p>适用于状态和选项的表示：枚举类型非常适用于表示状态、选项和固定集合，如季节、颜色、星期几等。</p>
</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li><p>不适用于动态变化的数据：枚举类型是在编译时定义的，其常量集合是固定的。如果需要表示动态变化的数据集合，枚举类型可能不适合。</p>
</li>
<li><p>不适用于大型数据集合：如果需要表示大型的数据集合，枚举类型的常量定义可能会变得冗长和繁琐。</p>
</li>
<li><p>缺乏扩展性：枚举类型的常量是在编译时确定的，不支持动态添加或删除常量。因此，如果需要频繁地修改常量集合，可能会导致代码的改动和维护成本的增加。</p>
</li>
<li><p>不支持继承：枚举类型不支持继承，无法实现枚举类型之间的继承关系。</p>
</li>
</ul>
<h1 id="异常分类及处理"><a href="#异常分类及处理" class="headerlink" title="异常分类及处理"></a>异常分类及处理</h1><h4 id="4-1-1-异常概念"><a href="#4-1-1-异常概念" class="headerlink" title="4.1.1. 异常概念"></a>4.1.1. 异常概念</h4><p>​	如果某个方法不能按照正常的途径完成任务，就可以通过另一种路径退出方法。在这种情况下会抛出一个封装了错误信息的对象。此时，这个方法会立刻退出同时不返回任何值。另外，调用这个方法的其他代码也无法继续执行，异常处理机制会将代码执行交给异常处理器。</p>
<h4 id="4-1-2-异常分类"><a href="#4-1-2-异常分类" class="headerlink" title="4.1.2. 异常分类"></a>4.1.2. 异常分类</h4><p><strong><u>Throwable</u></strong> 是 Java 语言中所有错误或异常的超类。下一层分为 <u>Error 和 Exception</u></p>
<h5 id="Error-非检查异常-："><a href="#Error-非检查异常-：" class="headerlink" title="Error (非检查异常)："></a>Error (非检查异常)：</h5><ul>
<li>Error 类是指 java <u>运行时系统的内部错误和资源耗尽错误</u>。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。</li>
</ul>
<h5 id="Exception（-RuntimeException-非检查异常-、-CheckedException-检查异常-）："><a href="#Exception（-RuntimeException-非检查异常-、-CheckedException-检查异常-）：" class="headerlink" title="Exception（ RuntimeException(非检查异常)、 CheckedException(检查异常) ）："></a>Exception（ RuntimeException(非检查异常)、 CheckedException(检查异常) ）：</h5><ul>
<li><p>Exception 又 有 两 个 分 支 ， <u>运行时异常(非检查异常)</u> RuntimeException ， <u>检查异常</u>CheckedException。</p>
<ul>
<li><p>RuntimeException 如 ： NullPointerException 、 ClassCastException ； <u><strong>RuntimeException 是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 如果出现 RuntimeException，那么一定是程序员的错误。</strong></u></p>
<ul>
<li>比如除数为 0 错误 ArithmeticException，强制类型转换错误 ClassCastException，数组索引越界ArrayIndexOutOfBoundsException，使用了空对象NullPointerException等等</li>
</ul>
</li>
<li><p>CheckedException如 ： I&#x2F;O 错误导致的 IOException、 SQLException。一般是外部错误，<u>这种异常都发生在编译阶段</u>， **<u>Java 编译器会强制程序去捕获此类异常，即会出现要求你把这段可能出现异常的程序进行 try catch</u>**，该类异常一般包括几个方面：</p>
<ul>
<li>试图在文件尾部读取数据</li>
<li>试图打开一个错误格式的 URL</li>
<li>试图根据给定的字符串查找 class 对象，而这个字符串表示的类并不存在</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-1-3-三种处理方式"><a href="#4-1-3-三种处理方式" class="headerlink" title="4.1.3.三种处理方式"></a>4.1.3.三种处理方式</h4><ul>
<li>在try-catch中自定义throw错误信息</li>
<li>throws给上层</li>
<li>啥也不做，系统默认帮你抛异常</li>
</ul>
<h4 id="4-1-4-Throw-和-throws-的区别："><a href="#4-1-4-Throw-和-throws-的区别：" class="headerlink" title="4.1.4. Throw 和 throws 的区别："></a>4.1.4. Throw 和 throws 的区别：</h4><h5 id="位置不同："><a href="#位置不同：" class="headerlink" title="位置不同："></a>位置不同：</h5><pre><code>1. throws 用在方法上，后面跟的是&lt;u&gt;异常类，可以跟多个&lt;/u&gt;； 而 throw 用在函数内，后面跟的是&lt;u&gt;异常对象&lt;/u&gt;。
</code></pre>
<h5 id="功能不同："><a href="#功能不同：" class="headerlink" title="功能不同："></a>功能不同：</h5><ol start="2">
<li><p>throws 用来<u><strong>声明异常，让调用者只知道该功能可能出现的问题，可以给出预先的处理方式</strong></u>； throw <u><strong>抛出具体的问题对象，执行到 throw，功能就已经结束了，跳转到调用者，并将具体的问题对象抛给调用者</strong></u>。也就是说 throw 语句独立存在时，下面不要定义其他语句，因为执行不到。</p>
</li>
<li><p>🌟throws 表示出现异常的一种<strong>可能性</strong>，并<strong>不一定会发生这些异常</strong>； throw 则是<u>抛出了异常</u>，<u>执行 throw 则一定抛出了某种异常对象。</u></p>
</li>
<li><p>两者都是消极处理异常的方式，<u>只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理</u>。</p>
</li>
</ol>
<h4 id="4-1-5-try-cache-finally-与try-with-resources"><a href="#4-1-5-try-cache-finally-与try-with-resources" class="headerlink" title="4.1.5 try-cache-finally 与try-with-resources"></a>4.1.5 try-cache-finally 与try-with-resources</h4><p><code>try-finally</code> 是java SE7之前我们处理一些需要关闭的资源的做法，无论是否出现异常都要对资源进行关闭。</p>
<p><strong>如果try块和finally块中的方法都抛出异常那么try块中的异常会被抑制（suppress），只会抛出finally中的异常，而把try块的异常完全忽略。</strong></p>
<p>这里如果我们用<code>catch</code>语句去获得<code>try</code>块的异常，也没有什么影响，<code>catch</code>块虽然能获取到<code>try</code>块的异常但是对函数运行结束抛出的异常并没有什么影响。</p>
<p>try-with-resources语句能够帮你自动调用资源的close()函数关闭资源不用到finally块。<br>前提是<strong>只有实现了Closeable接口的才能自动关闭</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">(String path, Consumer&lt;String&gt; consumer)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path))) &#123;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span> )&#123;</span><br><span class="line">            consumer.accept(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是<code>try-with-resources</code>语句的结构，在try关键字后面的( )里<code>new</code>一些需要自动关闭的资源。</p>
<p>这个时候如果方法 <code>readLine</code> 和自动关闭资源的过程都抛出异常，那么：</p>
<ul>
<li><strong>函数执行结束之后抛出的是try块的异常</strong>，而try-with-resources语句<u>关闭过程中的异常</u>会被抑制，放在try块抛出的异常的一个数组里。（上面的非try-with-resources例子抛出的是finally的异常，而且try块的异常也不会放在fianlly抛出的异常的抑制数组里）</li>
<li>可以通过异常的<code>public final synchronized Throwable[] getSuppressed()</code> 方法获得一个被抑制异常的数组。</li>
<li><code>try</code>块抛出的异常调用<code>getSuppressed()</code>方法获得一个被它抑制的异常的数组，其中就有关闭资源的过程产生的异常。</li>
</ul>
<h5 id="try-with-resources-语句能放多个资源-使用-分割"><a href="#try-with-resources-语句能放多个资源-使用-分割" class="headerlink" title="try-with-resources 语句能放多个资源,使用 ; 分割"></a>try-with-resources 语句能放多个资源,使用 <code>;</code> 分割</h5><p>​	最后任务执行完毕或者出现异常中断之后是根据<code>new</code>的反向顺序调用各资源的<code>close()</code>的。后<code>new</code>的先关。</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h4 id="4-2-1-反射机制概念"><a href="#4-2-1-反射机制概念" class="headerlink" title="4.2.1.反射机制概念"></a>4.2.1.反射机制概念</h4><p>在 Java 中的反射机制是指<u>在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；</u>并且<u>对于任意一个对象，都能够调用它的任意一个方法</u>；这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制。</p>
<h4 id="4-2-2-反射的应用场合"><a href="#4-2-2-反射的应用场合" class="headerlink" title="4.2.2. 反射的应用场合"></a>4.2.2. 反射的应用场合</h4><p>🌟：</p>
<p>​	<u>程序在运行时还可能接收到外部传入的对象， 该对象的编译时类型为 Object,但是程序有需要调用该对象的运行时类型的方法</u>。为了解决这些问题， 程序需要在运行时发现对象和类的真实信息。然而，如果编译时根本无法预知该对象和类属于哪些类，程序只能依靠运行时信息来发现该对象和类的真实信息，此时就必须使用到反射了。</p>
<h4 id="4-2-3-Java-反射"><a href="#4-2-3-Java-反射" class="headerlink" title="4.2.3. Java 反射"></a>4.2.3. Java 反射</h4><p>API反射 API 用来生成 JVM 中的类、接口或则对象的信息。</p>
<pre><code>1. Class 类：反射的核心类，可以获取类的属性，方法等信息。
</code></pre>
<ol start="2">
<li><p>Field 类： Java.lang.reflec 包中的类， 表示类的<u><strong>成员变量</strong></u>，可以用来获取和设置类之中的属性值。</p>
</li>
<li><p>Method 类： Java.lang.reflec 包中的类，表示<u><strong>类的方法</strong></u>，它可以用来获取类中的方法信息或者执行方法。</p>
</li>
<li><p>Constructor 类： Java.lang.reflec 包中的类，表示<u><strong>类的构造方法</strong></u>。</p>
</li>
</ol>
<h4 id="4-2-4-反射使用步骤（获取-Class-对象、调用对象方法）"><a href="#4-2-4-反射使用步骤（获取-Class-对象、调用对象方法）" class="headerlink" title="4.2.4. 反射使用步骤（获取 Class 对象、调用对象方法）"></a>4.2.4. 反射使用步骤（获取 Class 对象、调用对象方法）</h4><ol>
<li><p><u>获取想要操作的类的 Class 对象</u>，他是反射的核心，通过 Class 对象我们可以任意调用类的方法。</p>
</li>
<li><p><u>调用 Class 类中的方法</u>，既就是反射的使用阶段。</p>
</li>
<li><p>使用反射 API 来操作这些信息。</p>
</li>
</ol>
<p>具体使用看java基础</p>
<p>反射、注解、内部类、泛型、序列化等看javaguide吧</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://Tangjiayang.github.io">donn</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://tangjiayang.github.io/2023/08/10/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/">https://tangjiayang.github.io/2023/08/10/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">语言基础</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230810141014749.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/15/Redis%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/" title="Redis原理学习"><img class="cover" src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727134719639.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Redis原理学习</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">计算机网络</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/09/21/java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0/" title="java8新特性学习"><img class="cover" src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230810141014749.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-21</div><div class="title">java8新特性学习</div></div></a></div><div><a href="/2023/09/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="java并发编程"><img class="cover" src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230810141014749.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-11</div><div class="title">java并发编程</div></div></a></div><div><a href="/2023/05/26/JVM%E6%8E%A2%E7%A9%B6/" title="JVM探究"><img class="cover" src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230810141014749.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-26</div><div class="title">JVM探究</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81ODUzNy8zNTAwMA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/bg.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">donn</div><div class="author-info__description">一起学习，一起进步吧😁</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Tangjiayang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Tangjiayang" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">小站成立于2023-5-27！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%BB%A5%E5%8F%8A%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D%EF%BC%9A"><span class="toc-text">1.深拷贝、浅拷贝以及引用拷贝：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Object%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">2.Object类中的常见方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-hashCode-%E5%92%8C-equals"><span class="toc-text">3.hashCode() 和 equals()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3"><span class="toc-text">4.字符串相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String-%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-text">String:不可变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%EF%BC%9A"><span class="toc-text">字符串拼接：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">字符串常量池的作用了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#intern-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-text">intern 方法有什么作用?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F"><span class="toc-text">5.包装类型的缓存机制了解么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F%E5%8C%85%E8%A3%85%E7%B1%BB%E7%AD%89%E5%80%BC%E6%AF%94%E8%BE%83%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9A"><span class="toc-text">⚠️包装类等值比较的注意点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%9A%E6%9C%89%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="toc-text">6.为什么浮点数运算的时候会有精度丢失的风险？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">7.如何解决浮点数运算的精度丢失问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%92%8C-List-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-text">8.如何实现数组和 List 之间的转换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-CAS%E5%8E%9F%E7%90%86"><span class="toc-text">9.CAS原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-text">集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0"><span class="toc-text">ArrayList源码学习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-%E4%B8%AD%E7%9A%84elementData%E5%AF%B9%E8%B1%A1%E8%A2%ABtransient%E4%BF%AE%E9%A5%B0%EF%BC%8C%E5%8E%9F%E5%9B%A0%E6%98%AF%EF%BC%9A"><span class="toc-text">ArrayList 中的elementData对象被transient修饰，原因是：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-text">ArrayList扩容机制：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8C%9FArrayList%E6%BA%90%E7%A0%81%E4%B8%AD%E6%9C%89%E4%B8%AA%E5%8F%82%E6%95%B0%E5%8F%AB%E5%81%9A-modCount%EF%BC%8C%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-text">🌟ArrayList源码中有个参数叫做 modCount，它有什么用？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap%EF%BC%9A"><span class="toc-text">ConcurrentHashMap：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-7"><span class="toc-text">JDK1.7:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Segment-%E6%AE%B5%EF%BC%9A"><span class="toc-text">1.Segment 段：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%88Segment-%E7%BB%A7%E6%89%BF-ReentrantLock-%E5%8A%A0%E9%94%81%EF%BC%89%EF%BC%9A"><span class="toc-text">2.线程安全（Segment 继承 ReentrantLock 加锁）：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%B9%B6%E8%A1%8C%E5%BA%A6%EF%BC%88%E9%BB%98%E8%AE%A4-16%EF%BC%89%EF%BC%9A"><span class="toc-text">3.并行度（默认 16）：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%8C%9Fsegment-%E6%95%B0%E9%87%8F%E5%9C%A8-ConcurrentHashMap-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%8E%E5%B0%B1%E4%B8%8D%E5%8F%AF%E6%94%B9%E5%8F%98"><span class="toc-text">🌟segment 数量在 ConcurrentHashMap 初始化后就不可改变</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%8C%9F%E6%AF%8F%E4%B8%AA-segment-%E4%B8%AD%E7%9A%84hashmap%E5%A4%A7%E5%B0%8F%E5%8F%AF%E6%89%A9%E5%AE%B9%EF%BC%8C%E7%B1%BB%E4%BC%BCHashMap"><span class="toc-text">🌟每个 segment 中的hashmap大小可扩容，类似HashMap</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-8"><span class="toc-text">JDK1.8:</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%EF%BC%9A"><span class="toc-text">枚举类：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">缺点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB%E5%8F%8A%E5%A4%84%E7%90%86"><span class="toc-text">异常分类及处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E5%BC%82%E5%B8%B8%E6%A6%82%E5%BF%B5"><span class="toc-text">4.1.1. 异常概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB"><span class="toc-text">4.1.2. 异常分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Error-%E9%9D%9E%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8-%EF%BC%9A"><span class="toc-text">Error (非检查异常)：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Exception%EF%BC%88-RuntimeException-%E9%9D%9E%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8-%E3%80%81-CheckedException-%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8-%EF%BC%89%EF%BC%9A"><span class="toc-text">Exception（ RuntimeException(非检查异常)、 CheckedException(检查异常) ）：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-%E4%B8%89%E7%A7%8D%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">4.1.3.三种处理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-Throw-%E5%92%8C-throws-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">4.1.4. Throw 和 throws 的区别：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE%E4%B8%8D%E5%90%8C%EF%BC%9A"><span class="toc-text">位置不同：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E4%B8%8D%E5%90%8C%EF%BC%9A"><span class="toc-text">功能不同：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-5-try-cache-finally-%E4%B8%8Etry-with-resources"><span class="toc-text">4.1.5 try-cache-finally 与try-with-resources</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#try-with-resources-%E8%AF%AD%E5%8F%A5%E8%83%BD%E6%94%BE%E5%A4%9A%E4%B8%AA%E8%B5%84%E6%BA%90-%E4%BD%BF%E7%94%A8-%E5%88%86%E5%89%B2"><span class="toc-text">try-with-resources 语句能放多个资源,使用 ; 分割</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%A6%82%E5%BF%B5"><span class="toc-text">4.2.1.反射机制概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E5%90%88"><span class="toc-text">4.2.2. 反射的应用场合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-Java-%E5%8F%8D%E5%B0%84"><span class="toc-text">4.2.3. Java 反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-%E5%8F%8D%E5%B0%84%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4%EF%BC%88%E8%8E%B7%E5%8F%96-Class-%E5%AF%B9%E8%B1%A1%E3%80%81%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-text">4.2.4. 反射使用步骤（获取 Class 对象、调用对象方法）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/" title="操作系统原理学习"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统原理学习"/></a><div class="content"><a class="title" href="/2023/10/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/" title="操作系统原理学习">操作系统原理学习</a><time datetime="2023-10-09T08:22:22.000Z" title="Created 2023-10-09 16:22:22">2023-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/28/Docker%E5%AD%A6%E4%B9%A0/" title="Docker学习"><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230928101501813.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker学习"/></a><div class="content"><a class="title" href="/2023/09/28/Docker%E5%AD%A6%E4%B9%A0/" title="Docker学习">Docker学习</a><time datetime="2023-09-28T01:13:06.000Z" title="Created 2023-09-28 09:13:06">2023-09-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/21/java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0/" title="java8新特性学习"><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230810141014749.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java8新特性学习"/></a><div class="content"><a class="title" href="/2023/09/21/java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0/" title="java8新特性学习">java8新特性学习</a><time datetime="2023-09-21T08:37:10.000Z" title="Created 2023-09-21 16:37:10">2023-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="java并发编程"><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230810141014749.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java并发编程"/></a><div class="content"><a class="title" href="/2023/09/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="java并发编程">java并发编程</a><time datetime="2023-09-11T03:08:03.000Z" title="Created 2023-09-11 11:08:03">2023-09-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/09/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8/" title="MySQL高可用"><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727223615031.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL高可用"/></a><div class="content"><a class="title" href="/2023/09/09/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8/" title="MySQL高可用">MySQL高可用</a><time datetime="2023-09-09T08:30:38.000Z" title="Created 2023-09-09 16:30:38">2023-09-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230810141014749.png')"><div id="footer-wrap"><div class="copyright">&copy;2023 By donn</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">很高兴认识你🤪</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>