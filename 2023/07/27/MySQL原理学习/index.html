<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MySQL原理学习 | donn的博客</title><meta name="author" content="donn"><meta name="copyright" content="donn"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MySQL原理——知识架构  架构MySQL架构  MySQL服务器逻辑架构： 最上层的服务并不是 MySQL 所独有的，大多数基于网络的客户端&#x2F;服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。 第二层架构是 MysQL 比较有意思的部分。大多数 MysQL 的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL原理学习">
<meta property="og:url" content="https://tangjiayang.github.io/2023/07/27/MySQL%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="donn的博客">
<meta property="og:description" content="MySQL原理——知识架构  架构MySQL架构  MySQL服务器逻辑架构： 最上层的服务并不是 MySQL 所独有的，大多数基于网络的客户端&#x2F;服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。 第二层架构是 MysQL 比较有意思的部分。大多数 MysQL 的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数">
<meta property="og:locale">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727223615031.png">
<meta property="article:published_time" content="2023-07-27T14:32:58.000Z">
<meta property="article:modified_time" content="2023-08-10T08:48:45.795Z">
<meta property="article:author" content="donn">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727223615031.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://tangjiayang.github.io/2023/07/27/MySQL%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":30,"languages":{"author":"Author: donn","link":"Link: ","source":"Source: donn的博客","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL原理学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-10 16:48:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/bg.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">11</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727223615031.png')"><nav id="nav"><span id="blog-info"><a href="/" title="donn的博客"><span class="site-name">donn的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL原理学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-07-27T14:32:58.000Z" title="Created 2023-07-27 22:32:58">2023-07-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-08-10T08:48:45.795Z" title="Updated 2023-08-10 16:48:45">2023-08-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/">数据库相关</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">39.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>122min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL原理学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><strong><u>MySQL原理——知识架构</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728105935995.png" alt="image-20230728105935995"></p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h3 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h3><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728111959688.png" alt="image-20230728111959688" style="zoom: 67%;" />

<h4 id="MySQL服务器逻辑架构："><a href="#MySQL服务器逻辑架构：" class="headerlink" title="MySQL服务器逻辑架构："></a>MySQL服务器逻辑架构：</h4><ul>
<li>最上层的服务并不是 MySQL 所独有的，大多数基于网络的客户端&#x2F;服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。</li>
<li>第二层架构是 MysQL 比较有意思的部分。大多数 MysQL 的核心服务功能都在这一层，包括<strong>查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数）</strong>，所有跨存储引擎的功能都在这一层实现：<strong>存储过程、触发器、视图</strong>等。</li>
<li>第三层包含了存储引擎。存储引擎负责 MySQL 中数据的存储和提取。和 GNU&#x2F;Linux 下的各种文件系统一样，每个存储引l擎都有它的优势和劣势。<strong>服务器通过 API 与存储引擎进行通信。这些接口屏蔽了不同存储引擎之问的差异，使得这些差异对上层的查询过程透明</strong>。存储引擎API包合几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行记录” 等操作。但存储引擎不会去解析 SQL，不同存储引擎之间也不会相互通信，而只是简单地响应上层服务器的请求。</li>
</ul>
<h4 id="连接管理与安全性"><a href="#连接管理与安全性" class="headerlink" title="连接管理与安全性"></a>连接管理与安全性</h4><ul>
<li><u>每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行</u>，该线程只能轮流在服务器的CPU中运行。</li>
<li>客户端连接到服务器时，服务器对其进行认证(用户名、主机信息、密码)，认证成功后进一步验证该客户端是否具有执行某个查询的权限</li>
</ul>
<h4 id="优化与执行"><a href="#优化与执行" class="headerlink" title="优化与执行"></a>优化与执行</h4><ul>
<li>MysQL会<strong>解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适索引等</strong>。用户可以通过特殊的关键宇提示(hint） 优化器，影响它的决策过程。也可以请求优化器解释 (explain）优化过程的各个因素，使用户可以知道服务器是如何进行优化决策的，并提供一个参考基准，便于用戶重构查询和 schetna、修改相关配置，使应用尽可能高效运行。</li>
<li>优化器并不关心表使用的是什么存储引擎，但存储引擎对于优化查询是有影响的。优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等。例如，某些存储引擎的某种索引，可能对一些特定的查询有优化。</li>
<li>对于 SELECT 语向，在解析查询之前，服务器会先检查查询缓存 (Query Cache)，<strong>如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集</strong>。</li>
</ul>
<h3 id="一条SQL的执行过程"><a href="#一条SQL的执行过程" class="headerlink" title="一条SQL的执行过程"></a>一条SQL的执行过程</h3><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728122544760.png" alt="image-20230728122544760"></p>
<p>MySQL执行SQL查询的流程图⬆️：</p>
<p>可以看到， MySQL 的架构共分为两层：<strong>Server 层和存储引擎层</strong>，</p>
<ul>
<li>**Server 层负责<u>建立连接、分析和执行 SQL</u>**。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。</li>
<li><strong>存储引擎层负责数据的存储和提取</strong>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。</li>
</ul>
<p>好了，现在我们对 Server 层和存储引擎层有了一个简单认识，接下来，就详细说一条 SQL 查询语句的执行流程，依次看看每一个功能模块的作用。</p>
<h4 id="Step1-连接器"><a href="#Step1-连接器" class="headerlink" title="Step1: 连接器"></a>Step1: 连接器</h4><p>服务器(通常，我们的日常学习中，使用本机提供mysql服务，所以也需要在本机启动mysql)启动MySQL后，用户端连接MySQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># -h 指定 MySQL 服务得 IP 地址，如果是连接本地的 MySQL服务，可以不用这个参数；</span><br><span class="line"># -u 指定用户名，管理员角色名为 root；</span><br><span class="line"># -p 指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里面输入密码</span><br><span class="line">mysql -h$ip -u$user -p</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>服务器未启动mysql</strong>：连接的过程需要先经过 TCP 三次握手，因为 **<u>MySQL 是基于 TCP 协议进行传输的</u>**，如果 <strong>MySQL 服务并没有启动</strong>，则会收到报错</p>
</li>
<li><p><strong>客户端用户名&#x2F;密码错误</strong>：如果 MySQL 服务正常运行，完成 TCP 连接的建立后，连接器就要开始验证你的用户名和密码，如果用户名或密码不对，就收到一个”Access denied for user”的错误，然后客户端程序结束执行。</p>
</li>
</ol>
<p>🌟<strong>如果用户密码都没有问题，连接器就会获取该用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断。所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</strong>	——用户信息修改后，本次连接不生效，需重新连接</p>
<h5 id="如何查看-MySQL-服务被多少个客户端连接了？"><a href="#如何查看-MySQL-服务被多少个客户端连接了？" class="headerlink" title="如何查看 MySQL 服务被多少个客户端连接了？"></a>如何查看 MySQL 服务被多少个客户端连接了？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show processlist;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728123837566.png" alt="image-20230728123837566" style="zoom:50%;" />

<h5 id="空闲连接会一直占用着吗？"><a href="#空闲连接会一直占用着吗？" class="headerlink" title="空闲连接会一直占用着吗？"></a>空闲连接会一直占用着吗？</h5><p>不会，MySQL 定义了空闲连接的最大空闲时长，由 <strong>wait_timeout 参数控制</strong>的，默认值是 8 小时（28880秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。</p>
<p>我们自己也可以手动断开空闲的连接，使用的是 kill connection + id 的命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; kill connection +6;</span><br></pre></td></tr></table></figure>

<p>一个处于空闲状态的连接被服务端主动断开后，<strong>这个客户端并不会马上知道</strong>，等到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”</p>
<h5 id="MySQL-的连接数有限制吗？"><a href="#MySQL-的连接数有限制吗？" class="headerlink" title="MySQL 的连接数有限制吗？"></a>MySQL 的连接数有限制吗？</h5><p><u>MySQL 服务支持的最大连接数由 max_connections 参数控制</u>，比如我的 MySQL 服务默认是 151 个,超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。</p>
<h5 id="MySQL-短连接和长连接："><a href="#MySQL-短连接和长连接：" class="headerlink" title="MySQL 短连接和长连接："></a>MySQL 短连接和长连接：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 短连接</span><br><span class="line">连接 mysql 服务（TCP 三次握手）</span><br><span class="line">执行sql</span><br><span class="line">断开 mysql 服务（TCP 四次挥手）</span><br><span class="line"></span><br><span class="line">// 长连接</span><br><span class="line">连接 mysql 服务（TCP 三次握手）</span><br><span class="line">执行sql</span><br><span class="line">执行sql</span><br><span class="line">执行sql</span><br><span class="line">....</span><br><span class="line">断开 mysql 服务（TCP 四次挥手）</span><br></pre></td></tr></table></figure>

<p>可以看到，使用<strong>长连接</strong>的好处就是可以<strong>减少建立连接和断开连接的过程</strong>，所以一般是推荐使用长连接。</p>
<p>但是，<u>使用长连接后可能会占用内存增多</u>，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，<u>这些连接对象资源只有在连接断开时才会释放</u>。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象。</p>
<h5 id="怎么解决长连接占用内存的问题？"><a href="#怎么解决长连接占用内存的问题？" class="headerlink" title="怎么解决长连接占用内存的问题？"></a>怎么解决长连接占用内存的问题？</h5><p>第一种，<strong>定期断开长连接</strong>。既然断开连接后就会释放连接占用的内存资源，那么我们可以定期断开长连接。</p>
<p>第二种，<strong>客户端主动重置连接</strong>。MySQL 5.7 版本实现了 mysql_reset_connection() 函数的接口，注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。👍</p>
<h5 id="连接器工作总结："><a href="#连接器工作总结：" class="headerlink" title="连接器工作总结："></a>连接器工作总结：</h5><ul>
<li>与客户端进行 TCP 三次握手建立<strong>连接</strong>；</li>
<li><strong>校验客户端的用户名和密码</strong>，如果用户名或密码不对，则会报错；</li>
<li>如果用户名和密码都对了，会<strong>读取该用户的权限</strong>，然后后面的权限逻辑判断都基于此时读取到的权限；</li>
</ul>
<h4 id="Step2-查询缓存"><a href="#Step2-查询缓存" class="headerlink" title="Step2: 查询缓存"></a>Step2: 查询缓存</h4><p>MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段，看看是什么类型的语句。</p>
<p>如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，<strong>这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。</strong></p>
<p>但是查询缓存被命中的几率很低，基本不会命中，因此 MySQL 8.0 开始(被移除了)，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了。</p>
<p>对于 MySQL 8.0 之前的版本，如果想关闭查询缓存，我们可以通过将参数 query_cache_type 设置成 DEMAND。</p>
<h4 id="Step3-解析SQL"><a href="#Step3-解析SQL" class="headerlink" title="Step3: 解析SQL"></a>Step3: 解析SQL</h4><p>在正式执行 SQL 查询语句之前， MySQL 会先<strong>对 SQL 语句做解析</strong>，这个工作交由「解析器」来完成。</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="解析器："><a href="#解析器：" class="headerlink" title="解析器："></a>解析器：</h5><ul>
<li><p><strong>词法分析</strong>。MySQL 会根据你输入的字符串<strong>识别出关键字</strong>出来，构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。</p>
</li>
<li><p><strong>语法分析</strong>。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p>
</li>
</ul>
<p><u>如果我们输入的 SQL 语句语法不对，就会在解析器这个阶段报错</u>。比如，我下面这条查询语句，把 from 写成了 form，这时 MySQL 解析器就会给报错。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF.png" alt="img"></p>
<p>⚠️但是注意，<strong>表不存在或者字段不存在，并不是在解析器里做的</strong></p>
<h4 id="Step4-执行SQL"><a href="#Step4-执行SQL" class="headerlink" title="Step4: 执行SQL"></a>Step4: 执行SQL</h4><p>​	经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条<strong>SELECT 查询语句</strong>流程主要可以分为下面这三个阶段：</p>
<ul>
<li>prepare 阶段，也就是<strong>预处理阶段；</strong></li>
<li>optimize 阶段，也就是<strong>优化阶段；</strong></li>
<li>execute 阶段，也就是<strong>执行阶段；</strong></li>
</ul>
<h5 id="🌟预处理阶段："><a href="#🌟预处理阶段：" class="headerlink" title="🌟预处理阶段："></a>🌟预处理阶段：</h5><p>预处理器主要进行如下操作：</p>
<ol>
<li><p><strong>检查 SQL 查询语句中的表或者字段是否存在；</strong></p>
</li>
<li><p>将 select * 中的 * 符号，扩展为表上的所有列；</p>
</li>
</ol>
<h5 id="🌟优化阶段："><a href="#🌟优化阶段：" class="headerlink" title="🌟优化阶段："></a>🌟优化阶段：</h5><p>优化器主要进行如下操作：</p>
<p>​	<strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</p>
<p>*要想知道优化器选择了哪个索引，我们可以在查询语句最前面加个 explain 命令，这样就会输出这条 SQL 语句的执行计划，然后执行计划中的 key 就表示执行过程中使用了哪个索引</p>
<h5 id="🌟执行阶段："><a href="#🌟执行阶段：" class="headerlink" title="🌟执行阶段："></a>🌟执行阶段：</h5><p>执行器主要进行如下操作：</p>
<p><strong>执行前要对操作用户的权限进行判断！</strong></p>
<p><strong>执行器将与存储引擎交互，执行SQL语句(交互是以记录为单位的)</strong></p>
<p>​	共有三种执行方式：</p>
<ol>
<li><strong>主键索引查询</strong></li>
</ol>
<p>​		根据主键字段的值来查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>​	这条查询语句的查询条件用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用访问类型为 const 进行查询，也就是使用主键索引查询一条记录，那么执行器与存储引擎的执行流程是这样的：</p>
<ul>
<li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 id &#x3D; 1 交给存储引擎，<strong>让存储引擎定位符合条件的第一条记录</strong>。</li>
<li>存储引擎通过主键索引的 B+ 树结构定位到 id &#x3D; 1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；</li>
<li>执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。</li>
<li>执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。</li>
</ul>
<p>至此，这个语句就执行完成了。</p>
<ol start="2">
<li><strong>全表扫描</strong></li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from product where name = &#x27;iphone&#x27;;</span><br></pre></td></tr></table></figure>

<p>这条查询语句的查询条件没有用到索引，所以优化器决定选用访问类型为 ALL 进行查询，也就是全表扫描的方式查询，那么这时执行器与存储引擎的执行流程是这样的：</p>
<ul>
<li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，<strong>让存储引擎读取表中的第一条记录</strong>；</li>
<li>执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；<strong>如果是则将记录发给客户</strong>（是的没错，S<u>erver 层每从存储引擎读到一条记录就会发送给客户端</u>，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）。</li>
<li>执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 all，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；</li>
<li>一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息；</li>
<li>执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。</li>
</ul>
<p>至此，这个语句就执行完成了</p>
<ol start="3">
<li><strong>索引下推</strong></li>
</ol>
<p>索引下推能够减少<strong>二级索引</strong>在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。</p>
<p>「<strong>索引下推暂时不必了解</strong>」</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>​	执行一条 SQL 查询语句，期间发生了什么？</p>
<ul>
<li>连接器：建立连接，管理连接、校验用户身份；</li>
<li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li>
<li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li>
<li>执行 SQL：执行 SQL 共有三个阶段：<ul>
<li>预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。</li>
<li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li>
<li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li>
</ul>
</li>
</ul>
<h3 id="引擎分类："><a href="#引擎分类：" class="headerlink" title="引擎分类："></a>引擎分类：</h3><h4 id="MySQL存储引擎有哪些？"><a href="#MySQL存储引擎有哪些？" class="headerlink" title="MySQL存储引擎有哪些？"></a>MySQL存储引擎有哪些？</h4><ul>
<li>InnoDB	</li>
<li>MyISAM</li>
<li>……(上面两款最常用)</li>
</ul>
<h4 id="Innodb-和-MyISAM-存储引擎有什么区别？"><a href="#Innodb-和-MyISAM-存储引擎有什么区别？" class="headerlink" title="Innodb 和 MyISAM 存储引擎有什么区别？"></a>Innodb 和 MyISAM 存储引擎有什么区别？</h4><h5 id="1-磁盘文件的对比"><a href="#1-磁盘文件的对比" class="headerlink" title="1. 磁盘文件的对比"></a>1. 磁盘文件的对比</h5><p>创建两张表：zz_myisam_index、zz_innodb_index，分别使用了不同的引擎</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230728163011906.png" alt="image-20230728163011906"></p>
<h6 id="1-1-使用MyISAM引擎的表"><a href="#1-1-使用MyISAM引擎的表" class="headerlink" title="1.1 使用MyISAM引擎的表"></a>1.1 使用MyISAM引擎的表</h6><p>zz_myisam_index这张表是使用MyISAM引擎的表，在磁盘中有三个文件：</p>
<ul>
<li>zz_myisam_index.frm：该文件中<strong>存储表的结构信息</strong>。</li>
<li>zz_myisam_index.MYD：该文件中<strong>存储表的行数据</strong>。</li>
<li>zz_myisam_index.MYI：该文件中<strong>存储表的索引数据</strong>。</li>
</ul>
<h6 id="1-2-使用InnoDB引擎的表"><a href="#1-2-使用InnoDB引擎的表" class="headerlink" title="1.2 使用InnoDB引擎的表"></a>1.2 使用InnoDB引擎的表</h6><p>zz_innodb_index这张表是使用InnoDB引擎的表，在磁盘中仅有两个文件：</p>
<ul>
<li>zz_innodb_index.frm：该文件中存储表的<strong>结构信息</strong>。</li>
<li>zz_innodb_index.ibd：该文件中存储表的<strong>行数据和索引数据</strong>。</li>
</ul>
<h5 id="2-索引支持的对比"><a href="#2-索引支持的对比" class="headerlink" title="2.索引支持的对比"></a>2.索引支持的对比</h5><ul>
<li>因为MyISAM引擎在设计之初，会将表分为.frm、.MYD、.MYI三个文件放在磁盘存储，<strong>表数据和索引数据是分别放在.MYD、.MYI文件中</strong>，所以注定了<u>MyISAM引擎只支持非聚簇索引</u>。</li>
<li>而InnoDB引擎的<strong>表数据、索引数据都放在.ibd文件中存储</strong>，因此<u>InnoDB是支持聚簇索引</u>的。</li>
</ul>
<p><strong>聚簇索引的要求</strong>是：索引键和行数据必须在物理空间上也是连续的，而MyISAM表数据和索引数据，分别位于两个磁盘文件中，这也就注定了它无法满足聚簇索引的要求。</p>
<p>但<strong>不支持聚簇索引也有好处</strong>，也就是<u>无论走任何索引，都只需要一遍查询即可获得数据</u>，而InnoDB引擎的表中，<u>如果不走聚簇（主键）索引查询数据，走其他索引的情况下，都需要经过两遍（回表）查询才能获得数据。</u></p>
<h5 id="3-事务机制的对比"><a href="#3-事务机制的对比" class="headerlink" title="3.事务机制的对比"></a>3.事务机制的对比</h5><ul>
<li><strong>InnoDB引擎中有两个自己专享的日志，即 undo-log、redo-log</strong>，使用InnoDB存储引擎的表，可以借助undo-log日志实现事务机制，支持多条SQL组成一个事务，可以保证发生异常的情况下，组成这个事务的SQL到底回滚还是提交。</li>
<li>而MyISAM并未设计类似的技术，在启动时不会在内存中构建undo_log_buffer缓冲区，磁盘中也没有相应的日志文件，因此MyISAM并<strong>不支持事务机制</strong></li>
</ul>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&gt; 一个引擎是否支持事务，这点尤为重要</p>
<h5 id="4-故障恢复的对比"><a href="#4-故障恢复的对比" class="headerlink" title="4.故障恢复的对比"></a>4.故障恢复的对比</h5><ul>
<li>InnoDB在启动时，同样会在内存中构建一个redo_log_buffer缓冲区，在磁盘中也会有相应的redo-log日志文件，所以当一条或多条SQL语句执行成功后，不论MySQL在何时宕机，<strong>只要这个事务提交了，InnoDB引擎都能确保该事务的数据不会丢失，也就以此保障了事务的持久性。</strong></li>
<li>但MyISAM引擎同样<strong>没有redo-log日志，所以并不支持数据的故障恢复</strong>，如果表是使用MyISAM引擎创建的，当一条SQL将数据写入到了缓冲区后，SQL还未被写到bin-log日志，此时机器断电、DB宕机了，重启之后由于数据在宕机前还未落盘，所以丢了也就无法找回。</li>
</ul>
<h5 id="5-锁粒度的对比"><a href="#5-锁粒度的对比" class="headerlink" title="5.锁粒度的对比"></a>5.锁粒度的对比</h5><p>MyISAM仅支持表锁，而InnoDB同时支持表锁、行锁，但为啥MyISAM引擎不支持行锁呢？不是不想，而是做不到!</p>
<p>—-由于MyISAM每个索引都会对应一棵B+树，那么对可能导致基于不同索引查询数据时，可能会导致一行数据上加多个锁，导致锁失效。</p>
<h5 id="6-并发性能的对比"><a href="#6-并发性能的对比" class="headerlink" title="6.并发性能的对比"></a>6.并发性能的对比</h5><p>​	MyISAM仅支持表锁，InnoDB同时支持表锁、行锁，由于这点原因，其实<strong>InnoDB引擎的并发支持性早已远超MyISAM了，毕竟锁的粒度越小，并发冲突的概率也就越低，因此并发支撑就越高。</strong></p>
<h5 id="7-内存利用度的对比"><a href="#7-内存利用度的对比" class="headerlink" title="7.内存利用度的对比"></a>7.内存利用度的对比</h5><p>InnoDB引擎的创始人Heikki Tuuri早早想到了这点，通过缓冲池结合异步IO技术，活生生将一款基于磁盘的引擎，演变成了半内存式的引擎。反观MyISAM引擎，内部虽然也有缓冲池以及异步IO技术，但对内存的开发度远不足于InnoDB引擎，运行期间大量操作依旧会走磁盘完成。</p>
<p>—-InnoDB引擎的内存利用率很高</p>
<h4 id="🌟为什么InnoDB代替了MyISAM？"><a href="#🌟为什么InnoDB代替了MyISAM？" class="headerlink" title="🌟为什么InnoDB代替了MyISAM？"></a>🌟为什么InnoDB代替了MyISAM？</h4><p>①存储方式：<code>MyISAM</code>引擎会将表数据和索引数据分成两个文件存储。</p>
<p>②索引支持：因为<code>MyISAM</code>引擎的表数据和索引数据是分开的，因此不支持聚簇索引。</p>
<p>③事务支持：由于<code>MyISAM</code>引擎没有<code>undo-log</code>日志，所以不支持多条<code>SQL</code>组成事务并回滚。</p>
<p>④故障恢复：<code>MyISAM</code>引擎依靠<code>bin-log</code>日志实现，<code>bin-log</code>中未写入的数据会永久丢失。</p>
<p>⑤锁粒度支持：因为<code>MyISAM</code>不支持聚簇索引，因此无法实现行锁，所有并发操作只能加表锁。</p>
<p>⑥并发性能：<code>MyISAM</code>引擎仅支持表锁，所以多条线程出现读-写并发场景时会阻塞。</p>
<p>⑦内存利用度：<code>MyISAM</code>引擎过于依赖<code>MySQL Server</code>，对缓冲池、异步<code>IO</code>技术开发度不够。</p>
<h4 id="MyISAM引擎的可取之处："><a href="#MyISAM引擎的可取之处：" class="headerlink" title="MyISAM引擎的可取之处："></a>MyISAM引擎的可取之处：</h4><ol>
<li><p>统计总数的优化：</p>
<p>仅仅是对于<code>select count(*) from table_name;</code>这条语句，MyISAM引擎有更好的表现——因为其维护了一个变量——其存储了表中的记录总数，仅此而已，上述语句添加任何条件都会原形毕露。</p>
</li>
<li><p>删除数据&#x2F;表的优化：</p>
</li>
</ol>
<p>​		当使用<code>delete</code>命令清空表数据时，<code>MyISAM</code>会直接<strong>重新创建表数据文件</strong>，而<code>InnoDB</code>则是一行行删除数据，因此对于清空表数据的操作，<code>MyISAM</code>比<code>InnoDB</code>快上无数倍。</p>
<p>​		同时<code>MyISAM</code>引擎的表，对于<code>delete</code>过的数据不会立即删除，而且先隐藏起来，后续定时删除或手动删除，</p>
<ol start="3">
<li>CRUD速度更快</li>
</ol>
<p>​		<code>InnoDB</code>的聚簇索引，会影响读写数据的性能：基于非聚簇索引查找数据，就算查到了也需要经过一次回表才能得到数据，同时插入数据、修改数据时，都需要维护聚簇索引和非聚簇索引之间的关系</p>
<p>​		而<code>MyISAM</code>引擎中，所有已创建的索引都是非聚簇索引，每个索引之间都是独立的，在索引中存储的是直接指向行数据的地址，而并非聚簇索引的索引键，因此无论走任何索引，都仅需一次即可获得数据，无需做回表查询。</p>
<p><strong>but</strong>：以单连接的方式测试，确实<code>MyISAM</code>会远超<code>InnoDB</code>，毕竟单个连接意味着只有一条线程，一条线程就不会出现锁竞争，表锁会一直由这条线程持有。但是在多连接的情况下，由于MyISAM只支持表锁，因此性能会大大降低，远低于InnoDB！</p>
<h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h1><h3 id="一行记录的存储格式"><a href="#一行记录的存储格式" class="headerlink" title="一行记录的存储格式"></a>一行记录的存储格式</h3><h4 id="MySQL-的数据存放在哪个文件？"><a href="#MySQL-的数据存放在哪个文件？" class="headerlink" title="MySQL 的数据存放在哪个文件？"></a>MySQL 的数据存放在哪个文件？</h4><p>—-MySQL 存储的行为是由存储引擎实现的，MySQL 支持多种存储引擎，<strong>不同的存储引擎保存的文件自然也不同</strong></p>
<p>本小节针对InnoDB展开讨论：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 我们可以在MySQL中使用下面的指令来获取mysql存储表信息的路径，所有的表结构和表数据都会在这个文件中</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;datadir&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>进入该目录，mysql中的每个数据库都会在该目录中对应一个子目录，进入数据库对应的子目录，我们发现其中结构为：</p>
<ul>
<li><strong>db.opt</strong> : 存放当前数据库的默认字符集和字idb符校验规则</li>
<li><strong>表名.frm</strong> : <strong>表结构</strong>会保存在这个文件。在 <u>MySQL 中建立一张表都会生成一个.frm 文件</u>，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。 </li>
<li><strong>表名.ibd</strong> : <strong>表数据</strong>会保存在这个文件，InnoDB引擎默认将每个表的<u>数据</u>分开存放， <strong>表名.ibd 文件也称为独占表空间文件</strong></li>
</ul>
<h5 id="表空间文件-存放表中数据的文件-的结构是怎么样的？"><a href="#表空间文件-存放表中数据的文件-的结构是怎么样的？" class="headerlink" title="表空间文件(存放表中数据的文件)的结构是怎么样的？"></a>表空间文件(存放表中数据的文件)的结构是怎么样的？</h5><p>​	<strong>表空间由段（segment）、区（extent）、页（page）、行（row）组成</strong>，InnoDB存储引擎的逻辑存储结构大致如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730144124140.png" alt="image-20230730144124140"></p>
<h6 id="1、行（row）"><a href="#1、行（row）" class="headerlink" title="1、行（row）"></a>1、行（row）</h6><p>数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。</p>
<h6 id="2、页（page）"><a href="#2、页（page）" class="headerlink" title="2、页（page）"></a>2、页（page）</h6><p>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I&#x2F;O 操作）只能处理一行数据，效率会非常低。</p>
<p>因此，<strong>InnoDB 的数据是按「页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。</p>
<p><strong>默认每个页的大小为 16KB</strong>，也就是最多能保证 16KB 的连续存储空间。</p>
<p>页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p>
<h6 id="3、区（extent）"><a href="#3、区（extent）" class="headerlink" title="3、区（extent）"></a>3、区（extent）</h6><p>我们知道 InnoDB 存储引擎是用 B+ 树来组织数据的。</p>
<p>B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I&#x2F;O，随机 I&#x2F;O 是非常慢的。</p>
<p>解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I&#x2F;O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。</p>
<p>那具体怎么解决呢？</p>
<p><strong>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I&#x2F;O 了</strong>。</p>
<h6 id="4、段（segment）"><a href="#4、段（segment）" class="headerlink" title="4、段（segment）"></a>4、段（segment）</h6><p>表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。</p>
<ul>
<li><strong>索引段</strong>：存放 B + 树的非叶子节点的区的集合；</li>
<li><strong>数据段</strong>：存放 B + 树的叶子节点的区的集合；</li>
<li><strong>回滚段</strong>：存放的是回滚数据的区的集合；</li>
</ul>
<h4 id="InnoDB-行格式学习："><a href="#InnoDB-行格式学习：" class="headerlink" title="InnoDB 行格式学习："></a>InnoDB 行格式学习：</h4><p><u>行格式（row_format），就是一条记录的存储结构。</u></p>
<p><strong>COMPACT行格式</strong>——是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。</p>
<p>其他行格式要么就是太落后已经被淘汰、要么就是在COMPACT格式上进行增强，所以选择了解<strong>COMPACT</strong>行格式。</p>
<h5 id="COMPACT行格式："><a href="#COMPACT行格式：" class="headerlink" title="COMPACT行格式："></a>COMPACT行格式：</h5><p>​	<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730145223318.png" alt="image-20230730145223318"></p>
<h6 id="1-变长字段长度列表"><a href="#1-变长字段长度列表" class="headerlink" title="1. 变长字段长度列表"></a>1. 变长字段长度列表</h6><ul>
<li><p>「变长字段长度列表」只出现在<strong>数据表有变长字段的时候</strong></p>
</li>
<li><p>根据列的顺序，<strong>逆序</strong>存放每条记录中各个变长字段的真实长度</p>
</li>
</ul>
<p>— 🌟为什么要逆序？</p>
<ol>
<li><p>「记录头信息」中指向下一个记录的指针，指向的是下一条记录的<strong>「记录头信息」和「真实数据」之间的位置</strong>，这样向左读就是记录头信息，向右读就是真实数据，比较方便。</p>
</li>
<li><p>「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以<strong>使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率</strong>。</p>
</li>
<li><p>🧠<u><em>通俗易懂，但不准确的说明</em></u>： 你初始指向的是中间的位置，往左一格更容易读到字段长度信息，往右一格能够读到该字段的真实数据信息(从中间向两边扩张地读取，更容易实现现在同一次指针移动，读到同一字段的数据 &amp; 长度信息)</p>
</li>
</ol>
<p>同样的道理， NULL 值列表的信息也需要逆序存放。</p>
<h6 id="2-NULL-值列表"><a href="#2-NULL-值列表" class="headerlink" title="2. NULL 值列表"></a>2. NULL 值列表</h6><p>NULL 值列表也不是必须的。</p>
<p><strong>当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了</strong>。</p>
<p>所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）。</p>
<p>表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中。</p>
<p><u>如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit）</u>，二进制位<strong>按照列的顺序<u>逆序</u>排列</strong>。</p>
<ul>
<li>二进制位的值为<code>1</code>时，代表该列的值为NULL</li>
<li>二进制位的值为<code>0</code>时，代表该列的值不为NULL</li>
</ul>
<p>NULL 值列表必须用整数个字节的位表示（1字节8位），<strong>如果使用的二进制位个数不足整数个字节，则在字节的高位补 0</strong>——–&gt;意思就是，如果你的允许为null的字段数量不足8的倍数，也会开辟 8 的倍数的空间来存储(高位补0)，即InnoDB的基本存储单元为1B</p>
<h6 id="3-记录头信息"><a href="#3-记录头信息" class="headerlink" title="3. 记录头信息"></a>3. 记录头信息</h6><p>记录头信息中包含的内容很多，举例几个比较重要的：</p>
<ul>
<li><strong>delete_mask</strong> ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。</li>
<li><strong>next_record</strong>：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</li>
<li><strong>record_type</strong>：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</li>
</ul>
<h6 id="4-记录的真实数据"><a href="#4-记录的真实数据" class="headerlink" title="4. 记录的真实数据"></a>4. 记录的真实数据</h6><p>​	记录真实数据部分除了我们定义的字段，还有**<u>三个隐藏字段</u><strong>，分别为：</strong>row_id、trx_id、roll_pointer**，我们来看下这三个字段是什么。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730152307044.png" alt="image-20230730152307044"></p>
<ul>
<li>row_id</li>
</ul>
<p>​	如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id<strong>不是必需的</strong>，占用 6 个字节。</p>
<p>​	没有主键或唯一约束列时，会自动帮你生成一个隐藏主键(用于聚簇索引！)</p>
<ul>
<li>trx_id</li>
</ul>
<p>​	事务id，表示<strong>这个数据是由哪个事务生成的</strong>。 trx_id是<strong>必需的</strong>，占用 6 个字节。</p>
<ul>
<li>roll_pointer</li>
</ul>
<p>​	<strong>这条记录上一个版本的指针</strong>。roll_pointer 是<strong>必需的</strong>，占用 7 个字节。——-后面我们可以知道，这用于MVCC的实现</p>
<h4 id="varchar-n-中-n-最大取值为多少？"><a href="#varchar-n-中-n-最大取值为多少？" class="headerlink" title="varchar(n) 中 n 最大取值为多少？"></a>varchar(n) 中 n 最大取值为多少？</h4><p>我们要清楚一点，<strong>MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度<u>加起来</u>不能超过 65535 个字节</strong>。</p>
<p>也就是说，一行记录除了 TEXT、BLOBs 类型的列，限制最大为 65535 字节，<u>注意是一行的总长度</u>，不是一列。</p>
<p>知道了这个前提之后，我们再来看看这个问题：「varchar(n) 中 n 最大取值为多少？」</p>
<p>varchar(n) 字段类型的 n 代表的是最多存储的字符数量，并不是字节大小哦。</p>
<p>要算 varchar(n) 最大能允许存储的字节数，还要看数据库表的字符集，因为字符集代表着，1个字符要占用多少字节，比如 ascii 字符集， 1 个字符占用 1 字节，那么 varchar(100) 意味着最大能允许存储 100 字节的数据。</p>
<p>答：一条记录所有字段的「真实数据 + 变长字段长度列表 + NULL值列表」长度和 &lt;&#x3D; 65535 B</p>
<h4 id="行溢出后，MySQL-是怎么处理的？"><a href="#行溢出后，MySQL-是怎么处理的？" class="headerlink" title="行溢出后，MySQL 是怎么处理的？"></a>行溢出后，MySQL 是怎么处理的？</h4><p>MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 <code>16KB</code>，也就是 <code>16384字节</code>，而一个 varchar(n) 类型的列最多可以存储 <code>65532字节</code>，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会<strong>发生行溢出，多的数据就会存到另外的「溢出页」中</strong>。</p>
<p>🌟当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。大致如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230730153621037.png" alt="image-20230730153621037"></p>
<p>注意：Compressed 和 Dynamic 这两种行格式(COMPACT的改进版)，它们对于行溢出的处理为：</p>
<ul>
<li>采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，<strong>只存储 20 个字节的指针来指向溢出页！而实际的数据都存储在溢出页中；</strong></li>
</ul>
<h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><h5 id="MySQL-的-NULL-值是怎么存放的？"><a href="#MySQL-的-NULL-值是怎么存放的？" class="headerlink" title="MySQL 的 NULL 值是怎么存放的？"></a>MySQL 的 NULL 值是怎么存放的？</h5><p>​	MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。</p>
<p>​	NULL值列表会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。</p>
<h5 id="MySQL-怎么知道-varchar-n-实际占用数据的大小？"><a href="#MySQL-怎么知道-varchar-n-实际占用数据的大小？" class="headerlink" title="MySQL 怎么知道 varchar(n) 实际占用数据的大小？"></a>MySQL 怎么知道 varchar(n) 实际占用数据的大小？</h5><p>​	MySQL 的 Compact 行格式中会用「变长字段长度列表」存储变长字段实际占用的数据大小。</p>
<h5 id="varchar-n-中-n-最大取值为多少？-1"><a href="#varchar-n-中-n-最大取值为多少？-1" class="headerlink" title="varchar(n) 中 n 最大取值为多少？"></a>varchar(n) 中 n 最大取值为多少？</h5><p>​	所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;&#x3D; 65535。</p>
<h5 id="行溢出后，MySQL-是怎么处理的？-1"><a href="#行溢出后，MySQL-是怎么处理的？-1" class="headerlink" title="行溢出后，MySQL 是怎么处理的？"></a>行溢出后，MySQL 是怎么处理的？</h5><p>​	存到溢出页中，真实数据区存放溢出页地址(非完全行溢出方式、完全行溢出方式)</p>
<h3 id="char和varchar"><a href="#char和varchar" class="headerlink" title="char和varchar"></a>char和varchar</h3><h4 id="存储机制区别："><a href="#存储机制区别：" class="headerlink" title="存储机制区别："></a>存储机制区别：</h4><ul>
<li><strong>最大长度</strong>：char是255，varchar是65535，单位是字符（而不是字节）。</li>
<li><strong>尾随空格</strong>：char会将尾随空格去掉，而varchar不会。<br>因为存储时，char会用空格填充至指定长度，所以取出时需要去除空格。如果char字段有唯一索引，<code>a</code> 和 <code>a空格</code> 会提示唯一索引冲突。</li>
<li><strong>存储空间占用</strong>：<u>varchar会占用额外的1~2字节来<strong>存储字符串长度</strong></u>。如果最大长度超过255，就需要2字节，否则1字节。</li>
</ul>
<h4 id="性能差异："><a href="#性能差异：" class="headerlink" title="性能差异："></a>性能差异：</h4><p>从char和varchar的存储结构对比，可以得出一个结论：<strong>char填充空格可能导致浪费存储空间，进而导致性能下降</strong>。因为char多存储一些空格，意味着需要<u>从磁盘读写更多的数据、耗费更多内存、查找数据时删除空格可能也会耗费一些CPU性能</u>。</p>
<p><strong>大部分情况下，varchar的性能优于char，最好使用varchar。</strong></p>
<p>不过考虑一个极端的场景：某个字段的最大长度是100字节，但是会频繁修改。如果使用<code>char(100)</code>，则插入记录后就分配了100个字节，后续修改不会造成页分裂、页空隙等问题，而<code>varchar(100)</code>由于没有提前分配存储空间，后续修改时可能出现页分裂，进而导致性能下降。</p>
<h3 id="数据页"><a href="#数据页" class="headerlink" title="数据页"></a>数据页</h3><h4 id="InnoDB-是如何存储数据的？"><a href="#InnoDB-是如何存储数据的？" class="headerlink" title="InnoDB 是如何存储数据的？"></a>InnoDB 是如何存储数据的？</h4><p>——按行存储数据，但是读取数据时，一次会读取目标行所在的整列</p>
<p>数据库的 I&#x2F;O 操作的最小单位是页，<strong>InnoDB 数据页的默认大小是 16KB</strong>，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p>
<p>数据页包括七个部分，结构如下图：</p>
<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731110101701.png" alt="image-20230731110101701" style="zoom: 33%;" />

<p><strong>说明：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731110642767.png" alt="image-20230731110642767"></p>
<h5 id="File-Header："><a href="#File-Header：" class="headerlink" title="File Header："></a>File Header：</h5><p>在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731110737757.png" alt="image-20230731110737757"></p>
<p>采用链表的结构是让数据页之间不需要是物理上的连续的，而是逻辑上的连续。</p>
<h5 id="User-Records："><a href="#User-Records：" class="headerlink" title="User Records："></a>User Records：</h5><p><strong>数据页中的记录按照「主键」顺序组成单向链表</strong>，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。</p>
<p>因此，数据页中有一个<strong>页目录</strong>，起到记录的索引作用，就像我们书那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。</p>
<h5 id="Page-Directory："><a href="#Page-Directory：" class="headerlink" title="Page Directory："></a>Page Directory：</h5><p>页目录创建的过程如下：</p>
<ol>
<li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；</li>
<li><u>每个记录组的最后一条记录就是组内最大的那条记录</u>，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段</li>
<li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），<strong>每个槽相当于指针指向了不同组的最后一个记录</strong>。</li>
</ol>
<p><strong>页目录就是由多个槽组成的，槽相当于分组记录的索引</strong>。然后，因为记录是按照「主键值」从小到大排序的，所以<strong>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个页中的记录链表。</p>
<p>举个例子，5 个槽的编号分别为 0，1，2，3，4，我想查找主键为 11 的用户记录：</p>
<ul>
<li>先二分得出槽中间位是 (0+4)&#x2F;2&#x3D;2 ，2号槽里最大的记录为 8。因为 11 &gt; 8，所以需要从 2 号槽后继续搜索记录；</li>
<li>再使用二分搜索出 2 号和 4 槽的中间位是 (2+4)&#x2F;2&#x3D; 3，3 号槽里最大的记录为 12。因为 11 &lt; 12，所以主键为 11 的记录在 3 号槽里；</li>
<li>这里有个问题，<strong>「槽对应的值都是这个组的主键最大的记录，如何找到组里最小的记录」</strong>？<ul>
<li>找前一个槽最大记录+1即可</li>
</ul>
</li>
</ul>
<p>看到第三步的时候，可能有的同学会疑问，如果某个槽内的记录很多，然后因为记录都是单向链表串起来的，那这样在槽内查找某个记录的时间复杂度不就是 O(n) 了吗？</p>
<p>这点不用担心，InnoDB 对每个分组中的记录条数都是有规定的，槽内的记录就只有几条：</p>
<ul>
<li>第一个分组中的记录只能有 1 条记录；</li>
<li>最后一个分组中的记录条数范围只能在 1-8 条之间；</li>
<li>剩下的分组中记录条数范围只能在 4-8 条之间。</li>
</ul>
<h5 id="总结——单数据页内的查询步骤："><a href="#总结——单数据页内的查询步骤：" class="headerlink" title="总结——单数据页内的查询步骤："></a>总结——单数据页内的查询步骤：</h5><p>上面我们都是在说一个数据页中的记录检索，因为一个数据页中的记录是有限的，且主键值是有序的，所以通过对所有记录进行分组，然后将组号（槽号）存储到页目录，使其起到索引作用，通过二分查找的方法快速检索到记录在哪个分组，来降低检索的时间复杂度。</p>
<h4 id="B-树是如何进行查询的？"><a href="#B-树是如何进行查询的？" class="headerlink" title="B+ 树是如何进行查询的？"></a>B+ 树是如何进行查询的？</h4><p>当我们需要存储大量的记录时，就需要多个数据页。<strong>InnoDB 采用了 B+ 树作为索引</strong>。磁盘的 I&#x2F;O 操作次数对索引的使用效率至关重要，因此在构造索引的时候，我们更倾向于采用“矮胖”的 B+ 树数据结构，这样所需要进行的磁盘 I&#x2F;O 次数更少，而且 B+ 树 更适合进行关键字的范围查询。</p>
<p>InnoDB 里的 B+ 树中的<strong>每个节点都是一个数据页</strong>，结构示意图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731111828591.png" alt="image-20230731111828591"></p>
<p>通过上图，我们看出 B+ 树的特点：</p>
<ul>
<li><u>只有叶子节点（最底层的节点）才存放了数据</u>，非叶子节点（其他上层节）仅用来存放目录项作为索引。</li>
<li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li>
<li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</li>
</ul>
<p>🌰我们再看看 B+ 树如何实现快速查找主键为 6 的记录，以上图为例子：</p>
<ul>
<li>从根节点开始，通过二分法快速定位到符合页内范围包含查询值的页，因为查询的主键值为 6，在[1, 7)范围之间，所以到页 30 中查找更详细的目录项；</li>
<li>在非叶子节点（页30）中，继续通过二分法快速定位到符合页内范围包含查询值的页，主键值大于 5，所以就到叶子节点（页16）查找记录；</li>
<li>接着，在叶子节点（页16）中，通过槽查找记录时，使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到主键为 6 的记录。</li>
</ul>
<p>🌟<strong>可以看到，在定位记录所在哪一个页时，也是通过二分法快速定位到包含该记录的页。定位到该页后，又会在该页内进行二分法快速定位记录所在的分组（槽号），最后在分组内进行遍历查找。</strong></p>
<h5 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h5><ol>
<li><p>构建数据页的B+树</p>
</li>
<li><p>将要查询的主键值与B+树节点的最大、最小记录比较，进行二分查找，找到记录所在的数据页</p>
</li>
<li><p>在数据页中，再使用二分查找找到记录在哪个槽，在槽中顺序遍历找到结果</p>
</li>
</ol>
<h4 id="聚簇索引和二级索引"><a href="#聚簇索引和二级索引" class="headerlink" title="聚簇索引和二级索引"></a>聚簇索引和二级索引</h4><p>另外，索引又可以分成聚簇索引和非聚簇索引（二级索引），它们<strong>区别就在于叶子节点存放的是什么数据</strong>：</p>
<ul>
<li><u>聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点</u>；(InnoDB,索引与数据都存在.idb文件中)</li>
<li>二级索引的叶子节点存放的是主键值，而不是实际数据。</li>
</ul>
<p>因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。</p>
<p>InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：</p>
<ul>
<li>如果有主键，默认会使用<strong>主键</strong>作为聚簇索引的索引键；</li>
<li>如果没有主键，就选择第一个<strong>不包含 NULL 值的唯一列</strong>作为聚簇索引的索引键；</li>
<li>在上面两个都没有的情况下，InnoDB 将自动生成一个<strong>隐式自增 id 列</strong>作为聚簇索引的索引键；</li>
</ul>
<p>一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了<u>二级索引（非聚簇索引&#x2F;辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。</u></p>
<p>二级索引的 B+ 树如下图，数据部分为主键值：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731112821532.png" alt="image-20230731112821532"></p>
<p>因此，<strong>如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。</strong></p>
<h4 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h4><ul>
<li>InnoDB 的数据是按「数据页」为单位来读写的，默认数据页大小为 16 KB。<u>每个数据页之间通过双向链表的形式组织起来，物理上不连续，但是逻辑上连续。</u></li>
<li>数据页内包含用户记录，每个记录之间用单向链表的方式组织起来，为了加快在数据页内高效查询记录，设计了一个页目录，页目录存储各个槽（分组），且主键值是有序的，于是可以通过二分查找法的方式进行检索从而提高效率。</li>
<li>为了高效查询记录所在的数据页，InnoDB 采用 b+ 树作为索引，每个节点都是一个数据页。</li>
<li>如果叶子节点存储的是实际数据的就是聚簇索引，一个表只能有一个聚簇索引；如果叶子节点存储的不是实际数据，而是主键值则就是二级索引，一个表中可以有多个二级索引。</li>
<li>在使用二级索引进行查找数据时，如果查询的数据能在二级索引找到(也就是说，查找的数据是建立聚簇索引的列)，那么就是「索引覆盖」操作，如果查询的数据不在二级索引里，就需要先在二级索引找到主键值，需要去聚簇索引中获得数据行，这个过程就叫作「回表」。</li>
</ul>
<h3 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h3><h4 id="引出："><a href="#引出：" class="headerlink" title="引出："></a>引出：</h4><p><strong>——就是一个cache，为了减少读磁盘的次数</strong></p>
<p>虽然说 MySQL 的数据是存储在磁盘里的，但如果每次都从磁盘中读取数据，性能差；</p>
<p>要想提升查询性能，加个缓存就行了嘛。所以，<u>当数据从磁盘中取出后，缓存内存中，下次查询同样的数据的时候，直接从内存中读取</u>。</p>
<p>为此，Innodb 存储引擎设计了一个<strong>缓冲池（Buffer Pool）</strong>，来提高数据库的读写性能</p>
<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230801091252147.png" alt="image-20230801091252147" style="zoom: 33%;" />

<ul>
<li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li>
<li>当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后<u>由后台线程将脏页写入到磁盘</u>。</li>
</ul>
<h4 id="Buffer-Pool-有多大？"><a href="#Buffer-Pool-有多大？" class="headerlink" title="Buffer Pool 有多大？"></a>Buffer Pool 有多大？</h4><p>—-默认128MB，可以通过调整 <code>innodb_buffer_pool_size</code> 参数来设置 Buffer Pool 的大小，一般建议设置成可用物理内存的 60%~80%</p>
<h4 id="Buffer-Pool-缓存什么？"><a href="#Buffer-Pool-缓存什么？" class="headerlink" title="Buffer Pool 缓存什么？"></a>Buffer Pool 缓存什么？</h4><p>–<u><strong>一页一页进行缓存</strong></u></p>
<p>​	在 MySQL 启动的时候，<strong>InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的<code>16KB</code>的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页</strong>。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。</p>
<p>为了更好的管理这些在 Buffer Pool 中的缓存页，InnoDB 为每一个缓存页都创建了一个<strong>控制块</strong>，控制块信息包括「缓存页的表空间、页号、缓存页地址、链表节点」等等。</p>
<p>控制块也是占有内存空间的，它是放在 Buffer Pool 的最前面，接着才是缓存页，如下图：</p>
<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230801095607789.png" alt="image-20230801095607789" style="zoom:50%;" />

<p>上图中控制块和缓存页之间白色部分称为碎片空间。</p>
<h4 id="如何管理-Buffer-Pool？"><a href="#如何管理-Buffer-Pool？" class="headerlink" title="如何管理 Buffer Pool？"></a>如何管理 Buffer Pool？</h4><h5 id="如何管理空闲页？"><a href="#如何管理空闲页？" class="headerlink" title="如何管理空闲页？"></a>如何管理空闲页？</h5><p>使用一个Free链表，专门管理空闲页(使空闲页方便被获取)</p>
 <img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230801100926879.png" alt="image-20230801100926879" style="zoom:50%;" />

<h6 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h6><ul>
<li><p>Free 链表上除了有控制块，还有一个头节点，该<u>头节点包含链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息</u>。</p>
</li>
<li><p><u>Free 链表节点是一个一个的控制块，而每个控制块包含着对应缓存页的地址，所以相当于 Free 链表节点都对应一个空闲的缓存页。</u></p>
</li>
<li><p>有了 Free 链表后，每当需要从磁盘中加载一个页到 Buffer Pool 中时，就<u>从 Free链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的控制块从 Free 链表中移除。</u></p>
</li>
</ul>
<h5 id="如何管理脏页？"><a href="#如何管理脏页？" class="headerlink" title="如何管理脏页？"></a>如何管理脏页？</h5><p>—Flush 链表，表中节点都是脏页的控制块，方便管理所有脏页！</p>
<p>​	设计 Buffer Pool 除了能提高读性能，还能提高写性能，也就是<u>更新数据的时候，不需要每次都要写入磁盘，而是将 Buffer Pool 对应的缓存页标记为<strong>脏页</strong>，然后再由后台线程将脏页写入到磁盘。</u></p>
<p>​	那为了能快速知道哪些缓存页是脏的，于是就设计出 <strong>Flush 链表</strong>，它跟 Free 链表类似的，链表的节点也是控制块，区别在于 Flush 链表的元素都是脏页。</p>
<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230801101340605.png" alt="image-20230801101340605" style="zoom:45%;" />

<p>有了 Flush 链表后，后台线程就可以遍历 Flush 链表，将脏页写入到磁盘。</p>
<h5 id="如何提高缓存命中率？"><a href="#如何提高缓存命中率？" class="headerlink" title="如何提高缓存命中率？"></a>如何提高缓存命中率？</h5><p>​	Buffer Pool 的大小是有限的，<u>对于一些频繁访问的数据我们希望可以一直留在 Buffer Pool 中，而一些很少访问的数据希望可以在某些时机可以淘汰掉；</u></p>
<p>​	——使用简单的LRU算法</p>
<ul>
<li>当访问的页在 Buffer Pool 里，就直接把该页对应的 LRU 链表节点移动到链表的头部。</li>
<li>当访问的页不在 Buffer Pool 里，除了要把页放入到 LRU 链表的头部，还要淘汰 LRU 链表末尾的节点。</li>
</ul>
<p>⚠️简单的 LRU 算法并没有被 MySQL 使用，因为简单的 LRU 算法无法避免下面这两个问题：</p>
<ul>
<li>预读失效；</li>
<li>Buffer Pool 污染；</li>
</ul>
<h6 id="预读失效："><a href="#预读失效：" class="headerlink" title="预读失效："></a>预读失效：</h6><p>​	先来说说 MySQL 的预读机制。程序是有空间局部性的，靠近当前被访问数据的数据，在未来很大概率会被访问到。</p>
<p>所以，<strong>MySQL 在加载数据页时，会提前把它 <u><em>相邻的</em></u> 数据页一并加载进来，目的是为了减少磁盘 IO。</strong></p>
<p>但是可能这些<strong>被提前加载进来的数据页，并没有被访问</strong>，相当于这个预读是白做了，这个就是<strong>预读失效</strong>。</p>
<p>​	如果这些预读页如果一直不会被访问到，就会出现问题：不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是频繁访问的页，这样就大大降低了缓存命中率。</p>
<h6 id="🌟预读失效解决方案："><a href="#🌟预读失效解决方案：" class="headerlink" title="🌟预读失效解决方案："></a>🌟预读失效解决方案：</h6><p>​	要避免预读失效带来影响，最好就是**<u>让预读的页停留在 Buffer Pool 里的时间要尽可能的短</u>，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在 Buffer Pool 里的时间尽可能长**。</p>
<p>MySQL 是这样做的，它改进了 LRU 算法，将 LRU 划分了 2 个区域：<strong>old 区域 和 young 区域</strong>。</p>
<p>young 区域在 LRU 链表的前半部分，old 区域则是在后半部分，如下图：</p>
<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230801102129142.png" alt="image-20230801102129142" style="zoom: 33%;" />

<p>**划分这两个区域后，预读的页(所有从磁盘读入的页都先放到old区头部)就只需要加入到 old 区域的头部，<u>当页被真正访问的时候，才将页插入 young 区域的头部</u>**。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。</p>
<p>—-young、old区域比例关系可手动设计</p>
<h6 id="Buffer-Pool-污染："><a href="#Buffer-Pool-污染：" class="headerlink" title="Buffer Pool 污染："></a>Buffer Pool 污染：</h6><p>​	当某一个 SQL 语句<strong>扫描了大量的数据</strong>时，在 Buffer Pool 空间比较有限的情况下，可能会将 <strong>Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了</strong>，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 <strong>Buffer Pool 污染</strong>。</p>
<h6 id="Buffer-Pool-污染解决方案："><a href="#Buffer-Pool-污染解决方案：" class="headerlink" title="Buffer Pool 污染解决方案："></a>Buffer Pool 污染解决方案：</h6><p>​	像前面这种全表扫描的查询，<u>很多缓冲页其实只会被访问一次，但是它却只因为被访问了一次而进入到 young 区域，从而导致热点数据被替换了。</u></p>
<p>LRU 链表中 young 区域就是热点数据，只要我们<u>提高进入到 young 区域的门槛</u>，就能有效地保证 young 区域里的热点数据不会被替换掉。</p>
<p>MySQL 是这样做的，进入到 young 区域条件增加了一个<strong>停留在 old 区域的时间判断</strong>。</p>
<p>具体是这样做的，在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间：</p>
<ul>
<li>如果后续的访问时间与第一次访问的时间<strong>在某个时间间隔内</strong>，那么<strong>该缓存页就不会被从 old 区域移动到 young 区域的头部</strong>；</li>
<li>如果后续的访问时间与第一次访问的时间<strong>不在某个时间间隔内</strong>，那么<strong>该缓存页移动到 young 区域的头部</strong>；</li>
</ul>
<p>这个间隔时间是由 <code>innodb_old_blocks_time</code> 控制的，默认是 1000 ms。</p>
<p>也就说，<strong>只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部</strong>，这样就解决了 Buffer Pool 污染的问题 。</p>
<h5 id="脏页什么时候会被刷入磁盘？"><a href="#脏页什么时候会被刷入磁盘？" class="headerlink" title="脏页什么时候会被刷入磁盘？"></a>脏页什么时候会被刷入磁盘？</h5><p>如果每次都要把脏页写入磁盘同步数据的话性能会很低，但是如果不立即同步的话，如果mysql宕机了就会丢失数据？</p>
<p>​	这个不用担心，InnoDB 的更新操作采用的是 Write Ahead Log 策略，即先写日志，再写入磁盘，通过 redo log 日志让 MySQL 拥有了崩溃恢复能力。</p>
<p>下面几种情况会**<u>触发脏页的刷新</u>**：</p>
<ul>
<li>当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；</li>
<li>Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；</li>
<li>MySQL 认为空闲时，后台线程会定期将适量的脏页刷入到磁盘；</li>
<li>MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；</li>
</ul>
<p>在我们开启了慢 SQL 监控后，如果你发现<strong>「偶尔」会出现一些用时稍长的 SQL</strong>，这可能是因为脏页在刷新到磁盘时可能会给数据库带来性能开销，导致数据库操作抖动。</p>
<p>在很短的时间内多次出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Innodb 存储引擎设计了一个<strong>缓冲池（<em>Buffer Pool</em>）</strong>，来提高数据库的读写性能。</p>
<p>Buffer Pool 以页为单位缓冲数据，可以通过 <code>innodb_buffer_pool_size</code> 参数调整缓冲池的大小，默认是 128 M。</p>
<p>Innodb 通过三种链表来管理缓页：</p>
<ul>
<li>Free List （空闲页链表），管理空闲页；</li>
<li>Flush List （脏页链表），管理脏页；</li>
<li>LRU List，管理脏页+干净页，将最近且经常查询的数据缓存在其中，而不常查询的数据就淘汰出去。；</li>
</ul>
<p>InnoDB 对 LRU 做了一些优化，我们熟悉的 LRU 算法通常是将最近查询的数据放到 LRU 链表的头部，而 InnoDB 做 2 点优化：</p>
<ul>
<li>将 LRU 链表 分为<strong>young 和 old 两个区域</strong>，加入缓冲池的页，优先插入 old 区域；页被访问时，才进入 young 区域，目的是为了解决预读失效的问题。</li>
<li>当<strong>「页被访问」且「 old 区域停留时间超过 <code>innodb_old_blocks_time</code> 阈值（默认为1秒）」</strong>时，才会将页插入到 young 区域，否则还是插入到 old 区域，目的是为了解决批量数据访问，大量热数据淘汰的问题。</li>
</ul>
<p>可以通过调整 <code>innodb_old_blocks_pct</code> 参数，设置 young 区域和 old 区域比例。</p>
<p>在开启了慢 SQL 监控后，如果你发现「偶尔」会出现一些用时稍长的 SQL，这可能因为脏页在刷新到磁盘时导致数据库性能抖动。如果在很短的时间内多次出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。</p>
<h3 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h3><p>​	当需要更新一个数据页时，如果数据页在内存中就直接更新，而<u>如果这个数据页还没有在内存中</u>的话，在不影响数据一致性的前提下，InooDB 会<u>将这些更新操作缓存在 change buffer 中</u>，这样就不需要从磁盘中读入这个数据页了。在<u>下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作</u>。通过这种方式就能保证这个数据逻辑的正确性。</p>
<p>需要说明的是，虽然名字叫作 change buffer，实际上它是可以持久化的数据。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。</p>
<p><strong>将 change buffer 中的操作应用到原数据页</strong>，得到最新结果的过程称为 <strong>merge</strong>。</p>
<p>执行merge：</p>
<ol>
<li>访问这个数据页会触发 merge</li>
<li>系统有后台线程会定期 merge</li>
<li>在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作</li>
</ol>
<h4 id="什么条件下可以使用-change-buffer？"><a href="#什么条件下可以使用-change-buffer？" class="headerlink" title="什么条件下可以使用 change buffer？"></a>什么条件下可以使用 change buffer？</h4><h5 id="例1🌰："><a href="#例1🌰：" class="headerlink" title="例1🌰："></a>例1🌰：</h5><p>​	对于唯一索引来说，<u>所有的更新操作都要先判断这个操作是否违反唯一性约束</u>。比如，要插入 (4,400) 这个记录，就要先判断现在表中是否已经存在 k&#x3D;4 的记录，<u>而这必须要将数据页读入内存才能判断</u>。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。</p>
<p>⚠️因此，唯一索引的更新就不能使用 change buffer，实际上也只有普通索引(不用判断唯一性，因此更新操作不可能报错)可以使用。</p>
<h5 id="例2🌰："><a href="#例2🌰：" class="headerlink" title="例2🌰："></a>例2🌰：</h5><p>如果要在这张表中插入一个新记录 (4 {索引列} ,400 {普通列}) 的话，InnoDB 的处理流程是怎样的。</p>
<p>第一种情况是，<strong>这个记录要更新的目标页在内存中</strong>。这时，InnoDB 的处理流程如下：</p>
<ul>
<li>对于唯一索引来说，找到 3 和 5 之间的位置，判断到没有冲突，插入这个值，语句执行结束；</li>
<li>对于普通索引来说，找到 3 和 5 之间的位置，插入这个值，语句执行结束。</li>
</ul>
<p>这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间。</p>
<p>但，这不是我们关注的重点。</p>
<p>第二种情况是，<strong>这个记录要更新的目标页不在内存中</strong>。这时，InnoDB 的处理流程如下：</p>
<ul>
<li>对于唯一索引来说，需要<u>将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束</u>；</li>
<li>对于普通索引来说，则是<u>将更新记录在 change buffer，语句执行就结束了</u>。</li>
</ul>
<p>将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p>
<h4 id="change-buffer-的使用场景"><a href="#change-buffer-的使用场景" class="headerlink" title="change buffer 的使用场景"></a>change buffer 的使用场景</h4><p>现在，我们已经清楚了使用 change buffer 对更新过程的加速作用，也清楚了 change buffer <u>只限于用在普通索引的场景下，而不适用于唯一索引。</u></p>
<p>​	<strong>那么普通索引的所有场景，使用 change buffer 都可以起到加速作用吗？</strong></p>
<p>​		因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以<u><strong>在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。</strong></u></p>
<p>​		因此，对于<u>写多读少</u>的业务来说，页面在写完以后马上被访问到的概率比较小，此时 <u>change buffer 的使用效果最好</u>。这种业务模型常见的就是账单类、日志类的系统。</p>
<p>​		反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。<u>这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价</u>。所以，对于这种业务模式来说，change buffer 反而起到了副作用。</p>
<h4 id="普通索引和唯一索引应该怎么选择？"><a href="#普通索引和唯一索引应该怎么选择？" class="headerlink" title="普通索引和唯一索引应该怎么选择？"></a>普通索引和唯一索引应该怎么选择？</h4><p>​	其实，这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。所以，建议尽量选择普通索引。</p>
<p>​	如果所有的更新后面，都<u>马上伴随着对这个记录的查询</u>，那么你应该关闭 change buffer。而在其他情况下，change buffer 都能提升更新性能。</p>
<p>​	在实际使用中，你会发现，普通索引和 change buffer 的配合使用，对于数据量大的表的更新优化还是很明显的。</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h3 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h3><h4 id="B-树索引结构-最广泛"><a href="#B-树索引结构-最广泛" class="headerlink" title="B+树索引结构(最广泛)"></a>B+树索引结构(最广泛)</h4><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><p>​	基于<strong>磁盘</strong>的平衡树，但<u>树非常矮，通常为 3~4 层</u>，能存放千万到上亿的排序数据。树矮意味着访问效率高，从千万或上亿数据里查询一条数据，只用 3、4 次 I&#x2F;O。</p>
<h5 id="组成："><a href="#组成：" class="headerlink" title="组成："></a>组成：</h5><ul>
<li>B+ 树索引由根节点（root node）、中间节点（non leaf node）、叶子节点（leaf node）组成，其中<strong>叶子节点存放所有排序后的数据</strong>。</li>
<li>因此在其叶子结点寻找数据只需要logn的时间复杂度！</li>
</ul>
<p>⚠️：当 B+ 树的高度大于等于 2 时，<u><strong>根节点和中间节点存放的是索引键对</strong>(仅用来当作‘路标’，划分不同索引值的叶子结点)</u>，由（索引键、指针）组成。</p>
<h5 id="优化-B-树索引的插入性能："><a href="#优化-B-树索引的插入性能：" class="headerlink" title="优化 B+ 树索引的插入性能："></a>优化 B+ 树索引的插入性能：</h5><p>B+ 树在插入时就对要对数据进行排序，但排序的开销其实并没有你想象得那么大，因为排序是 CPU 操作（当前一个时钟周期 CPU 能处理上亿指令）。</p>
<p><strong>真正的开销在于 B+ 树索引的维护，保证数据排序，这里存在两种不同数据类型的插入情况</strong>。</p>
<ul>
<li><strong>数据顺序（或逆序）插入：</strong> B+ 树索引的维护代价非常小，叶子节点都是从左往右进行插入，比较典型的是自增 ID 的插入、时间的插入（若在自增 ID 上创建索引，时间列上创建索引，则 B+ 树插入通常是比较快的）。</li>
<li><strong>数据无序插入：</strong> B+ 树为了维护排序，需要对页进行分裂、旋转等开销较大的操作，另外，即便对于固态硬盘，随机写的性能也不如顺序写，所以磁盘性能也会收到较大影响。比较典型的是用户昵称，每个用户注册时，昵称是随意取的，若在昵称上创建索引，插入是无序的，索引维护需要的开销会比较大。</li>
</ul>
<p>你不可能要求所有插入的数据都是有序的，因为索引的本身就是用于数据的排序，插入数据都已经是排序的，那么你就不需要 B+ 树索引进行数据查询了。</p>
<p>所以对于 B+ 树索引，在 MySQL 数据库设计中，仅<u>要求主键的索引设计为顺序</u>，比如使用自增，或使用函数 UUID_TO_BIN 排序的 UUID，而不用无序值做主键。</p>
<h4 id="为什么-MySQL-采用-B-树作为索引？"><a href="#为什么-MySQL-采用-B-树作为索引？" class="headerlink" title="为什么 MySQL 采用 B+ 树作为索引？"></a>为什么 MySQL 采用 B+ 树作为索引？</h4><p>​	数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I&#x2F;O，而磁盘 I&#x2F;O 次数越多，所消耗的时间也就越大。</p>
<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230802111506165.png" alt="image-20230802111506165" style="zoom:50%;" />

<h5 id="MySQL-默认的存储引擎-InnoDB-采用的是-B-作为索引的数据结构，原因有："><a href="#MySQL-默认的存储引擎-InnoDB-采用的是-B-作为索引的数据结构，原因有：" class="headerlink" title="MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有："></a>MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：</h5><ul>
<li>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I&#x2F;O次数会更少。</li>
<li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</li>
<li>B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树。</li>
</ul>
<h5 id="Innodb-里的-B-树："><a href="#Innodb-里的-B-树：" class="headerlink" title="Innodb 里的 B+ 树："></a>Innodb 里的 B+ 树：</h5><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230731111828591.png" alt="image-20230731111828591"></p>
<p>但是 Innodb 使用的 B+ 树有一些特别的点，比如：</p>
<ul>
<li>B+ 树的叶子节点之间是用「双向链表」进行连接，这样的好处是既能向右遍历，也能向左遍历。</li>
<li>B+ 树点节点内容是数据页，数据页里存放了用户的记录以及各种信息，每个数据页默认大小是 16 KB。</li>
</ul>
<p>Innodb 根据索引类型不同，分为聚簇和二级索引。他们区别在于，聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点，而二级索引的叶子节点存放的是主键值，而不是实际数据。</p>
<p>因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个，而二级索引可以创建多个。</p>
<h3 id="索引存储"><a href="#索引存储" class="headerlink" title="索引存储"></a>索引存储</h3><h4 id="堆表：-性能差"><a href="#堆表：-性能差" class="headerlink" title="堆表：(性能差)"></a>堆表：(性能差)</h4><p>堆表的组织结构中，数据和索引分开存储。索引是排序后的数据，而堆表中的数据是无序的，索引的叶子节点存放了数据在堆表中的地址，当堆表的数据发生改变，且位置发生了变更，所有索引中的地址都要更新，这非常影响性能，特别是对于 OLTP 业务。</p>
<h4 id="索引组织表："><a href="#索引组织表：" class="headerlink" title="索引组织表："></a>索引组织表：</h4><p><strong>MySQL InnoDB 存储引擎是索引组织表</strong></p>
<p>​	<strong>数据根据主键排序存放在索引中</strong>，<u>主键索引也叫聚簇索引（Clustered Index）</u>。在索引组织表中，数据即索引，索引即数据。</p>
<h4 id="二级索引："><a href="#二级索引：" class="headerlink" title="二级索引："></a>二级索引：</h4><p>​	InnoDB 存储引擎的数据是根据主键索引排序存储的，除了主键索引外，<strong>其他的索引都称之为二级索引（Secondeary Index），</strong> 或非聚簇索引（None Clustered Index）。</p>
<p>二级索引也是一颗 B+ 树索引，但它和主键索引不同的是<u>叶子节点存放的是索引键值、主键<strong>值</strong></u>。</p>
<p>索引组织表这样的二级索引设计有一个非常大的好处：<u>若记录发生了修改，则其他索引无须进行维护，除非记录的主键发生了修改。</u></p>
<p>与堆表的索引实现对比着看，你会发现索引组织表在存在大量变更的场景下，性能优势会非常明显，因为大部分情况下都不需要维护其他二级索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 根据 name 进行查询的 SQL 可以理解为拆分成了两个步骤：(id为主键，name为普通索引)</span></span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> idx_name <span class="keyword">WHERE</span> name <span class="operator">=</span> ?</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">User</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> _id; <span class="comment">-- 回表</span></span><br></pre></td></tr></table></figure>





<p>在实际核心业务中，开发同学还有很大可能会<u>设计带有业务属性的主键</u>，但请牢记以下两点设计原则：</p>
<ul>
<li>要比较顺序，对聚簇索引性能友好；</li>
<li>尽可能紧凑，对二级索引的性能和存储友好；</li>
</ul>
<h4 id="索引组织表和堆表之间的区别总结："><a href="#索引组织表和堆表之间的区别总结：" class="headerlink" title="索引组织表和堆表之间的区别总结："></a><u>索引组织表和堆表</u>之间的区别总结：</h4><ul>
<li>索引组织表主键是聚簇索引，索引的叶子节点存放表中一整行完整记录；</li>
<li>除主键索引外的索引都是二级索引，索引的叶子节点存放的是（索引键值，主键值）；</li>
<li>由于二级索引不存放完整记录，因此需要通过主键值再进行一次回表才能定位到完整数据；</li>
<li>索引组织表对比堆表，在海量并发的OLTP业务中能有更好的性能表现；</li>
<li>每种不同数据，对二级索引的性能开销影响是不一样的；(有序的二级索引性能更好)</li>
<li>有时通过函数索引可以快速解决线上SQL的性能问题；</li>
<li>虚拟列不占用实际存储空间，在虚拟列上创建索引本质就是函数索引。</li>
</ul>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><h4 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h4><p>​	在实际业务中，我们会遇到很多复杂的场景，比如对多个列进行查询。这时，可能会要求用户创建多个列组成的索引，如列 a 和 b 创建的组合索引，但究竟是创建（a，b）的索引，还是（b，a）的索引，结果却是完全不同的。</p>
<p>组合索引（Compound Index）是指<u>由多个列所组合而成的 B+树索引</u>，这和我们之前介绍的B+ 树索引的原理完全一样，只是<u><strong>之前是对一个列排序，现在是对多个列排序</strong></u>。</p>
<p>组合索引既可以是主键索引，也可以是二级索引，下图显示的是一个二级组合索引：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230803090636470.png" alt="image-20230803090636470"></p>
<p>从上图可以看到，组合索引只是排序的键值从 1 个变成了多个，本质还是一颗 B+ 树索引。但是你<u>一定要意识到（a，b）和（b，a）这样的组合索引，其排序结果是完全不一样的</u>。而索引的字段变多了，设计上更容易出问题，如：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230803090754475.png" alt="image-20230803090754475"></p>
<h4 id="示例🌰："><a href="#示例🌰：" class="headerlink" title="示例🌰："></a>示例🌰：</h4><p><strong>对组合索引（a，b）来说，因为其对列 a、b 做了排序，所以它可以对下面两个查询进行优化：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> ?</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> ？ <span class="keyword">AND</span> b <span class="operator">=</span> ？</span><br></pre></td></tr></table></figure>

<p>上述 SQL 查询中，WHERE 后查询列 a 和 b 的顺序无关，即使先写 b &#x3D; ? AND a &#x3D; ？依然可以使用组合索引（a，b）。</p>
<p>但是下面的 SQL 无法使用组合索引（a，b），因为（a，b）排序并不能推出（b，a）排序：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> b <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure>

<p>此外，同样由于索引（a，b）已排序，因此下面这条 SQL 依然可以使用组合索引（a，b），以此提升查询的效率：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> ？ <span class="keyword">ORDER</span> <span class="keyword">BY</span> b <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<p>同样的原因，索引（a，b）排序不能得出（b，a）排序，因此下面的 SQL 无法使用组合索引（a，b）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> b <span class="operator">=</span> ？ <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>



<h4 id="避免回表可以极大提升性能：！！！"><a href="#避免回表可以极大提升性能：！！！" class="headerlink" title="避免回表可以极大提升性能：！！！"></a>避免回表可以极大提升性能：！！！</h4><p>由于二级组合索引的叶子节点，包含索引键值和主键值，若查询的字段在二级索引的叶子节点中，则可直接返回结果，无需回表。这种<strong>通过组合索引避免回表的优化技术也称为索引覆盖（Covering Index）</strong>。</p>
<h4 id="总结：-4"><a href="#总结：-4" class="headerlink" title="总结："></a>总结：</h4><p>组合索引也是一颗 B+ 树，只是索引的列由多个组成，组合索引既可以是主键索引，也可以是二级索引。通过今天的学习，我们可以归纳组合索引的三大优势：</p>
<ol>
<li>覆盖多个查询条件，如（a，b）索引可以覆盖查询 a &#x3D; ? 或者 a &#x3D; ? and b &#x3D; ?；</li>
<li>避免 SQL 的额外排序，提升 SQL 性能，如 WHERE a &#x3D; ? ORDER BY b 这样的查询条件；</li>
<li>利用组合索引包含多个列的特性，可以实现<u><strong>索引覆盖技术</strong></u>，提升 SQL 的查询性能，用好索引覆盖技术，性能提升 10 倍不是难事。</li>
</ol>
<h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><p>​	在我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据在「二级索引」的叶子节点，那么只需要在「二级索引」的 B+ 树找到对应的叶子节点，然后读取要查询的数据即可，这个过程叫做<strong>覆盖索引</strong>。</p>
<p>但是<u><strong>并不意味着，查询条件用上了索引列，就查询过程就一定都用上索引</strong></u>，接下来我们再一起看看哪些情况会导致索引失效，而发生全表扫描。</p>
<h4 id="1-对索引使用左或者左右模糊匹配"><a href="#1-对索引使用左或者左右模糊匹配" class="headerlink" title="1.对索引使用左或者左右模糊匹配"></a>1.对索引使用<u>左</u>或者<u>左右</u>模糊匹配</h4><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p>​	🌟因为Innodb对你定义索引的字段值进行排序，如果你对字段值的左边进行模糊匹配，当然就无法对目标字段的范围进行一定程度的划分———意思就是找谁都不知道，即便你有序有什么用？</p>
<p>​	因此右模糊匹配还是会走索引的！</p>
<h4 id="2-对索引使用函数"><a href="#2-对索引使用函数" class="headerlink" title="2.对索引使用函数"></a>2.对索引使用函数</h4><p>​	有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，<u>如果查询条件中对索引字段使用函数，就会导致索引失效。</u></p>
<p>比如下面这条语句查询条件中对 name 字段使用了 LENGTH 函数，执行计划中的 type&#x3D;ALL，代表了全表扫描：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230803094403523.png" alt="image-20230803094403523"></p>
<h5 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h5><p>​	因为存储引擎只对name进行排序，并没有对length(name)或者是任何 函数名(name)进行排序，所以索引自然得失效了！</p>
<p>不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即<u><strong>可以针对函数计算后的值建立一个索引</strong></u>，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</p>
<h4 id="3-对索引进行表达式计算"><a href="#3-对索引进行表达式计算" class="headerlink" title="3.对索引进行表达式计算"></a>3.对索引进行表达式计算</h4><p>​	在查询条件中<u>对索引进行表达式计算</u>，也是无法走索引的。</p>
<p>​	比如，下面这条查询语句，执行计划中 type &#x3D; ALL，说明是通过全表扫描的方式查询数据的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230803094828483.png" alt="image-20230803094828483"></p>
<h5 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a>分析：</h5><p>​	显然，对id建立索引，并没有对 (id-1) 建立索引 ——-(虽然这里id - 1 的排序结果 &#x3D;&#x3D; id 的排序结果，但是如果不是简单的加减运算而是 比如 id^2 等计算的话，可能会与原本建立索引的排序结果不相同，因此对索引进行表达式计算，也是无法走索引的！)</p>
<h4 id="4-对索引隐式类型转换"><a href="#4-对索引隐式类型转换" class="headerlink" title="4.对索引隐式类型转换"></a>4.对索引隐式类型转换</h4><p>涉及mysql整形&lt;&#x3D;&#x3D;&gt;字符串的自动变化：</p>
<p>MySQL 在<strong>遇到字符串和数字比较的时候</strong>，<u><strong>⚠️会自动把字符串转为数字，然后再进行比较⚠️</strong></u>。</p>
<h5 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h5><p>​	如果<u>索引字段是字符串类型</u>，但是在条件查询中，<u>输入的参数是整型</u>的话，你会在执行计划的结果发现这条语句会走全表扫描。</p>
<p>​	因为：索引字段会被自动转换成数字类型，相当于走了一个函数，因此索引失效！！</p>
<h5 id="例2"><a href="#例2" class="headerlink" title="例2:"></a>例2:</h5><p>​	如果<u>索引字段是整型类型</u>，<u>查询条件中的输入参数即使字符串，是不会导致索引失效</u>，还是可以走索引扫描。</p>
<p>​	因为索引字段是整形，输入参数会改变类型，变为整形，因此索引可以生效！！</p>
<h4 id="5-联合索引非最左匹配"><a href="#5-联合索引非最左匹配" class="headerlink" title="5.联合索引非最左匹配"></a>5.联合索引非最左匹配</h4><p>那么<strong>多个普通字段组合在一起创建的索引就叫做联合索引</strong>，也叫组合索引。</p>
<p>创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。</p>
<p>联合索引要能正确使用需要遵循<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。</p>
<p>🌟比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p>
<ul>
<li>where a&#x3D;1；</li>
<li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li>
<li>where a&#x3D;1 and b&#x3D;2；</li>
</ul>
<p>需要注意的是，<u>因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。(但如果没有a，是万万不行的！)</u></p>
<p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p>
<ul>
<li>where b&#x3D;2；</li>
<li>where c&#x3D;3；</li>
<li>where b&#x3D;2 and c&#x3D;3；</li>
</ul>
<p>⚠️有一个比较特殊的查询条件：where a &#x3D; 1 and c &#x3D; 3 ，符合最左匹配吗？</p>
<p>这种其实严格意义上来说是属于索引截断，不同版本处理方式也不一样。</p>
<ul>
<li>MySQL 5.5 的话，<u>前面 a 会走索引，在联合索引找到主键值后，开始回表</u>，到主键索引读取数据行，Server 层从存储引擎层获取到数据行后，然后在 Server 层再比对 c 字段的值。</li>
<li>从 MySQL 5.6 之后，有一个<strong>索引下推功能</strong>，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">重要细节！！！！！</span><br><span class="line"></span><br><span class="line">⚠️：范围查询后的字段无法使用索引！！！</span><br><span class="line"></span><br><span class="line">🥩：如果查询条件中有多个以 and 连接的 联合索引声明的列的查询条件，那么会按找联合索引的顺序对查询条件进行处理</span><br><span class="line"></span><br><span class="line">例：对(c,b,a)简历联合索引，那么在查询条件为：where a=1 and b=2 and c=3时，会先筛选c=3 再 b=2 最后 a=1</span><br><span class="line"></span><br><span class="line">⚠️注意：如果条件为：where a=1 and b=2 and c&gt;3，先根据c的索引找到c&gt;3的记录，但是因为「范围查询后的字段无法使用索引！」，所以a、b此时无法走索引！！！！！</span><br></pre></td></tr></table></figure>



<h5 id="索引下推："><a href="#索引下推：" class="headerlink" title="索引下推："></a>索引下推：</h5><p>索引下推的大概原理是：截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在 <code>(a, b, c)</code> 联合索引里的），然后<u><strong>过滤出符合条件的数据后</strong>再返回给 Server 层</u>。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。</p>
<h4 id="6-WHERE-子句中的-OR"><a href="#6-WHERE-子句中的-OR" class="headerlink" title="6.WHERE 子句中的 OR"></a>6.WHERE 子句中的 OR</h4><p>​	在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p>
<p>​	举个例子，比如下面的查询语句，id 是主键，age 是普通列，从执行计划的结果看，是走了全表扫描。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure>

<p>这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。</p>
<p>要解决办法很简单，将 age 字段设置为索引即可。</p>
<h4 id="👍总结："><a href="#👍总结：" class="headerlink" title="👍总结："></a>👍总结：</h4><p>6 种会发生索引失效的情况：</p>
<ul>
<li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li>
<li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li>
<li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li>
<li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li>
<li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li>
<li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li>
</ul>
<h3 id="索引选择"><a href="#索引选择" class="headerlink" title="索引选择"></a>索引选择</h3><p>MySQL 数据库中的优化器是怎么执行的？根据什么标准选择索引的？</p>
<h4 id="CBO（Cost-based-Optimizer，基于成本的优化器）"><a href="#CBO（Cost-based-Optimizer，基于成本的优化器）" class="headerlink" title="CBO（Cost-based Optimizer，基于成本的优化器）"></a>CBO（Cost-based Optimizer，基于成本的优化器）</h4><p>MySQL中，<strong>一条 SQL 的计算成本计算如下所示：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cost  = Server Cost + Engine Cost</span><br><span class="line"></span><br><span class="line">      = CPU Cost + IO Cost</span><br></pre></td></tr></table></figure>

<p>CPU Cost 表示计算的开销，比如<u>索引键值的比较、记录值的比较、结果集的排序</u>……这些操作都在 Server 层完成；</p>
<p>IO Cost 表示引擎层 IO 的开销，MySQL 8.0 可以通过区分一张表的数据是否在内存中，分别计算<u>读取内存 IO 开销以及读取磁盘 IO 的开销。</u></p>
<p>MySQL 优化器是 CBO，即一种基于成本的优化器。其会判单每个索引的执行成本，从中选择出最优的执行计划。总结来说：</p>
<ul>
<li><p>MySQL 优化器是 CBO 的；</p>
</li>
<li><p>MySQL 会<u>选择成本最低的执行计划</u>，你可以通过 EXPLAIN 命令查看每个 SQL 的成本；</p>
</li>
<li><p>**<u>一般只对高选择度的字段和字段组合创建索引</u>**，低选择度的字段如性别，不创建索引；</p>
</li>
<li><p>低选择性，但是**<u>数据存在倾斜</u>**，通过索引找出少部分数据，可以<u>考虑创建索引</u>；</p>
<ul>
<li><p>在电商业务中会有一个这样的逻辑：即会定期扫描字段 o_orderstatus 为支付中的订单，然后强制让其关闭，从而释放库存，给其他有需求的买家进行购买。</p>
<p>但字段 o_orderstatus 的状态是有限的，一般仅为已完成、支付中、超时已关闭这几种。</p>
<p>通常订单状态<u>绝大部分都是已完成，只有绝少部分因为系统故障原因，会在 15 分钟后还没有完成订单</u>，<strong>因此订单状态是存在数据倾斜的。</strong></p>
</li>
</ul>
</li>
<li><p>若数据存在倾斜，可以创建直方图，让优化器知道索引中数据的分布，进一步校准执行计划。</p>
</li>
</ul>
<h3 id="索引应用"><a href="#索引应用" class="headerlink" title="索引应用"></a>索引应用</h3><h4 id="索引的优点："><a href="#索引的优点：" class="headerlink" title="索引的优点："></a>索引的优点：</h4><ul>
<li>整个数据库中，数据表的<u>查询速度直线提升</u>，数据量越大时效果越明显。</li>
<li>通过创建<u>唯一索引，可以确保数据表中的数据唯一性</u>，无需额外建立唯一约束。</li>
<li>在使用<u>分组和排序</u>时，同样可以显著减少<code>SQL</code>查询的分组和排序的时间。</li>
<li>连表查询时，基于主外键字段上建立索引，可以带来十分明显的性能提升。</li>
<li>索引默认是<code>B+Tree</code>有序结构，<u>基于索引字段做范围查询时，效率会明显提高</u>。</li>
<li>从<code>MySQL</code>整体架构而言，减少了查询<code>SQL</code>的执行时间，提高了数据库整体吞吐量。</li>
</ul>
<h4 id="索引的缺点："><a href="#索引的缺点：" class="headerlink" title="索引的缺点："></a>索引的缺点：</h4><ul>
<li>建立索引会生成本地磁盘文件，<u>需要额外的空间存储索引数据</u>，磁盘占用率会变高。</li>
<li><u><strong>写入数据时，需要额外维护索引结构</strong></u>，增、删、改数据时，都需要额外操作索引。</li>
<li><u><strong>写入数据</strong></u>时维护索引需要额外的时间开销，执行写<code>SQL</code>时效率会降低，性能会下降。</li>
</ul>
<h4 id="🌟主键索引最好使用带顺序性的值-比如：自增id、自增uuid-："><a href="#🌟主键索引最好使用带顺序性的值-比如：自增id、自增uuid-：" class="headerlink" title="🌟主键索引最好使用带顺序性的值(比如：自增id、自增uuid)："></a>🌟主键索引最好使用带顺序性的值(比如：自增id、自增uuid)：</h4><p>因为默认对主键建立索引，主键将被维护在B+树中，如果主键是随机的数，那么B+树将几乎在每次插入数据时重构，但如果主键有序，每次只需要将数据放到最后即可———便于维护B+树🌲</p>
<h4 id="🌟联合主键要注意非最左匹配的问题-详见索引失效章节"><a href="#🌟联合主键要注意非最左匹配的问题-详见索引失效章节" class="headerlink" title="🌟联合主键要注意非最左匹配的问题(详见索引失效章节)"></a>🌟联合主键要注意非最左匹配的问题(详见索引失效章节)</h4><h4 id="🌟前缀索引的弊端："><a href="#🌟前缀索引的弊端：" class="headerlink" title="🌟前缀索引的弊端："></a>🌟前缀索引的弊端：</h4><p>​	前缀索引的特点是短小精悍，我们可以利用一个字段的前<code>N</code>个字符创建索引，以这种形式创建的索引也被称之为前缀索引，相较于使用一个完整字段创建索引，前缀索引能够更加节省存储空间，当数据越多时，带来的优势越明显。</p>
<p>​	前缀索引<u>虽然带来了节省空间的好处</u>，但也正由于其索引节点中，未存储一个字段的完整值，所以<code>MySQL</code>也<u><strong>无法通过前缀索引来完成<code>ORDER BY、GROUP BY</code>等分组排序工作，同时也无法完成覆盖扫描等操作。</strong></u></p>
<h4 id="🌟全文索引："><a href="#🌟全文索引：" class="headerlink" title="🌟全文索引："></a>🌟全文索引：</h4><p>​	可以利用全文索引代替<code>like%</code>语法实现模糊查询，它的性能会比<code>like%</code>快上<code>N</code>倍。</p>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>由于全文索引是基于分词实现的，所以对一个字段建立全文索引后，<code>MySQL</code>会对该字段做分词处理，这些分词结果也会被存储在全文索引中，因此全文索引的文件会额外的大！</li>
<li>由于全文索引对每个字段值都会做分词，因此当修改字段值后，分词是需要时间的，所以修改字段数据后不会立马自动更新全文索引，此时需要咱们写存储过程，并调用它手动更新全文索引中的数据。</li>
<li>除开上述两点外，全文索引最大的硬伤在于对中文支持不够友好，类似于英文可以直接通过符号、空格来分词，但中文呢？一个词语来形容就是博大精深，无法精准的对一段文字做分词，因此全文索引在检索中文时，存在些许精准度问题。</li>
</ul>
<h4 id="🌟唯一索引的利弊："><a href="#🌟唯一索引的利弊：" class="headerlink" title="🌟唯一索引的利弊："></a>🌟唯一索引的利弊：</h4><p>​	查询快：不用考虑是否有多条索引值相同的记录</p>
<p>​	插入数据慢：需要考虑是否有多条索引值相同的记录</p>
<h4 id="🍓建立索引时，需要遵守的一些原则："><a href="#🍓建立索引时，需要遵守的一些原则：" class="headerlink" title="🍓建立索引时，需要遵守的一些原则："></a>🍓建立索引时，需要遵守的一些原则：</h4><ul>
<li>经常频繁用作查询条件的字段应酌情考虑为其创建索引。</li>
<li>表的主外键或连表字段，必须建立索引，因为能很大程度提升连表查询的性能。</li>
<li>建立索引的字段，一般值的区分性要足够高，这样才能提高索引的检索效率。</li>
<li>建立索引的字段，值不应该过长，如果较长的字段要建立索引，可以选择前缀索引。</li>
<li>建立联合索引，应当遵循最左前缀原则，将多个字段之间按优先级顺序组合。</li>
<li>经常根据范围取值、排序、分组的字段应建立索引，因为索引有序，能加快排序时间。</li>
<li>对于唯一索引，如果确认不会利用该字段排序，那可以将结构改为<code>Hash</code>结构。</li>
<li>尽量使用联合索引代替单值索引，联合索引比多个单值索引查询效率要高。</li>
</ul>
<h4 id="🫐建立索引时还需有些注意点："><a href="#🫐建立索引时还需有些注意点：" class="headerlink" title="🫐建立索引时还需有些注意点："></a>🫐建立索引时还需有些注意点：</h4><ul>
<li><u>值经常会增删改的字段，不合适建立索引，</u>因为每次改变后需维护索引结构。</li>
<li>一个字段存在<u>大量的重复值时，不适合建立索引</u>，比如之前举例的性别字段。</li>
<li>索引不能参与计算，因此经常带函数查询的字段，并不适合建立索引。</li>
<li>一张表中的索引数量并不是越多越好，一般控制在<code>3</code>，最多不能超过<code>5</code>。</li>
<li><u>建立联合索引时，一定要考虑优先级，查询频率最高的字段应当放首位</u>。</li>
<li>当表的数据较少，不应当建立索引，因为数据量不大时，维护索引反而开销更大。</li>
<li><u><strong>索引的字段值无序时，不推荐建立索引</strong></u>，因为会造成页分裂，尤其是主键索引。</li>
</ul>
<h3 id="索引面试题🍖-全部学习完再回来看！"><a href="#索引面试题🍖-全部学习完再回来看！" class="headerlink" title="索引面试题🍖(全部学习完再回来看！)"></a>索引面试题🍖(全部学习完再回来看！)</h3><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务的ACID："><a href="#事务的ACID：" class="headerlink" title="事务的ACID："></a>事务的ACID：</h2><h4 id="A–原子性-Atomicity"><a href="#A–原子性-Atomicity" class="headerlink" title="A–原子性(Atomicity):"></a>A–原子性(Atomicity):</h4><p>​			一些操作要么全做、要么全不做</p>
<h4 id="C–一致性-Consistency-："><a href="#C–一致性-Consistency-：" class="headerlink" title="C–一致性(Consistency)："></a>C–一致性(Consistency)：</h4><p>​			一致性的体现：操作执行完成后保证数据符合所有既定的约束</p>
<p>​			例如：某个约束为：参与转账的账户的总的余额是不变的</p>
<h4 id="I–隔离性-Isolation"><a href="#I–隔离性-Isolation" class="headerlink" title="I–隔离性(Isolation):"></a>I–隔离性(Isolation):</h4><p>​			不同的操作之间不应相互影响</p>
<h4 id="D–持久性-Durability"><a href="#D–持久性-Durability" class="headerlink" title="D–持久性(Durability):"></a>D–持久性(Durability):</h4><p>​			在操作完成后，实现了数据的状态转换，这个转换的结果将永久地保留。</p>
<h2 id="事务的隔离级别："><a href="#事务的隔离级别：" class="headerlink" title="事务的隔离级别："></a>事务的隔离级别：</h2><h3 id="并行事务会引发什么问题？"><a href="#并行事务会引发什么问题？" class="headerlink" title="并行事务会引发什么问题？"></a>并行事务会引发什么问题？</h3><p>在同时处理多个事务的时候，就可能出现<strong>脏读（dirty read）</strong>、<strong>不可重复读（non-repeatable read）</strong>、<strong>幻读（phantom read）</strong>的问题。</p>
<h4 id="脏读："><a href="#脏读：" class="headerlink" title="脏读："></a>脏读：</h4><p>​	<u>如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</u>		</p>
<h4 id="不可重复读："><a href="#不可重复读：" class="headerlink" title="不可重复读："></a>不可重复读：</h4><p>​	<u>在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</u></p>
<p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取某数据，然后继续执行代码逻辑处理，<strong>在这过程中如果<u>事务 B 更新了这条数据，并提交了事务</u>，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。</strong></p>
<h4 id="幻读："><a href="#幻读：" class="headerlink" title="幻读："></a>幻读：</h4><p>​	在一个事务内多次<u>查询某个符合查询条件的「记录数量」</u>，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。</p>
<h4 id="📖总结："><a href="#📖总结：" class="headerlink" title="📖总结："></a>📖总结：</h4><ul>
<li>脏读：读到其他事务未提交的数据；</li>
<li>不可重复读：前后读取的数据不一致；</li>
<li>幻读：前后读取的记录数量不一致。</li>
</ul>
<h3 id="事务的隔离级别有哪些？"><a href="#事务的隔离级别有哪些？" class="headerlink" title="事务的隔离级别有哪些？"></a>事务的隔离级别有哪些？</h3><p>​	<u>上述三个现象的严重性排序：   					脏读 &gt; 不可重复读 &gt; 幻读</u></p>
<p>SQL 标准提出了四种隔离级别来规避这些现象，<strong>隔离级别越高🔢，性能效率就越低</strong>，这四个隔离级别如下：</p>
<ul>
<li>4️⃣<strong>读未提交（<em>read uncommitted</em>）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li>
<li>3️⃣<strong>读提交（<em>read committed</em>）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li>
<li>2️⃣<strong>可重复读（<em>repeatable read</em>）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li>
<li>1️⃣<strong>串行化（<em>serializable</em> ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li>
</ul>
<p>​	</p>
<p>针对不同的隔离级别，并发事务时可能发生的现象也会不同，如图：</p>
<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230804164017574.png" alt="image-20230804164017574" style="zoom:33%;" />

<p>我们讨论的 <u>MySQL 虽然支持 4 种隔离级别，但是与SQL 标准中规定的各级隔离级别允许发生的现象却有些出入。</u></p>
<p>–MySQL中的「可重复读」比SQL标准的「可重复读」更牛！</p>
<p>MySQL 在「可重复读」隔离级别下，<u>可以很大程度上避免幻读现象的发生</u>（注意是很大程度避免，并不是彻底避免），所以 MySQL 并<u>不会使用「串行化」隔离级别来避免幻读现象的发生，因为使用「串行化」隔离级别会影响性能。</u></p>
<h4 id="MySQL-InnoDB-引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种："><a href="#MySQL-InnoDB-引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：" class="headerlink" title="MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种："></a><strong>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了）</strong>，解决的方案有两种：</h4><ul>
<li>针对<strong>快照读</strong>（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<u><strong>即使中途有其他事务插入了一条数据，是查询不出来这条数据的</strong></u>，所以就很好了避免幻读问题。</li>
<li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li>
</ul>
<h4 id="这四种隔离级别具体是如何实现的呢？"><a href="#这四种隔离级别具体是如何实现的呢？" class="headerlink" title="这四种隔离级别具体是如何实现的呢？"></a>这四种隔离级别具体是如何实现的呢？</h4><ul>
<li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li>
<li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li>
<li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 <strong>Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。<ul>
<li>注意，执行「开始事务」命令，并不意味着<u>启动了事务</u>。在 MySQL 有两种开启事务的命令，分别是：<ul>
<li>第一种：begin&#x2F;start transaction 命令；</li>
<li>第二种：start transaction with consistent snapshot 命令；</li>
</ul>
</li>
<li>这两种开启事务的命令，事务的启动时机是不同的：<ul>
<li>执行了 begin&#x2F;start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机；</li>
<li>执行了 start transaction with consistent snapshot 命令，就会马上启动事务。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Read-View-在-MVCC-里如何工作的？"><a href="#Read-View-在-MVCC-里如何工作的？" class="headerlink" title="Read View 在 MVCC 里如何工作的？"></a>Read View 在 MVCC 里如何工作的？</h3><p>​	我们需要了解两个知识：</p>
<ul>
<li>Read View 中四个字段作用；</li>
<li>聚簇索引记录中两个跟事务有关的隐藏列；</li>
</ul>
<h4 id="Read-View中的四个字段："><a href="#Read-View中的四个字段：" class="headerlink" title="Read View中的四个字段："></a>Read View中的四个字段：</h4><p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230804190142894.png" alt="image-20230804190142894"></p>
<ul>
<li>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li>
<li>min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值。</li>
<li>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1；</li>
<li>creator_trx_id ：指的是<strong>创建该 Read View 的事务的事务 id</strong>。</li>
</ul>
<p>知道了 Read View 的字段，我们还需要了解聚簇索引记录中的两个隐藏列。</p>
<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230804224256537.png" alt="image-20230804224256537" style="zoom: 33%;" />

<ul>
<li><u><strong>trx_id</strong></u>：当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</li>
<li><u><strong>roll_pointer</strong></u>：每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</li>
</ul>
<p>在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：</p>
<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230804224507005.png" alt="image-20230804224507005" style="zoom:40%;" />

<p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p>
<ul>
<li>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</li>
<li>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</li>
<li>如果记录的 trx_id 值在 Read View 的<code>min_trx_id</code>和 <code>max_trx_id</code>之间，需要判断 trx_id 是否在 m_ids 列表中：<ul>
<li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。</li>
<li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li>
</ul>
</li>
</ul>
<p><u><strong>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</strong></u></p>
<h3 id="可重复读是如何工作的？读提交是如何工作的？"><a href="#可重复读是如何工作的？读提交是如何工作的？" class="headerlink" title="可重复读是如何工作的？读提交是如何工作的？"></a>可重复读是如何工作的？读提交是如何工作的？</h3><p>对于「读提交」和「可重复读」隔离级别的事务来说，它们是<u>通过 Read View 来实现的</u>，它们的区别在于创建 Read View 的时机不同：</p>
<ul>
<li>「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</li>
<li>「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。</li>
</ul>
<p>这两个隔离级别实现<u><strong>是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。</strong></u></p>
<p>在可重复读隔离级别中，普通的 select 语句就是基于 MVCC 实现的快照读，也就是不会加锁的。而 select .. for update 语句就不是快照读了，而是当前读了，也就是每次读都是拿到最新版本的数据，但是它会对读到的记录加上 next-key lock 锁。</p>
<h3 id="MySQL-可重复读隔离级别，完全解决幻读了吗？"><a href="#MySQL-可重复读隔离级别，完全解决幻读了吗？" class="headerlink" title="MySQL 可重复读隔离级别，完全解决幻读了吗？"></a>MySQL 可重复读隔离级别，完全解决幻读了吗？</h3><h4 id="1-快照读是如何避免幻读的？"><a href="#1-快照读是如何避免幻读的？" class="headerlink" title="1.快照读是如何避免幻读的？"></a>1.快照读是如何避免幻读的？</h4><p>​	可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是开始事务后（执行 begin 语句后），在执行第一个查询语句后，会创建一个 Read View，<u><strong>后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的</strong>，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。</u></p>
<h4 id="2-当前读是如何避免幻读的？"><a href="#2-当前读是如何避免幻读的？" class="headerlink" title="2.当前读是如何避免幻读的？"></a>2.当前读是如何避免幻读的？</h4><p>MySQL 里除了普通查询是快照读，其他都是<strong>当前读</strong>，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。</p>
<p>这很好理解，假设你要 update 一个记录，另一个事务已经 delete 这条记录并且提交事务了，这样不是会产生冲突吗，所以 update 的时候肯定要知道最新的数据。</p>
<p>另外，<code>select ... for update</code> 这种查询语句是当前读，每次执行的时候都是读取最新的数据。</p>
<p><strong>Innodb 引擎为了解决「可重复读」隔离级别使用「当前读」而造成的幻读问题，就引出了next-key lock</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230807143817869.png" alt="image-20230807143817869"></p>
<p><strong>事务 A 执行了这面这条锁定读语句后，就在对表中的记录加上 id 范围为 (2, +∞] 的 next-key lock（next-key lock 是间隙锁+记录锁的组合）。</strong></p>
<p>然后，事务 B 在执行插入语句的时候，判断到插入的位置被事务 A 加了 next-key lock，于是事物 B 会生成一个插入意向锁，同时进入等待状态，直到事务 A 提交了事务。这就避免了由于事务 B 插入新记录而导致事务 A 发生幻读的现象。</p>
<h4 id="幻读被完全解决了吗？"><a href="#幻读被完全解决了吗？" class="headerlink" title="幻读被完全解决了吗？"></a>幻读被完全解决了吗？</h4><p>**可重复读隔离级别下虽然很大程度上避免了幻读，但是还是<u>没能完全解决幻读</u>**。</p>
<h5 id="幻读场景1"><a href="#幻读场景1" class="headerlink" title="幻读场景1:"></a>幻读场景1:</h5><p>​	<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230807144311080.png" alt="image-20230807144311080" style="zoom:50%;" /></p>
<p>在可重复读隔离级别下，<u>事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id &#x3D; 5 的记录并提交。接着，<strong>事务 A 对 id &#x3D; 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了</strong>，于是就发生了幻读。</u></p>
<p>因为这种特殊现象的存在，所以我们认为 <strong>MySQL Innodb 中的 MVCC 并不能完全避免幻读现象</strong>。</p>
<h5 id="幻读场景2"><a href="#幻读场景2" class="headerlink" title="幻读场景2:"></a>幻读场景2:</h5><p>除了上面这一种场景会发生幻读现象之外，还有下面这个场景也会发生幻读现象。</p>
<ul>
<li>T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。</li>
<li>T2 时刻：事务 B 往插入一个 id&#x3D; 200 的记录并提交；</li>
<li>T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。</li>
</ul>
<p><strong>🌟因为T1时刻没有 for update -&gt;进行当前读，因此没有加上next-key lock，因此导致了幻读</strong></p>
<p><strong>——所以我们开启事务后，要趁早添加next-key lock，即执行select … for update 这类当前读的语句，从而避免其他事务插入一条新记录。</strong></p>
<h1 id="锁🔒"><a href="#锁🔒" class="headerlink" title="锁🔒"></a>锁🔒</h1><h2 id="锁粒度："><a href="#锁粒度：" class="headerlink" title="锁粒度："></a>锁粒度：</h2><h3 id="1-全局锁："><a href="#1-全局锁：" class="headerlink" title="1.全局锁："></a>1.全局锁：</h3><p>​	要使用全局锁，则要执行这条命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用全局锁：</span></span><br><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br><span class="line"><span class="comment">-- 释放全局锁：</span></span><br><span class="line">unlock tables</span><br></pre></td></tr></table></figure>

<p>​	执行完后，<strong>数据库只能被查询</strong>，其他操作都不能做！！！！</p>
<h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><p>​	全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><p>​	那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。</p>
<h4 id="🌟既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？"><a href="#🌟既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？" class="headerlink" title="🌟既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？"></a>🌟既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？</h4><p>​	有的，如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，<u>那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</u></p>
<p>​	因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。</p>
<p>​	备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 <code>–single-transaction</code> 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。</p>
<p>​	InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。</p>
<p>​	但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。</p>
<h3 id="2-表级锁："><a href="#2-表级锁：" class="headerlink" title="2.表级锁："></a>2.表级锁：</h3><p>MySQL 里面表级别的锁有这几种：</p>
<ul>
<li>表锁；</li>
<li>元数据锁（MDL）;</li>
<li>意向锁；</li>
<li>AUTO-INC 锁；</li>
</ul>
<h4 id="2-1-表锁："><a href="#2-1-表锁：" class="headerlink" title="2.1.表锁："></a>2.1.表锁：</h4><p>​	表锁能够锁住一张表：一个线程对一张表添加了表锁，那么所有线程对该表的写操作都会被阻塞！</p>
<p>不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，<strong>InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁</strong>。</p>
<h4 id="2-2-元数据锁-MDL-："><a href="#2-2-元数据锁-MDL-：" class="headerlink" title="2.2.元数据锁(MDL)："></a>2.2.元数据锁(MDL)：</h4><p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p>
<ul>
<li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li>
<li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li>
</ul>
<p><u>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</u></p>
<p>​	🌟<strong>当有线程在执行 select 语句（ 加 MDL <u>读</u>锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL <u>写</u>锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。</strong></p>
<p>​	<strong>🌟反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。</strong></p>
<blockquote>
<p>MDL 不需要显示调用，那它是在什么时候释放的?</p>
</blockquote>
<p>MDL 是<u>在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</u></p>
<p>那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：</p>
<ol>
<li>首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；</li>
<li>然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；</li>
<li>接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，</li>
</ol>
<p>那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。</p>
<h4 id="2-3-意向锁："><a href="#2-3-意向锁：" class="headerlink" title="2.3.意向锁："></a>2.3.意向锁：</h4><ul>
<li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li>
<li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li>
</ul>
<p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p>
<p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p>
<p>总之：<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p>
<h4 id="2-4-AUTO-INC-锁："><a href="#2-4-AUTO-INC-锁：" class="headerlink" title="2.4.AUTO-INC 锁："></a>2.4.AUTO-INC 锁：</h4><p>表里的主键通常都会设置成自增的，这是通过对主键字段声明 <code>AUTO_INCREMENT</code> 属性实现的。</p>
<p>之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 <strong>AUTO-INC 锁</strong>实现的。</p>
<p>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。</p>
<p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p>
<p>那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 <code>AUTO_INCREMENT</code> 修饰的字段的值是连续递增的。</p>
<p>但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</p>
<p>因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增。</p>
<p>一样也是在插入数据的时候，会为被 <code>AUTO_INCREMENT</code> 修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。</p>
<h3 id="3-行级锁："><a href="#3-行级锁：" class="headerlink" title="3.行级锁："></a>3.行级锁：</h3><p>​	行锁的释放时机是在事务提交（commit）后，锁会被释放，并不是一条语句执行完就释放行锁。</p>
<p>​	需要注意的是，如果 update 语句的 where 条件没有用到索引列，那么就会全表扫描，在一行行扫描的过程中，不仅给行记录加上了行锁，还给行记录两边的空隙也加上了间隙锁，相当于锁住整个表，然后直到事务结束才会释放锁。</p>
<p>所以在线上千万不要执行没有带索引条件的 update 语句，不然会造成业务停滞</p>
<h4 id="3-1-记录锁：Record-Lock"><a href="#3-1-记录锁：Record-Lock" class="headerlink" title="3.1.记录锁：Record Lock"></a>3.1.记录锁：Record Lock</h4><p>​	Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁( 类似读锁 )和 X 锁( 类似写锁 )之分的：</p>
<ul>
<li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li>
<li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</li>
</ul>
<h4 id="3-2-间隙锁：Gap-Lock"><a href="#3-2-间隙锁：Gap-Lock" class="headerlink" title="3.2.间隙锁：Gap Lock"></a>3.2.间隙锁：Gap Lock</h4><p>​	Gap Lock **<u>只存在于可重复读隔离级别</u>**，目的是<u>为了解决可重复读隔离级别下幻读的现象</u>。</p>
<p>假设，表中有一个范围 id 为（3，5）间隙锁，那么<strong>其他事务就<u>无法插入</u> id &#x3D; 4 这条记录了</strong>，这样就有效的防止幻读现象的发生。</p>
<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230806093108438.png" alt="image-20230806093108438" style="zoom:50%;" />

<p>间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，<strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong>。</p>
<h4 id="3-3-临键锁：Next-Key-Lock"><a href="#3-3-临键锁：Next-Key-Lock" class="headerlink" title="3.3.临键锁：Next-Key Lock"></a>3.3.临键锁：Next-Key Lock</h4><p>Next-Key Lock 称为临键锁，是 <u><strong>Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</strong></u></p>
<p>假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id &#x3D; 4 记录，也不能修改 id &#x3D; 5 这条记录。</p>
<p><strong>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。—-因为记录X锁不能兼容</p>
<h4 id="3-4-插入意向锁："><a href="#3-4-插入意向锁：" class="headerlink" title="3.4.插入意向锁："></a>3.4.插入意向锁：</h4><p>​	一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。</p>
<p>如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p>
<p>举个例子，假设事务 A 已经对表加了一个范围 id 为（3，5）间隙锁。</p>
<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230806093108438.png" alt="image-20230806093108438" style="zoom:50%;" />

<p>当事务 A 还没提交的时候，事务 B 向该表插入一条 id &#x3D; 4 的新记录，这时会判断到插入的位置已经被事务 A 加了间隙锁，于是事物 B 会生成一个插入意向锁，然后将锁的状态设置为等待状态（<em>PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁</em>），此时事务 B 就会发生阻塞，直到事务 A 提交了事务。</p>
<p>插入意向锁名字虽然有意向锁，但是它并<strong>不是意向锁，它是一种特殊的间隙锁，属于行级别锁</strong>。</p>
<p>如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。</p>
<p>插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。</p>
<h2 id="死锁："><a href="#死锁：" class="headerlink" title="死锁："></a>死锁：</h2><p>​	</p>
<h3 id="Insert-语句是怎么加行级锁的？"><a href="#Insert-语句是怎么加行级锁的？" class="headerlink" title="Insert 语句是怎么加行级锁的？"></a>Insert 语句是怎么加行级锁的？</h3><p>Insert 语句在正常执行时是不会生成锁结构的，它是靠聚簇索引记录自带的 trx_id 隐藏列来作为<strong>隐式锁</strong>来保护记录的。</p>
<blockquote>
<p>什么是隐式锁？</p>
</blockquote>
<p>当事务需要加锁的时，<u>如果这个锁不可能发生冲突，InnoDB会跳过加锁环节，这种机制称为隐式锁</u>。隐式锁是 InnoDB 实现的一种延迟加锁机制，其特点是只有在可能发生冲突时才加锁，从而减少了锁的数量，提高了系统整体性能。</p>
<p>隐式锁就是在 Insert 过程中不加锁，只有在特殊情况下，才会将隐式锁转换为显示锁，这里我们列举两个场景。</p>
<ul>
<li>如果记录之间加有间隙锁，为了避免幻读，此时是不能插入记录的；<ul>
<li>每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，如果已加间隙锁，此时会生成一个插入意向锁，然后锁的状态设置为等待状态（<em>PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁</em>），现象就是 Insert 语句会被阻塞。</li>
</ul>
</li>
<li>如果 Insert 的记录和已有记录存在唯一键冲突，此时也不能插入记录；<ul>
<li>如果在插入新记录时，插入了一个与「已有的记录的主键或者唯一二级索引列值相同」的记录（不过可以有多条记录的唯一二级索引列的值同时为NULL，这里不考虑这种情况），此时插入就会失败，然后对于这条记录加上了 <strong>S 型的锁</strong>。<ul>
<li>如果<u>主键索引重复</u>，插入新记录的事务会给已存在的主键值重复的聚簇索引记录<strong>添加 S 型记录锁</strong>。</li>
<li>如果<u>唯一二级索引重复</u>，插入新记录的事务都会给已存在的二级索引列值重复的二级索引记录<strong>添加 S 型 next-key 锁</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h3><p>​	死锁的四个必要条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。</p>
<p>在数据库层面，有两种策略通过「打破循环等待条件」来解除死锁状态：</p>
<ul>
<li><p><strong>设置事务等待锁的超时时间</strong>。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 <code>innodb_lock_wait_timeout</code> 是用来设置超时时间的，默认值时 50 秒。</p>
<p>当发生超时后，就出现下面这个提示：</p>
</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/c296c1889f0101d335699311b4ef20a8.png" alt="图片"></p>
<ul>
<li><p><strong>开启主动死锁检测</strong>。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑，默认就开启。</p>
<p>当检测到死锁后，就会出现下面这个提示：</p>
</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/f380ef357d065498d8d54ad07f145e09.png" alt="图片"></p>
<p>上面这个两种策略是「当有死锁发生时」的避免方式。</p>
<p>我们可以回归业务的角度来预防死锁，对订单做幂等性校验的目的是为了保证不会出现重复的订单，那我们可以直接将 order_no 字段设置为唯一索引列，利用它的唯一性来保证订单表不会出现重复的订单，不过有一点不好的地方就是在我们插入一个已经存在的订单记录时就会抛出异常。</p>
<h3 id="一道面试题："><a href="#一道面试题：" class="headerlink" title="一道面试题："></a>一道面试题：</h3><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230807154158632.png" alt="image-20230807154158632" style="zoom: 33%;" />

<p>按题中顺序执行，会发生什么？</p>
<h4 id="Time1"><a href="#Time1" class="headerlink" title="Time1:"></a>Time1:</h4><p>​	**此时事务 A 在主键索引（INDEX_NAME : PRIMARY）上加了间隙锁，锁范围是<code>(20, 30)</code>**。</p>
<h4 id="Time2"><a href="#Time2" class="headerlink" title="Time2:"></a>Time2:</h4><p>​	**事务 B 在主键索引（INDEX_NAME : PRIMARY）上加了间隙锁，锁范围是<code>(20, 30)</code>**。</p>
<h4 id="Time3"><a href="#Time3" class="headerlink" title="Time3:"></a>Time3:</h4><p>​		事务 A 的状态为等待状态（LOCK_STATUS: WAITING），因为向事务 B 生成的间隙锁（范围 <code>(20, 30)</code>）中插入了一条记录，<u>所以事务 A 的插入操作生成了一个插入意向锁</u></p>
<p>​	<strong>尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。所以，插入意向锁和间隙锁之间是冲突的</strong>。</p>
<p><u><strong>因此事务A会等待事务B在主键范围20~30上的间隙锁释放！</strong></u></p>
<h4 id="Time4"><a href="#Time4" class="headerlink" title="Time4:"></a>Time4:</h4><p>​		事务B会等待事务A在主键范围20~30上的间隙锁释放</p>
<p>​	</p>
<p>📖 事务 A 和事务 B 在执行完后 update 语句后都持有范围为<code>(20, 30）</code>的间隙锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，满足了死锁的四个条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>，因此发生了死锁。</p>
<h4 id="总结🌟："><a href="#总结🌟：" class="headerlink" title="总结🌟："></a>总结🌟：</h4><p>​	两个事务即使生成的间隙锁的范围是一样的，也不会发生冲突，因为<u>间隙锁目的是为了防止其他事务插入数据，因此间隙锁与间隙锁之间是相互兼容的。</u></p>
<p>​	<u><strong>在执行插入语句时，如果插入的记录在其他事务持有间隙锁范围内，插入语句就会被阻塞，因为插入语句在碰到间隙锁时，会生成一个插入意向锁，然后插入意向锁和间隙锁之间是互斥的关系。</strong></u></p>
<p>​	<u>如果两个事务分别向对方持有的间隙锁范围内插入一条记录，而插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，满足了死锁的四个条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>，因此发生了死锁。</u></p>
<h3 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h3><p>在工作过程中偶尔会遇到死锁问题，虽然这种问题遇到的概率不大，但每次遇到的时候要想彻底弄懂其原理并找到解决方案却并不容易。其实，对于 MySQL 的 InnoDb 存储引擎来说，死锁问题是避免不了的，没有哪种解决方案可以说完全解决死锁问题，但是我们可以通过一些可控的手段，降低出现死锁的概率。</p>
<ol>
<li>对索引加锁顺序的不一致很可能会导致死锁，所以如果可以，尽量以相同的顺序来访问索引记录和表。在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能；</li>
<li>Gap 锁往往是程序中导致死锁的真凶，由于默认情况下 MySQL 的隔离级别是 RR，所以如果能确定幻读和不可重复读对应用的影响不大，可以考虑将隔离级别改成 RC，可以避免 Gap 锁导致的死锁；</li>
<li>为表添加合理的索引，如果不走索引将会为表的每一行记录加锁，死锁的概率就会大大增大；</li>
<li>我们知道 MyISAM 只支持表锁，它采用一次封锁技术来保证事务之间不会发生死锁，所以，我们也可以使用同样的思想，在事务中一次锁定所需要的所有资源，减少死锁概率；</li>
<li>避免大事务，尽量将大事务拆成多个小事务来处理；因为大事务占用资源多，耗时长，与其他事务冲突的概率也会变高；</li>
<li>避免在同一时间点运行多个对同一表进行读写的脚本，特别注意加锁且操作数据量比较大的语句；我们经常会有一些定时脚本，避免它们在同一时间点运行；</li>
<li>设置锁等待超时参数：<code>innodb_lock_wait_timeout</code>，这个参数并不是只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获得所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖跨数据库。我们通过设置合适的锁等待超时阈值，可以避免这种情况发生。</li>
</ol>
<h2 id="悲观锁与乐观锁："><a href="#悲观锁与乐观锁：" class="headerlink" title="悲观锁与乐观锁："></a>悲观锁与乐观锁：</h2><h3 id="悲观锁："><a href="#悲观锁：" class="headerlink" title="悲观锁："></a>悲观锁：</h3><p><strong>悲观锁（Pessimistic Lock）：</strong> 就是很悲观，每次去拿数据的时候都认为别人会修改。所以每次在拿数据的时候都会上锁。这样别人想拿数据就被挡住，直到悲观锁被释放，<strong>悲观锁中的共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong></p>
<p>但是在效率方面，处理加锁的机制会产生额外的开销，还有增加产生死锁的机会。另外还会降低并行性，如果已经锁定了一个线程 A，其他线程就必须等待该线程 A 处理完才可以处理</p>
<p>数据库中的行锁，表锁，读锁（共享锁），写锁（排他锁），以及 <strong>syncronized</strong> 实现的锁均为悲观锁</p>
<p>悲观并发控制实际上是“<strong>先取锁再访问</strong>”的保守策略，为数据处理的安全提供了保证</p>
<h3 id="乐观锁："><a href="#乐观锁：" class="headerlink" title="乐观锁："></a>乐观锁：</h3><p><strong>乐观锁（Optimistic Lock）：</strong> 就是很乐观，每次去拿数据的时候都认为别人不会修改。所以不会上锁，<u>但是如果想要更新数据，则会在更新前检查在读取至更新这段时间别人有没有修改过这个数据。如果修改过，则重新读取，再次尝试更新，循环上述步骤直到更新成功（当然也允许更新失败的线程放弃操作）,<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong></u></p>
<p>相对于悲观锁，在对数据库进行处理的时候，乐观锁<u>并不会使用数据库提供的锁机制</u>。<u><strong>一般的实现乐观锁的方式就是记录数据版本（version）或者是时间戳来实现，不过使用版本记录是最常用的。</strong></u></p>
<p>—-&gt;为数据添加一列version，用于version管理</p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h3 id="MySQL-日志：undo-log、redo-log、binlog-有什么用？"><a href="#MySQL-日志：undo-log、redo-log、binlog-有什么用？" class="headerlink" title="MySQL 日志：undo log、redo log、binlog 有什么用？"></a>MySQL 日志：undo log、redo log、binlog 有什么用？</h3><ul>
<li><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</li>
<li><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</li>
<li><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li>
</ul>
<h4 id="为什么需要-undo-log？"><a href="#为什么需要-undo-log？" class="headerlink" title="为什么需要 undo log？"></a>为什么需要 undo log？</h4><p>如果我们每次在事务执行过程中，都记录下回滚时需要的信息到一个日志里，那么在事务执行中途发生了 MySQL 崩溃后，就不用担心无法回滚到事务之前的数据，我们可以通过这个日志回滚到事务之前的数据。</p>
<p>实现这一机制就是 <strong>undo log（回滚日志），它保证了事务的 <a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/transaction/mvcc.html#%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7">ACID 特性 (opens new window)</a>中的原子性（Atomicity）</strong>。</p>
<p>undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。</p>
<p><u><strong>一条记录的每一次更新操作产生的 undo log 格式都有一个 roll_pointer 指针和一个 trx_id 事务id：</strong></u></p>
<ul>
<li>通过 trx_id 可以知道该记录是被哪个事务修改的；</li>
<li>通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链；</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230808100304687.png" alt="image-20230808100304687" style="zoom:50%;" />

<h5 id="🌟undo-log-两大作用："><a href="#🌟undo-log-两大作用：" class="headerlink" title="🌟undo log 两大作用："></a>🌟undo log 两大作用：</h5><ul>
<li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li>
<li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li>
</ul>
<h4 id="为什么需要-Buffer-Pool？"><a href="#为什么需要-Buffer-Pool？" class="headerlink" title="为什么需要 Buffer Pool？"></a>为什么需要 Buffer Pool？</h4><p>​	Innodb 存储引擎设计了一个<strong>缓冲池（Buffer Pool）</strong>，来提高数据库的读写性能。</p>
<p>​	有了 Buffer Pool 后：</p>
<ul>
<li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li>
<li>当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。</li>
</ul>
<p>Buffer Pool中还有Undo页，用于记录undo log：</p>
<p>​	开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。</p>
<h4 id="为什么需要-redo-log-？"><a href="#为什么需要-redo-log-？" class="headerlink" title="为什么需要 redo log ？"></a>为什么需要 redo log ？</h4><p>​	Buffer Pool 是提高了读写效率没错，但是问题来了，Buffer Pool 是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。</p>
<p>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，<strong>这个时候更新就算完成了</strong>。</p>
<p>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <strong>WAL （Write-Ahead Logging）技术</strong>。</p>
<p><strong>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230808101725828.png" alt="image-20230808101725828" style="zoom: 45%;" />

<p>redo log 是物理日志，记录了某个数据页做了什么修改，比如<strong>对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新</strong>，每当执行一个事务就会产生这样的一条或者多条物理日志。</p>
<p>在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。</p>
<p>当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。</p>
<ul>
<li>redo log 记录了此次事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值；</li>
<li>undo log 记录了此次事务「<strong>开始前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值；</li>
</ul>
<p>⚠️<u><strong>事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务</strong></u></p>
<h5 id="redo-log-要写到磁盘，数据也要写磁盘，为什么要多此一举？"><a href="#redo-log-要写到磁盘，数据也要写磁盘，为什么要多此一举？" class="headerlink" title="redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？"></a>redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？</h5><p>写入 redo log 的方式使用了追加操作， 所以磁盘操作是<strong>顺序写</strong>，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是<strong>随机写</strong>。</p>
<p>磁盘的「顺序写 」比「随机写」 高效的多，因此 redo log 写入磁盘的开销更小。</p>
<p>可以说这是 WAL 技术的另外一个优点：<strong>MySQL 的写操作从磁盘的「随机写」变成了「顺序写」</strong>，提升语句的执行性能。这是因为 MySQL 的写操作并不是立刻更新到磁盘上，而是先记录在日志上，然后在合适的时间再更新到磁盘上 。</p>
<p>⚠️至此， 针对为什么需要 redo log 这个问题我们有两个答案：</p>
<ul>
<li><strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li>
<li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。</li>
</ul>
<h5 id="redo-log直接写入磁盘吗？"><a href="#redo-log直接写入磁盘吗？" class="headerlink" title="redo log直接写入磁盘吗？"></a>redo log直接写入磁盘吗？</h5><p>redo log 也会先被保存在内存中的<strong>redo log buffer</strong>中，一定时机下存入磁盘——因为如果每条redo log都立即存入磁盘会增加I&#x2F;O开销，大大降低性能。</p>
<h5 id="redo-log-buffer何时写入磁盘："><a href="#redo-log-buffer何时写入磁盘：" class="headerlink" title="redo log buffer何时写入磁盘："></a>redo log buffer何时写入磁盘：</h5><ul>
<li>MySQL 正常关闭时；</li>
<li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li>
<li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li>
<li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制，别的参数代表别的方案）</li>
</ul>
<h5 id="redo-log-文件写满了怎么办？"><a href="#redo-log-文件写满了怎么办？" class="headerlink" title="redo log 文件写满了怎么办？"></a>redo log 文件写满了怎么办？</h5><p>默认情况下， InnoDB 存储引擎有 1 个重做日志文件组( redo log Group），「重做日志文件组」由有 2 个 redo log 文件组成，这两个 redo 日志的文件名叫 ：<code>ib_logfile0</code> 和 <code>ib_logfile1</code> 。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84.drawio.png" alt="重做日志文件组"></p>
<p>在重做日志组中，每个 redo log File 的大小是固定且一致的，假设每个 redo log File 设置的上限是 1 GB，那么总共就可以记录 2GB 的操作。</p>
<p>重做日志文件组是以<strong>循环写</strong>的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形。</p>
<p>所以 InnoDB 存储引擎会先写 ib_logfile0 文件，当 ib_logfile0 文件被写满的时候，会切换至 ib_logfile1 文件，当 ib_logfile1 文件也被写满时，会切换回 ib_logfile0 文件。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B.drawio.png" alt="重做日志文件组写入过程"></p>
<p>我们知道 redo log 是为了防止 Buffer Pool 中的脏页丢失而设计的，那么如果随着系统运行，Buffer Pool 的脏页刷新到了磁盘中，那么 redo log 对应的记录也就没用了，这时候我们擦除这些旧记录，以腾出空间记录新的更新操作。</p>
<h4 id="为什么需要-binlog-？"><a href="#为什么需要-binlog-？" class="headerlink" title="为什么需要 binlog ？"></a>为什么需要 binlog ？</h4><p>—-记录了所有<strong>数据库表结构变更和表数据修改</strong>的日志</p>
<p>前面介绍的 undo log 和 redo log 这两个日志都是 <u>Innodb 存储引擎生成</u>的。</p>
<p>MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后<u>事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件。</u></p>
<p>binlog 文件是<u>记录了所有<strong>数据库表结构变更和表数据修改</strong>的日志</u>，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。</p>
<h5 id="redo-log-和-binlog-有什么区别？"><a href="#redo-log-和-binlog-有什么区别？" class="headerlink" title="redo log 和 binlog 有什么区别？"></a>redo log 和 binlog 有什么区别？</h5><p>这两个日志有四个区别。</p>
<p><em>1、适用对象不同：</em></p>
<ul>
<li>binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；</li>
<li>redo log 是 Innodb 存储引擎实现的日志；</li>
</ul>
<p><em>2、文件格式不同：</em></p>
<ul>
<li>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：<ul>
<li>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；</li>
<li>ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；</li>
<li>MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</li>
</ul>
</li>
<li>redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；</li>
</ul>
<p><em>3、写入方式不同：</em></p>
<ul>
<li>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</li>
<li>redo log 是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。</li>
</ul>
<p><em>4、用途不同：</em></p>
<ul>
<li>binlog 用于备份恢复、主从复制；</li>
<li>redo log 用于掉电等故障恢复。</li>
</ul>
<p>如果不小心整个数据库的数据被删除了，只能使用binlog恢复数据库，redolog文件为循环写机制，边写边擦除，只留有最新的操作</p>
<h5 id="MySQL主从复制："><a href="#MySQL主从复制：" class="headerlink" title="MySQL主从复制："></a>MySQL主从复制：</h5><p>MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上。</p>
<p>这个过程一般是<strong>异步</strong>的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="MySQL 主从复制过程"></p>
<p>MySQL 集群的主从复制过程梳理成 3 个阶段：</p>
<ul>
<li><strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据。</li>
<li><strong>同步 Binlog</strong>：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。</li>
<li><strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据。</li>
</ul>
<p>具体详细过程如下：</p>
<ul>
<li>MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。</li>
<li>从库会创建一个专门的 I&#x2F;O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。</li>
<li>从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。</li>
</ul>
<p>在完成主从复制之后，你就可以在写数据时只写主库，在读数据时只读从库，这样即使写请求会锁表或者锁记录，也不会影响读请求的执行。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="MySQL 主从架构"></p>
<h5 id="binlog-什么时候刷盘？"><a href="#binlog-什么时候刷盘？" class="headerlink" title="binlog 什么时候刷盘？"></a>binlog 什么时候刷盘？</h5><p>事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，再把 binlog cache 写到 binlog 文件中。</p>
<p>一个事务的 binlog 是不能被拆开的，因此无论这个事务有多大（比如有很多条语句），也要保证一次性写入。这是因为有一个线程只能同时有一个事务在执行的设定，所以每当执行一个 begin&#x2F;start transaction 的时候，就会默认提交上一个事务，这样如果一个事务的 binlog 被拆开的时候，在备库执行就会被当做多个事务分段自行，这样破坏了原子性，是有问题的。</p>
<p>MySQL 给每个线程分配了一片内存用于缓冲 binlog ，该内存叫 binlog cache，参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p>
<h5 id="为什么需要两阶段提交？"><a href="#为什么需要两阶段提交？" class="headerlink" title="为什么需要两阶段提交？"></a>为什么需要两阶段提交？</h5><p>​	事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。<strong>因为 redo log 影响主库的数据，binlog 影响从库的数据，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致。</strong></p>
<h5 id="两阶段提交的实现过程："><a href="#两阶段提交的实现过程：" class="headerlink" title="两阶段提交的实现过程："></a>两阶段提交的实现过程：</h5><p>​	事务的提交过程有两个阶段，就是<strong>将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog</strong>，具体如下：</p>
<ul>
<li><strong>prepare 阶段</strong>：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit &#x3D; 1 的作用）；</li>
<li><strong>commit 阶段</strong>：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog &#x3D; 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功；</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230808110410810.png" alt="image-20230808110410810" style="zoom: 43%;" />



<h5 id="事务没提交的时候，redo-log-会被持久化到磁盘吗？"><a href="#事务没提交的时候，redo-log-会被持久化到磁盘吗？" class="headerlink" title="事务没提交的时候，redo log 会被持久化到磁盘吗？"></a>事务没提交的时候，redo log 会被持久化到磁盘吗？</h5><p>会的。</p>
<p>事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些缓存在 redo log buffer 里的 redo log 也会被「后台线程」每隔一秒一起持久化到磁盘。</p>
<p>也就是说，<strong>事务没提交的时候，redo log 也是可能被持久化到磁盘的</strong>。</p>
<p>有的同学可能会问，如果 mysql 崩溃了，还没提交事务的 redo log 已经被持久化磁盘了，mysql 重启后，数据不就不一致了？</p>
<p>放心，这种情况 mysql 重启会进行回滚操作，因为事务没提交的时候，binlog 是还没持久化到磁盘的。</p>
<p>所以， redo log 可以在事务没提交之前持久化到磁盘，但是 binlog 必须在事务提交之后，才可以持久化到磁盘。</p>
<h4 id="🌟总结："><a href="#🌟总结：" class="headerlink" title="🌟总结："></a>🌟总结：</h4><p>具体更新一条记录 <code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1;</code> 的流程如下:</p>
<ol>
<li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id &#x3D; 1 这一行记录：<ul>
<li>如果 id&#x3D;1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li>
<li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li>
</ul>
</li>
<li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：<ul>
<li>如果一样的话就不进行后续更新流程；</li>
<li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li>
</ul>
</li>
<li>开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li>
<li>InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 <strong>WAL 技术</strong>，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</li>
<li>至此，一条记录更新完了。</li>
<li>在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li>
<li>事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：<ul>
<li><strong>prepare 阶段</strong>：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li>
<li><strong>commit 阶段</strong>：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；</li>
</ul>
</li>
<li>至此，一条更新语句执行完成。</li>
</ol>
<h3 id="数据库备份：备份文件也要检查！"><a href="#数据库备份：备份文件也要检查！" class="headerlink" title="数据库备份：备份文件也要检查！"></a>数据库备份：备份文件也要检查！</h3><h4 id="全量备份："><a href="#全量备份：" class="headerlink" title="全量备份："></a>全量备份：</h4><h5 id="1-逻辑备份："><a href="#1-逻辑备份：" class="headerlink" title="1. 逻辑备份："></a>1. 逻辑备份：</h5><p>指备份数据库的逻辑内容，就是每张表中的内容<u>通过 INSERT 语句的形式进行备份</u>。</p>
<p>MySQL 官方提供的逻辑备份工具有 <strong>mysqldump 和 mysqlpump</strong></p>
<p>mysqldump：单线程</p>
<p>mysqlpump：基于表的多线程，<u>不同表可以同时备份</u>(不能构建一个一致性的备份)</p>
<h5 id="2-物理备份："><a href="#2-物理备份：" class="headerlink" title="2. 物理备份："></a>2. 物理备份：</h5><p>逻辑备份虽然好，但是它所需要的时间比较长，因为本质上逻辑备份就是进行 INSERT … SELECT … 的操作。</p>
<p>而<u>物理备份直接备份数据库的物理表空间文件和重做日志，不用通过逻辑的 SELECT 取出数据</u>。所以物理备份的速度，通常是比逻辑备份快的，恢复速度也比较快。</p>
<p>但它不如 mydumper 的是，<u><strong>物理备份只能恢复整个实例的数据，而不能按指定表进行恢复</strong></u>。MySQL 8.0 的物理备份工具可以选择官方的 Clone Plugin。</p>
<h4 id="增量备份："><a href="#增量备份：" class="headerlink" title="增量备份："></a>增量备份：</h4><p>​	我们需要通过“全量备份 + 增量备份”的方式，构建完整的备份策略。<strong>增量备份就是对日志文件进行备份，在 MySQL 数据库中就是二进制日志文件。</strong></p>
<p>​	因为二进制日志保存了对数据库所有变更的修改，所以“全量备份 + 增量备份”，就可以实现基于时间点的恢复（point in time recovery），也就是“通过全量 + 增量备份”可以恢复到任意时间点。</p>
<p>​	MySQL 增量备份的本质是通过 mysqlbinlog 模拟一个 slave 从服务器，然后主服务器不断将二进制日志推送给从服务器，利用之前介绍的复制技术，实现数据库的增量备份。</p>
<p>增量备份的恢复，就是通过 mysqlbinlog 解析二进制日志，然后进行恢复</p>
<h4 id="备份策略："><a href="#备份策略：" class="headerlink" title="备份策略："></a>备份策略：</h4><p>在掌握全量备份、增量备份的知识点后，我们就能构建自己的备份策略了。</p>
<p>首先，我们要设置全量备份的频率，因为全量备份比较大，所以建议设置 1 周 1 次全量备份，实时增量备份的频率。这样最坏的情况就是要恢复 7 天前的一个全备，然后通过 7 天的增量备份恢复。</p>
<p>对于备份文件，也需要进行备份。我们不能认为备份文件的存储介质不会损坏。所以，至少在 2 个机房的不同存储服务器上存储备份文件，即备份文件至少需要 2 个副本。至于备份文件的保存期限，取决于每个公司自己的要求（比如有的公司要求永久保存，有的公司要求保留至少近 3 个月的备份文件）。</p>
<p>所有的这些备份策略，都需要自己的备份系统进行调度，这个并没有什么特别好的开源项目，需要根据自己的业务需求，定制开发。</p>
<h1 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h1><h3 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a>benchmark</h3><p>mysql性能测试：<a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/250710">https://developer.aliyun.com/article/250710</a></p>
<h3 id="explain执行计划"><a href="#explain执行计划" class="headerlink" title="explain执行计划"></a>explain执行计划</h3><p>​	一条查询语句在经过MySQL**<u>查询优化器</u>**的各种基于成本和规则的优化会后<u>生成一个所谓的执行计划</u>，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。</p>
<p>​	设计MySQL的大叔贴心的为我们提供了EXPLAIN语句来<u><strong>帮助我们查看某个查询语句的具体执行计划</strong></u>，本章的内容就是为了帮助大家看懂EXPLAIN语句的各个输出项都是干嘛使的，从而可以有针对性的提升我们查询语句的性能。</p>
<h4 id="1-查看某条查询语句的执行计划："><a href="#1-查看某条查询语句的执行计划：" class="headerlink" title="1.查看某条查询语句的执行计划："></a>1.查看某条查询语句的执行计划：</h4><p>​		在查询语句前加上 explain 即可</p>
<h4 id="2-explain执行计划中每个列的含义："><a href="#2-explain执行计划中每个列的含义：" class="headerlink" title="2.explain执行计划中每个列的含义："></a>2.explain执行计划中每个列的含义：</h4><p>​		先把EXPLAIN 语句输出的各个列的作用先大致罗列一下：</p>
<p>​	<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230809143140850.png" alt="image-20230809143140850" style="zoom:50%;" /></p>
<h5 id="table："><a href="#table：" class="headerlink" title="table："></a>table：</h5><p>​	EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名。</p>
<p>——每条记录的table列中只有一个表名、如果查询语句中查了多个表，那么就会有多条执行计划记录，每个记录的table中只有一个表</p>
<h5 id="id："><a href="#id：" class="headerlink" title="id："></a>id：</h5><p>​	mysql为每个select语句分配一个id，其中：</p>
<ul>
<li><u><strong>连接查询</strong></u>中出现的几个表的**<u>id是相同</u>**的，出现在前面的表是主表，出现在后面的表是从表<ul>
<li>对于连接查询来说，一个 SELECT 关键字后边的 FROM 子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的</li>
</ul>
</li>
<li>对于<u><strong>包含子查询的查询语句</strong></u>来说，就可能涉及多个 SELECT 关键字，所以在包含子查询的查询语句的执行计划中，<u>每个 SELECT 关键字都会对应一个<strong>唯一</strong>的 id 值</u><ul>
<li>⚠️但是，<u>查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询</u>。所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，**<u>直接查看执行计划就好了，如果子查询的执行计划中多条记录的id相同，那么说明语句被重写！</u>**</li>
</ul>
</li>
</ul>
<h5 id="select-type："><a href="#select-type：" class="headerlink" title="select_type："></a>select_type：</h5><p>SIMPLE：简单 SELECT，不需要使用 UNION 操作或子查询。<br>PRIMARY：如果查询包含子查询，最外层的 SELECT 被标记为 PRIMARY；或者UNION语句的最左边的查询<br>UNION：UNION 操作中第二个或后面的 SELECT 语句。<br>SUBQUERY：子查询中的第一个 SELECT。<br>DERIVED：派生表的 SELECT 子查询。（从一个刚select出来的表中查询）</p>
<p>……</p>
<h5 id="type："><a href="#type：" class="headerlink" title="type："></a>type：</h5><p>mysql对某个表执行查询时的访问方法</p>
<ul>
<li><p>system</p>
<ul>
<li>当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是 system 。</li>
</ul>
</li>
<li><p>const</p>
<ul>
<li>当我们根据主键或者唯一二级索引列与<u>常数进行等值匹配</u>时，对单表的访问方法就是 const</li>
</ul>
</li>
<li><p>eq_ref</p>
<ul>
<li>⚠️<u>针对被驱动表的执行计划</u></li>
<li>在连接查询时，如果<u><strong>被驱动表</strong></u>是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是eq_ref</li>
</ul>
</li>
<li><p>ref</p>
<ul>
<li>当**<u>通过普通的二级索引列与常量进行等值匹配</u>**时来查询某个表，那么对该表的访问方法就可能是 ref</li>
</ul>
</li>
<li><p>range</p>
<ul>
<li>如果使用索引获取某些 <u>范围区间</u> 的记录，那么就可能使用到 range 访问方法</li>
</ul>
</li>
<li><p>index</p>
<ul>
<li>当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是 index</li>
</ul>
</li>
<li><p>all</p>
<ul>
<li>全表扫描</li>
</ul>
</li>
</ul>
<h5 id="possible-keys和key："><a href="#possible-keys和key：" class="headerlink" title="possible_keys和key："></a>possible_keys和key：</h5><p>​	可能用到的索引、用到的索引</p>
<h5 id="key-len："><a href="#key-len：" class="headerlink" title="key_len："></a>key_len：</h5><p>​	key_len 列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度，它是由这三个部分构成的：</p>
<ul>
<li>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是 VARCHAR(100) ，使用的字符集是 utf8 ，那么该列实际占用的最大存储空间就是 100 × 3 &#x3D; 300 个字节。</li>
<li>如果该索引列可以存储 NULL 值，则 key_len 比不可以存储 NULL 值时多1个字节。</li>
<li>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</li>
</ul>
<h5 id="ref："><a href="#ref：" class="headerlink" title="ref："></a>ref：</h5><p>当使用索引列等值匹配的条件去执行查询时，也就是在<u>访问方法是 const 、 eq_ref 、 ref 、 ref_or_null 、unique_subquery 、 index_subquery 其中之一时</u>， <u><strong>ref 列展示的就是与索引列作等值匹配的东东是个啥，比如只是一个常数或者是某个列。</strong></u></p>
<h5 id="rows："><a href="#rows：" class="headerlink" title="rows："></a>rows：</h5><p>​	如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的 rows 列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的 rows 列就代表预计扫描的索引记录行数。</p>
<h5 id="Extra："><a href="#Extra：" class="headerlink" title="Extra："></a>Extra：</h5><p>​	顾名思义， Extra 列是用来说明一些额外信息的，我们可以通过这些额外信息来更准确的<u><strong>理解 MySQL 到底将如何执行给定的查询语句。</strong></u></p>
<p>—大多数是报错信息</p>
<ul>
<li>No tables used —— 当查询语句的<u>没有 FROM 子句</u>时将会提示该额外信息</li>
<li>Impossible WHERE —— 查询语句的 WHERE 子句永远为 FALSE 时将会提示该额外信息</li>
<li>No matching min&#x2F;max row —— 当查询列表处有 MIN 或者 MAX 聚集函数，但是<u>并没有符合 WHERE 子句中的搜索条件的记录时，将会提示该额外信息，</u></li>
</ul>
<h3 id="索引调优"><a href="#索引调优" class="headerlink" title="索引调优"></a>索引调优</h3><h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><h3 id="MySQL性能优化"><a href="#MySQL性能优化" class="headerlink" title="MySQL性能优化"></a>MySQL性能优化</h3><p>本博客对以下文章有参考借鉴，十分感谢这些作者的文章🙏：</p>
<ul>
<li>执行一条 select 语句，期间发生了什么？<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/base/how_select.html)https://xiaolincoding.com/mysql/base/how_select.html">https://xiaolincoding.com/mysql/base/how_select.html)https://xiaolincoding.com/mysql/base/how_select.html</a></li>
<li>MySQL引擎篇：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7151275584218202143">https://juejin.cn/post/7151275584218202143</a></li>
<li>MySQL 一行记录是怎么存储的？<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/base/row_format.html">https://xiaolincoding.com/mysql/base/row_format.html</a></li>
<li>MySQL中char与varchar的区别：存储机制、性能差异：<a target="_blank" rel="noopener" href="https://www.maoyingdong.com/mysql-char-vs-varchar/">https://www.maoyingdong.com/mysql-char-vs-varchar/</a></li>
<li>从数据页的角度看 B+ 树：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/index/page.html">https://xiaolincoding.com/mysql/index/page.html</a></li>
<li>揭开 Buffer Pool 的面纱：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/buffer_pool/buffer_pool.html">https://xiaolincoding.com/mysql/buffer_pool/buffer_pool.html</a></li>
<li>普通索引和唯一索引，应该怎么选择？<a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2">https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%98%E5%AE%9D%E5%85%B8">https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%98%E5%AE%9D%E5%85%B8</a><ul>
<li>08 索引：排序的艺术</li>
<li>09 索引组织表：万物皆索引</li>
<li>10 组合索引：用好，性能提升 10 倍！</li>
<li>11 索引出错：请理解 CBO 的工作原理</li>
<li>21 数据库备份：备份文件也要检查！</li>
</ul>
</li>
<li>为什么 MySQL 采用 B+ 树作为索引？<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/index/why_index_chose_bpuls_tree.html">https://xiaolincoding.com/mysql/index/why_index_chose_bpuls_tree.html</a></li>
<li>索引失效有哪些？<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/index/index_lose.html">https://xiaolincoding.com/mysql/index/index_lose.html</a></li>
<li>建立索引的正确姿势与使用索引的最佳指南！<a target="_blank" rel="noopener" href="https://juejin.cn/post/7149074488649318431">https://juejin.cn/post/7149074488649318431</a></li>
<li>索引常见面试题：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/index/index_interview.html">https://xiaolincoding.com/mysql/index/index_interview.html</a></li>
<li>事务隔离级别是怎么实现的？<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/transaction/mvcc.html">https://xiaolincoding.com/mysql/transaction/mvcc.html</a></li>
<li>MySQL 可重复读隔离级别，完全解决幻读了吗？<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/transaction/phantom.html">https://xiaolincoding.com/mysql/transaction/phantom.html</a></li>
<li>MySQL 有哪些锁？<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/lock/mysql_lock.html">https://xiaolincoding.com/mysql/lock/mysql_lock.html</a></li>
<li>MySQL 是怎么加锁的？(校招可不掌握)<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/lock/how_to_lock.html">https://xiaolincoding.com/mysql/lock/how_to_lock.html</a></li>
<li>MySQL 死锁了，怎么办？<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/lock/deadlock.html">https://xiaolincoding.com/mysql/lock/deadlock.html</a></li>
<li>字节面试：加了什么锁，导致死锁的？<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/lock/show_lock.html">https://xiaolincoding.com/mysql/lock/show_lock.html</a></li>
<li>MySQL 日志：undo log、redo log、binlog 有什么用？<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/log/how_update.html">https://xiaolincoding.com/mysql/log/how_update.html</a></li>
<li></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://Tangjiayang.github.io">donn</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://tangjiayang.github.io/2023/07/27/MySQL%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/">https://tangjiayang.github.io/2023/07/27/MySQL%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727223615031.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">计算机网络</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/27/SpringMVC/" title="SpringMVC"><img class="cover" src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727101759956.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">SpringMVC</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/06/02/MyBatis-Plus/" title="MyBatis-Plus"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-02</div><div class="title">MyBatis-Plus</div></div></a></div><div><a href="/2023/06/02/Redis/" title="Redis"><img class="cover" src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727134719639.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-02</div><div class="title">Redis</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81ODUzNy8zNTAwMA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/bg.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">donn</div><div class="author-info__description">欢迎访问donn的博客!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Tangjiayang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Tangjiayang" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">小站成立于2023-5-27！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-text">架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E6%9E%B6%E6%9E%84"><span class="toc-text">MySQL架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%EF%BC%9A"><span class="toc-text">MySQL服务器逻辑架构：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">连接管理与安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E4%B8%8E%E6%89%A7%E8%A1%8C"><span class="toc-text">优化与执行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%9D%A1SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">一条SQL的执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Step1-%E8%BF%9E%E6%8E%A5%E5%99%A8"><span class="toc-text">Step1: 连接器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B-MySQL-%E6%9C%8D%E5%8A%A1%E8%A2%AB%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E4%BA%86%EF%BC%9F"><span class="toc-text">如何查看 MySQL 服务被多少个客户端连接了？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E8%BF%9E%E6%8E%A5%E4%BC%9A%E4%B8%80%E7%9B%B4%E5%8D%A0%E7%94%A8%E7%9D%80%E5%90%97%EF%BC%9F"><span class="toc-text">空闲连接会一直占用着吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MySQL-%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%9C%89%E9%99%90%E5%88%B6%E5%90%97%EF%BC%9F"><span class="toc-text">MySQL 的连接数有限制吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MySQL-%E7%9F%AD%E8%BF%9E%E6%8E%A5%E5%92%8C%E9%95%BF%E8%BF%9E%E6%8E%A5%EF%BC%9A"><span class="toc-text">MySQL 短连接和长连接：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">怎么解决长连接占用内存的问题？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">连接器工作总结：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step2-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-text">Step2: 查询缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step3-%E8%A7%A3%E6%9E%90SQL"><span class="toc-text">Step3: 解析SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%99%A8%EF%BC%9A"><span class="toc-text">解析器：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step4-%E6%89%A7%E8%A1%8CSQL"><span class="toc-text">Step4: 执行SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%8C%9F%E9%A2%84%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5%EF%BC%9A"><span class="toc-text">🌟预处理阶段：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%8C%9F%E4%BC%98%E5%8C%96%E9%98%B6%E6%AE%B5%EF%BC%9A"><span class="toc-text">🌟优化阶段：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%8C%9F%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5%EF%BC%9A"><span class="toc-text">🌟执行阶段：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E6%93%8E%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-text">引擎分类：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">MySQL存储引擎有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Innodb-%E5%92%8C-MyISAM-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Innodb 和 MyISAM 存储引擎有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">1. 磁盘文件的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-1-%E4%BD%BF%E7%94%A8MyISAM%E5%BC%95%E6%93%8E%E7%9A%84%E8%A1%A8"><span class="toc-text">1.1 使用MyISAM引擎的表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-2-%E4%BD%BF%E7%94%A8InnoDB%E5%BC%95%E6%93%8E%E7%9A%84%E8%A1%A8"><span class="toc-text">1.2 使用InnoDB引擎的表</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%B4%A2%E5%BC%95%E6%94%AF%E6%8C%81%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">2.索引支持的对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">3.事务机制的对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">4.故障恢复的对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E9%94%81%E7%B2%92%E5%BA%A6%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">5.锁粒度的对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%B9%B6%E5%8F%91%E6%80%A7%E8%83%BD%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">6.并发性能的对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E5%86%85%E5%AD%98%E5%88%A9%E7%94%A8%E5%BA%A6%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">7.内存利用度的对比</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8C%9F%E4%B8%BA%E4%BB%80%E4%B9%88InnoDB%E4%BB%A3%E6%9B%BF%E4%BA%86MyISAM%EF%BC%9F"><span class="toc-text">🌟为什么InnoDB代替了MyISAM？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyISAM%E5%BC%95%E6%93%8E%E7%9A%84%E5%8F%AF%E5%8F%96%E4%B9%8B%E5%A4%84%EF%BC%9A"><span class="toc-text">MyISAM引擎的可取之处：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#InnoDB"><span class="toc-text">InnoDB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F"><span class="toc-text">一行记录的存储格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E6%94%BE%E5%9C%A8%E5%93%AA%E4%B8%AA%E6%96%87%E4%BB%B6%EF%BC%9F"><span class="toc-text">MySQL 的数据存放在哪个文件？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8%E7%A9%BA%E9%97%B4%E6%96%87%E4%BB%B6-%E5%AD%98%E6%94%BE%E8%A1%A8%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%87%E4%BB%B6-%E7%9A%84%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">表空间文件(存放表中数据的文件)的结构是怎么样的？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81%E8%A1%8C%EF%BC%88row%EF%BC%89"><span class="toc-text">1、行（row）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E9%A1%B5%EF%BC%88page%EF%BC%89"><span class="toc-text">2、页（page）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%E3%80%81%E5%8C%BA%EF%BC%88extent%EF%BC%89"><span class="toc-text">3、区（extent）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%E3%80%81%E6%AE%B5%EF%BC%88segment%EF%BC%89"><span class="toc-text">4、段（segment）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB-%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%EF%BC%9A"><span class="toc-text">InnoDB 行格式学习：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#COMPACT%E8%A1%8C%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-text">COMPACT行格式：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A8"><span class="toc-text">1. 变长字段长度列表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-NULL-%E5%80%BC%E5%88%97%E8%A1%A8"><span class="toc-text">2. NULL 值列表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF"><span class="toc-text">3. 记录头信息</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E8%AE%B0%E5%BD%95%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE"><span class="toc-text">4. 记录的真实数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#varchar-n-%E4%B8%AD-n-%E6%9C%80%E5%A4%A7%E5%8F%96%E5%80%BC%E4%B8%BA%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">varchar(n) 中 n 最大取值为多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E6%BA%A2%E5%87%BA%E5%90%8E%EF%BC%8CMySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E7%9A%84%EF%BC%9F"><span class="toc-text">行溢出后，MySQL 是怎么处理的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-1"><span class="toc-text">总结：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#MySQL-%E7%9A%84-NULL-%E5%80%BC%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E6%94%BE%E7%9A%84%EF%BC%9F"><span class="toc-text">MySQL 的 NULL 值是怎么存放的？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MySQL-%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93-varchar-n-%E5%AE%9E%E9%99%85%E5%8D%A0%E7%94%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%9F"><span class="toc-text">MySQL 怎么知道 varchar(n) 实际占用数据的大小？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#varchar-n-%E4%B8%AD-n-%E6%9C%80%E5%A4%A7%E5%8F%96%E5%80%BC%E4%B8%BA%E5%A4%9A%E5%B0%91%EF%BC%9F-1"><span class="toc-text">varchar(n) 中 n 最大取值为多少？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%8C%E6%BA%A2%E5%87%BA%E5%90%8E%EF%BC%8CMySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E7%9A%84%EF%BC%9F-1"><span class="toc-text">行溢出后，MySQL 是怎么处理的？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#char%E5%92%8Cvarchar"><span class="toc-text">char和varchar</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">存储机制区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%B7%AE%E5%BC%82%EF%BC%9A"><span class="toc-text">性能差异：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B5"><span class="toc-text">数据页</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84%EF%BC%9F"><span class="toc-text">InnoDB 是如何存储数据的？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#File-Header%EF%BC%9A"><span class="toc-text">File Header：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#User-Records%EF%BC%9A"><span class="toc-text">User Records：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Page-Directory%EF%BC%9A"><span class="toc-text">Page Directory：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%8D%95%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%86%85%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-text">总结——单数据页内的查询步骤：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%A0%91%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%9A%84%EF%BC%9F"><span class="toc-text">B+ 树是如何进行查询的？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-2"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-text">聚簇索引和二级索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-3"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer-Pool"><span class="toc-text">Buffer Pool</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%87%BA%EF%BC%9A"><span class="toc-text">引出：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer-Pool-%E6%9C%89%E5%A4%9A%E5%A4%A7%EF%BC%9F"><span class="toc-text">Buffer Pool 有多大？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer-Pool-%E7%BC%93%E5%AD%98%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Buffer Pool 缓存什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86-Buffer-Pool%EF%BC%9F"><span class="toc-text">如何管理 Buffer Pool？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E7%A9%BA%E9%97%B2%E9%A1%B5%EF%BC%9F"><span class="toc-text">如何管理空闲页？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">工作原理：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E8%84%8F%E9%A1%B5%EF%BC%9F"><span class="toc-text">如何管理脏页？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD%E7%8E%87%EF%BC%9F"><span class="toc-text">如何提高缓存命中率？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88%EF%BC%9A"><span class="toc-text">预读失效：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%F0%9F%8C%9F%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-text">🌟预读失效解决方案：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Buffer-Pool-%E6%B1%A1%E6%9F%93%EF%BC%9A"><span class="toc-text">Buffer Pool 污染：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Buffer-Pool-%E6%B1%A1%E6%9F%93%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-text">Buffer Pool 污染解决方案：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%84%8F%E9%A1%B5%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%A2%AB%E5%88%B7%E5%85%A5%E7%A3%81%E7%9B%98%EF%BC%9F"><span class="toc-text">脏页什么时候会被刷入磁盘？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Change-Buffer"><span class="toc-text">Change Buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%9D%A1%E4%BB%B6%E4%B8%8B%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8-change-buffer%EF%BC%9F"><span class="toc-text">什么条件下可以使用 change buffer？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B1%F0%9F%8C%B0%EF%BC%9A"><span class="toc-text">例1🌰：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B2%F0%9F%8C%B0%EF%BC%9A"><span class="toc-text">例2🌰：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#change-buffer-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">change buffer 的使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="toc-text">普通索引和唯一索引应该怎么选择？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">索引数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84-%E6%9C%80%E5%B9%BF%E6%B3%9B"><span class="toc-text">B+树索引结构(最广泛)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E6%88%90%EF%BC%9A"><span class="toc-text">组成：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8F%92%E5%85%A5%E6%80%A7%E8%83%BD%EF%BC%9A"><span class="toc-text">优化 B+ 树索引的插入性能：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-MySQL-%E9%87%87%E7%94%A8-B-%E6%A0%91%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">为什么 MySQL 采用 B+ 树作为索引？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#MySQL-%E9%BB%98%E8%AE%A4%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-InnoDB-%E9%87%87%E7%94%A8%E7%9A%84%E6%98%AF-B-%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8E%9F%E5%9B%A0%E6%9C%89%EF%BC%9A"><span class="toc-text">MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Innodb-%E9%87%8C%E7%9A%84-B-%E6%A0%91%EF%BC%9A"><span class="toc-text">Innodb 里的 B+ 树：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8"><span class="toc-text">索引存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E8%A1%A8%EF%BC%9A-%E6%80%A7%E8%83%BD%E5%B7%AE"><span class="toc-text">堆表：(性能差)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87%E8%A1%A8%EF%BC%9A"><span class="toc-text">索引组织表：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%EF%BC%9A"><span class="toc-text">二级索引：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87%E8%A1%A8%E5%92%8C%E5%A0%86%E8%A1%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">索引组织表和堆表之间的区别总结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-text">联合索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%EF%BC%9A"><span class="toc-text">背景：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%F0%9F%8C%B0%EF%BC%9A"><span class="toc-text">示例🌰：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%9B%9E%E8%A1%A8%E5%8F%AF%E4%BB%A5%E6%9E%81%E5%A4%A7%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%EF%BC%9A%EF%BC%81%EF%BC%81%EF%BC%81"><span class="toc-text">避免回表可以极大提升性能：！！！</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-4"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-text">索引失效</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%B9%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E5%B7%A6%E6%88%96%E8%80%85%E5%B7%A6%E5%8F%B3%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D"><span class="toc-text">1.对索引使用左或者左右模糊匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-text">分析：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">2.对索引使用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%9E%90%EF%BC%9A-1"><span class="toc-text">分析：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%B9%E7%B4%A2%E5%BC%95%E8%BF%9B%E8%A1%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97"><span class="toc-text">3.对索引进行表达式计算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%9E%90%EF%BC%9A-2"><span class="toc-text">分析：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AF%B9%E7%B4%A2%E5%BC%95%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">4.对索引隐式类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B1%EF%BC%9A"><span class="toc-text">例1：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B2"><span class="toc-text">例2:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E9%9D%9E%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D"><span class="toc-text">5.联合索引非最左匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%EF%BC%9A"><span class="toc-text">索引下推：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-WHERE-%E5%AD%90%E5%8F%A5%E4%B8%AD%E7%9A%84-OR"><span class="toc-text">6.WHERE 子句中的 OR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%91%8D%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">👍总结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%80%89%E6%8B%A9"><span class="toc-text">索引选择</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CBO%EF%BC%88Cost-based-Optimizer%EF%BC%8C%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96%E5%99%A8%EF%BC%89"><span class="toc-text">CBO（Cost-based Optimizer，基于成本的优化器）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8"><span class="toc-text">索引应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">索引的优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">索引的缺点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8C%9F%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E6%9C%80%E5%A5%BD%E4%BD%BF%E7%94%A8%E5%B8%A6%E9%A1%BA%E5%BA%8F%E6%80%A7%E7%9A%84%E5%80%BC-%E6%AF%94%E5%A6%82%EF%BC%9A%E8%87%AA%E5%A2%9Eid%E3%80%81%E8%87%AA%E5%A2%9Euuid-%EF%BC%9A"><span class="toc-text">🌟主键索引最好使用带顺序性的值(比如：自增id、自增uuid)：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8C%9F%E8%81%94%E5%90%88%E4%B8%BB%E9%94%AE%E8%A6%81%E6%B3%A8%E6%84%8F%E9%9D%9E%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E7%9A%84%E9%97%AE%E9%A2%98-%E8%AF%A6%E8%A7%81%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%AB%A0%E8%8A%82"><span class="toc-text">🌟联合主键要注意非最左匹配的问题(详见索引失效章节)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8C%9F%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BC%8A%E7%AB%AF%EF%BC%9A"><span class="toc-text">🌟前缀索引的弊端：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8C%9F%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95%EF%BC%9A"><span class="toc-text">🌟全文索引：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8C%9F%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%A9%E5%BC%8A%EF%BC%9A"><span class="toc-text">🌟唯一索引的利弊：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8D%93%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E6%97%B6%EF%BC%8C%E9%9C%80%E8%A6%81%E9%81%B5%E5%AE%88%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%9F%E5%88%99%EF%BC%9A"><span class="toc-text">🍓建立索引时，需要遵守的一些原则：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%AB%90%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E6%97%B6%E8%BF%98%E9%9C%80%E6%9C%89%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9A"><span class="toc-text">🫐建立索引时还需有些注意点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%9D%A2%E8%AF%95%E9%A2%98%F0%9F%8D%96-%E5%85%A8%E9%83%A8%E5%AD%A6%E4%B9%A0%E5%AE%8C%E5%86%8D%E5%9B%9E%E6%9D%A5%E7%9C%8B%EF%BC%81"><span class="toc-text">索引面试题🍖(全部学习完再回来看！)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%EF%BC%9A"><span class="toc-text">事务的ACID：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A%E2%80%93%E5%8E%9F%E5%AD%90%E6%80%A7-Atomicity"><span class="toc-text">A–原子性(Atomicity):</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C%E2%80%93%E4%B8%80%E8%87%B4%E6%80%A7-Consistency-%EF%BC%9A"><span class="toc-text">C–一致性(Consistency)：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I%E2%80%93%E9%9A%94%E7%A6%BB%E6%80%A7-Isolation"><span class="toc-text">I–隔离性(Isolation):</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D%E2%80%93%E6%8C%81%E4%B9%85%E6%80%A7-Durability"><span class="toc-text">D–持久性(Durability):</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9A"><span class="toc-text">事务的隔离级别：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E4%BA%8B%E5%8A%A1%E4%BC%9A%E5%BC%95%E5%8F%91%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">并行事务会引发什么问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%84%8F%E8%AF%BB%EF%BC%9A"><span class="toc-text">脏读：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%9A"><span class="toc-text">不可重复读：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BB%E8%AF%BB%EF%BC%9A"><span class="toc-text">幻读：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%93%96%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">📖总结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">事务的隔离级别有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL-InnoDB-%E5%BC%95%E6%93%8E%E7%9A%84%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%99%BD%E7%84%B6%E6%98%AF%E3%80%8C%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E3%80%8D%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%83%E5%BE%88%E5%A4%A7%E7%A8%8B%E5%BA%A6%E4%B8%8A%E9%81%BF%E5%85%8D%E5%B9%BB%E8%AF%BB%E7%8E%B0%E8%B1%A1%EF%BC%88%E5%B9%B6%E4%B8%8D%E6%98%AF%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E4%BA%86%EF%BC%89%EF%BC%8C%E8%A7%A3%E5%86%B3%E7%9A%84%E6%96%B9%E6%A1%88%E6%9C%89%E4%B8%A4%E7%A7%8D%EF%BC%9A"><span class="toc-text">MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%99%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%85%B7%E4%BD%93%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-text">这四种隔离级别具体是如何实现的呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Read-View-%E5%9C%A8-MVCC-%E9%87%8C%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-text">Read View 在 MVCC 里如何工作的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Read-View%E4%B8%AD%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%AD%97%E6%AE%B5%EF%BC%9A"><span class="toc-text">Read View中的四个字段：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%E8%AF%BB%E6%8F%90%E4%BA%A4%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-text">可重复读是如何工作的？读提交是如何工作的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%8C%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E4%BA%86%E5%90%97%EF%BC%9F"><span class="toc-text">MySQL 可重复读隔离级别，完全解决幻读了吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BF%AB%E7%85%A7%E8%AF%BB%E6%98%AF%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%B9%BB%E8%AF%BB%E7%9A%84%EF%BC%9F"><span class="toc-text">1.快照读是如何避免幻读的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BD%93%E5%89%8D%E8%AF%BB%E6%98%AF%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%B9%BB%E8%AF%BB%E7%9A%84%EF%BC%9F"><span class="toc-text">2.当前读是如何避免幻读的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BB%E8%AF%BB%E8%A2%AB%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E4%BA%86%E5%90%97%EF%BC%9F"><span class="toc-text">幻读被完全解决了吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%BB%E8%AF%BB%E5%9C%BA%E6%99%AF1"><span class="toc-text">幻读场景1:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%BB%E8%AF%BB%E5%9C%BA%E6%99%AF2"><span class="toc-text">幻读场景2:</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81%F0%9F%94%92"><span class="toc-text">锁🔒</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%B2%92%E5%BA%A6%EF%BC%9A"><span class="toc-text">锁粒度：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%A8%E5%B1%80%E9%94%81%EF%BC%9A"><span class="toc-text">1.全局锁：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">应用场景：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-1"><span class="toc-text">缺点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8C%9F%E6%97%A2%E7%84%B6%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E9%94%81%E4%BC%9A%E5%BD%B1%E5%93%8D%E4%B8%9A%E5%8A%A1%EF%BC%8C%E9%82%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B6%E4%BB%96%E6%96%B9%E5%BC%8F%E5%8F%AF%E4%BB%A5%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-text">🌟既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%A1%A8%E7%BA%A7%E9%94%81%EF%BC%9A"><span class="toc-text">2.表级锁：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E8%A1%A8%E9%94%81%EF%BC%9A"><span class="toc-text">2.1.表锁：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81-MDL-%EF%BC%9A"><span class="toc-text">2.2.元数据锁(MDL)：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%84%8F%E5%90%91%E9%94%81%EF%BC%9A"><span class="toc-text">2.3.意向锁：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-AUTO-INC-%E9%94%81%EF%BC%9A"><span class="toc-text">2.4.AUTO-INC 锁：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%A1%8C%E7%BA%A7%E9%94%81%EF%BC%9A"><span class="toc-text">3.行级锁：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E8%AE%B0%E5%BD%95%E9%94%81%EF%BC%9ARecord-Lock"><span class="toc-text">3.1.记录锁：Record Lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%9AGap-Lock"><span class="toc-text">3.2.间隙锁：Gap Lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E4%B8%B4%E9%94%AE%E9%94%81%EF%BC%9ANext-Key-Lock"><span class="toc-text">3.3.临键锁：Next-Key Lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81%EF%BC%9A"><span class="toc-text">3.4.插入意向锁：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%EF%BC%9A"><span class="toc-text">死锁：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Insert-%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E8%A1%8C%E7%BA%A7%E9%94%81%E7%9A%84%EF%BC%9F"><span class="toc-text">Insert 语句是怎么加行级锁的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-text">如何避免死锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A"><span class="toc-text">一道面试题：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Time1"><span class="toc-text">Time1:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Time2"><span class="toc-text">Time2:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Time3"><span class="toc-text">Time3:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Time4"><span class="toc-text">Time4:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%F0%9F%8C%9F%EF%BC%9A"><span class="toc-text">总结🌟：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-text">如何避免死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9A"><span class="toc-text">悲观锁与乐观锁：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%9A"><span class="toc-text">悲观锁：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9A"><span class="toc-text">乐观锁：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-text">日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E6%97%A5%E5%BF%97%EF%BC%9Aundo-log%E3%80%81redo-log%E3%80%81binlog-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-text">MySQL 日志：undo log、redo log、binlog 有什么用？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-undo-log%EF%BC%9F"><span class="toc-text">为什么需要 undo log？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%8C%9Fundo-log-%E4%B8%A4%E5%A4%A7%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-text">🌟undo log 两大作用：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Buffer-Pool%EF%BC%9F"><span class="toc-text">为什么需要 Buffer Pool？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-redo-log-%EF%BC%9F"><span class="toc-text">为什么需要 redo log ？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#redo-log-%E8%A6%81%E5%86%99%E5%88%B0%E7%A3%81%E7%9B%98%EF%BC%8C%E6%95%B0%E6%8D%AE%E4%B9%9F%E8%A6%81%E5%86%99%E7%A3%81%E7%9B%98%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%A4%9A%E6%AD%A4%E4%B8%80%E4%B8%BE%EF%BC%9F"><span class="toc-text">redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#redo-log%E7%9B%B4%E6%8E%A5%E5%86%99%E5%85%A5%E7%A3%81%E7%9B%98%E5%90%97%EF%BC%9F"><span class="toc-text">redo log直接写入磁盘吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#redo-log-buffer%E4%BD%95%E6%97%B6%E5%86%99%E5%85%A5%E7%A3%81%E7%9B%98%EF%BC%9A"><span class="toc-text">redo log buffer何时写入磁盘：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#redo-log-%E6%96%87%E4%BB%B6%E5%86%99%E6%BB%A1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">redo log 文件写满了怎么办？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-binlog-%EF%BC%9F"><span class="toc-text">为什么需要 binlog ？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#redo-log-%E5%92%8C-binlog-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">redo log 和 binlog 有什么区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%9A"><span class="toc-text">MySQL主从复制：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#binlog-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%B7%E7%9B%98%EF%BC%9F"><span class="toc-text">binlog 什么时候刷盘？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%EF%BC%9F"><span class="toc-text">为什么需要两阶段提交？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">两阶段提交的实现过程：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%B2%A1%E6%8F%90%E4%BA%A4%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8Credo-log-%E4%BC%9A%E8%A2%AB%E6%8C%81%E4%B9%85%E5%8C%96%E5%88%B0%E7%A3%81%E7%9B%98%E5%90%97%EF%BC%9F"><span class="toc-text">事务没提交的时候，redo log 会被持久化到磁盘吗？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8C%9F%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">🌟总结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%EF%BC%9A%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E4%B9%9F%E8%A6%81%E6%A3%80%E6%9F%A5%EF%BC%81"><span class="toc-text">数据库备份：备份文件也要检查！</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E9%87%8F%E5%A4%87%E4%BB%BD%EF%BC%9A"><span class="toc-text">全量备份：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD%EF%BC%9A"><span class="toc-text">1. 逻辑备份：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%89%A9%E7%90%86%E5%A4%87%E4%BB%BD%EF%BC%9A"><span class="toc-text">2. 物理备份：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E5%A4%87%E4%BB%BD%EF%BC%9A"><span class="toc-text">增量备份：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%87%E4%BB%BD%E7%AD%96%E7%95%A5%EF%BC%9A"><span class="toc-text">备份策略：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-text">性能调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#benchmark"><span class="toc-text">benchmark</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-text">explain执行计划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9F%A5%E7%9C%8B%E6%9F%90%E6%9D%A1%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%EF%BC%9A"><span class="toc-text">1.查看某条查询语句的执行计划：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%AD%E6%AF%8F%E4%B8%AA%E5%88%97%E7%9A%84%E5%90%AB%E4%B9%89%EF%BC%9A"><span class="toc-text">2.explain执行计划中每个列的含义：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#table%EF%BC%9A"><span class="toc-text">table：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#id%EF%BC%9A"><span class="toc-text">id：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#select-type%EF%BC%9A"><span class="toc-text">select_type：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#type%EF%BC%9A"><span class="toc-text">type：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#possible-keys%E5%92%8Ckey%EF%BC%9A"><span class="toc-text">possible_keys和key：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#key-len%EF%BC%9A"><span class="toc-text">key_len：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ref%EF%BC%9A"><span class="toc-text">ref：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rows%EF%BC%9A"><span class="toc-text">rows：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Extra%EF%BC%9A"><span class="toc-text">Extra：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%B0%83%E4%BC%98"><span class="toc-text">索引调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E4%BC%98%E5%8C%96"><span class="toc-text">SQL优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-text">连接池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">MySQL性能优化</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/10/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/" title="java基础复习"><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230810141014749.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java基础复习"/></a><div class="content"><a class="title" href="/2023/08/10/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/" title="java基础复习">java基础复习</a><time datetime="2023-08-10T06:08:10.000Z" title="Created 2023-08-10 14:08:10">2023-08-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/2023/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a><time datetime="2023-07-27T14:37:02.000Z" title="Created 2023-07-27 22:37:02">2023-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/27/MySQL%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/" title="MySQL原理学习"><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727223615031.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL原理学习"/></a><div class="content"><a class="title" href="/2023/07/27/MySQL%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/" title="MySQL原理学习">MySQL原理学习</a><time datetime="2023-07-27T14:32:58.000Z" title="Created 2023-07-27 22:32:58">2023-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/27/SpringMVC/" title="SpringMVC"><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727101759956.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringMVC"/></a><div class="content"><a class="title" href="/2023/07/27/SpringMVC/" title="SpringMVC">SpringMVC</a><time datetime="2023-07-27T02:16:50.000Z" title="Created 2023-07-27 10:16:50">2023-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/24/%E5%AE%9E%E6%93%8D%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="实操中遇到的后端开发相关问题与解决方案"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="实操中遇到的后端开发相关问题与解决方案"/></a><div class="content"><a class="title" href="/2023/07/24/%E5%AE%9E%E6%93%8D%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="实操中遇到的后端开发相关问题与解决方案">实操中遇到的后端开发相关问题与解决方案</a><time datetime="2023-07-24T00:53:57.000Z" title="Created 2023-07-24 08:53:57">2023-07-24</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727223615031.png')"><div id="footer-wrap"><div class="copyright">&copy;2023 By donn</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">很高兴认识你🤪</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>