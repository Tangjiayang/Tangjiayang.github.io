<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统 | donn的博客</title><meta name="author" content="donn"><meta name="copyright" content="donn"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="操作系统(参照清华——操作系统课程)： os：对硬件的管理和控制 	本课程着重对kernel层的研究 Chapter1 概述什么是OS？CPU —–&gt; 进程 磁盘 —–&gt; 文件 内存 —–&gt; 地址空间 用户角度： 管理应用程序 为应用程序提供服务 杀死应用程序  资源角度： 资源管理 管理外设、分配资源  Kernel层内部组件： CPU调度器 物理内存管理 虚拟内存管理 文件系">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="https://tangjiayang.github.io/2023/06/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="donn的博客">
<meta property="og:description" content="操作系统(参照清华——操作系统课程)： os：对硬件的管理和控制 	本课程着重对kernel层的研究 Chapter1 概述什么是OS？CPU —–&gt; 进程 磁盘 —–&gt; 文件 内存 —–&gt; 地址空间 用户角度： 管理应用程序 为应用程序提供服务 杀死应用程序  资源角度： 资源管理 管理外设、分配资源  Kernel层内部组件： CPU调度器 物理内存管理 虚拟内存管理 文件系">
<meta property="og:locale">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-06-02T07:36:55.000Z">
<meta property="article:modified_time" content="2023-06-06T07:51:08.613Z">
<meta property="article:author" content="donn">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://tangjiayang.github.io/2023/06/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":30,"languages":{"author":"Author: donn","link":"Link: ","source":"Source: donn的博客","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-06 15:51:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/bg.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="donn的博客"><span class="site-name">donn的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-06-02T07:36:55.000Z" title="Created 2023-06-02 15:36:55">2023-06-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-06-06T07:51:08.613Z" title="Updated 2023-06-06 15:51:08">2023-06-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">8.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>26min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>(参照清华——操作系统课程)：</p>
<p>os：对硬件的管理和控制 	本课程着重对<strong>kernel层</strong>的研究</p>
<h2 id="Chapter1-概述"><a href="#Chapter1-概述" class="headerlink" title="Chapter1 概述"></a>Chapter1 概述</h2><h4 id="什么是OS？"><a href="#什么是OS？" class="headerlink" title="什么是OS？"></a>什么是OS？</h4><p>CPU —–&gt; 进程</p>
<p>磁盘 —–&gt; 文件</p>
<p>内存 —–&gt; 地址空间</p>
<h5 id="用户角度："><a href="#用户角度：" class="headerlink" title="用户角度："></a>用户角度：</h5><ul>
<li>管理应用程序</li>
<li>为应用程序提供服务</li>
<li>杀死应用程序</li>
</ul>
<h5 id="资源角度："><a href="#资源角度：" class="headerlink" title="资源角度："></a>资源角度：</h5><ul>
<li>资源管理</li>
<li>管理外设、分配资源</li>
</ul>
<h4 id="Kernel层内部组件："><a href="#Kernel层内部组件：" class="headerlink" title="Kernel层内部组件："></a>Kernel层内部组件：</h4><ul>
<li>CPU调度器</li>
<li>物理内存管理</li>
<li>虚拟内存管理</li>
<li>文件系统管理</li>
<li>中断处理与设备驱动</li>
</ul>
<h4 id="OS-Kernel的特征："><a href="#OS-Kernel的特征：" class="headerlink" title="OS Kernel的特征："></a>OS Kernel的特征：</h4><ul>
<li><p>并发</p>
<ul>
<li>计算机系统中同时存在多个运行的程序，需要OS管理和调度</li>
</ul>
</li>
<li><p>共享</p>
<ul>
<li>互斥共享</li>
</ul>
</li>
<li><p>虚拟</p>
<ul>
<li>利用<strong>多道程序设计技术</strong>让每个用户都觉得有一个计算机专门为他服务。</li>
</ul>
</li>
<li><p>异步</p>
<ul>
<li>程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知</li>
<li>只要运行环境相同，OS需要保证程序的运行结果也相同</li>
</ul>
</li>
</ul>
<h2 id="Chapter2-操作系统基础操作"><a href="#Chapter2-操作系统基础操作" class="headerlink" title="Chapter2 操作系统基础操作"></a>Chapter2 操作系统基础操作</h2><h3 id="2-1-操作系统的启动"><a href="#2-1-操作系统的启动" class="headerlink" title="2.1 操作系统的启动"></a>2.1 操作系统的启动</h3><h4 id="开机顺序："><a href="#开机顺序：" class="headerlink" title="开机顺序："></a>开机顺序：</h4><p>​		电脑开机后，将先执行bootstrap program程序(引导程序)，引导程序一般位于计算机的固件中，由它初始化系统的内核以及各个组件。</p>
<h3 id="2-2-中断、异常和系统调用"><a href="#2-2-中断、异常和系统调用" class="headerlink" title="2.2 中断、异常和系统调用"></a>2.2 中断、异常和系统调用</h3><h4 id="中断-from-外设"><a href="#中断-from-外设" class="headerlink" title="中断(from 外设)"></a>中断(from 外设)</h4><ul>
<li><p>来自不同的硬件设备的计时器和网络的中断</p>
</li>
<li><p>异步</p>
</li>
<li><p>对用户应用程序是透明的</p>
</li>
</ul>
<h5 id="中断的处理过程："><a href="#中断的处理过程：" class="headerlink" title="中断的处理过程："></a>中断的处理过程：</h5><h6 id="硬件："><a href="#硬件：" class="headerlink" title="硬件："></a>硬件：</h6><ul>
<li>设置中断标记[CPU初始化]<br>1. 将内部事件、外部事件设置中断标记<br>      1. CPU通过标记获得中断事件的ID(凭借中断向量表)</li>
</ul>
<p>	</p>
<h6 id="软件："><a href="#软件：" class="headerlink" title="软件："></a>软件：</h6><ul>
<li>保存当前处理状态</li>
<li>中断服务程序处理</li>
<li>清除中断标记</li>
<li>恢复之前保存的处理状态</li>
</ul>
<h4 id="异常-from-不良的应用程序"><a href="#异常-from-不良的应用程序" class="headerlink" title="异常(from 不良的应用程序)"></a>异常(from 不良的应用程序)</h4><ul>
<li><p>应用程序产生，由于非法指令或者其他坏的处理状态</p>
</li>
<li><p>同步</p>
</li>
<li><p>杀死或重新执行意想不到的应用程序指令</p>
</li>
</ul>
<h5 id="异常的处理过程："><a href="#异常的处理过程：" class="headerlink" title="异常的处理过程："></a>异常的处理过程：</h5><ul>
<li>保存现场</li>
<li>异常处理<ul>
<li>杀死异常程序</li>
<li>或者 重新执行异常命令</li>
</ul>
</li>
<li>恢复现场</li>
</ul>
<h4 id="系统调用-from-应用程序"><a href="#系统调用-from-应用程序" class="headerlink" title="系统调用(from 应用程序)"></a>系统调用(from 应用程序)</h4><ul>
<li><p>应用程序主动向OS发送服务请求</p>
</li>
<li><p>同步或异步</p>
</li>
<li><p>等待后继续执行</p>
</li>
</ul>
<h5 id="系统调用的处理过程："><a href="#系统调用的处理过程：" class="headerlink" title="系统调用的处理过程："></a>系统调用的处理过程：</h5><p>​	调用系统函数 如printf()后，会触发系统调用，在屏幕上打印</p>
<p><u>将OS能提供的系统调用进行某种集成，形成各色各样的API供开发人员使用</u></p>
<ul>
<li><p>Win32 API 用于Windows</p>
</li>
<li><p>POSIX API 用于 POSIX-based systems(such as: UNIX、LINUX、MAX OS X)</p>
</li>
<li><p>Java API 用于 JVM</p>
<ol>
<li>通常情况下，每个系统调用有自己的序号，系统调用接口根据这些序号维护表的索引</li>
<li>系统调用接口 调用内核态中的系统调用，返回系统调用的状态和结果(其返回值)</li>
<li>用户不需要知道系统调用是如何实现的，只需要获取各个API的作用即可；操作系统接口的细节大部分隐藏在API中</li>
</ol>
</li>
</ul>
<p><strong>🌟用户从系统调用的库中调用系统调用接口，在调用系统调用接口时，会触发一个从用户态-&gt;内核态的转换，执行内核态中的系统调用。</strong></p>
<p>系统调用的开销会大于普通的函数调用，因为：</p>
<p>​	系统调用会从用户态切换到内核态，需要两次建立函数空间，而函数调用只有自己唯一的栈空间</p>
<h4 id="跨越操作系统边界的开销-中断、异常、系统调用"><a href="#跨越操作系统边界的开销-中断、异常、系统调用" class="headerlink" title="跨越操作系统边界的开销(中断、异常、系统调用)"></a>跨越操作系统边界的开销(中断、异常、系统调用)</h4><p>在执行时间上开销超过应用程序</p>
<p>开销体现于：</p>
<ul>
<li>建立中断&#x2F;异常&#x2F;系统<strong>调用号 与 对应服务例程映射关系的初始化开销</strong>(因为你跨越了OS边界，不能把原本的状态带过去，所以需要一张映射表，由编号找到你需要做的事)</li>
<li>建立内核堆栈(因为在内核态进行操作，需要在内核态建立变量存储空间)</li>
<li>验证参数(内核态不信任用户态，需要进行验证)</li>
<li>内核态映射到用户态的地址空间(内核态产生的数据需要拷贝回用户态)</li>
<li>内核态独立地址空间(TLB)</li>
</ul>
<p>这些开销都是值得的，它们保证了OS的操作安全、可靠！</p>
<h2 id="Chapter3-连续式内存分配"><a href="#Chapter3-连续式内存分配" class="headerlink" title="Chapter3 连续式内存分配"></a>Chapter3 连续式内存分配</h2><h3 id="计算机体系结构及内存分层体系"><a href="#计算机体系结构及内存分层体系" class="headerlink" title="计算机体系结构及内存分层体系"></a>计算机体系结构及内存分层体系</h3><p>分层……计组里都学过</p>
<h4 id="操作系统的内存管理方面的四个目标"><a href="#操作系统的内存管理方面的四个目标" class="headerlink" title="操作系统的内存管理方面的四个目标"></a>操作系统的内存管理方面的四个目标</h4><ul>
<li>抽象<ul>
<li>逻辑地址空间</li>
</ul>
</li>
<li>保护<ul>
<li>独立地址空间</li>
</ul>
</li>
<li>共享<ul>
<li>访问相同内存</li>
</ul>
</li>
<li>虚拟化<ul>
<li>更多的地址空间</li>
</ul>
</li>
</ul>
<h3 id="地址空间与地址生成"><a href="#地址空间与地址生成" class="headerlink" title="地址空间与地址生成"></a>地址空间与地址生成</h3><h4 id="1-地址空间定义"><a href="#1-地址空间定义" class="headerlink" title="1.地址空间定义"></a>1.地址空间定义</h4><p>​	物理地址空间：硬件支持的地址空间</p>
<p>​	逻辑地址空间：一个运行的程序所拥有的内存范围</p>
<h4 id="2-地址生成"><a href="#2-地址生成" class="headerlink" title="2.地址生成"></a>2.地址生成</h4><p>​	逻辑地址生成：从变量的符号，通过一系列操作(编译、汇编、链接、载入)变为逻辑地址</p>
<p>​	物理地址生成：已知逻辑地址，通过硬件MMU将逻辑地址映射到物理地址</p>
<h4 id="3-地址安全检查"><a href="#3-地址安全检查" class="headerlink" title="3.地址安全检查"></a>3.地址安全检查</h4><p>​	OS记录每一个程序能够访问的地址空间(开始位置和大小)</p>
<p>​	这个表由OS维护，CPU要执行某个程序时，OS检查该程序的地址是否满足表中的限制(不与已占用空间冲突)，能满足则正常执行；否则CPU产生内存访问异常，让OS进行进一步处理。</p>
<h3 id="连续内存分配：内存碎片与分区的动态分配"><a href="#连续内存分配：内存碎片与分区的动态分配" class="headerlink" title="连续内存分配：内存碎片与分区的动态分配"></a>连续内存分配：内存碎片与分区的动态分配</h3><h4 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h4><p>空闲内存不能被利用</p>
<ul>
<li>外部碎片</li>
</ul>
<p>在**分配单元<u>间</u>**的未使用内存</p>
<ul>
<li>内部碎片</li>
</ul>
<p>在**分配单元<u>中</u>**的未使用内存</p>
<h4 id="分区的动态分配"><a href="#分区的动态分配" class="headerlink" title="分区的动态分配"></a>分区的动态分配</h4><h5 id="常见分配策略"><a href="#常见分配策略" class="headerlink" title="常见分配策略"></a>常见分配策略</h5><h6 id="第一适配"><a href="#第一适配" class="headerlink" title="第一适配"></a>第一适配</h6><p>​		放在<strong>第一个</strong>能够满足需求的空闲块中</p>
<p>​	<strong>简单实现：</strong></p>
<ul>
<li>对空闲块列表按地址排序</li>
<li>分配到第一个合适的分区</li>
<li>回收时进行检查，看看自由分区能不能与相邻的空闲分区合并	<ul>
<li>缺点：产生外部碎片、不确定性</li>
</ul>
</li>
</ul>
<h6 id="最佳适配"><a href="#最佳适配" class="headerlink" title="最佳适配"></a>最佳适配</h6><p>​		在能放下空闲块的分区中，寻找<strong>最小</strong>的分区（避免了分割大空闲块，为了最小化外部碎片产生的尺寸）</p>
<p>​		<strong>简单实现：</strong></p>
<ul>
<li>按尺寸排列空闲块列表</li>
<li>分配时需要寻找最合适的分区</li>
<li>回收时进行检查，看看自由分区能不能与相邻的空闲分区合并	<ul>
<li>优势：当大部分分配是小尺寸时十分有效</li>
<li>劣势：会产生外部碎片，重分配(回收)慢，容易产生很多很小的内部碎片</li>
</ul>
</li>
</ul>
<p>	</p>
<h6 id="最差适配"><a href="#最差适配" class="headerlink" title="最差适配"></a>最差适配</h6><p>​		在能放下空闲块的分区中，寻找<strong>最大</strong>的分区（为了避免有太多微小的碎片）</p>
<p>​		<strong>简单实现：</strong></p>
<ul>
<li>按尺寸排列空闲块列表(从大到小)</li>
<li>分配时需要寻找最合适的分区(找最大的，所以找非常快)</li>
<li>回收时进行检查，看看自由分区能不能与相邻的空闲分区合并	<ul>
<li>优势：分配中等大小的块效果最好</li>
<li>劣势：重分配慢、外部碎片、每次都使用大空闲块可能导致大分区无法被分配</li>
</ul>
</li>
</ul>
<h4 id="压缩式碎片整理"><a href="#压缩式碎片整理" class="headerlink" title="压缩式碎片整理"></a>压缩式碎片整理</h4><p>​	在程序处于等待状态时，将其进行移动，从而消除外部碎片————目的是消除外部碎片</p>
<h4 id="交换式碎片整理"><a href="#交换式碎片整理" class="headerlink" title="交换式碎片整理"></a>交换式碎片整理</h4><p>​	如果运行中的程序需要比较大的内存空间，那么可以让它<u>抢占等待中的程序的内存空间(</u>先将占用了内存空间的等待中的程序转存到硬盘中)</p>
<p>​		问题：将哪个等待中的程序换出呢？什么时候执行换入、换出的操作呢？</p>
<h2 id="Chapter4-非连续式内存分配"><a href="#Chapter4-非连续式内存分配" class="headerlink" title="Chapter4 非连续式内存分配"></a>Chapter4 非连续式内存分配</h2><h3 id="连续内存分配的缺点："><a href="#连续内存分配的缺点：" class="headerlink" title="连续内存分配的缺点："></a>连续内存分配的缺点：</h3><p>​	分配给一个程序的物理内存是连续的、内存利用率较低、有外、内部碎片的问题</p>
<h3 id="非连续内存分配的优点："><a href="#非连续内存分配的优点：" class="headerlink" title="非连续内存分配的优点："></a>非连续内存分配的优点：</h3><ul>
<li>更好的内存利用和管理</li>
<li>允许共享代码与数据</li>
<li>支持动态加载和动态链接</li>
</ul>
<h3 id="非连续内存分配的缺点："><a href="#非连续内存分配的缺点：" class="headerlink" title="非连续内存分配的缺点："></a>非连续内存分配的缺点：</h3><ul>
<li>如何建立虚拟地址与物理地址之间的联系<ul>
<li>硬件方案<ul>
<li>分段		(分段和分页的区别：段的大小可以改变、页的大小是固定的)	</li>
<li>分页</li>
</ul>
</li>
<li>软件方案(开销大，不展开讨论)</li>
</ul>
</li>
</ul>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><h4 id="程序的分段地址空间"><a href="#程序的分段地址空间" class="headerlink" title="程序的分段地址空间"></a>程序的分段地址空间</h4><p>​		有堆、栈、各种部分  逻辑空间是连续的，但实际上物理地址空间毫无关联(跟分配策略有关)</p>
<h4 id="分段寻址方案"><a href="#分段寻址方案" class="headerlink" title="分段寻址方案"></a>分段寻址方案</h4><h5 id="段访问机制："><a href="#段访问机制：" class="headerlink" title="段访问机制："></a>段访问机制：</h5><p>​			s + addr （段号 + 段内偏移）	多地址空间</p>
<p>​			s与addr一起存 							单地址空间</p>
<p>​			s通过 <strong>segment table(段表)</strong> 根据段号 查询 段所对应的物理地址，再加上偏移量就 &#x3D; 物理地址		段表由OS建立	</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><ul>
<li>逻辑空间：页	物理页面：帧</li>
<li>物理内存被分成大小相同的帧</li>
</ul>
<p>一个程序的逻辑地址空间被划分为大小相等的页</p>
<p>​			<strong>🌟(页内偏移大小&#x3D;帧内偏移大小；页号大小 !&#x3D; 帧号大小{在页表中，通过页号得到帧号})</strong></p>
<ul>
<li>页映射到帧</li>
<li>页是连续的虚拟内存</li>
<li>帧是非连续的物理内存</li>
<li>不是所有的页都有对应的帧</li>
</ul>
<h4 id="分页地址空间"><a href="#分页地址空间" class="headerlink" title="分页地址空间"></a>分页地址空间</h4><p>​		帧的物理地址&#x3D;帧号 + 帧内偏移</p>
<h4 id="页寻址方案——页表"><a href="#页寻址方案——页表" class="headerlink" title="页寻址方案——页表"></a>页寻址方案——页表</h4><h5 id="分页机制性能问题："><a href="#分页机制性能问题：" class="headerlink" title="分页机制性能问题："></a>分页机制性能问题：</h5><h6 id="访问一个内存单元需要2次内存访问"><a href="#访问一个内存单元需要2次内存访问" class="headerlink" title="访问一个内存单元需要2次内存访问"></a>访问一个内存单元需要2次内存访问</h6><p>​        	1.用于获取页表项</p>
<p>​			2.根据获得的页表项访问数据</p>
<h6 id="页表可能非常大"><a href="#页表可能非常大" class="headerlink" title="页表可能非常大"></a>页表可能非常大</h6><h5 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h5><h6 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h6><p>​			TLB：缓存近期访问的页-帧转换表项(TLB存于Cache中)</p>
<h6 id="间接访问"><a href="#间接访问" class="headerlink" title="间接访问"></a>间接访问</h6><p>​			二级、多级页表：多次寻址速度降低，但是缩减了页表(时间换空间，但是可以通过TLB提速！)</p>
<h6 id="反向页表-说实话没听明白，先挖个坑，回顾时填上"><a href="#反向页表-说实话没听明白，先挖个坑，回顾时填上" class="headerlink" title="反向页表(说实话没听明白，先挖个坑，回顾时填上)"></a><u>反向</u>页表(说实话没听明白，先挖个坑，回顾时填上)</h6><p>​		程序的地址空间很大时，逻辑地址空间会大于内存的物理地址空间</p>
<p>​		这时 我们<u>不是让页表与逻辑地址空间的大小相对应</u>，而是<strong>让页表与物理地址空间的大小相对应</strong></p>
<p>​		利：</p>
<ul>
<li><p>转换表的大小相对于物理内存来说很小</p>
</li>
<li><p>转换表的大小跟逻辑地址空间的大小无关</p>
<p>弊：</p>
</li>
<li><p>需要的信息对调了，即现在只能根据帧号找到页号</p>
</li>
<li><p>如何转换回来？即如何根据页号找到帧号？</p>
</li>
<li><p>需要在反向页表中搜索想要的页号</p>
</li>
</ul>
<p>	</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*如何实现呢？</span></span><br><span class="line"><span class="comment">*		对页号做hash计算，为了在“帧表”中获取对应的帧号</span></span><br><span class="line"><span class="comment">*		页i被放置在“帧表”中f(i)的位置 #f为hash函数</span></span><br><span class="line"><span class="comment">*			为了查找页i，执行以下操作：</span></span><br><span class="line"><span class="comment">*				对于页i，计算f(i)并使用它作为页寄存器表的索引，获取对应的页寄存器</span></span><br><span class="line"><span class="comment">*				检查寄存器标签是否包含i，如果包含，则代表成功获取帧号，否则失败。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="Chapter5-虚拟内存"><a href="#Chapter5-虚拟内存" class="headerlink" title="Chapter5 虚拟内存"></a>Chapter5 虚拟内存</h2><h3 id="覆盖技术："><a href="#覆盖技术：" class="headerlink" title="覆盖技术："></a>覆盖技术：</h3><p>​			为了在较小的内存中运行较大的程序，常用于多道程序系统，与分区存储管理配合使用</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h4><p>目标：把程序按照其自身逻辑结构，划分为若干个功能上相对独立的程序模块那些不会同时执行的模块共享同一块内存区域，按时间先后来运行。</p>
<ul>
<li><p>必要部分 (常用功能)的代码和数据<strong>常驻内存</strong></p>
</li>
<li><p>可选部分(不常用功能)在其他程序模块中实现,<u><em>平时存放在外存中，在需要用到时才装入内存</em></u>;</p>
<ul>
<li>不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖,即这些模块共用一个分区。</li>
</ul>
</li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>程序的划分复杂，费时费力</li>
<li>经常性的从外存读取数据，实际上是时间换空间</li>
<li>需要程序员自己把整个程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，增加了程序员的负担;</li>
</ul>
<h3 id="交换技术："><a href="#交换技术：" class="headerlink" title="交换技术："></a>交换技术：</h3><p>​		多道程序在内存中时,让正在运行的程序或需要运行的程序获得更多的内存资源。</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理:"></a>原理:</h4><ul>
<li>​	可将暂时不能运行的程序送到外存，从而获得空闲内存空间。</li>
<li>​	操作系统把一个进程的整个地址空间的内容保存到外存中(换出swap out)，而将外存中的某个进程的地址空间读入到内存中(换入swap in)。换入换出内容的大小为整个程序的地址空间。</li>
</ul>
<p>	</p>
<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><ul>
<li>何时交换？<ul>
<li>只有当内存不够或者有不够的风险时进行交换</li>
</ul>
</li>
<li>交换区的大小<ul>
<li>必须足够存放用户进程中所有内存映像的拷贝</li>
<li>必须能对这些内存映像进行直接存取</li>
</ul>
</li>
<li>交换技术:以进程作为交换的单位，需要把进程的整个地址空间都换进换出，增加了处理器的开销。</li>
</ul>
<h3 id="覆盖与交换的比较："><a href="#覆盖与交换的比较：" class="headerlink" title="覆盖与交换的比较："></a>覆盖与交换的比较：</h3><p><strong>覆盖技术</strong>只能发生在那些相互之间没有调用关系的程序模块之间。因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构。(移动的最小粒度为一个程序)</p>
<p><strong>交换技术</strong>是以在内存中的程序大小为单位来进行的，它不需要程序员给出各个模块之间的逻辑覆盖结构。(移动的最小粒度为程序的一个子模块)</p>
<p>换言之，交换发生在内存中程序与管理程序或操作系统之间，而覆盖则发生在运行程序的内部。</p>
<h3 id="虚存技术："><a href="#虚存技术：" class="headerlink" title="虚存技术："></a>虚存技术：</h3><p>像覆盖技术那样，<u>不是把程序的所有内容都放在内存中</u>，因而能够运行比当前的空闲内存空间还要大的程序。但做得更好，由<u>操作系统自动来完成，无须程序员的干涉;</u></p>
<p>像交换技术那样，能够实现进程在内存与外存之间的交换，因而获得更多的空闲内存空间。但做得更好，<u>只对进程的部分内容在内存和外存之间进行交换。</u></p>
<h4 id="程序的局部性原理-principle-of-locality"><a href="#程序的局部性原理-principle-of-locality" class="headerlink" title="程序的局部性原理(principle of locality):"></a>程序的局部性原理(principle of locality):</h4><p>​	指程序在执行过程中的<strong>一个较短时期</strong>，所执行的指令地址和指令的操作数地址，分别<strong>局限于一定区域</strong>。这可以表现为:</p>
<ul>
<li><u>时间局部性</u>:一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内;</li>
<li><u>空间局部性</u>:当前指令和邻近的几条指令，当前访问的数据和邻近的几个数据都集中在一个较小区域内。</li>
</ul>
<p>程序的局部性原理表明，从理论上来说，虚拟存储技术是能够实现的，而且在实现了以后应该是能够取得一个满意的效果的。</p>
<h4 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h4><p>​	可以在页式或段式内存管理的基础上实现</p>
<ul>
<li><p>在装入程序时，不必将其全部装入到内存，而只需将当前需要执行的部分页面或段装入到内存，就可让程序开始执行；</p>
</li>
<li><p>在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序；</p>
</li>
<li><p>另一方面，操作系统将内存中暂时不使用的页面或段调出保存在外存上，从而腾出更多空闲空间存放将要装入的程序以及将要调入的页面或段。</p>
</li>
</ul>
<h4 id="基本特征："><a href="#基本特征：" class="headerlink" title="基本特征："></a>基本特征：</h4><ul>
<li><p>大的用户空间：通过把物理内存与外存相结合，提供给用户的虚拟内存空间通常大于实际的物理内存，即实现了这两者的分离。如32位的虚拟地址理论上可以访问4GB，而可能计算机上仅 有256M的物理内存，但硬盘容量大于4GB。</p>
</li>
<li><p>部分交换：与交换技术相比较，虚拟存储的调入和调出是对部分虛拟地址空间进行的：</p>
</li>
<li><p>不连续性：物理内存分配的不连续，虚拟地址空间使用的不连续。</p>
</li>
</ul>
<h4 id="虚拟页式内存管理："><a href="#虚拟页式内存管理：" class="headerlink" title="虚拟页式内存管理："></a>虚拟页式内存管理：</h4><ul>
<li><p>大部分虚拟存储系统都采用虚拟页式存储管理技术，即在<strong>页式存储管理</strong>的基础上，<strong>增加</strong><u>请求调页和页面置换功能</u>。</p>
</li>
<li><p>基本思路：</p>
<ul>
<li>当一个用户程序要调入内存运行时，<u>不是将该程序的所有页面都装入内存，而是只装入部分的页面</u>，就可启动程序运行。</li>
<li>在运行的过程中，如果发现要运行的程序或要访问数据<u>不在内存，则向系统发出缺页中断请求</u>，系统在处理这个中断时，将外存中相应的页面调入内存，使得该程序能够继续运行。</li>
</ul>
</li>
</ul>
<h5 id="页表表项需要增加："><a href="#页表表项需要增加：" class="headerlink" title="页表表项需要增加："></a>页表表项需要增加：</h5><ol>
<li><strong>驻留位：1表示该页在内存中；0表示在外存中</strong></li>
<li><strong>保护位</strong>：表示允许对该页做何种类型的访问，如只读、可读写、可执行等</li>
<li><strong>修改位</strong>：表明此页在内存中是否被修改过。若修改过，在回收此页时需要把这个页的内容同步到外存。</li>
<li><strong>访问位</strong>：如果最近被访问过，置为1；用于页面置换算法</li>
</ol>
<h5 id="缺页中断处理过程："><a href="#缺页中断处理过程：" class="headerlink" title="缺页中断处理过程："></a>缺页中断处理过程：</h5><ol>
<li><p>如果在内存中有空闲的物理页面，则分配一物理页帧f，然后转第4步：否则转第2步：</p>
</li>
<li><p>采用某种页面置换算法，选择一个将被替换的物理页帧f，它所对应的逻辑页为q。如果该页在内存期间被修改过，则需把它写回外存；</p>
</li>
<li><p>对q所对应的页表项进行修改，把驻留位置为0；</p>
</li>
<li><p>将需要访问的页p裝入到物理页面f当中；</p>
</li>
<li><p>修改p所对应的页表项的内容，把驻留位置为1，把物理页帧号置为f</p>
</li>
<li><p>重新运行被中断的指令。</p>
</li>
</ol>
<h5 id="后备存储-Backing-Store"><a href="#后备存储-Backing-Store" class="headerlink" title="后备存储 Backing Store"></a>后备存储 Backing Store</h5><h6 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h6><ul>
<li><p>一个虚拟地址空间的页面可以被映射到一个文件（在二级存储中）中的某个位置</p>
</li>
<li><p>代码段：映射到可执行二进制文件</p>
</li>
<li><p>动态加载的共享库程序段：映射到动态调用的库文件</p>
</li>
<li><p>其它段：可能被映射到交换文件(swap file)</p>
</li>
</ul>
<p>​	在何处保存未被映射的页？</p>
<ul>
<li><p>能够简单地识别在二级存储器中的页</p>
</li>
<li><p>交换空间（磁盘或者文件）：特殊格式，用于存储末被映射的页面</p>
</li>
</ul>
<h2 id="Chapter6-页面置换算法"><a href="#Chapter6-页面置换算法" class="headerlink" title="Chapter6 页面置换算法"></a>Chapter6 页面置换算法</h2><h3 id="局部页面置换算法"><a href="#局部页面置换算法" class="headerlink" title="局部页面置换算法"></a>局部页面置换算法</h3><h4 id="功能与目标"><a href="#功能与目标" class="headerlink" title="功能与目标"></a>功能与目标</h4><p><strong>功能</strong>：缺页，但主存满了，换谁出去？</p>
<p><strong>目标</strong>：<strong>尽可能减少页面更换的次数</strong>，(通常在局部性原理指导下依据过去的统计数据进行预测)</p>
<p>&lt;页面锁定&gt;:有些页面必须常驻于内存中，不应参与页面置换算法。(通过在页表中添加 ‘锁定标志位,lock bit’ 判断)</p>
<h4 id="6-1最优页面置换算法"><a href="#6-1最优页面置换算法" class="headerlink" title="6.1最优页面置换算法"></a>6.1最优页面置换算法</h4><p>​	是一种理想情况下的页面置换算法, 该算法使用的前提是OS提前知道接下来要访问的页面，换出近期最不会被用到的页面。</p>
<p>无实际意义，但可以用于评价别的算法的性能，作为一个理想的标杆</p>
<h4 id="6-2FIFO算法"><a href="#6-2FIFO算法" class="headerlink" title="6.2FIFO算法"></a>6.2FIFO算法</h4><p>系统维护一个页面的链表，<strong>每次淘汰驻留时间最长的页面</strong>(一个已经在链表中的页面再次被使用并不会刷新该页面的驻留时间，而是继续按原来的计时)</p>
<p><strong>性能较差</strong>，调出的页面可能是经常被调用的页面，并且有**<u><em>Belady现象</em></u>**</p>
<h4 id="6-3最近最久未使用算法-LRU"><a href="#6-3最近最久未使用算法-LRU" class="headerlink" title="6.3最近最久未使用算法(LRU)"></a>6.3最近最久未使用算法(LRU)</h4><p>当缺页中断发生时，选择淘汰最久未使用的页面（根据历史，推测未来，依据程序的访问具有局部性</p>
<p>​	LRU算法需要记录每个页面使用时间的先后顺序，<u><strong>开销比较大</strong></u></p>
<p>两种可能的实现方法：</p>
<ul>
<li>维护一个链表，运行新页面：则放在链表头；运行链表中出现过的页面：将该结点移动到链表头部；若要淘汰页面，则删除队尾的页面。</li>
<li>维护一个栈，刚使用的页面放在栈顶，如果栈中已经有该页面则还需要将栈中记录删去，若要淘汰页面，则删除栈底部的页面(ps:没啥区别啊)</li>
</ul>
<h4 id="6-4时钟页面置换算法"><a href="#6-4时钟页面置换算法" class="headerlink" title="6.4时钟页面置换算法"></a>6.4时钟页面置换算法</h4><ul>
<li>clock页面置换算法，LRU的近似，是对FIFO的一种改进：</li>
</ul>
<h5 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h5><ul>
<li><p>﻿﻿需要用到页表项当中的访问位，当一个页面被装入内存时，把该位初始化为0。然后如果这个页面被访问（读&#x2F;写)，则把该位置为1;</p>
</li>
<li><p>﻿把各个页面组织成环形链表（类似钟表面），把指针指向最老的页面（最<br> 先进来）；</p>
</li>
<li><p>当发生一个缺页中断时，考察指针所指向的最老页面，若它的访问位为0，立即淘汰：若访问位为1，则把该位置为0，然后指针往下移动一格。如此下去，直到找到被淘汰的页面，然后把指针移动到它的下一格。</p>
</li>
</ul>
<h4 id="6-5二次机会法"><a href="#6-5二次机会法" class="headerlink" title="6.5二次机会法"></a>6.5二次机会法</h4><p><strong>添加脏位</strong>(用于标识有没有被写过)，如果被淘汰的页只被读过，则直接删除；如果该页面被修改过，就需要将更新的数据同步至硬盘。</p>
<p>用访问位、脏位两个位来判断被淘汰的页面，只有都为0的页面才会立即被淘汰，有1的页面会首先失去一个1，幸免于本轮循环。(脏位由1变0时，也需要写回硬盘)</p>
<p>给修改过的页面更多的机会留在主存中(<u>其实只针对一种情况：访问位、脏位都为1时，页面被循环轮到后会先把访问位置为0，而不是改变脏位，这样就相当于给这个页面多一条命！</u>)——通过减少写回硬盘的次数来降低开销</p>
<h4 id="6-6最不常用法"><a href="#6-6最不常用法" class="headerlink" title="6.6最不常用法"></a>6.6最不常用法</h4><p>Least frequency used LFU:</p>
<h5 id="基本思路：-1"><a href="#基本思路：-1" class="headerlink" title="基本思路："></a>基本思路：</h5><p>​	当一个缺页中断产生时，选择被访问次数最少的页面淘汰</p>
<p>​	给主存中的每个页都安排一个计数器，淘汰计数器值最小的页面</p>
<p>缺点：计数器开销大</p>
<h4 id="6-7Belady现象"><a href="#6-7Belady现象" class="headerlink" title="6.7Belady现象"></a>6.7Belady现象</h4><p>​	在采用FIFO算法时，有时会出现分配的物理页面数增加，缺页率反而提高的现象；</p>
<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230605214433150.png" alt="image-20230605214433150" style="zoom:30%;" />

<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230605214507498.png" alt="image-20230605214507498" style="zoom:31%;" />

<h4 id="6-8局部页面替换算法的问题、工作集模型"><a href="#6-8局部页面替换算法的问题、工作集模型" class="headerlink" title="6.8局部页面替换算法的问题、工作集模型"></a>6.8局部页面替换算法的问题、工作集模型</h4><p><strong>工作集：一个进程当前正在使用的逻辑页面集合，可以用一个二元函数w(t，∆)来表示</strong></p>
<ul>
<li><p>t是当前的执行时刻；</p>
</li>
<li><p>∆称为工作集窗口 (working set window），即一个定长的页面访问的时同窗口：</p>
</li>
<li><p>w(t，∆)一在当前时刻 t 之前的 ∆时间窗口当中的所有页面所组成的集合(随着 t 的变化，该集合也在不断地变化）</p>
</li>
<li><p>|w(t，∆）|指工作集的大小，即页面数目。</p>
</li>
</ul>
<p><strong>常驻集：是指在当前时刻，进程实际驻留在内存当中的页面集合。</strong></p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ol>
<li><p>工作集是进程在运行过程中固有的性质，而常驻集取决于系统分配给进程的物理页面数日，以及所采用的页面置换算法；</p>
</li>
<li><p>如果一个进程的整个工作集都在内存当中，即常驻集&gt;&#x3D;工作集，那么进程将很顺利地运行，而不会造成太多的缺页中断（直到工作集发生剧烈变动，从而过渡到另一个状态）</p>
</li>
<li><p>当进程常驻集的大小达到某个数目之后，再给它分配更多的物理页面，缺页率也不会明显下降。</p>
</li>
</ol>
<h3 id="全局页面置换算法："><a href="#全局页面置换算法：" class="headerlink" title="全局页面置换算法："></a>全局页面置换算法：</h3><h4 id="1-工作集页面置换算法"><a href="#1-工作集页面置换算法" class="headerlink" title="1.工作集页面置换算法"></a>1.工作集页面置换算法</h4><p>​	如果页面不在工作集中，那么即使没有发生缺页中断，也会把该页面换出。</p>
<p>​	每次都看看自己的常驻集和工作集，常驻集里有，但工作集中没有的页面都会被移除</p>
<h4 id="2-缺页率页面置换算法"><a href="#2-缺页率页面置换算法" class="headerlink" title="2.缺页率页面置换算法"></a>2.缺页率页面置换算法</h4><h5 id="可变分配策路："><a href="#可变分配策路：" class="headerlink" title="可变分配策路："></a>可变分配策路：</h5><p>​	常驻集大小可变，例如：每个进程在刚开始运行的时候，先根据程序大小给它分配一定数目的物理页面，然后在进程运行过程中，再<u>动态地调整常驻集的大小</u>。</p>
<ul>
<li>可采用全局页面置换的方式。当发生一个缺页中断时，被置换的页面可以是在其它进程当中，各个并发进程竞争地使用物理页面。</li>
<li>优缺点：性能较好。但增加了系统开销。</li>
<li>具体实现：可以使用<strong>缺页率算法</strong> (PPF, page fault freguency)来动态调整常驻集的大小。</li>
</ul>
<p><strong>🌟如何动态地调整常驻集的大小？</strong></p>
<p>​	设置一个阈值k，将本次发生缺页的下标 - 上次发生缺页的下标 与 k 进行比较，</p>
<ul>
<li><p>如果k比较大，说明中断异常出现的太频繁了，直接将缺失页加入到工作集中(扩大工作集，降低缺页概率)</p>
</li>
<li><p>如果k比较小，说明不怎么出现中断，那么执行下述操作：将工作集中不在[t_last, t_current]区间内出现的页面移除   (t_last, t_current指上一次、这次出现中断异常的时间下标)</p>
</li>
</ul>
<h3 id="抖动问题："><a href="#抖动问题：" class="headerlink" title="抖动问题："></a>抖动问题：</h3><ul>
<li>﻿如果分配给一个进程的物理页面太少，不能包含整个的工作集，即常驻集＜ 工作集，那么进程将会造成很多的缺页中断，需要频繁地在内存与外存之间替换页面，从而使进程的运行速度变得很慢，我们把这种狀态称为 “抖动”。</li>
<li>﻿产生抖动的原因：随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减小，导致缺页率不断上升。所以<strong>os要选择一个适当的进程数目和进程需要的帧数</strong>，以便在并发水平和缺页率之间达到一个平衡。</li>
</ul>
<p>抖动问题在一些情况下可以被本地的页面置换算法改善</p>
<h2 id="Chapter7-进程和线程"><a href="#Chapter7-进程和线程" class="headerlink" title="Chapter7 进程和线程"></a>Chapter7 进程和线程</h2><h3 id="7-1进程-process-的描述"><a href="#7-1进程-process-的描述" class="headerlink" title="7.1进程(process)的描述"></a>7.1进程(process)的描述</h3><h4 id="进程定义："><a href="#进程定义：" class="headerlink" title="进程定义："></a>进程定义：</h4><p>​	一个具有一定功能的程序在一个数据集合上的一次动态执行的过程</p>
<h4 id="进程组成："><a href="#进程组成：" class="headerlink" title="进程组成："></a>进程组成：</h4><p>包含了一个正在运行的程序的所有状态信息</p>
<pre><code>        1. 程序的代码
        1. 程序处理的数据
        1. 程序计数器的值，指示下一条即将运行的指令
        1. 一组通用的寄存器的当前值，堆、栈
        1. 一组系统资源(如打开的程序)
</code></pre>
<h5 id="进程与程序的联系："><a href="#进程与程序的联系：" class="headerlink" title="进程与程序的联系："></a>进程与程序的联系：</h5><ul>
<li>﻿程序是产生进程的基础</li>
<li>﻿<u>程序的每次运行构成不同的进程</u></li>
<li>﻿进程是程序功能的体现</li>
<li>﻿通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序。</li>
</ul>
<h5 id="进程与程序的区别："><a href="#进程与程序的区别：" class="headerlink" title="进程与程序的区别："></a>进程与程序的区别：</h5><ul>
<li><p>进程是动态的，程序是静态的：程序是有序代码的集合；进程是程序的执行，进程有核心态&#x2F;用户态</p>
</li>
<li><p>进程是暂时的，程序的永久的：进程是一个状态变化的过程，程序可长久保存</p>
</li>
<li><p>进程与程序的组成不同：进程的组成包括**<u>程序、数据和进程控制块</u>**（即进程状态信息）</p>
</li>
</ul>
<h4 id="进程的特点："><a href="#进程的特点：" class="headerlink" title="进程的特点："></a>进程的特点：</h4><ul>
<li>﻿动态性：可动态地创建、结束进程；</li>
<li>﻿并发性：进程可以被独立调度并占用处理机运行；(并发-&gt;串、并行-&gt;并)</li>
<li>﻿独立性：不同进程的工作不相互影响：</li>
<li>﻿制约性：因访问共享数据&#x2F;资源或进程间同步而产生制约。</li>
</ul>
<h4 id="进程控制结构："><a href="#进程控制结构：" class="headerlink" title="进程控制结构："></a>进程控制结构：</h4><p>​	程序 &#x3D; 算法 + 数据结构</p>
<p>​	描述进程的数据结构：<strong>进程控制块</strong>(Process Control Block, PCB)</p>
<p>进程控制块：OS管理进程运行所用信息的集合，OS用PCB描述<u>进程的基本情况及运行变化的过程</u>，PCB是进程存在的<strong>唯一标志。</strong></p>
<h5 id="PCB中包含的内容："><a href="#PCB中包含的内容：" class="headerlink" title="PCB中包含的内容："></a>PCB中包含的内容：</h5><ol>
<li><p><strong>进程标识信息</strong>。如本进程的标识，本进程的产生者标识(父进程标识)；用户标识。</p>
</li>
<li><p><strong>处理机状态信息保存区</strong>。保存进程的运行现场信息：</p>
<ul>
<li><p>﻿用户可见寄存器，用户程序可以使用的数据，地址等寄存器。</p>
</li>
<li><p>﻿控制和状态寄存器，如程序计数器(PC)，程序状态字 (PSW)。</p>
</li>
<li><p>﻿栈指针，过程调用&#x2F;系统调用&#x2F;中断处理和返回时需要用到它。</p>
</li>
</ul>
</li>
<li><p><strong>进程控制信息</strong></p>
</li>
</ol>
<ul>
<li><p>调度和状态信息，用于操作系统调度进程并占用处理机使用。</p>
</li>
<li><p>进程间通信信息，为支持进程问的与通信相关的各种标识、信号、信件等，这些信息存在接收方的进程控制块中。</p>
</li>
<li><p>存储管理信息，包含有指向本进程映像存储空间的数据结构。</p>
</li>
<li><p>﻿进程所用资源，说明由进程打开、使用的系统资源，如打开的文件等。</p>
</li>
<li><p>﻿有关数据结构连接信息，进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB。</p>
</li>
</ul>
<h5 id="PCB的组织方式"><a href="#PCB的组织方式" class="headerlink" title="PCB的组织方式"></a>PCB的组织方式</h5><ul>
<li>链表(常用)：同一状态的进程其PCB成一链表，多个状态对应多个不同的链表</li>
</ul>
<p>各状态的进程形成不同的链表：就绪链表、阻塞链表</p>
<ul>
<li>索引表：同一状态的进程归入一个index表（由index指向PCB)，多个状态对应多个不同的index表</li>
</ul>
<p>各状态的进行形成不同的索引表：就绪索引表、阻塞索引表</p>
<h3 id="7-2进程状态"><a href="#7-2进程状态" class="headerlink" title="7.2进程状态"></a>7.2进程状态</h3><h4 id="进程生命周期管理"><a href="#进程生命周期管理" class="headerlink" title="进程生命周期管理"></a>进程生命周期管理</h4><h5 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h5><h6 id="引起进程创建的三个主要事件："><a href="#引起进程创建的三个主要事件：" class="headerlink" title="引起进程创建的三个主要事件："></a>引起进程创建的三个主要事件：</h6><pre><code>    1. 系统初始化时(创建init进程)	
    2. **用户请求**创建一个新进程
    3. 正在运行的**进程执行**了创建进程的系统调用
</code></pre>
<h5 id="进程运行"><a href="#进程运行" class="headerlink" title="进程运行"></a>进程运行</h5><h6 id="内核选择一个就绪的进程，让它占用处理机并执行"><a href="#内核选择一个就绪的进程，让它占用处理机并执行" class="headerlink" title="内核选择一个就绪的进程，让它占用处理机并执行"></a>内核<strong>选择一个就绪的进程</strong>，让它占用处理机<strong>并执行</strong></h6><h5 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h5><h6 id="以下情况下，进程等待："><a href="#以下情况下，进程等待：" class="headerlink" title="以下情况下，进程等待："></a>以下情况下，进程等待：</h6><ol>
<li>﻿<strong>请求并等待系统服务</strong>，无法马上完成</li>
<li>﻿<strong>启动某种操作</strong>，无法马上完成</li>
<li>﻿<strong>需要的数据没有到达</strong></li>
</ol>
<p><u>进程只能自己阻塞自己，因为只有进程自身才能知道何时需要等待某种事件的发生。</u></p>
<h5 id="进程唤醒"><a href="#进程唤醒" class="headerlink" title="进程唤醒"></a>进程唤醒</h5><h6 id="唤醒进程的原因："><a href="#唤醒进程的原因：" class="headerlink" title="唤醒进程的原因："></a>唤醒进程的原因：</h6><ol>
<li>﻿被阻塞进程需要的资源可被满足</li>
<li>﻿被阻塞进程等待的事件到达</li>
<li>﻿将该进程的PCB插入到就绪队列</li>
</ol>
<p><u>进程只能被别的进程或操作系统唤醒。</u></p>
<h5 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h5><h6 id="在以下四种情形下，进程结束："><a href="#在以下四种情形下，进程结束：" class="headerlink" title="在以下四种情形下，进程结束："></a>在以下四种情形下，进程结束：</h6><ul>
<li><p>正常退出（自愿的）</p>
</li>
<li><p>错误退出（自愿的）</p>
</li>
<li><p>致命错误（强制性的）</p>
</li>
<li><p>被其他进程所杀（强制性的）</p>
</li>
</ul>
<h4 id="进程状态变化模型"><a href="#进程状态变化模型" class="headerlink" title="进程状态变化模型"></a>进程状态变化模型</h4><h5 id="进程的三种基本状态："><a href="#进程的三种基本状态：" class="headerlink" title="进程的三种基本状态："></a>进程的三种<u>基本</u>状态：</h5><p>​	进程在生命结束前处于且仅处于三种基本状态之一</p>
<ul>
<li><p>运行状态(Running)：当一个进程正在处理机上运行时。</p>
</li>
<li><p>就绪状态(Ready)：一个进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。</p>
</li>
<li><p>等待状态（又称阻塞状态Blocked)：一个进程正在等待某一事件而暂停运行时。如等待某资源，等待输入&#x2F;输出完成。</p>
</li>
</ul>
<h5 id="进程其它的基本状态："><a href="#进程其它的基本状态：" class="headerlink" title="进程其它的基本状态："></a>进程其它的基本状态：</h5><ul>
<li><p>创建状态(New)：一个进程正在被创建，还没被转到就绪状态之前的状态。</p>
</li>
<li><p>结束状态(Exit)：一个进程正在从系统中消失时的状态，这是因为进程结束或由于其他原因所导致。</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230606110651191.png" alt="image-20230606110651191" style="zoom:50%;" />

<h4 id="进程挂起模型"><a href="#进程挂起模型" class="headerlink" title="进程挂起模型"></a>进程挂起模型</h4><p> 进程挂起：进程不占用内存空间，处于挂起状态的进程映像在磁盘上。</p>
<h5 id="挂起状态："><a href="#挂起状态：" class="headerlink" title="挂起状态："></a>挂起状态：</h5><ul>
<li>﻿阻塞挂起状态 (Blocked-suspend）：进程在外存并<strong>等待某事件的出现</strong>；</li>
<li>﻿就绪挂起状态 (Ready-suspend）：进程在外存，但<strong>只要进入内存，即可运行</strong>；</li>
</ul>
<h5 id="挂起-Suspend）：把一个进程从内存转到外存；可能有以下几种情况："><a href="#挂起-Suspend）：把一个进程从内存转到外存；可能有以下几种情况：" class="headerlink" title="挂起 (Suspend）：把一个进程从内存转到外存；可能有以下几种情况："></a>挂起 (Suspend）：把一个进程从内存转到外存；可能有以下几种情况：</h5><ul>
<li><p>﻿阻塞到阻塞挂起：没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以提交新进程或运行就绪进程；</p>
</li>
<li><p>﻿就绪到就绪挂起：当有高优先级阻塞(系统认为会很快就绪的）进程和低优先就绪进程时，系统会选择挂起低优先级就绪进程；</p>
</li>
<li><p>﻿运行到就绪挂起：对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态；</p>
</li>
</ul>
<h5 id="在外存时的状态转换："><a href="#在外存时的状态转换：" class="headerlink" title="在外存时的状态转换："></a>在外存时的状态转换：</h5><ul>
<li>﻿阻塞挂起到就绪挂起：当有阻塞挂起进程因相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程。</li>
</ul>
<h5 id="解挂-x2F-激活-Activate）：把一个进程从外存转到内存；可能有以下几种情况："><a href="#解挂-x2F-激活-Activate）：把一个进程从外存转到内存；可能有以下几种情况：" class="headerlink" title="解挂&#x2F;激活 (Activate）：把一个进程从外存转到内存；可能有以下几种情况："></a>解挂&#x2F;激活 (Activate）：把一个进程从外存转到内存；可能有以下几种情况：</h5><ul>
<li>﻿就绪挂起到就绪：没有就绪进程或挂起就绪进程优先级高于就绪进程时，会进行这种转换；</li>
<li>﻿阻塞挂起到阻塞：当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起（系统认为会很快出现所等待的事件）进程转换为阻塞进程；</li>
</ul>
<h5 id="OS如何通过PCB完成进程的调度？"><a href="#OS如何通过PCB完成进程的调度？" class="headerlink" title="OS如何通过PCB完成进程的调度？"></a>OS如何通过PCB完成进程的调度？</h5><h6 id="🌟状态队列"><a href="#🌟状态队列" class="headerlink" title="🌟状态队列"></a>🌟状态队列</h6><ul>
<li><p>﻿由操作系统来维护一组队列，用来表示系统当中所有进程的当前状态；</p>
</li>
<li><p>﻿<u><strong>不同的状态分别用不同的队列来表示</strong></u>(就绪队列、各种类型的阻塞队列）；</p>
</li>
<li><p>每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生变化时，它的PCB从一个状态队列中脱离出来，加入到另外一个队列。</p>
</li>
</ul>
<h3 id="7-3线程"><a href="#7-3线程" class="headerlink" title="7.3线程"></a>7.3线程</h3><h3 id="7-4进程间通信"><a href="#7-4进程间通信" class="headerlink" title="7.4进程间通信"></a>7.4进程间通信</h3><h3 id="7-5进程互斥与同步"><a href="#7-5进程互斥与同步" class="headerlink" title="7.5进程互斥与同步"></a>7.5进程互斥与同步</h3><h3 id="7-6死锁"><a href="#7-6死锁" class="headerlink" title="7.6死锁"></a>7.6死锁</h3><h2 id="Chapter8-CPU调度"><a href="#Chapter8-CPU调度" class="headerlink" title="Chapter8 CPU调度"></a>Chapter8 CPU调度</h2><h2 id="Chapter9-同步"><a href="#Chapter9-同步" class="headerlink" title="Chapter9 同步"></a>Chapter9 同步</h2><h2 id="Chapter10-信号量和管程"><a href="#Chapter10-信号量和管程" class="headerlink" title="Chapter10 信号量和管程"></a>Chapter10 信号量和管程</h2><h5 id=""><a href="#" class="headerlink" title=""></a></h5></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://Tangjiayang.github.io">donn</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://tangjiayang.github.io/2023/06/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">https://tangjiayang.github.io/2023/06/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/06/02/Redis/" title="Redis"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Redis</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81ODUzNy8zNTAwMA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/bg.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">donn</div><div class="author-info__description">欢迎访问donn的博客!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Tangjiayang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Tangjiayang" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">小站成立于2023-5-27！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter1-%E6%A6%82%E8%BF%B0"><span class="toc-text">Chapter1 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFOS%EF%BC%9F"><span class="toc-text">什么是OS？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%A7%92%E5%BA%A6%EF%BC%9A"><span class="toc-text">用户角度：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E8%A7%92%E5%BA%A6%EF%BC%9A"><span class="toc-text">资源角度：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kernel%E5%B1%82%E5%86%85%E9%83%A8%E7%BB%84%E4%BB%B6%EF%BC%9A"><span class="toc-text">Kernel层内部组件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OS-Kernel%E7%9A%84%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="toc-text">OS Kernel的特征：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="toc-text">Chapter2 操作系统基础操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="toc-text">2.1 操作系统的启动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E6%9C%BA%E9%A1%BA%E5%BA%8F%EF%BC%9A"><span class="toc-text">开机顺序：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">2.2 中断、异常和系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD-from-%E5%A4%96%E8%AE%BE"><span class="toc-text">中断(from 外设)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">中断的处理过程：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%EF%BC%9A"><span class="toc-text">硬件：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%EF%BC%9A"><span class="toc-text">软件：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8-from-%E4%B8%8D%E8%89%AF%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-text">异常(from 不良的应用程序)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">异常的处理过程：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-from-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-text">系统调用(from 应用程序)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">系统调用的处理过程：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E8%B6%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BE%B9%E7%95%8C%E7%9A%84%E5%BC%80%E9%94%80-%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">跨越操作系统边界的开销(中断、异常、系统调用)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter3-%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">Chapter3 连续式内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E5%86%85%E5%AD%98%E5%88%86%E5%B1%82%E4%BD%93%E7%B3%BB"><span class="toc-text">计算机体系结构及内存分层体系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E9%9D%A2%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%9B%AE%E6%A0%87"><span class="toc-text">操作系统的内存管理方面的四个目标</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%9C%B0%E5%9D%80%E7%94%9F%E6%88%90"><span class="toc-text">地址空间与地址生成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%AE%9A%E4%B9%89"><span class="toc-text">1.地址空间定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9C%B0%E5%9D%80%E7%94%9F%E6%88%90"><span class="toc-text">2.地址生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9C%B0%E5%9D%80%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5"><span class="toc-text">3.地址安全检查</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%9A%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E4%B8%8E%E5%88%86%E5%8C%BA%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-text">连续内存分配：内存碎片与分区的动态分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98"><span class="toc-text">内存碎片问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-text">分区的动态分配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-text">常见分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%80%82%E9%85%8D"><span class="toc-text">第一适配</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E9%80%82%E9%85%8D"><span class="toc-text">最佳适配</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%80%E5%B7%AE%E9%80%82%E9%85%8D"><span class="toc-text">最差适配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%BC%8F%E7%A2%8E%E7%89%87%E6%95%B4%E7%90%86"><span class="toc-text">压缩式碎片整理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E5%BC%8F%E7%A2%8E%E7%89%87%E6%95%B4%E7%90%86"><span class="toc-text">交换式碎片整理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter4-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">Chapter4 非连续式内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">连续内存分配的缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">非连续内存分配的优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">非连续内存分配的缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5"><span class="toc-text">分段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%AE%B5%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-text">程序的分段地址空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%AF%BB%E5%9D%80%E6%96%B9%E6%A1%88"><span class="toc-text">分段寻址方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AE%B5%E8%AE%BF%E9%97%AE%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-text">段访问机制：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5"><span class="toc-text">分页</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-text">分页地址空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E5%AF%BB%E5%9D%80%E6%96%B9%E6%A1%88%E2%80%94%E2%80%94%E9%A1%B5%E8%A1%A8"><span class="toc-text">页寻址方案——页表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">分页机制性能问题：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83%E9%9C%80%E8%A6%812%E6%AC%A1%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE"><span class="toc-text">访问一个内存单元需要2次内存访问</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E5%8F%AF%E8%83%BD%E9%9D%9E%E5%B8%B8%E5%A4%A7"><span class="toc-text">页表可能非常大</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">如何解决？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-text">缓存</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E8%AE%BF%E9%97%AE"><span class="toc-text">间接访问</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E9%A1%B5%E8%A1%A8-%E8%AF%B4%E5%AE%9E%E8%AF%9D%E6%B2%A1%E5%90%AC%E6%98%8E%E7%99%BD%EF%BC%8C%E5%85%88%E6%8C%96%E4%B8%AA%E5%9D%91%EF%BC%8C%E5%9B%9E%E9%A1%BE%E6%97%B6%E5%A1%AB%E4%B8%8A"><span class="toc-text">反向页表(说实话没听明白，先挖个坑，回顾时填上)</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter5-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-text">Chapter5 虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF%EF%BC%9A"><span class="toc-text">覆盖技术：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-text">原理:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%EF%BC%9A"><span class="toc-text">交换技术：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-text">原理:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">问题：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%9A"><span class="toc-text">覆盖与交换的比较：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%AD%98%E6%8A%80%E6%9C%AF%EF%BC%9A"><span class="toc-text">虚存技术：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86-principle-of-locality"><span class="toc-text">程序的局部性原理(principle of locality):</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-text">基本概念：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="toc-text">基本特征：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A"><span class="toc-text">虚拟页式内存管理：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E8%A1%A8%E9%A1%B9%E9%9C%80%E8%A6%81%E5%A2%9E%E5%8A%A0%EF%BC%9A"><span class="toc-text">页表表项需要增加：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">缺页中断处理过程：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E5%A4%87%E5%AD%98%E5%82%A8-Backing-Store"><span class="toc-text">后备存储 Backing Store</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-text">概念：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter6-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">Chapter6 页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">局部页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%9B%AE%E6%A0%87"><span class="toc-text">功能与目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1%E6%9C%80%E4%BC%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">6.1最优页面置换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2FIFO%E7%AE%97%E6%B3%95"><span class="toc-text">6.2FIFO算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95-LRU"><span class="toc-text">6.3最近最久未使用算法(LRU)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4%E6%97%B6%E9%92%9F%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">6.4时钟页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-text">基本思路：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5%E4%BA%8C%E6%AC%A1%E6%9C%BA%E4%BC%9A%E6%B3%95"><span class="toc-text">6.5二次机会法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6%E6%9C%80%E4%B8%8D%E5%B8%B8%E7%94%A8%E6%B3%95"><span class="toc-text">6.6最不常用法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF%EF%BC%9A-1"><span class="toc-text">基本思路：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7Belady%E7%8E%B0%E8%B1%A1"><span class="toc-text">6.7Belady现象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8%E5%B1%80%E9%83%A8%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%81%E5%B7%A5%E4%BD%9C%E9%9B%86%E6%A8%A1%E5%9E%8B"><span class="toc-text">6.8局部页面替换算法的问题、工作集模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-text">全局页面置换算法：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B7%A5%E4%BD%9C%E9%9B%86%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">1.工作集页面置换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BC%BA%E9%A1%B5%E7%8E%87%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">2.缺页率页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E9%85%8D%E7%AD%96%E8%B7%AF%EF%BC%9A"><span class="toc-text">可变分配策路：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%96%E5%8A%A8%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">抖动问题：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter7-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-text">Chapter7 进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1%E8%BF%9B%E7%A8%8B-process-%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="toc-text">7.1进程(process)的描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-text">进程定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84%E6%88%90%EF%BC%9A"><span class="toc-text">进程组成：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%81%94%E7%B3%BB%EF%BC%9A"><span class="toc-text">进程与程序的联系：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">进程与程序的区别：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">进程的特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-text">进程控制结构：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#PCB%E4%B8%AD%E5%8C%85%E5%90%AB%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%9A"><span class="toc-text">PCB中包含的内容：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PCB%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-text">PCB的组织方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-text">7.2进程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="toc-text">进程生命周期管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-text">进程创建</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%95%E8%B5%B7%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E4%B8%89%E4%B8%AA%E4%B8%BB%E8%A6%81%E4%BA%8B%E4%BB%B6%EF%BC%9A"><span class="toc-text">引起进程创建的三个主要事件：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C"><span class="toc-text">进程运行</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E9%80%89%E6%8B%A9%E4%B8%80%E4%B8%AA%E5%B0%B1%E7%BB%AA%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%8C%E8%AE%A9%E5%AE%83%E5%8D%A0%E7%94%A8%E5%A4%84%E7%90%86%E6%9C%BA%E5%B9%B6%E6%89%A7%E8%A1%8C"><span class="toc-text">内核选择一个就绪的进程，让它占用处理机并执行</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85"><span class="toc-text">进程等待</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%A5%E4%B8%8B%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85%EF%BC%9A"><span class="toc-text">以下情况下，进程等待：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%94%A4%E9%86%92"><span class="toc-text">进程唤醒</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%94%A4%E9%86%92%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="toc-text">唤醒进程的原因：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9D%9F"><span class="toc-text">进程结束</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%A8%E4%BB%A5%E4%B8%8B%E5%9B%9B%E7%A7%8D%E6%83%85%E5%BD%A2%E4%B8%8B%EF%BC%8C%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9D%9F%EF%BC%9A"><span class="toc-text">在以下四种情形下，进程结束：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E6%A8%A1%E5%9E%8B"><span class="toc-text">进程状态变化模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-text">进程的三种基本状态：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%85%B6%E5%AE%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-text">进程其它的基本状态：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8C%82%E8%B5%B7%E6%A8%A1%E5%9E%8B"><span class="toc-text">进程挂起模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-text">挂起状态：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7-Suspend%EF%BC%89%EF%BC%9A%E6%8A%8A%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%BB%8E%E5%86%85%E5%AD%98%E8%BD%AC%E5%88%B0%E5%A4%96%E5%AD%98%EF%BC%9B%E5%8F%AF%E8%83%BD%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A"><span class="toc-text">挂起 (Suspend）：把一个进程从内存转到外存；可能有以下几种情况：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E5%A4%96%E5%AD%98%E6%97%B6%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%EF%BC%9A"><span class="toc-text">在外存时的状态转换：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%8C%82-x2F-%E6%BF%80%E6%B4%BB-Activate%EF%BC%89%EF%BC%9A%E6%8A%8A%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%BB%8E%E5%A4%96%E5%AD%98%E8%BD%AC%E5%88%B0%E5%86%85%E5%AD%98%EF%BC%9B%E5%8F%AF%E8%83%BD%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A"><span class="toc-text">解挂&#x2F;激活 (Activate）：把一个进程从外存转到内存；可能有以下几种情况：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#OS%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87PCB%E5%AE%8C%E6%88%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%EF%BC%9F"><span class="toc-text">OS如何通过PCB完成进程的调度？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%F0%9F%8C%9F%E7%8A%B6%E6%80%81%E9%98%9F%E5%88%97"><span class="toc-text">🌟状态队列</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3%E7%BA%BF%E7%A8%8B"><span class="toc-text">7.3线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">7.4进程间通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="toc-text">7.5进程互斥与同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6%E6%AD%BB%E9%94%81"><span class="toc-text">7.6死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter8-CPU%E8%B0%83%E5%BA%A6"><span class="toc-text">Chapter8 CPU调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter9-%E5%90%8C%E6%AD%A5"><span class="toc-text">Chapter9 同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter10-%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8C%E7%AE%A1%E7%A8%8B"><span class="toc-text">Chapter10 信号量和管程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text"></span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统"/></a><div class="content"><a class="title" href="/2023/06/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统">操作系统</a><time datetime="2023-06-02T07:36:55.000Z" title="Created 2023-06-02 15:36:55">2023-06-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/02/Redis/" title="Redis"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis"/></a><div class="content"><a class="title" href="/2023/06/02/Redis/" title="Redis">Redis</a><time datetime="2023-06-02T07:35:17.000Z" title="Created 2023-06-02 15:35:17">2023-06-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/02/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" title="消息队列"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="消息队列"/></a><div class="content"><a class="title" href="/2023/06/02/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" title="消息队列">消息队列</a><time datetime="2023-06-02T07:33:40.000Z" title="Created 2023-06-02 15:33:40">2023-06-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式"/></a><div class="content"><a class="title" href="/2023/06/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">设计模式</a><time datetime="2023-06-02T07:31:53.000Z" title="Created 2023-06-02 15:31:53">2023-06-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/02/SpringBoot/" title="SpringBoot"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot"/></a><div class="content"><a class="title" href="/2023/06/02/SpringBoot/" title="SpringBoot">SpringBoot</a><time datetime="2023-06-02T07:29:39.000Z" title="Created 2023-06-02 15:29:39">2023-06-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 By donn</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">很高兴认识你🤪</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>