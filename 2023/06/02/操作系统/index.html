<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统 | donn的博客</title><meta name="author" content="donn"><meta name="copyright" content="donn"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="操作系统(参照清华——操作系统课程)： os：对硬件的管理和控制 	本课程着重对kernel层的研究 Chapter1 概述什么是OS？CPU —–&gt; 进程 磁盘 —–&gt; 文件 内存 —–&gt; 地址空间 用户角度： 管理应用程序 为应用程序提供服务 杀死应用程序  资源角度： 资源管理 管理外设、分配资源  Kernel层内部组件： CPU调度器 物理内存管理 虚拟内存管理 文件系">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="https://tangjiayang.github.io/2023/06/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="donn的博客">
<meta property="og:description" content="操作系统(参照清华——操作系统课程)： os：对硬件的管理和控制 	本课程着重对kernel层的研究 Chapter1 概述什么是OS？CPU —–&gt; 进程 磁盘 —–&gt; 文件 内存 —–&gt; 地址空间 用户角度： 管理应用程序 为应用程序提供服务 杀死应用程序  资源角度： 资源管理 管理外设、分配资源  Kernel层内部组件： CPU调度器 物理内存管理 虚拟内存管理 文件系">
<meta property="og:locale">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-06-02T07:36:55.000Z">
<meta property="article:modified_time" content="2023-06-20T06:19:28.157Z">
<meta property="article:author" content="donn">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://tangjiayang.github.io/2023/06/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":30,"languages":{"author":"Author: donn","link":"Link: ","source":"Source: donn的博客","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-20 14:19:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/bg.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="donn的博客"><span class="site-name">donn的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-06-02T07:36:55.000Z" title="Created 2023-06-02 15:36:55">2023-06-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-06-20T06:19:28.157Z" title="Updated 2023-06-20 14:19:28">2023-06-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">20.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>60min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>(参照清华——操作系统课程)：</p>
<p>os：对硬件的管理和控制 	本课程着重对<strong>kernel层</strong>的研究</p>
<h2 id="Chapter1-概述"><a href="#Chapter1-概述" class="headerlink" title="Chapter1 概述"></a>Chapter1 概述</h2><h4 id="什么是OS？"><a href="#什么是OS？" class="headerlink" title="什么是OS？"></a>什么是OS？</h4><p>CPU —–&gt; 进程</p>
<p>磁盘 —–&gt; 文件</p>
<p>内存 —–&gt; 地址空间</p>
<h5 id="用户角度："><a href="#用户角度：" class="headerlink" title="用户角度："></a>用户角度：</h5><ul>
<li>管理应用程序</li>
<li>为应用程序提供服务</li>
<li>杀死应用程序</li>
</ul>
<h5 id="资源角度："><a href="#资源角度：" class="headerlink" title="资源角度："></a>资源角度：</h5><ul>
<li>资源管理</li>
<li>管理外设、分配资源</li>
</ul>
<h4 id="Kernel层内部组件："><a href="#Kernel层内部组件：" class="headerlink" title="Kernel层内部组件："></a>Kernel层内部组件：</h4><ul>
<li>CPU调度器</li>
<li>物理内存管理</li>
<li>虚拟内存管理</li>
<li>文件系统管理</li>
<li>中断处理与设备驱动</li>
</ul>
<h4 id="OS-Kernel的特征："><a href="#OS-Kernel的特征：" class="headerlink" title="OS Kernel的特征："></a>OS Kernel的特征：</h4><ul>
<li><p>并发</p>
<ul>
<li>计算机系统中同时存在多个运行的程序，需要OS管理和调度</li>
</ul>
</li>
<li><p>共享</p>
<ul>
<li>互斥共享</li>
</ul>
</li>
<li><p>虚拟</p>
<ul>
<li>利用<strong>多道程序设计技术</strong>让每个用户都觉得有一个计算机专门为他服务。</li>
</ul>
</li>
<li><p>异步</p>
<ul>
<li>程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知</li>
<li>只要运行环境相同，OS需要保证程序的运行结果也相同</li>
</ul>
</li>
</ul>
<h2 id="Chapter2-操作系统基础操作"><a href="#Chapter2-操作系统基础操作" class="headerlink" title="Chapter2 操作系统基础操作"></a>Chapter2 操作系统基础操作</h2><h3 id="2-1-操作系统的启动"><a href="#2-1-操作系统的启动" class="headerlink" title="2.1 操作系统的启动"></a>2.1 操作系统的启动</h3><h4 id="开机顺序："><a href="#开机顺序：" class="headerlink" title="开机顺序："></a>开机顺序：</h4><p>​		电脑开机后，将先执行bootstrap program程序(引导程序)，引导程序一般位于计算机的固件中，由它初始化系统的内核以及各个组件。</p>
<h3 id="2-2-中断、异常和系统调用"><a href="#2-2-中断、异常和系统调用" class="headerlink" title="2.2 中断、异常和系统调用"></a>2.2 中断、异常和系统调用</h3><h4 id="中断-from-外设"><a href="#中断-from-外设" class="headerlink" title="中断(from 外设)"></a>中断(from 外设)</h4><ul>
<li><p>来自不同的硬件设备的计时器和网络的中断</p>
</li>
<li><p>异步</p>
</li>
<li><p>对用户应用程序是透明的</p>
</li>
</ul>
<h5 id="中断的处理过程："><a href="#中断的处理过程：" class="headerlink" title="中断的处理过程："></a>中断的处理过程：</h5><h6 id="硬件："><a href="#硬件：" class="headerlink" title="硬件："></a>硬件：</h6><ul>
<li>设置中断标记[CPU初始化]<br>1. 将内部事件、外部事件设置中断标记<br>      1. CPU通过标记获得中断事件的ID(凭借中断向量表)</li>
</ul>
<p>	</p>
<h6 id="软件："><a href="#软件：" class="headerlink" title="软件："></a>软件：</h6><ul>
<li>保存当前处理状态</li>
<li>中断服务程序处理</li>
<li>清除中断标记</li>
<li>恢复之前保存的处理状态</li>
</ul>
<h4 id="异常-from-不良的应用程序"><a href="#异常-from-不良的应用程序" class="headerlink" title="异常(from 不良的应用程序)"></a>异常(from 不良的应用程序)</h4><ul>
<li><p>应用程序产生，由于非法指令或者其他坏的处理状态</p>
</li>
<li><p>同步</p>
</li>
<li><p>杀死或重新执行意想不到的应用程序指令</p>
</li>
</ul>
<h5 id="异常的处理过程："><a href="#异常的处理过程：" class="headerlink" title="异常的处理过程："></a>异常的处理过程：</h5><ul>
<li>保存现场</li>
<li>异常处理<ul>
<li>杀死异常程序</li>
<li>或者 重新执行异常命令</li>
</ul>
</li>
<li>恢复现场</li>
</ul>
<h4 id="系统调用-from-应用程序"><a href="#系统调用-from-应用程序" class="headerlink" title="系统调用(from 应用程序)"></a>系统调用(from 应用程序)</h4><ul>
<li><p>应用程序主动向OS发送服务请求</p>
</li>
<li><p>同步或异步</p>
</li>
<li><p>等待后继续执行</p>
</li>
</ul>
<h5 id="系统调用的处理过程："><a href="#系统调用的处理过程：" class="headerlink" title="系统调用的处理过程："></a>系统调用的处理过程：</h5><p>​	调用系统函数 如printf()后，会触发系统调用，在屏幕上打印</p>
<p><u>将OS能提供的系统调用进行某种集成，形成各色各样的API供开发人员使用</u></p>
<ul>
<li><p>Win32 API 用于Windows</p>
</li>
<li><p>POSIX API 用于 POSIX-based systems(such as: UNIX、LINUX、MAX OS X)</p>
</li>
<li><p>Java API 用于 JVM</p>
<ol>
<li>通常情况下，每个系统调用有自己的序号，系统调用接口根据这些序号维护表的索引</li>
<li>系统调用接口 调用内核态中的系统调用，返回系统调用的状态和结果(其返回值)</li>
<li>用户不需要知道系统调用是如何实现的，只需要获取各个API的作用即可；操作系统接口的细节大部分隐藏在API中</li>
</ol>
</li>
</ul>
<p><strong>🌟用户从系统调用的库中调用系统调用接口，在调用系统调用接口时，会触发一个从用户态-&gt;内核态的转换，执行内核态中的系统调用。</strong></p>
<p>系统调用的开销会大于普通的函数调用，因为：</p>
<p>​	系统调用会从用户态切换到内核态，需要两次建立函数空间，而函数调用只有自己唯一的栈空间</p>
<h4 id="跨越操作系统边界的开销-中断、异常、系统调用"><a href="#跨越操作系统边界的开销-中断、异常、系统调用" class="headerlink" title="跨越操作系统边界的开销(中断、异常、系统调用)"></a>跨越操作系统边界的开销(中断、异常、系统调用)</h4><p>在执行时间上开销超过应用程序</p>
<p>开销体现于：</p>
<ul>
<li>建立中断&#x2F;异常&#x2F;系统<strong>调用号 与 对应服务例程映射关系的初始化开销</strong>(因为你跨越了OS边界，不能把原本的状态带过去，所以需要一张映射表，由编号找到你需要做的事)</li>
<li>建立内核堆栈(因为在内核态进行操作，需要在内核态建立变量存储空间)</li>
<li>验证参数(内核态不信任用户态，需要进行验证)</li>
<li>内核态映射到用户态的地址空间(内核态产生的数据需要拷贝回用户态)</li>
<li>内核态独立地址空间(TLB)</li>
</ul>
<p>这些开销都是值得的，它们保证了OS的操作安全、可靠！</p>
<h2 id="Chapter3-连续式内存分配"><a href="#Chapter3-连续式内存分配" class="headerlink" title="Chapter3 连续式内存分配"></a>Chapter3 连续式内存分配</h2><h3 id="计算机体系结构及内存分层体系"><a href="#计算机体系结构及内存分层体系" class="headerlink" title="计算机体系结构及内存分层体系"></a>计算机体系结构及内存分层体系</h3><p>分层……计组里都学过</p>
<h4 id="操作系统的内存管理方面的四个目标"><a href="#操作系统的内存管理方面的四个目标" class="headerlink" title="操作系统的内存管理方面的四个目标"></a>操作系统的内存管理方面的四个目标</h4><ul>
<li>抽象<ul>
<li>逻辑地址空间</li>
</ul>
</li>
<li>保护<ul>
<li>独立地址空间</li>
</ul>
</li>
<li>共享<ul>
<li>访问相同内存</li>
</ul>
</li>
<li>虚拟化<ul>
<li>更多的地址空间</li>
</ul>
</li>
</ul>
<h3 id="地址空间与地址生成"><a href="#地址空间与地址生成" class="headerlink" title="地址空间与地址生成"></a>地址空间与地址生成</h3><h4 id="1-地址空间定义"><a href="#1-地址空间定义" class="headerlink" title="1.地址空间定义"></a>1.地址空间定义</h4><p>​	物理地址空间：硬件支持的地址空间</p>
<p>​	逻辑地址空间：一个运行的程序所拥有的内存范围</p>
<h4 id="2-地址生成"><a href="#2-地址生成" class="headerlink" title="2.地址生成"></a>2.地址生成</h4><p>​	逻辑地址生成：从变量的符号，通过一系列操作(编译、汇编、链接、载入)变为逻辑地址</p>
<p>​	物理地址生成：已知逻辑地址，通过硬件MMU将逻辑地址映射到物理地址</p>
<h4 id="3-地址安全检查"><a href="#3-地址安全检查" class="headerlink" title="3.地址安全检查"></a>3.地址安全检查</h4><p>​	OS记录每一个程序能够访问的地址空间(开始位置和大小)</p>
<p>​	这个表由OS维护，CPU要执行某个程序时，OS检查该程序的地址是否满足表中的限制(不与已占用空间冲突)，能满足则正常执行；否则CPU产生内存访问异常，让OS进行进一步处理。</p>
<h3 id="连续内存分配：内存碎片与分区的动态分配"><a href="#连续内存分配：内存碎片与分区的动态分配" class="headerlink" title="连续内存分配：内存碎片与分区的动态分配"></a>连续内存分配：内存碎片与分区的动态分配</h3><h4 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h4><p>空闲内存不能被利用</p>
<ul>
<li>外部碎片</li>
</ul>
<p>在**分配单元<u>间</u>**的未使用内存</p>
<ul>
<li>内部碎片</li>
</ul>
<p>在**分配单元<u>中</u>**的未使用内存</p>
<h4 id="分区的动态分配"><a href="#分区的动态分配" class="headerlink" title="分区的动态分配"></a>分区的动态分配</h4><h5 id="常见分配策略"><a href="#常见分配策略" class="headerlink" title="常见分配策略"></a>常见分配策略</h5><h6 id="第一适配"><a href="#第一适配" class="headerlink" title="第一适配"></a>第一适配</h6><p>​		放在<strong>第一个</strong>能够满足需求的空闲块中</p>
<p>​	<strong>简单实现：</strong></p>
<ul>
<li>对空闲块列表按地址排序</li>
<li>分配到第一个合适的分区</li>
<li>回收时进行检查，看看自由分区能不能与相邻的空闲分区合并	<ul>
<li>缺点：产生外部碎片、不确定性</li>
</ul>
</li>
</ul>
<h6 id="最佳适配"><a href="#最佳适配" class="headerlink" title="最佳适配"></a>最佳适配</h6><p>​		在能放下空闲块的分区中，寻找<strong>最小</strong>的分区（避免了分割大空闲块，为了最小化外部碎片产生的尺寸）</p>
<p>​		<strong>简单实现：</strong></p>
<ul>
<li>按尺寸排列空闲块列表</li>
<li>分配时需要寻找最合适的分区</li>
<li>回收时进行检查，看看自由分区能不能与相邻的空闲分区合并	<ul>
<li>优势：当大部分分配是小尺寸时十分有效</li>
<li>劣势：会产生外部碎片，重分配(回收)慢，容易产生很多很小的内部碎片</li>
</ul>
</li>
</ul>
<p>	</p>
<h6 id="最差适配"><a href="#最差适配" class="headerlink" title="最差适配"></a>最差适配</h6><p>​		在能放下空闲块的分区中，寻找<strong>最大</strong>的分区（为了避免有太多微小的碎片）</p>
<p>​		<strong>简单实现：</strong></p>
<ul>
<li>按尺寸排列空闲块列表(从大到小)</li>
<li>分配时需要寻找最合适的分区(找最大的，所以找非常快)</li>
<li>回收时进行检查，看看自由分区能不能与相邻的空闲分区合并	<ul>
<li>优势：分配中等大小的块效果最好</li>
<li>劣势：重分配慢、外部碎片、每次都使用大空闲块可能导致大分区无法被分配</li>
</ul>
</li>
</ul>
<h4 id="压缩式碎片整理"><a href="#压缩式碎片整理" class="headerlink" title="压缩式碎片整理"></a>压缩式碎片整理</h4><p>​	在程序处于等待状态时，将其进行移动，从而消除外部碎片————目的是消除外部碎片</p>
<h4 id="交换式碎片整理"><a href="#交换式碎片整理" class="headerlink" title="交换式碎片整理"></a>交换式碎片整理</h4><p>​	如果运行中的程序需要比较大的内存空间，那么可以让它<u>抢占等待中的程序的内存空间(</u>先将占用了内存空间的等待中的程序转存到硬盘中)</p>
<p>​		问题：将哪个等待中的程序换出呢？什么时候执行换入、换出的操作呢？</p>
<h2 id="Chapter4-非连续式内存分配"><a href="#Chapter4-非连续式内存分配" class="headerlink" title="Chapter4 非连续式内存分配"></a>Chapter4 非连续式内存分配</h2><h3 id="连续内存分配的缺点："><a href="#连续内存分配的缺点：" class="headerlink" title="连续内存分配的缺点："></a>连续内存分配的缺点：</h3><p>​	分配给一个程序的物理内存是连续的、内存利用率较低、有外、内部碎片的问题</p>
<h3 id="非连续内存分配的优点："><a href="#非连续内存分配的优点：" class="headerlink" title="非连续内存分配的优点："></a>非连续内存分配的优点：</h3><ul>
<li>更好的内存利用和管理</li>
<li>允许共享代码与数据</li>
<li>支持动态加载和动态链接</li>
</ul>
<h3 id="非连续内存分配的缺点："><a href="#非连续内存分配的缺点：" class="headerlink" title="非连续内存分配的缺点："></a>非连续内存分配的缺点：</h3><ul>
<li>如何建立虚拟地址与物理地址之间的联系<ul>
<li>硬件方案<ul>
<li>分段		(分段和分页的区别：段的大小可以改变、页的大小是固定的)	</li>
<li>分页</li>
</ul>
</li>
<li>软件方案(开销大，不展开讨论)</li>
</ul>
</li>
</ul>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><h4 id="程序的分段地址空间"><a href="#程序的分段地址空间" class="headerlink" title="程序的分段地址空间"></a>程序的分段地址空间</h4><p>​		有堆、栈、各种部分  逻辑空间是连续的，但实际上物理地址空间毫无关联(跟分配策略有关)</p>
<h4 id="分段寻址方案"><a href="#分段寻址方案" class="headerlink" title="分段寻址方案"></a>分段寻址方案</h4><h5 id="段访问机制："><a href="#段访问机制：" class="headerlink" title="段访问机制："></a>段访问机制：</h5><p>​			s + addr （段号 + 段内偏移）	多地址空间</p>
<p>​			s与addr一起存 							单地址空间</p>
<p>​			s通过 <strong>segment table(段表)</strong> 根据段号 查询 段所对应的物理地址，再加上偏移量就 &#x3D; 物理地址		段表由OS建立	</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><ul>
<li>逻辑空间：页	物理页面：帧</li>
<li>物理内存被分成大小相同的帧</li>
</ul>
<p>一个程序的逻辑地址空间被划分为大小相等的页</p>
<p>​			<strong>🌟(页内偏移大小&#x3D;帧内偏移大小；页号大小 !&#x3D; 帧号大小{在页表中，通过页号得到帧号})</strong></p>
<ul>
<li>页映射到帧</li>
<li>页是连续的虚拟内存</li>
<li>帧是非连续的物理内存</li>
<li>不是所有的页都有对应的帧</li>
</ul>
<h4 id="分页地址空间"><a href="#分页地址空间" class="headerlink" title="分页地址空间"></a>分页地址空间</h4><p>​		帧的物理地址&#x3D;帧号 + 帧内偏移</p>
<h4 id="页寻址方案——页表"><a href="#页寻址方案——页表" class="headerlink" title="页寻址方案——页表"></a>页寻址方案——页表</h4><h5 id="分页机制性能问题："><a href="#分页机制性能问题：" class="headerlink" title="分页机制性能问题："></a>分页机制性能问题：</h5><h6 id="访问一个内存单元需要2次内存访问"><a href="#访问一个内存单元需要2次内存访问" class="headerlink" title="访问一个内存单元需要2次内存访问"></a>访问一个内存单元需要2次内存访问</h6><p>​        	1.用于获取页表项</p>
<p>​			2.根据获得的页表项访问数据</p>
<h6 id="页表可能非常大"><a href="#页表可能非常大" class="headerlink" title="页表可能非常大"></a>页表可能非常大</h6><h5 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h5><h6 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h6><p>​			TLB：缓存近期访问的页-帧转换表项(TLB存于Cache中)</p>
<h6 id="间接访问"><a href="#间接访问" class="headerlink" title="间接访问"></a>间接访问</h6><p>​			二级、多级页表：多次寻址速度降低，但是缩减了页表(时间换空间，但是可以通过TLB提速！)</p>
<h6 id="反向页表-说实话没听明白，先挖个坑，回顾时填上"><a href="#反向页表-说实话没听明白，先挖个坑，回顾时填上" class="headerlink" title="反向页表(说实话没听明白，先挖个坑，回顾时填上)"></a><u>反向</u>页表(说实话没听明白，先挖个坑，回顾时填上)</h6><p>​		程序的地址空间很大时，逻辑地址空间会大于内存的物理地址空间</p>
<p>​		这时 我们<u>不是让页表与逻辑地址空间的大小相对应</u>，而是<strong>让页表与物理地址空间的大小相对应</strong></p>
<p>​		利：</p>
<ul>
<li><p>转换表的大小相对于物理内存来说很小</p>
</li>
<li><p>转换表的大小跟逻辑地址空间的大小无关</p>
<p>弊：</p>
</li>
<li><p>需要的信息对调了，即现在只能根据帧号找到页号</p>
</li>
<li><p>如何转换回来？即如何根据页号找到帧号？</p>
</li>
<li><p>需要在反向页表中搜索想要的页号</p>
</li>
</ul>
<p>	</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*如何实现呢？</span></span><br><span class="line"><span class="comment">*		对页号做hash计算，为了在“帧表”中获取对应的帧号</span></span><br><span class="line"><span class="comment">*		页i被放置在“帧表”中f(i)的位置 #f为hash函数</span></span><br><span class="line"><span class="comment">*			为了查找页i，执行以下操作：</span></span><br><span class="line"><span class="comment">*				对于页i，计算f(i)并使用它作为页寄存器表的索引，获取对应的页寄存器</span></span><br><span class="line"><span class="comment">*				检查寄存器标签是否包含i，如果包含，则代表成功获取帧号，否则失败。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="Chapter5-虚拟内存"><a href="#Chapter5-虚拟内存" class="headerlink" title="Chapter5 虚拟内存"></a>Chapter5 虚拟内存</h2><h3 id="覆盖技术："><a href="#覆盖技术：" class="headerlink" title="覆盖技术："></a>覆盖技术：</h3><p>​			为了在较小的内存中运行较大的程序，常用于多道程序系统，与分区存储管理配合使用</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h4><p>目标：把程序按照其自身逻辑结构，划分为若干个功能上相对独立的程序模块那些不会同时执行的模块共享同一块内存区域，按时间先后来运行。</p>
<ul>
<li><p>必要部分 (常用功能)的代码和数据<strong>常驻内存</strong></p>
</li>
<li><p>可选部分(不常用功能)在其他程序模块中实现,<u><em>平时存放在外存中，在需要用到时才装入内存</em></u>;</p>
<ul>
<li>不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖,即这些模块共用一个分区。</li>
</ul>
</li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>程序的划分复杂，费时费力</li>
<li>经常性的从外存读取数据，实际上是时间换空间</li>
<li>需要程序员自己把整个程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，增加了程序员的负担;</li>
</ul>
<h3 id="交换技术："><a href="#交换技术：" class="headerlink" title="交换技术："></a>交换技术：</h3><p>​		多道程序在内存中时,让正在运行的程序或需要运行的程序获得更多的内存资源。</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理:"></a>原理:</h4><ul>
<li>​	可将暂时不能运行的程序送到外存，从而获得空闲内存空间。</li>
<li>​	操作系统把一个进程的整个地址空间的内容保存到外存中(换出swap out)，而将外存中的某个进程的地址空间读入到内存中(换入swap in)。换入换出内容的大小为整个程序的地址空间。</li>
</ul>
<p>	</p>
<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><ul>
<li>何时交换？<ul>
<li>只有当内存不够或者有不够的风险时进行交换</li>
</ul>
</li>
<li>交换区的大小<ul>
<li>必须足够存放用户进程中所有内存映像的拷贝</li>
<li>必须能对这些内存映像进行直接存取</li>
</ul>
</li>
<li>交换技术:以进程作为交换的单位，需要把进程的整个地址空间都换进换出，增加了处理器的开销。</li>
</ul>
<h3 id="覆盖与交换的比较："><a href="#覆盖与交换的比较：" class="headerlink" title="覆盖与交换的比较："></a>覆盖与交换的比较：</h3><p><strong>覆盖技术</strong>只能发生在那些相互之间没有调用关系的程序模块之间。因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构。(移动的最小粒度为一个程序)</p>
<p><strong>交换技术</strong>是以在内存中的程序大小为单位来进行的，它不需要程序员给出各个模块之间的逻辑覆盖结构。(移动的最小粒度为程序的一个子模块)</p>
<p>换言之，交换发生在内存中程序与管理程序或操作系统之间，而覆盖则发生在运行程序的内部。</p>
<h3 id="虚存技术："><a href="#虚存技术：" class="headerlink" title="虚存技术："></a>虚存技术：</h3><p>像覆盖技术那样，<u>不是把程序的所有内容都放在内存中</u>，因而能够运行比当前的空闲内存空间还要大的程序。但做得更好，由<u>操作系统自动来完成，无须程序员的干涉;</u></p>
<p>像交换技术那样，能够实现进程在内存与外存之间的交换，因而获得更多的空闲内存空间。但做得更好，<u>只对进程的部分内容在内存和外存之间进行交换。</u></p>
<h4 id="程序的局部性原理-principle-of-locality"><a href="#程序的局部性原理-principle-of-locality" class="headerlink" title="程序的局部性原理(principle of locality):"></a>程序的局部性原理(principle of locality):</h4><p>​	指程序在执行过程中的<strong>一个较短时期</strong>，所执行的指令地址和指令的操作数地址，分别<strong>局限于一定区域</strong>。这可以表现为:</p>
<ul>
<li><u>时间局部性</u>:一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内;</li>
<li><u>空间局部性</u>:当前指令和邻近的几条指令，当前访问的数据和邻近的几个数据都集中在一个较小区域内。</li>
</ul>
<p>程序的局部性原理表明，从理论上来说，虚拟存储技术是能够实现的，而且在实现了以后应该是能够取得一个满意的效果的。</p>
<h4 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h4><p>​	可以在页式或段式内存管理的基础上实现</p>
<ul>
<li><p>在装入程序时，不必将其全部装入到内存，而只需将当前需要执行的部分页面或段装入到内存，就可让程序开始执行；</p>
</li>
<li><p>在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序；</p>
</li>
<li><p>另一方面，操作系统将内存中暂时不使用的页面或段调出保存在外存上，从而腾出更多空闲空间存放将要装入的程序以及将要调入的页面或段。</p>
</li>
</ul>
<h4 id="基本特征："><a href="#基本特征：" class="headerlink" title="基本特征："></a>基本特征：</h4><ul>
<li><p>大的用户空间：通过把物理内存与外存相结合，提供给用户的虚拟内存空间通常大于实际的物理内存，即实现了这两者的分离。如32位的虚拟地址理论上可以访问4GB，而可能计算机上仅 有256M的物理内存，但硬盘容量大于4GB。</p>
</li>
<li><p>部分交换：与交换技术相比较，虚拟存储的调入和调出是对部分虛拟地址空间进行的：</p>
</li>
<li><p>不连续性：物理内存分配的不连续，虚拟地址空间使用的不连续。</p>
</li>
</ul>
<h4 id="虚拟页式内存管理："><a href="#虚拟页式内存管理：" class="headerlink" title="虚拟页式内存管理："></a>虚拟页式内存管理：</h4><ul>
<li><p>大部分虚拟存储系统都采用虚拟页式存储管理技术，即在<strong>页式存储管理</strong>的基础上，<strong>增加</strong><u>请求调页和页面置换功能</u>。</p>
</li>
<li><p>基本思路：</p>
<ul>
<li>当一个用户程序要调入内存运行时，<u>不是将该程序的所有页面都装入内存，而是只装入部分的页面</u>，就可启动程序运行。</li>
<li>在运行的过程中，如果发现要运行的程序或要访问数据<u>不在内存，则向系统发出缺页中断请求</u>，系统在处理这个中断时，将外存中相应的页面调入内存，使得该程序能够继续运行。</li>
</ul>
</li>
</ul>
<h5 id="页表表项需要增加："><a href="#页表表项需要增加：" class="headerlink" title="页表表项需要增加："></a>页表表项需要增加：</h5><ol>
<li><strong>驻留位：1表示该页在内存中；0表示在外存中</strong></li>
<li><strong>保护位</strong>：表示允许对该页做何种类型的访问，如只读、可读写、可执行等</li>
<li><strong>修改位</strong>：表明此页在内存中是否被修改过。若修改过，在回收此页时需要把这个页的内容同步到外存。</li>
<li><strong>访问位</strong>：如果最近被访问过，置为1；用于页面置换算法</li>
</ol>
<h5 id="缺页中断处理过程："><a href="#缺页中断处理过程：" class="headerlink" title="缺页中断处理过程："></a>缺页中断处理过程：</h5><ol>
<li><p>如果在内存中有空闲的物理页面，则分配一物理页帧f，然后转第4步：否则转第2步：</p>
</li>
<li><p>采用某种页面置换算法，选择一个将被替换的物理页帧f，它所对应的逻辑页为q。如果该页在内存期间被修改过，则需把它写回外存；</p>
</li>
<li><p>对q所对应的页表项进行修改，把驻留位置为0；</p>
</li>
<li><p>将需要访问的页p裝入到物理页面f当中；</p>
</li>
<li><p>修改p所对应的页表项的内容，把驻留位置为1，把物理页帧号置为f</p>
</li>
<li><p>重新运行被中断的指令。</p>
</li>
</ol>
<h5 id="后备存储-Backing-Store"><a href="#后备存储-Backing-Store" class="headerlink" title="后备存储 Backing Store"></a>后备存储 Backing Store</h5><h6 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h6><ul>
<li><p>一个虚拟地址空间的页面可以被映射到一个文件（在二级存储中）中的某个位置</p>
</li>
<li><p>代码段：映射到可执行二进制文件</p>
</li>
<li><p>动态加载的共享库程序段：映射到动态调用的库文件</p>
</li>
<li><p>其它段：可能被映射到交换文件(swap file)</p>
</li>
</ul>
<p>​	在何处保存未被映射的页？</p>
<ul>
<li><p>能够简单地识别在二级存储器中的页</p>
</li>
<li><p>交换空间（磁盘或者文件）：特殊格式，用于存储末被映射的页面</p>
</li>
</ul>
<h2 id="Chapter6-页面置换算法"><a href="#Chapter6-页面置换算法" class="headerlink" title="Chapter6 页面置换算法"></a>Chapter6 页面置换算法</h2><h3 id="局部页面置换算法"><a href="#局部页面置换算法" class="headerlink" title="局部页面置换算法"></a>局部页面置换算法</h3><h4 id="功能与目标"><a href="#功能与目标" class="headerlink" title="功能与目标"></a>功能与目标</h4><p><strong>功能</strong>：缺页，但主存满了，换谁出去？</p>
<p><strong>目标</strong>：<strong>尽可能减少页面更换的次数</strong>，(通常在局部性原理指导下依据过去的统计数据进行预测)</p>
<p>&lt;页面锁定&gt;:有些页面必须常驻于内存中，不应参与页面置换算法。(通过在页表中添加 ‘锁定标志位,lock bit’ 判断)</p>
<h4 id="6-1最优页面置换算法"><a href="#6-1最优页面置换算法" class="headerlink" title="6.1最优页面置换算法"></a>6.1最优页面置换算法</h4><p>​	是一种理想情况下的页面置换算法, 该算法使用的前提是OS提前知道接下来要访问的页面，换出近期最不会被用到的页面。</p>
<p>无实际意义，但可以用于评价别的算法的性能，作为一个理想的标杆</p>
<h4 id="6-2FIFO算法"><a href="#6-2FIFO算法" class="headerlink" title="6.2FIFO算法"></a>6.2FIFO算法</h4><p>系统维护一个页面的链表，<strong>每次淘汰驻留时间最长的页面</strong>(一个已经在链表中的页面再次被使用并不会刷新该页面的驻留时间，而是继续按原来的计时)</p>
<p><strong>性能较差</strong>，调出的页面可能是经常被调用的页面，并且有**<u><em>Belady现象</em></u>**</p>
<h4 id="6-3最近最久未使用算法-LRU"><a href="#6-3最近最久未使用算法-LRU" class="headerlink" title="6.3最近最久未使用算法(LRU)"></a>6.3最近最久未使用算法(LRU)</h4><p>当缺页中断发生时，选择淘汰最久未使用的页面（根据历史，推测未来，依据程序的访问具有局部性</p>
<p>​	LRU算法需要记录每个页面使用时间的先后顺序，<u><strong>开销比较大</strong></u></p>
<p>两种可能的实现方法：</p>
<ul>
<li>维护一个链表，运行新页面：则放在链表头；运行链表中出现过的页面：将该结点移动到链表头部；若要淘汰页面，则删除队尾的页面。</li>
<li>维护一个栈，刚使用的页面放在栈顶，如果栈中已经有该页面则还需要将栈中记录删去，若要淘汰页面，则删除栈底部的页面(ps:没啥区别啊)</li>
</ul>
<h4 id="6-4时钟页面置换算法"><a href="#6-4时钟页面置换算法" class="headerlink" title="6.4时钟页面置换算法"></a>6.4时钟页面置换算法</h4><ul>
<li>clock页面置换算法，LRU的近似，是对FIFO的一种改进：</li>
</ul>
<h5 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h5><ul>
<li><p>﻿﻿需要用到页表项当中的访问位，当一个页面被装入内存时，把该位初始化为0。然后如果这个页面被访问（读&#x2F;写)，则把该位置为1;</p>
</li>
<li><p>﻿把各个页面组织成环形链表（类似钟表面），把指针指向最老的页面（最<br> 先进来）；</p>
</li>
<li><p>当发生一个缺页中断时，考察指针所指向的最老页面，若它的访问位为0，立即淘汰：若访问位为1，则把该位置为0，然后指针往下移动一格。如此下去，直到找到被淘汰的页面，然后把指针移动到它的下一格。</p>
</li>
</ul>
<h4 id="6-5二次机会法"><a href="#6-5二次机会法" class="headerlink" title="6.5二次机会法"></a>6.5二次机会法</h4><p><strong>添加脏位</strong>(用于标识有没有被写过)，如果被淘汰的页只被读过，则直接删除；如果该页面被修改过，就需要将更新的数据同步至硬盘。</p>
<p>用访问位、脏位两个位来判断被淘汰的页面，只有都为0的页面才会立即被淘汰，有1的页面会首先失去一个1，幸免于本轮循环。(脏位由1变0时，也需要写回硬盘)</p>
<p>给修改过的页面更多的机会留在主存中(<u>其实只针对一种情况：访问位、脏位都为1时，页面被循环轮到后会先把访问位置为0，而不是改变脏位，这样就相当于给这个页面多一条命！</u>)——通过减少写回硬盘的次数来降低开销</p>
<h4 id="6-6最不常用法"><a href="#6-6最不常用法" class="headerlink" title="6.6最不常用法"></a>6.6最不常用法</h4><p>Least frequency used LFU:</p>
<h5 id="基本思路：-1"><a href="#基本思路：-1" class="headerlink" title="基本思路："></a>基本思路：</h5><p>​	当一个缺页中断产生时，选择被访问次数最少的页面淘汰</p>
<p>​	给主存中的每个页都安排一个计数器，淘汰计数器值最小的页面</p>
<p>缺点：计数器开销大</p>
<h4 id="6-7Belady现象"><a href="#6-7Belady现象" class="headerlink" title="6.7Belady现象"></a>6.7Belady现象</h4><p>​	在采用FIFO算法时，有时会出现分配的物理页面数增加，缺页率反而提高的现象；</p>
<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230605214433150.png" alt="image-20230605214433150" style="zoom:30%;" />

<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230605214507498.png" alt="image-20230605214507498" style="zoom:31%;" />

<h4 id="6-8局部页面替换算法的问题、工作集模型"><a href="#6-8局部页面替换算法的问题、工作集模型" class="headerlink" title="6.8局部页面替换算法的问题、工作集模型"></a>6.8局部页面替换算法的问题、工作集模型</h4><p><strong>工作集：一个进程当前正在使用的逻辑页面集合，可以用一个二元函数w(t，∆)来表示</strong></p>
<ul>
<li><p>t是当前的执行时刻；</p>
</li>
<li><p>∆称为工作集窗口 (working set window），即一个定长的页面访问的时同窗口：</p>
</li>
<li><p>w(t，∆)一在当前时刻 t 之前的 ∆时间窗口当中的所有页面所组成的集合(随着 t 的变化，该集合也在不断地变化）</p>
</li>
<li><p>|w(t，∆）|指工作集的大小，即页面数目。</p>
</li>
</ul>
<p><strong>常驻集：是指在当前时刻，进程实际驻留在内存当中的页面集合。</strong></p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ol>
<li><p>工作集是进程在运行过程中固有的性质，而常驻集取决于系统分配给进程的物理页面数日，以及所采用的页面置换算法；</p>
</li>
<li><p>如果一个进程的整个工作集都在内存当中，即常驻集&gt;&#x3D;工作集，那么进程将很顺利地运行，而不会造成太多的缺页中断（直到工作集发生剧烈变动，从而过渡到另一个状态）</p>
</li>
<li><p>当进程常驻集的大小达到某个数目之后，再给它分配更多的物理页面，缺页率也不会明显下降。</p>
</li>
</ol>
<h3 id="全局页面置换算法："><a href="#全局页面置换算法：" class="headerlink" title="全局页面置换算法："></a>全局页面置换算法：</h3><h4 id="1-工作集页面置换算法"><a href="#1-工作集页面置换算法" class="headerlink" title="1.工作集页面置换算法"></a>1.工作集页面置换算法</h4><p>​	如果页面不在工作集中，那么即使没有发生缺页中断，也会把该页面换出。</p>
<p>​	每次都看看自己的常驻集和工作集，常驻集里有，但工作集中没有的页面都会被移除</p>
<h4 id="2-缺页率页面置换算法"><a href="#2-缺页率页面置换算法" class="headerlink" title="2.缺页率页面置换算法"></a>2.缺页率页面置换算法</h4><h5 id="可变分配策路："><a href="#可变分配策路：" class="headerlink" title="可变分配策路："></a>可变分配策路：</h5><p>​	常驻集大小可变，例如：每个进程在刚开始运行的时候，先根据程序大小给它分配一定数目的物理页面，然后在进程运行过程中，再<u>动态地调整常驻集的大小</u>。</p>
<ul>
<li>可采用全局页面置换的方式。当发生一个缺页中断时，被置换的页面可以是在其它进程当中，各个并发进程竞争地使用物理页面。</li>
<li>优缺点：性能较好。但增加了系统开销。</li>
<li>具体实现：可以使用<strong>缺页率算法</strong> (PPF, page fault freguency)来动态调整常驻集的大小。</li>
</ul>
<p><strong>🌟如何动态地调整常驻集的大小？</strong></p>
<p>​	设置一个阈值k，将本次发生缺页的下标 - 上次发生缺页的下标 与 k 进行比较，</p>
<ul>
<li><p>如果k比较大，说明中断异常出现的太频繁了，直接将缺失页加入到工作集中(扩大工作集，降低缺页概率)</p>
</li>
<li><p>如果k比较小，说明不怎么出现中断，那么执行下述操作：将工作集中不在[t_last, t_current]区间内出现的页面移除   (t_last, t_current指上一次、这次出现中断异常的时间下标)</p>
</li>
</ul>
<h3 id="抖动问题："><a href="#抖动问题：" class="headerlink" title="抖动问题："></a>抖动问题：</h3><ul>
<li>﻿如果分配给一个进程的物理页面太少，不能包含整个的工作集，即常驻集＜ 工作集，那么进程将会造成很多的缺页中断，需要频繁地在内存与外存之间替换页面，从而使进程的运行速度变得很慢，我们把这种狀态称为 “抖动”。</li>
<li>﻿产生抖动的原因：随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减小，导致缺页率不断上升。所以<strong>os要选择一个适当的进程数目和进程需要的帧数</strong>，以便在并发水平和缺页率之间达到一个平衡。</li>
</ul>
<p>抖动问题在一些情况下可以被本地的页面置换算法改善</p>
<h2 id="Chapter7-进程和线程"><a href="#Chapter7-进程和线程" class="headerlink" title="Chapter7 进程和线程"></a>Chapter7 进程和线程</h2><h3 id="7-1进程-process-的描述"><a href="#7-1进程-process-的描述" class="headerlink" title="7.1进程(process)的描述"></a>7.1进程(process)的描述</h3><h4 id="进程定义："><a href="#进程定义：" class="headerlink" title="进程定义："></a>进程定义：</h4><p>​	一个具有一定功能的程序在一个数据集合上的一次动态执行的过程</p>
<h4 id="进程组成："><a href="#进程组成：" class="headerlink" title="进程组成："></a>进程组成：</h4><p>包含了一个正在运行的程序的所有状态信息</p>
<pre><code>        1. 程序的代码
        1. 程序处理的数据
        1. 程序计数器的值，指示下一条即将运行的指令
        1. 一组通用的寄存器的当前值，堆、栈
        1. 一组系统资源(如打开的程序)
</code></pre>
<h5 id="进程与程序的联系："><a href="#进程与程序的联系：" class="headerlink" title="进程与程序的联系："></a>进程与程序的联系：</h5><ul>
<li>﻿程序是产生进程的基础</li>
<li>﻿<u>程序的每次运行构成不同的进程</u></li>
<li>﻿进程是程序功能的体现</li>
<li>﻿通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序。</li>
</ul>
<h5 id="进程与程序的区别："><a href="#进程与程序的区别：" class="headerlink" title="进程与程序的区别："></a>进程与程序的区别：</h5><ul>
<li><p>进程是动态的，程序是静态的：程序是有序代码的集合；进程是程序的执行，进程有核心态&#x2F;用户态</p>
</li>
<li><p>进程是暂时的，程序的永久的：进程是一个状态变化的过程，程序可长久保存</p>
</li>
<li><p>进程与程序的组成不同：进程的组成包括**<u>程序、数据和进程控制块</u>**（即进程状态信息）</p>
</li>
</ul>
<h4 id="进程的特点："><a href="#进程的特点：" class="headerlink" title="进程的特点："></a>进程的特点：</h4><ul>
<li>﻿动态性：可动态地创建、结束进程；</li>
<li>﻿并发性：进程可以被独立调度并占用处理机运行；(并发-&gt;串、并行-&gt;并)</li>
<li>﻿独立性：不同进程的工作不相互影响：</li>
<li>﻿制约性：因访问共享数据&#x2F;资源或进程间同步而产生制约。</li>
</ul>
<h4 id="进程控制结构："><a href="#进程控制结构：" class="headerlink" title="进程控制结构："></a>进程控制结构：</h4><p>​	程序 &#x3D; 算法 + 数据结构</p>
<p>​	描述进程的数据结构：<strong>进程控制块</strong>(Process Control Block, PCB)</p>
<p>进程控制块：OS管理进程运行所用信息的集合，OS用PCB描述<u>进程的基本情况及运行变化的过程</u>，PCB是进程存在的<strong>唯一标志。</strong></p>
<h5 id="PCB中包含的内容："><a href="#PCB中包含的内容：" class="headerlink" title="PCB中包含的内容："></a>PCB中包含的内容：</h5><ol>
<li><p><strong>进程标识信息</strong>。如本进程的标识，本进程的产生者标识(父进程标识)；用户标识。</p>
</li>
<li><p><strong>处理机状态信息保存区</strong>。保存进程的运行现场信息：</p>
<ul>
<li><p>﻿用户可见寄存器，用户程序可以使用的数据，地址等寄存器。</p>
</li>
<li><p>﻿控制和状态寄存器，如程序计数器(PC)，程序状态字 (PSW)。</p>
</li>
<li><p>﻿栈指针，过程调用&#x2F;系统调用&#x2F;中断处理和返回时需要用到它。</p>
</li>
</ul>
</li>
<li><p><strong>进程控制信息</strong></p>
</li>
</ol>
<ul>
<li><p>调度和状态信息，用于操作系统调度进程并占用处理机使用。</p>
</li>
<li><p>进程间通信信息，为支持进程问的与通信相关的各种标识、信号、信件等，这些信息存在接收方的进程控制块中。</p>
</li>
<li><p>存储管理信息，包含有指向本进程映像存储空间的数据结构。</p>
</li>
<li><p>﻿进程所用资源，说明由进程打开、使用的系统资源，如打开的文件等。</p>
</li>
<li><p>﻿有关数据结构连接信息，进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB。</p>
</li>
</ul>
<h5 id="PCB的组织方式"><a href="#PCB的组织方式" class="headerlink" title="PCB的组织方式"></a>PCB的组织方式</h5><ul>
<li>链表(常用)：同一状态的进程其PCB成一链表，多个状态对应多个不同的链表</li>
</ul>
<p>各状态的进程形成不同的链表：就绪链表、阻塞链表</p>
<ul>
<li>索引表：同一状态的进程归入一个index表（由index指向PCB)，多个状态对应多个不同的index表</li>
</ul>
<p>各状态的进行形成不同的索引表：就绪索引表、阻塞索引表</p>
<h3 id="7-2进程状态"><a href="#7-2进程状态" class="headerlink" title="7.2进程状态"></a>7.2进程状态</h3><h4 id="进程生命周期管理"><a href="#进程生命周期管理" class="headerlink" title="进程生命周期管理"></a>进程生命周期管理</h4><h5 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h5><h6 id="引起进程创建的三个主要事件："><a href="#引起进程创建的三个主要事件：" class="headerlink" title="引起进程创建的三个主要事件："></a>引起进程创建的三个主要事件：</h6><pre><code>    1. 系统初始化时(创建init进程)	
    2. **用户请求**创建一个新进程
    3. 正在运行的**进程执行**了创建进程的系统调用
</code></pre>
<h5 id="进程运行"><a href="#进程运行" class="headerlink" title="进程运行"></a>进程运行</h5><h6 id="内核选择一个就绪的进程，让它占用处理机并执行"><a href="#内核选择一个就绪的进程，让它占用处理机并执行" class="headerlink" title="内核选择一个就绪的进程，让它占用处理机并执行"></a>内核选择一个就绪的进程<strong>，让它占用处理机</strong>并执行</h6><h5 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h5><h6 id="以下情况下，进程等待："><a href="#以下情况下，进程等待：" class="headerlink" title="以下情况下，进程等待："></a>以下情况下，进程等待：</h6><ol>
<li>﻿<strong>请求并等待系统服务</strong>，无法马上完成</li>
<li>﻿<strong>启动某种操作</strong>，无法马上完成</li>
<li>﻿<strong>需要的数据没有到达</strong></li>
</ol>
<p><u>进程只能自己阻塞自己，因为只有进程自身才能知道何时需要等待某种事件的发生。</u></p>
<h5 id="进程唤醒"><a href="#进程唤醒" class="headerlink" title="进程唤醒"></a>进程唤醒</h5><h6 id="唤醒进程的原因："><a href="#唤醒进程的原因：" class="headerlink" title="唤醒进程的原因："></a>唤醒进程的原因：</h6><ol>
<li>﻿被阻塞进程需要的资源可被满足</li>
<li>﻿被阻塞进程等待的事件到达</li>
<li>﻿将该进程的PCB插入到就绪队列</li>
</ol>
<p><u>进程只能被别的进程或操作系统唤醒。</u></p>
<h5 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h5><h6 id="在以下四种情形下，进程结束："><a href="#在以下四种情形下，进程结束：" class="headerlink" title="在以下四种情形下，进程结束："></a>在以下四种情形下，进程结束：</h6><ul>
<li><p>正常退出（自愿的）</p>
</li>
<li><p>错误退出（自愿的）</p>
</li>
<li><p>致命错误（强制性的）</p>
</li>
<li><p>被其他进程所杀（强制性的）</p>
</li>
</ul>
<h4 id="进程状态变化模型"><a href="#进程状态变化模型" class="headerlink" title="进程状态变化模型"></a>进程状态变化模型</h4><h5 id="进程的三种基本状态："><a href="#进程的三种基本状态：" class="headerlink" title="进程的三种基本状态："></a>进程的三种<u>基本</u>状态：</h5><p>​	进程在生命结束前处于且仅处于三种基本状态之一</p>
<ul>
<li><p>运行状态(Running)：当一个进程正在处理机上运行时。</p>
</li>
<li><p>就绪状态(Ready)：一个进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。</p>
</li>
<li><p>等待状态（又称阻塞状态Blocked)：一个进程正在等待某一事件而暂停运行时。如等待某资源，等待输入&#x2F;输出完成。</p>
</li>
</ul>
<h5 id="进程其它的基本状态："><a href="#进程其它的基本状态：" class="headerlink" title="进程其它的基本状态："></a>进程其它的基本状态：</h5><ul>
<li><p>创建状态(New)：一个进程正在被创建，还没被转到就绪状态之前的状态。</p>
</li>
<li><p>结束状态(Exit)：一个进程正在从系统中消失时的状态，这是因为进程结束或由于其他原因所导致。</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230606110651191.png" alt="image-20230606110651191" style="zoom:50%;" />

<h4 id="进程挂起模型"><a href="#进程挂起模型" class="headerlink" title="进程挂起模型"></a>进程挂起模型</h4><p> 进程挂起：进程不占用内存空间，处于挂起状态的进程映像在磁盘上。</p>
<h5 id="挂起状态："><a href="#挂起状态：" class="headerlink" title="挂起状态："></a>挂起状态：</h5><ul>
<li>﻿阻塞挂起状态 (Blocked-suspend）：进程在外存并<strong>等待某事件的出现</strong>；</li>
<li>﻿就绪挂起状态 (Ready-suspend）：进程在外存，但<strong>只要进入内存，即可运行</strong>；</li>
</ul>
<h5 id="挂起-Suspend）：把一个进程从内存转到外存；可能有以下几种情况："><a href="#挂起-Suspend）：把一个进程从内存转到外存；可能有以下几种情况：" class="headerlink" title="挂起 (Suspend）：把一个进程从内存转到外存；可能有以下几种情况："></a>挂起 (Suspend）：把一个进程从内存转到外存；可能有以下几种情况：</h5><ul>
<li><p>﻿阻塞到阻塞挂起：没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以提交新进程或运行就绪进程；</p>
</li>
<li><p>﻿就绪到就绪挂起：当有高优先级阻塞(系统认为会很快就绪的）进程和低优先就绪进程时，系统会选择挂起低优先级就绪进程；</p>
</li>
<li><p>﻿运行到就绪挂起：对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态；</p>
</li>
</ul>
<h5 id="在外存时的状态转换："><a href="#在外存时的状态转换：" class="headerlink" title="在外存时的状态转换："></a>在外存时的状态转换：</h5><ul>
<li>﻿阻塞挂起到就绪挂起：当有阻塞挂起进程因相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程。</li>
</ul>
<h5 id="解挂-x2F-激活-Activate）：把一个进程从外存转到内存；可能有以下几种情况："><a href="#解挂-x2F-激活-Activate）：把一个进程从外存转到内存；可能有以下几种情况：" class="headerlink" title="解挂&#x2F;激活 (Activate）：把一个进程从外存转到内存；可能有以下几种情况："></a>解挂&#x2F;激活 (Activate）：把一个进程从外存转到内存；可能有以下几种情况：</h5><ul>
<li>﻿就绪挂起到就绪：没有就绪进程或挂起就绪进程优先级高于就绪进程时，会进行这种转换；</li>
<li>﻿阻塞挂起到阻塞：当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起（系统认为会很快出现所等待的事件）进程转换为阻塞进程；</li>
</ul>
<h5 id="OS如何通过PCB完成进程的调度？"><a href="#OS如何通过PCB完成进程的调度？" class="headerlink" title="OS如何通过PCB完成进程的调度？"></a>OS如何通过PCB完成进程的调度？</h5><h6 id="🌟状态队列"><a href="#🌟状态队列" class="headerlink" title="🌟状态队列"></a>🌟状态队列</h6><ul>
<li><p>﻿由操作系统来维护一组队列，用来表示系统当中所有进程的当前状态；</p>
</li>
<li><p>﻿<u><strong>不同的状态分别用不同的队列来表示</strong></u>(就绪队列、各种类型的阻塞队列）；</p>
</li>
<li><p>每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生变化时，它的PCB从一个状态队列中脱离出来，加入到另外一个队列。</p>
</li>
</ul>
<h3 id="7-3线程"><a href="#7-3线程" class="headerlink" title="7.3线程"></a>7.3线程</h3><h4 id="为什么需要线程？"><a href="#为什么需要线程？" class="headerlink" title="为什么需要线程？"></a>为什么需要线程？</h4><p>​	处理并行操作时，如果使用<strong>多进程</strong>方式，会导致开销巨大(进程占用资源、进程切换占用时间、进程共享数据产生开销)</p>
<p>​	因此，我们亟需提出一种实体，满足：1）实体之间可以并发运行；2）实体之间共享地址空间</p>
<p>​	于是 <strong>线程</strong> 被提出！</p>
<h4 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h4><p>​	＞<em>进程当中的一条执行流程。</em></p>
<p>从两个方面来重新理解进程</p>
<ul>
<li>﻿从资源组合的角度：<strong>进程</strong>把一组相关的资源组合起来，<strong>构成了一个资源平台（环境）</strong>，包括地址空间（代码段、数据段）、打开的文件等各种资源；</li>
<li>﻿从运行的角度：代码在这个资源平台上的一条执行流程（线程）。</li>
</ul>
<h5 id="线程的优点："><a href="#线程的优点：" class="headerlink" title="线程的优点："></a>线程的优点：</h5><ul>
<li>﻿一个进程中可以同时存在多个线程；</li>
<li>﻿各个线程之间可以并发地执行；</li>
<li>﻿各个线程之间可以共享地址空间和文件等资源。</li>
</ul>
<h5 id="线程的缺点："><a href="#线程的缺点：" class="headerlink" title="线程的缺点："></a>线程的缺点：</h5><ul>
<li><strong>一个线程崩溃，会导致其所属进程的所有线程崩溃</strong>。(因为线程间共享数据，因此一个线程的数据错误了，其他线程都要遭殃)</li>
</ul>
<h5 id="线程所需的资源："><a href="#线程所需的资源：" class="headerlink" title="线程所需的资源："></a>线程所需的资源：</h5><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230606161910704.png" alt="image-20230606161910704" style="zoom:50%;" />

<h5 id="线程与进程的比较"><a href="#线程与进程的比较" class="headerlink" title="线程与进程的比较"></a>线程与进程的比较</h5><ul>
<li><p>﻿进程是资源分配单位，线程是CPU调度单位；</p>
</li>
<li><p>﻿进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</p>
</li>
<li><p>﻿线程同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系；</p>
</li>
<li><p>﻿线程能减少并发执行的时间和空间开销：</p>
<ul>
<li><p>线程的创建时间比进程短；(线程无需创建代码块、数据、文件的管理信息)</p>
</li>
<li><p>线程的终止时间比进程短；(线程无需创建代码块、数据、文件的管理信息)</p>
</li>
<li><p>同一进程内的线程切换时间比进程短；(在同一进程中的线程具有同一个页表，切换时无需切换页表)</p>
</li>
<li><p>由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信；</p>
</li>
</ul>
</li>
</ul>
<h4 id="线程的实现："><a href="#线程的实现：" class="headerlink" title="线程的实现："></a>线程的实现：</h4><p>​	三种主要的实现方式：</p>
<pre><code> 1. 用户线程：在用户空间实现
 2. 内核线程：在内核中实现
 3. 轻量级线程：在内核中实现，支持用户线程
</code></pre>
<h5 id="🌟用户线程："><a href="#🌟用户线程：" class="headerlink" title="🌟用户线程："></a>🌟用户线程：</h5><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230606163157885.png" alt="image-20230606163157885" style="zoom:50%;" />

<p>OS看不到TCB，只能看到PCB，只知道进程信息，进程中的线程信息由线程库管理。</p>
<p>在用户空间实现的线程机制，它<strong>不依赖于操作系统的内核</strong>，<strong>由一组用户级的线程库函数来完成线程的管理</strong>，包括进程的创建、终止、同步和调度等。</p>
<h6 id="用户线程的优点："><a href="#用户线程的优点：" class="headerlink" title="用户线程的优点："></a>用户线程的优点：</h6><ul>
<li>﻿由于用户线程的维护由相应进程来完成 （通过线程库函数），不需要操作系统内核了解用户线程的存在，<u>可用于不支持线程技术的多进程操作系统；</u></li>
<li>﻿每个进程都需要它自己私有的线程控制块（TCB）列表，用来跟踪记录它的各个线程的状态信息 (PC、栈指针、寄存器），TCB由线程库函数来维护；</li>
<li>﻿用户线程的切换也是由线程库函数来完成．无需用户态&#x2F; 核心态切换，所以速度特别快；</li>
<li>﻿允许每个进程拥有自定义的线程调度算法。</li>
</ul>
<h6 id="用户线程的缺点："><a href="#用户线程的缺点：" class="headerlink" title="用户线程的缺点："></a>用户线程的缺点：</h6><ul>
<li>﻿阻塞性的系统调用如何实现？如果一个线程发起系统调用而阻塞，则整个进程在等待；(因为OS在内核态中只能管理进程，而不能单独地把进程中的某个线程阻塞)</li>
<li>﻿当一个线程开始运行后，除非它主动地交出CPU的使用权，否则它所在的进程当中的其他线程将无法运行；(同样，因为OS只能管理进程，因为只有OS有管理中断的权利，但是OS看不到线程)</li>
<li>﻿由于时间片分配给进程，故与其它进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢。</li>
</ul>
<h5 id="🌟内核线程："><a href="#🌟内核线程：" class="headerlink" title="🌟内核线程："></a>🌟内核线程：</h5><p>​	<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230606164400117.png" alt="image-20230606164400117" style="zoom:50%;" /></p>
<p><strong>TCB也放在内核中</strong></p>
<p>是指在操作系统<u>的内核当中实现的一种线程机制</u>，由操作系统的内核来完成线程的创建、终止和管理。</p>
<ul>
<li>﻿在支持内核线程的操作系统中，**<u>由内核来维护进程和线程的上下文信息 （PCB和TCB）</u>**；</li>
<li>﻿线程的创建、终止和切换都是通过系统调用&#x2F;内核函数的方式来进行，由内核来完成，因此系统开销较大；</li>
<li>在一个进程当中，如果某个内核线程发起系统调用而被阳塞，井不会影响其他内核线程的运行：</li>
<li>时间片分配给线程，多线程的进程获得更多CPU时间；</li>
<li>Windows NT和windows 2000&#x2F;xP支持内核线程。</li>
</ul>
<h5 id="🌟轻量级进程-了解"><a href="#🌟轻量级进程-了解" class="headerlink" title="🌟轻量级进程(了解)"></a>🌟轻量级进程(了解)</h5><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230606164824053.png" alt="image-20230606164824053" style="zoom:30%;" />

<h3 id="7-4上下文切换"><a href="#7-4上下文切换" class="headerlink" title="7.4上下文切换"></a>7.4上下文切换</h3><p>​	停止当前运行进程(从运行状态改变成其他状态）并且调度其他进程（转变成运行状态）</p>
<ul>
<li>﻿必须在切换之前存储许多部分的进程上下文</li>
<li>﻿必须能够在之后恢复他们，所以进程不能显示它曾经被暂停过</li>
<li>﻿必须快速（上下文转换时非常频繁的）</li>
</ul>
<p>​	需要存储什么上下文？</p>
<ul>
<li><p>寄存器(PC, SP， …)，CPU状态，……</p>
</li>
<li><p>一些时候可能会费时，所以我们应该尽可能避免</p>
</li>
</ul>
<h3 id="7-5进程控制"><a href="#7-5进程控制" class="headerlink" title="7.5进程控制"></a>7.5进程控制</h3><h4 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h4><p>fork函数：fork函数用于<u>从已经存在的进程中创建一个新的进程</u>。新的进程称为子进程，而原来的进程是父进程。</p>
<p><strong><u><em>返回值：子进程中返回0，父进程返回子进程id，出错返回-1</em></u></strong></p>
<p>当一个进程调用fork之后，就有两个二进制代码相同的进程。而且它们都运行到相同的地方。但每个进程都将可以开始它们自己的旅程</p>
<p>fork()的简单实现</p>
<ul>
<li>对子进程分配内存</li>
<li>复制父进程的内存和CPU寄存器到子进程</li>
<li>开销昂贵</li>
</ul>
<p>在99%的情况下,我们在调用fork()之后调用exec() —依据实际情况得出</p>
<ul>
<li>在fork()操作中内存复制是没有作用的（因为你fork完后立马去执行新的程序，会把你复制的东西都覆盖了</li>
<li>子进程将可能关闭打开的文件和连接</li>
<li>开销因此是最高的</li>
</ul>
<p>vfork()</p>
<ol>
<li><p>vfork用于创建一个子进程，子进程和父进程共享地址空间。(fork的子进程有独立的地址空间)</p>
</li>
<li><p>vfork保证子进程先运行，在子进程调用exec或exit之后父进程才可能被调度运行。</p>
</li>
</ol>
<ul>
<li>一个创建进程的系统调用,不需要创建一个同样的内存映像</li>
<li>一些时候称为轻量级fork()</li>
<li>子进程应该几乎立即调用exec()</li>
<li>现在不再使用如果我们使用 copy on write 技术(按需复制，不复制那些会被覆盖的部分，只复制进程创建必须的部分)</li>
</ul>
<h4 id="加载和执行进程"><a href="#加载和执行进程" class="headerlink" title="加载和执行进程"></a>加载和执行进程</h4><p>​	exec()函数：让当前进程执行新的程序</p>
<p>​		exec()调用允许一个进程”加载”一个不同的程序并且在main开始执行(事实上 _start)</p>
<p>​		它允许一个进程指定参数的数量(argc)和它字符串参数数组(argv)</p>
<h4 id="等待和终止进程"><a href="#等待和终止进程" class="headerlink" title="等待和终止进程"></a>等待和终止进程</h4><p>​	wait()系统调用 是被父进程用来等待子进程的结束</p>
<ul>
<li><p>一个子进程向父进程返回一个值，所以父进程必须接受这个值并处理</p>
</li>
<li><p>﻿wait()系统调用担任这个要求</p>
<ul>
<li><p>﻿它使父进程去睡眠来等待子进程的结果</p>
</li>
<li><p>﻿当一个子进程调用exit(的时候，操作系统解锁父进程，并且将通过exit()传递得到的返回值作为wait调用的一个结果(连同子进程的pid一起）如果这里没有子进程存活，wait()立刻返回</p>
</li>
<li><p>当然，如果这里有为父进程的僵尸等待，wait(立即返回其中一个值(并且解除僵尸状态）</p>
</li>
</ul>
</li>
<li><p>﻿进程结束执行之后，它调用exit()</p>
</li>
<li><p>﻿这个系统调用：</p>
<ul>
<li><p>﻿将这程序的 “结果” 作为一个参数</p>
</li>
<li><p>﻿关闭所有打开的文件，连接等等</p>
</li>
<li><p>﻿释放内存</p>
</li>
<li><p>﻿释放大部分支持进程的操作系统结构</p>
</li>
<li><p>﻿检查是否父进程是存活着的：</p>
<ul>
<li><p>﻿﻿如果是的话。它保留结果的值直到父进程需要它：在这种情况里。进程没有真正<br> 死亡，但是它进入了僵尸 (zombie&#x2F; defunct)状态</p>
</li>
<li><p>﻿如果没有，子进程将被init进程接管，init代替其父进程，释放其所有的数据结构</p>
</li>
</ul>
</li>
<li><p>﻿清理所有等待的僵尸进程</p>
</li>
</ul>
</li>
<li><p>﻿进程终止是最终的垃圾收集（资源回收）</p>
</li>
</ul>
<h4 id="进程状态图："><a href="#进程状态图：" class="headerlink" title="进程状态图："></a>进程状态图：</h4><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230606200728246.png" alt="image-20230606200728246" style="zoom:50%;" />

<h2 id="Chapter8-CPU调度"><a href="#Chapter8-CPU调度" class="headerlink" title="Chapter8 CPU调度"></a>Chapter8 CPU调度</h2><h3 id="8-1背景"><a href="#8-1背景" class="headerlink" title="8.1背景"></a>8.1背景</h3><h4 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h4><ul>
<li>从就绪队列中挑选一个进程&#x2F;线程作为CPU将要运行的下一个线程&#x2F;进程	</li>
<li>调度程序：挑选进程&#x2F;线程的内核函数(通过一些调度策略)</li>
<li>什么时候执行调度？——线程、进程生命周期中状态的转化时，会进行调度</li>
</ul>
<p>	</p>
<h4 id="CPU调度时间"><a href="#CPU调度时间" class="headerlink" title="CPU调度时间"></a>CPU调度时间</h4><p>​		满足一条即可：i): 一个进程从运行状态-&gt;等待状态; ii):一个进程被终结了</p>
<ul>
<li>不可抢占：<ul>
<li>调度程序必须等待事件结束</li>
</ul>
</li>
<li>可抢占：<ul>
<li>调度程序在中断被响应后执行</li>
<li>当前的进程从运行切换到就绪，或者一个进程从等待切换到就绪</li>
<li>当前运行的进程可以被换出</li>
</ul>
</li>
</ul>
<h3 id="8-2调度准则"><a href="#8-2调度准则" class="headerlink" title="8.2调度准则"></a>8.2调度准则</h3><h4 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h4><h4 id="程序执行模型"><a href="#程序执行模型" class="headerlink" title="程序执行模型"></a>程序执行模型</h4><p>​	程序在CPU突发和I&#x2F;O中交替</p>
<ul>
<li>每个调度决定都是关于在下一个CPU突发时将哪个工作交给CPU</li>
<li>在时间分片机制下，线程可能在结束当前CPU突发前被迫放弃CPU</li>
</ul>
<h4 id="比较调度算法的准则"><a href="#比较调度算法的准则" class="headerlink" title="比较调度算法的准则"></a>比较调度算法的准则</h4><h5 id="1-CPU使用率"><a href="#1-CPU使用率" class="headerlink" title="1.CPU使用率"></a>1.CPU使用率</h5><ul>
<li>CPU处于忙状态所占时间的百分比</li>
</ul>
<h5 id="2-吞吐量"><a href="#2-吞吐量" class="headerlink" title="2.吞吐量"></a>2.吞吐量</h5><ul>
<li>在单位时间内完成的进程数量</li>
</ul>
<h5 id="3-周转时间"><a href="#3-周转时间" class="headerlink" title="3.周转时间"></a>3.周转时间</h5><ul>
<li><u>一个进程从初始化到结束，包括所有等待时间</u>所花费的时间</li>
</ul>
<h5 id="4-等待时间"><a href="#4-等待时间" class="headerlink" title="4.等待时间"></a>4.等待时间</h5><ul>
<li>进程在<u>就绪队列</u>中的总时间</li>
</ul>
<h5 id="5-响应时间"><a href="#5-响应时间" class="headerlink" title="5.响应时间"></a>5.响应时间</h5><ul>
<li>从一个请求<u>被提交</u>到<u>产生第一次响应</u>所花费的总时间</li>
</ul>
<p>​	减少响应时间：及时处理用户的输出并且尽快将输出提供给用户</p>
<p>​	减少平均响应时间波动：在交互系统中，可预测性比高低差异平均更重要</p>
<p>​	增加吞吐量：i): 减少开销(操作系统开销，上下文切换) ii):系统资源的高效利用(CPU，I&#x2F;O设备)、</p>
<p>​	减少等待时间</p>
<p>​	低延迟利于系统与用户的交互</p>
<p>​	即使存在许多交互任务，我们也需要保证吞吐量不受影响</p>
<p>​	</p>
<h4 id="吞吐量vs延迟"><a href="#吞吐量vs延迟" class="headerlink" title="吞吐量vs延迟"></a>吞吐量vs延迟</h4><p>吞吐量是OS的计算带宽，响应时间是OS的计算延迟</p>
<h4 id="公平的目标"><a href="#公平的目标" class="headerlink" title="公平的目标"></a>公平的目标</h4><p>​	保证每个进程占用相同的CPU时间——会增加平均响应时间(真的要设计成公平的吗？)</p>
<h3 id="8-3调度算法"><a href="#8-3调度算法" class="headerlink" title="8.3调度算法"></a>8.3调度算法</h3><h4 id="1-先来先服务-FCFS"><a href="#1-先来先服务-FCFS" class="headerlink" title="1.先来先服务(FCFS)"></a>1.先来先服务(FCFS)</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>简单</li>
</ul>
<h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>平均等待时间波动较大</li>
<li>花费时间少的任务可能排在花费时间长的任务后面</li>
<li>可能导致I&#x2F;0和CPU之间的重叠处理<ul>
<li>﻿CPU密集型进程会导致I&#x2F;0设备闲置时，I&#x2F;0密集型进程也在等待</li>
</ul>
</li>
</ul>
<h4 id="2-短进程优先-x2F-短剩余时间优先"><a href="#2-短进程优先-x2F-短剩余时间优先" class="headerlink" title="2.短进程优先&#x2F;短剩余时间优先"></a>2.短进程优先&#x2F;短剩余时间优先</h4><p><strong>有抢占式</strong>、<strong>非抢占式</strong>的两种方案</p>
<h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>最优的平均等待时间</li>
</ul>
<h5 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>可能导致饥饿<ul>
<li>连续的短任务流会<strong>使长任务饥饿</strong></li>
<li>短任务可用时，任何长任务的CPU时间都会增加平均等待时间</li>
</ul>
</li>
<li>需要预知未来<ul>
<li>我们怎么在运行进程之前就提前知道进程要运行多久？<ul>
<li>最简单的方法——询问用户，如果用户撒谎，就杀死进程</li>
<li>如果用于不能给出时间，那么OS进行预估(根据之前的记录)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-最高响应比优先"><a href="#3-最高响应比优先" class="headerlink" title="3.最高响应比优先"></a>3.最高响应比优先</h4><p>​		在2的基础上进行了改进，考虑R ( R &#x3D; (w + s) &#x2F; s ) w:等待时间 s:执行时间</p>
<h5 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>不可抢占</li>
<li>关注进程等待了多长时间</li>
<li>防止无限期推迟</li>
</ul>
<h5 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>需要预知未来<ul>
<li>我们怎么在运行进程之前就提前知道进程要运行多久？<ul>
<li>最简单的方法——询问用户，如果用户撒谎，就杀死进程</li>
<li>如果用于不能给出时间，那么OS进行预估(根据之前的记录)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-轮询-RR"><a href="#4-轮询-RR" class="headerlink" title="4.轮询(RR)"></a>4.轮询(RR)</h4><ul>
<li>﻿RR 花销：额外的<strong>上下文切换</strong>开销</li>
<li>﻿时间量子太大<ul>
<li>等待时间过长</li>
<li>极限情况退化成FCFS</li>
</ul>
</li>
<li>﻿时间量子太小<ul>
<li>反应迅速但是切换频繁，开销大</li>
<li>吞吐量由于大量的上下文切换开销受到影响</li>
</ul>
</li>
<li>﻿目标：<ul>
<li>选择一个合适的时间量子</li>
<li>经验规则：维持上下文切换开销处于1%以内</li>
</ul>
</li>
</ul>
<p>——RR的优化</p>
<ul>
<li>﻿就绪队列被划分成独立的队列：<ul>
<li>E.g. 前台（交互）, 后台（批处理）</li>
</ul>
</li>
<li>﻿每个队列拥有自己的调度策略<ul>
<li>E.g. 前台一RR，后台—FCFS</li>
</ul>
</li>
<li>﻿调度必须在队列间进行<ul>
<li>固定优先级</li>
<li>﻿先处理前台，然后处理后台</li>
<li>可能导致饥饿</li>
<li>时间切片<ul>
<li>每个队列都得到一个确定的能够调度其进程的CPU总时间</li>
<li>E.g. 80%给使用RR的前台，20%给使用FCFS的后台</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-多级反馈队列"><a href="#5-多级反馈队列" class="headerlink" title="5.多级反馈队列"></a>5.多级反馈队列</h4><ul>
<li>一个进程可以在不同队列中移动<ul>
<li>时间量子大小随优先级级别的增加而增加</li>
<li>如果任务在当前的时间量子中没有完成，则降到下一优先级</li>
</ul>
</li>
</ul>
<h5 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>CPU密集型任务的优先级下降很快</li>
<li>I&#x2F;O密集型任务停留在高优先级</li>
</ul>
<h4 id="6-公平共享队列"><a href="#6-公平共享队列" class="headerlink" title="6.公平共享队列"></a>6.公平共享队列</h4><ul>
<li>FFS控制用户对系统资源的访问<ul>
<li>一些用户组比其他用户组更重要</li>
<li>保证不重要的组无法垄断资源</li>
<li>未使用的资源按照每个组所分配的资源的比例来分配</li>
<li>没有达到资源使用率目标的组获得更高的优先级</li>
</ul>
</li>
</ul>
<h3 id="8-4实时调度"><a href="#8-4实时调度" class="headerlink" title="8.4实时调度"></a>8.4实时调度</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>​	正确性依赖于时间与功能两方面</p>
<p>​	<u>需要保证<strong>及时性</strong></u>，速度和平均性能没那么重要</p>
<ul>
<li><p>强实时系统</p>
<ul>
<li>需要在<u>保证的时间内完成重要的任务</u>，必须完成</li>
</ul>
</li>
<li><p>弱实时系统</p>
<ul>
<li>要求<u>重要的进程的优先级更高</u>，尽量完成，并非必须</li>
</ul>
</li>
<li><p>硬时限</p>
<ul>
<li><p>如果错过了最后期限，可能会发生灾难性或非常严重的后果</p>
</li>
<li><p>必须验证：在最坏的情况下也能够满足时限吗？</p>
</li>
<li><p>保证确定性</p>
</li>
</ul>
</li>
<li><p>软时限</p>
<ul>
<li><p>理想情况下，时限应该被最大满足。如果有时限没有被满足，那么就相应地降低要求。</p>
</li>
<li><p>尽最大努力去保证</p>
</li>
</ul>
</li>
</ul>
<h4 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h4><p>​	静态、动态优先级调度(在程序执行之前就确定进程的优先级&#x2F;在程序运行过程中，优先级会不断变化)</p>
<h3 id="8-5多处理器调度"><a href="#8-5多处理器调度" class="headerlink" title="8.5多处理器调度"></a>8.5多处理器调度</h3><ul>
<li>﻿多处理器的CPU调度更加复杂<ul>
<li>多个相同的单处理器组成一个多处理器</li>
<li>优点：负载共享</li>
</ul>
</li>
<li>﻿对称多处理器(SMP)<ul>
<li>每个处理器运行自己的调度程序</li>
<li>需要在调度程序中同步</li>
</ul>
</li>
</ul>
<h3 id="8-6优先级反转"><a href="#8-6优先级反转" class="headerlink" title="8.6优先级反转"></a>8.6优先级反转</h3><p>​	现有优先级 T1 &lt; T2 &lt; T3，</p>
<p>T3和T1都需要用到一块共享资源，T3先执行，锁定了共享资源，T1再执行(抢占了T3)，虽然T1优先于T3，但是T3把T1要用到的资源锁住了，所以T1无法执行完毕，因此让T3继续执行，此时让T2再执行，会抢占T3，<u>这时候，T1需要等待T3，T3在等待T2，就出现了优先级反转问题！</u></p>
<p>解决方案：</p>
<ul>
<li>(当出现资源抢占现象时)低优先级任务继承高优先级任务的优先级</li>
<li>﻿优先级天花板：<ul>
<li>“资源” 的优先级和 “所有可以锁定该资源的任务中优先级最高的那个任务” 的优先级相同</li>
<li>除非优先级高于系统中所有被锁定的资源的优先级上限，否则任务尝试执行临界区的时候会被阻塞</li>
<li>﻿持有最高优先级上限信号量锁的任务，会继承被该锁所阳塞的任务的优先级</li>
</ul>
</li>
</ul>
<h2 id="Chapter9-同步"><a href="#Chapter9-同步" class="headerlink" title="Chapter9 同步"></a>Chapter9 同步</h2><h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><ul>
<li>﻿独立的线程：<ul>
<li>不和其他线程共享资源或状态</li>
<li>确定性：一输入状态决定结果</li>
<li>可重现：一 能够重现起始条件，I&#x2F;0</li>
<li>调度顺序不重要</li>
</ul>
</li>
<li>﻿合作线程：<ul>
<li>在多个线程中共享状态</li>
<li>不确定性</li>
<li>不可重现</li>
</ul>
</li>
<li>﻿不确定性和不可重现意味着bug可能是间歇性发生的</li>
</ul>
<p>进程间合作工作的原因：</p>
<ul>
<li>﻿进程&#x2F;线程，计算机&#x2F;设备需要合作</li>
<li>﻿优点1：共享资源<ul>
<li>一台电脑，多个用户</li>
<li>一个银行存款余额，多台ATM机</li>
<li>嵌入式系统（机器人控制：手臂和手的协调）</li>
</ul>
</li>
<li>﻿优点2：加速<ul>
<li>I&#x2F;0操作和计算可以重叠</li>
<li>多处理器 一 将程序分成多个部分井行执行</li>
</ul>
</li>
<li>﻿优点3：模块化<ul>
<li>将大程序分解成小程序</li>
</ul>
</li>
<li>﻿以编译为例，gcc会调用cpp, cc1, cc2. as, ld，使系统易于扩展</li>
</ul>
<p>但是进程并发会带来一些问题，接下来我们要对其进行解决</p>
<h3 id="一些概念："><a href="#一些概念：" class="headerlink" title="一些概念："></a>一些概念：</h3><h4 id="原子操作："><a href="#原子操作：" class="headerlink" title="原子操作："></a>原子操作：</h4><ul>
<li>﻿原子操作是指一次不存在任何中断或者失败的执行<ul>
<li>该执行成功结束</li>
<li>或者根本没有执行</li>
<li>并且不应该发现任何<strong>部分执行</strong>的状态</li>
</ul>
</li>
<li>﻿实际上操作往往不是原子的<ul>
<li>有些看上去是原子操作，实际上不是</li>
<li>连x++这样的简单语句，实际上是由3条指令构成的</li>
<li>有时候甚至连单条机器指令都不是原子的</li>
</ul>
</li>
</ul>
<h4 id="Critical-section-（临界区）"><a href="#Critical-section-（临界区）" class="headerlink" title="Critical section （临界区）"></a>Critical section （临界区）</h4><p>临界区是指进程中的一段需要访问共享资源并且当另一个进程处于相应代码区域时便不会被执行的代码区域</p>
<h4 id="Mutual-exclusion-（互斥）"><a href="#Mutual-exclusion-（互斥）" class="headerlink" title="Mutual exclusion （互斥）"></a>Mutual exclusion （互斥）</h4><p>当一个进程处于临界区井访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源</p>
<h4 id="Dead-lock-（死锁）"><a href="#Dead-lock-（死锁）" class="headerlink" title="Dead lock （死锁）"></a>Dead lock （死锁）</h4><p>两个或以上的进程，在相互等待完成特定任务，而最终没法将自身任务进行下去</p>
<h4 id="Starvation（饥饿）"><a href="#Starvation（饥饿）" class="headerlink" title="Starvation（饥饿）"></a>Starvation（饥饿）</h4><p>一个可执行的进程，被调度器持续忽略，以至于虽然处于可执行状态却不被执行		</p>
<h4 id="Critical-section-临界区）"><a href="#Critical-section-临界区）" class="headerlink" title="Critical section  (临界区）"></a>Critical section  (临界区）</h4><p>临界区是指进程中的一段需要访问共享资源井且当另一个进程处于相应代码区域时便不会被执行的代码区域</p>
<ul>
<li>﻿互斥：同一时间临界区中最多存在一个线程</li>
<li>﻿Progress：如果一个线程想要进入临界区，那么它最终会成功</li>
<li>有限等待：如果一个线程i处于入口区，那么在i的请求被接受之前，其他线程进入临界区的时间是有限制的</li>
<li>﻿无忙等待（可选)：如果一个进程在等待进入临界区，那么<strong>在它可以进入之前会被挂起</strong></li>
</ul>
<h4 id="Mutual-exclusion（互斥）"><a href="#Mutual-exclusion（互斥）" class="headerlink" title="Mutual exclusion（互斥）"></a>Mutual exclusion（互斥）</h4><p>当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源</p>
<h3 id="实现对临界区代码的保护"><a href="#实现对临界区代码的保护" class="headerlink" title="实现对临界区代码的保护"></a>实现对临界区代码的保护</h3><h4 id="方案1——禁用硬件中断："><a href="#方案1——禁用硬件中断：" class="headerlink" title="方案1——禁用硬件中断："></a>方案1——禁用硬件中断：</h4><ul>
<li>﻿没有中断，没有上下文切换，因此没有并发<ul>
<li>硬件将中断处理延迟到中断被启用之后</li>
<li>大多数现代计算机体系结构都提供指令来完成</li>
</ul>
</li>
<li>﻿进入临界区<ul>
<li>禁用中断</li>
</ul>
</li>
<li>﻿离开临界区<ul>
<li>开启中断</li>
</ul>
</li>
</ul>
<h5 id="缺点：-4"><a href="#缺点：-4" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>﻿一旦中断被禁用，线程就无法被停止<ul>
<li>整个系统都会为你停下来</li>
<li>可能导致其他线程处于饥饿状态</li>
</ul>
</li>
<li>﻿要是临界区可以任意长怎么办<ul>
<li>无法限制响应中断所需的时间(可能存在硬件影响）</li>
</ul>
</li>
</ul>
<p>​	要小心使用</p>
<ul>
<li>一般只能禁止单CPU的中断，那么面对多CPU的情况就无法使 禁用硬件中断失效</li>
</ul>
<h4 id="方案2——基于软件的解决方案"><a href="#方案2——基于软件的解决方案" class="headerlink" title="方案2——基于软件的解决方案:"></a>方案2——基于软件的解决方案:</h4><ul>
<li>﻿﻿Dekker算法 (1965）：第一个针对双线程例子的正确解决方案</li>
<li>﻿Bakery算法 ( Lamport 1979）：针对n线程的临界区问题解决方案</li>
<li>﻿复杂<ul>
<li>需要两个进程间的共享数据项</li>
</ul>
</li>
<li>﻿需要忙等待<ul>
<li>浪费CPU时间</li>
</ul>
</li>
<li>﻿没有硬件保证的情况下无真正的软件解决方案<ul>
<li>Peterson算法需要原子的LOAD和STORE指令</li>
</ul>
</li>
</ul>
<h4 id="方案3——更高级的抽象："><a href="#方案3——更高级的抽象：" class="headerlink" title="方案3——更高级的抽象："></a>方案3——更高级的抽象：</h4><ul>
<li>﻿大多数现代体系结构都提供特殊的原子操作指令<ul>
<li>通过特殊的内存访问电路，针对单处理器和多处理器</li>
</ul>
</li>
<li>﻿﻿Test-and-Set 测试和置位<ul>
<li>从内存中读取值</li>
<li>测试该值是否为1（然后返回真或假）</li>
<li>内存值设置为1</li>
</ul>
</li>
<li>﻿交换exchange<ul>
<li>交换内存中的两个值</li>
</ul>
</li>
</ul>
<p>我们可以通过Test-and-Set 或 exchange 来实现并发线程的管理</p>
<h5 id="优点：-4"><a href="#优点：-4" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>适用于单处理器或者共享主存的多处理器中任意数量的迸程</li>
<li>简单并且容易证明</li>
<li>可以用于支持多临界区</li>
</ul>
<h5 id="缺点：-5"><a href="#缺点：-5" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>忙等待消耗处理器时间</li>
<li>当进程离开临界区并且多个进程在等待的时候可能导致<u>饥饿</u></li>
<li>死锁</li>
<li>﻿如果一个低优先级的进程拥有临界区并且一个高优先级进程也需求，那么高优先级进程会获得处理器并等待临界区</li>
</ul>
<h2 id="Chapter10-信号量和管程"><a href="#Chapter10-信号量和管程" class="headerlink" title="Chapter10 信号量和管程"></a>Chapter10 信号量和管程</h2><h3 id="背景：-1"><a href="#背景：-1" class="headerlink" title="背景："></a>背景：</h3><ul>
<li>﻿并发问题：竞争条件（竞态条件）<ul>
<li>多程序并发存在大的问题</li>
</ul>
</li>
<li>﻿同步<ul>
<li>多线程<strong>共享公共数据的协调执行</strong></li>
<li>包括互斥与条件同步</li>
<li>互斥：在同一时间只有一个线程可以执行临界区</li>
</ul>
</li>
<li>﻿确保同步正确很难？<ul>
<li>需要高层次的编程抽象（如：锁）</li>
<li>从底层硬件支持编译</li>
</ul>
</li>
</ul>
<h3 id="信号量："><a href="#信号量：" class="headerlink" title="信号量："></a>信号量：</h3><ul>
<li><p>是一个整形（sem），有两个原子操作</p>
</li>
<li><p>P () :   sem 减1，如果sem&lt;0， 等待，否则继续</p>
</li>
<li><p>V () ：sem 加1，如果 sem&lt;&#x3D;0，唤醒一个等待的P</p>
</li>
<li><p>﻿信号量是被保护的变量</p>
<ul>
<li>初始化完成后，唯一改变一个信号量的值的办法是通过P0和v0</li>
<li>操作必须是原子</li>
</ul>
</li>
<li><p>﻿P () 能够阻塞，V () 不会阻塞</p>
</li>
<li><p>﻿我们假定信号量是   公平的</p>
<ul>
<li>没有线程被阻塞在P () if  V () 被无限频繁调用（对于同一个信号量）</li>
<li>在实践中，FIFO经常被使用</li>
</ul>
</li>
<li><p>﻿两种类型信号量</p>
<ul>
<li>二进制信号量：可以是0或1</li>
<li>一般&#x2F;计数信号量：可取任何非负值</li>
<li>两者相互表现(给定一个可以实现另一个)</li>
</ul>
</li>
<li><p>﻿信号量可以用在2个方面</p>
<ul>
<li>互斥</li>
<li>条件同步(调度约束一一一个线程等待另一个线程的事情发生）</li>
</ul>
</li>
</ul>
<h3 id="信号量缺点："><a href="#信号量缺点：" class="headerlink" title="信号量缺点："></a>信号量缺点：</h3><ul>
<li>信号量的双用途<ul>
<li>互斥和条件同步</li>
<li>但等待条件是独立的互斥</li>
</ul>
</li>
<li>读&#x2F;开发代码比较困难<ul>
<li>程序员必须非常精通信号量</li>
</ul>
</li>
<li>容易出错<ul>
<li>使用的信号量己经被另一个线程占用</li>
<li>忘记释放信号量</li>
</ul>
</li>
<li>不能够处理死锁问题</li>
</ul>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><ul>
<li><p>﻿什么是管程</p>
<ul>
<li>一个锁：指定临界区</li>
<li>0或者多个条件变量：等待&#x2F;通知信号量用于管理并发访问共享数据</li>
</ul>
</li>
<li><p>﻿一般方法</p>
<ul>
<li>收集在对象&#x2F;模块中的相关共享数据</li>
<li>定义方法来访问共享数据</li>
</ul>
</li>
<li><p>﻿﻿Lock</p>
<ul>
<li>Lock::Acquire（ 一 等待直到锁可用，然后抢占锁</li>
<li>Lock::Release （一释放锁，唤醒等待者如果有</li>
</ul>
</li>
<li><p>﻿﻿Condition Variable</p>
<ul>
<li><p>允许等待状态进入临界区</p>
<ul>
<li>﻿允许处于等待（睡眠）的线程进入临界区</li>
<li>﻿某个时刻原子释放锁进入睡眠</li>
</ul>
</li>
<li><p>Wait () operation</p>
<ul>
<li>﻿释放锁，睡眠，重新获得锁返回后</li>
</ul>
</li>
<li><p>﻿﻿Signal () operation ( or broadcast () operation )</p>
<ul>
<li>唤醒等待者（或者所有等待者），如果有</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/IMG_C86C23D6FA1D-1.jpeg" alt="IMG_C86C23D6FA1D-1" style="zoom:50%;" />



<h3 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h3><h4 id="读者—写者问题："><a href="#读者—写者问题：" class="headerlink" title="读者—写者问题："></a>读者—写者问题：</h4><ul>
<li><p>动机</p>
<ul>
<li>共享数据的访问</li>
</ul>
</li>
<li><p>两种类型使用者</p>
<ul>
<li>读者：不需要修改数据</li>
<li>写者：读取和修改数据</li>
</ul>
</li>
<li><p>问题的约束</p>
<ul>
<li>允许同一时间有多个读者，但在任何时候只有一个写者</li>
<li>当没有写者是读者才能访问数据</li>
<li>当没有读者和写者时写者才能访问数据</li>
<li>在任何时候只能有一个线程可以操作共享变量</li>
</ul>
</li>
<li><p>﻿多个并发进程的数据集共享</p>
<ul>
<li>读者一只读数据集；他们不执行任何更新</li>
<li>写者-可以读取和写入</li>
</ul>
</li>
<li><p>﻿共享数据</p>
<ul>
<li>数据集</li>
<li>信号量CountMutex初始化为1</li>
<li>信号量WriteMutex初始化为1</li>
<li>整数 Rcount 初始化为0</li>
</ul>
</li>
</ul>
<h5 id="读者优先实现-使用信号量方式-："><a href="#读者优先实现-使用信号量方式-：" class="headerlink" title="读者优先实现(使用信号量方式)："></a>读者优先实现(使用信号量方式)：</h5><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/IMG_4D5569A45E16-1.jpeg" alt="IMG_4D5569A45E16-1" style="zoom:50%;" />

<h4 id="哲学家就餐问题："><a href="#哲学家就餐问题：" class="headerlink" title="哲学家就餐问题："></a>哲学家就餐问题：</h4><h2 id="Chapter11-死锁"><a href="#Chapter11-死锁" class="headerlink" title="Chapter11 死锁"></a>Chapter11 死锁</h2><h3 id="死锁问题："><a href="#死锁问题：" class="headerlink" title="死锁问题："></a>死锁问题：</h3><p>​		一组阻塞的进程持有一种资源 等待获取 另一个进程所占有的一个资源。</p>
<h3 id="系统模型："><a href="#系统模型：" class="headerlink" title="系统模型："></a>系统模型：</h3><h4 id="可重复使用的资源"><a href="#可重复使用的资源" class="headerlink" title="可重复使用的资源"></a>可重复使用的资源</h4><ul>
<li><p>﻿在一个时间只能一个进程使用且不能被删除</p>
</li>
<li><p>﻿进程获得资源，后来释放由其他进程重用</p>
</li>
<li><p>﻿处理器，I&#x2F;O通道，主和副存储器，设备和数据结构，如文件，数据库和信号量</p>
</li>
<li><p>﻿如果每个进程拥有一个资源并请求其它资源，死锁可能发生</p>
<h4 id="使用资源"><a href="#使用资源" class="headerlink" title="使用资源"></a>使用资源</h4></li>
<li><p>﻿﻿创建和销毁</p>
</li>
<li><p>﻿在I&#x2F;O缓冲区的中断，信号，消息，信息</p>
</li>
<li><p>﻿如果接收消息阳塞可能会发生死锁</p>
</li>
<li><p>﻿可能少见的组合事件会引起死锁</p>
</li>
</ul>
<h3 id="死锁特征："><a href="#死锁特征：" class="headerlink" title="死锁特征："></a>死锁特征：</h3><p>死锁出现的必要条件：</p>
<h4 id="1、-互斥："><a href="#1、-互斥：" class="headerlink" title="1、 互斥："></a>1、 互斥：</h4><p>进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</p>
<h4 id="2、占用并等待："><a href="#2、占用并等待：" class="headerlink" title="2、占用并等待："></a>2、占用并等待：</h4><p>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p>
<h4 id="3、无抢占"><a href="#3、无抢占" class="headerlink" title="3、无抢占:"></a>3、无抢占:</h4><p>进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</p>
<h4 id="4、循环等待"><a href="#4、循环等待" class="headerlink" title="4、循环等待:"></a>4、循环等待:</h4><p>存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i&#x3D;0, 1, …, n-1)，Pn等待的资源被P0占有；</p>
<h3 id="死锁处理方法："><a href="#死锁处理方法：" class="headerlink" title="死锁处理方法："></a>死锁处理方法：</h3><h4 id="死锁预防："><a href="#死锁预防：" class="headerlink" title="死锁预防："></a>死锁预防：</h4><p>破坏任意死锁出现的必要条件：</p>
<ul>
<li><p>互斥——共享资源不是必须的，必须占用非共享资源。</p>
</li>
<li><p>占用并等待——必须保证当一个进程请求的资源，它不持有任何其他资源。</p>
<ul>
<li>需要进程请求并分配其所有资源，它开始执行之前或允许进程请求资源仅当进程没有资源。</li>
<li>资源利用率低;可能发生饥饿。</li>
</ul>
<p>					</p>
</li>
<li><p>无抢占</p>
<ul>
<li>如果进程占有某些资源，并请求其它不能被立即分配的资源，则释放当前正占有的资源</li>
<li>被抢占资源添加到资源列表中</li>
<li>只有当它能够获得旧的资源以及它请求新的资源，进程可以得到执行</li>
</ul>
</li>
<li><p>循环等待 —对所有资源类型进行<u><strong>排序</strong></u>，并<u><strong>要求每个进程按照资源的顺序进行申请</strong></u>。</p>
</li>
</ul>
<h4 id="死锁避免："><a href="#死锁避免：" class="headerlink" title="死锁避免："></a>死锁避免：</h4><p><u>需要系统具有一些额外的先验信息提供。</u></p>
<ul>
<li><p>﻿﻿最简单和最有效的模式是要求每个进程声明它可能需要的每个类型资源的<u>最大数目</u>。</p>
</li>
<li><p>﻿资源的分配状态是通过限定<u>提供</u>与<u>分配</u>的资源数量，和进程的<u>最大需求</u>。</p>
</li>
<li><p>﻿死锁避免算法<u>动态检查</u>的资源分配状态，以确保永远不会有一个环形等待状态。</p>
</li>
<li><p>﻿当一个进程请求可用资源，系统必须判断立即分配是否能<strong>使系统处于安全状态</strong>。</p>
</li>
<li><p>﻿系统处于安全状态指：针对所有进程，存在安全序列。</p>
</li>
<li><p>﻿序列&lt;P1，p2,……，PN&gt;是安全的：针对每个Pi, Pi要求的资源能够由当前可用的资源+所有的 Pj 持有的资源来满足，其中j&lt;i。</p>
<ul>
<li>如果 Pi 资源的需求不是立即可用，那么 Pi 可以等到所有 Pj 完成。</li>
<li>当 Pi 完成后，P i + 1 可以得到所需要的资源，执行，返回所分配的资源，并终止。</li>
<li>﻿用同样的方法。Pi+2, Pi+3，和 Pn 能获得其所需的资源。</li>
</ul>
</li>
</ul>
<h5 id="银行家算法-通过合理分配资源使得死锁避免"><a href="#银行家算法-通过合理分配资源使得死锁避免" class="headerlink" title="银行家算法(通过合理分配资源使得死锁避免)"></a>银行家算法(通过合理分配资源使得死锁避免)</h5><h4 id="死锁检测："><a href="#死锁检测：" class="headerlink" title="死锁检测："></a>死锁检测：</h4><p>​		就是银行家算法，看看能不能在现有资源下，让所有进程都跑通			(时间复杂度大、开销大)</p>
<h4 id="死锁恢复："><a href="#死锁恢复：" class="headerlink" title="死锁恢复："></a>死锁恢复：</h4><ul>
<li>﻿方法1：终止所有的死锁进程</li>
<li>﻿方法2：在一个时间内终止一个进程直到死锁消除<ul>
<li>终止进程的顺序应该是：<ul>
<li>进程的优先级</li>
<li>进程运行了多久以及需要多少时间才能完成</li>
<li>进程占用的资源</li>
<li>进程完成需要的资源</li>
<li>多少进程需要被终止</li>
<li>迸程是交互还是批处理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Chapter12进程间通信-IPC——Inter-Process-Communication"><a href="#Chapter12进程间通信-IPC——Inter-Process-Communication" class="headerlink" title="Chapter12进程间通信(IPC——Inter Process Communication)"></a>Chapter12进程间通信(IPC——Inter Process Communication)</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="通信模型"><a href="#通信模型" class="headerlink" title="通信模型"></a>通信模型</h4><ul>
<li><p>﻿进程通信的机制及同步</p>
</li>
<li><p>﻿不使用共享变量的迸程通信</p>
</li>
<li><p>﻿﻿IPC facility 提供2个操作：</p>
<ul>
<li>send(message）一消息大小固定或者可变</li>
<li>﻿﻿receive (message)</li>
</ul>
</li>
<li><p>﻿如果P和Q想通信，需要：</p>
<ul>
<li>在它们之间建立通信链路</li>
<li>通过 send&#x2F;receive交换消息</li>
</ul>
</li>
<li><p>﻿通信链路的实现</p>
<ul>
<li><p>物理（例如，<strong>共享内存</strong>，<strong>硬件总线</strong>）</p>
</li>
<li><p>﻿逻辑（例如，逻辑属性）</p>
</li>
</ul>
</li>
</ul>
<h4 id="直接与间接通信"><a href="#直接与间接通信" class="headerlink" title="直接与间接通信"></a>直接与间接通信</h4><h5 id="直接通信"><a href="#直接通信" class="headerlink" title="直接通信:"></a>直接通信:</h5><ul>
<li>进程必须正确的命名对方：<ul>
<li>send (P, message)        一 发送信息到进程P</li>
<li>receive (Q, messase） 一 从进程Q接受消息</li>
</ul>
</li>
<li>通信链路的属性:<ul>
<li>自动建立链路</li>
<li>一条链路恰好对应一对通信进程</li>
<li>每对进程之间只有一个链接存在</li>
<li>链接可以是单向的，但通常为双向的</li>
</ul>
</li>
</ul>
<h5 id="间接通信"><a href="#间接通信" class="headerlink" title="间接通信:"></a>间接通信:</h5><ul>
<li>﻿定向从消息队列接收消息<ul>
<li>每个消息队列都有一个唯一的ID</li>
<li>只有它们共享了一个消息队列，进程才能够通信</li>
</ul>
</li>
<li>﻿通信链路的属性<ul>
<li>只有进程共享一个共同的消息队列，才建立链路</li>
<li>链接可以与许多进程相关联</li>
<li>每对进程可以共享多个通信链路</li>
<li>连接可以是单向或双向</li>
</ul>
</li>
<li>﻿操作<ul>
<li>创建一个新的消息队列</li>
<li>通过消息队列发送和接收消息</li>
<li>销毁消息队列</li>
</ul>
</li>
<li>﻿原语的定义如下：<ul>
<li>send （A, message）一 发送消息到队列A</li>
<li>receive (A,message）一 从队列 A接受消息</li>
</ul>
</li>
</ul>
<h4 id="阻塞与非阻塞："><a href="#阻塞与非阻塞：" class="headerlink" title="阻塞与非阻塞："></a>阻塞与非阻塞：</h4><p>​	阻塞：异步</p>
<p>​	非阻塞：同步(发送方一定要等到接收方收到消息后再进行下一步操作)</p>
<h4 id="通信链路缓冲："><a href="#通信链路缓冲：" class="headerlink" title="通信链路缓冲："></a>通信链路缓冲：</h4><ul>
<li>队列的消息被附加到链路；可以是以下3种方式之一：</li>
</ul>
<ol>
<li><p>﻿﻿﻿0容量<br> 发送方必须等待接收方 (rendezvous)</p>
</li>
<li><p>﻿﻿有限容量 —— n messages的有限长度</p>
<p>​		如果队列满，发送方必须等待</p>
</li>
<li><p>﻿﻿﻿无限容量——无限长度<br> 发送方不需要等待</p>
</li>
</ol>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><ul>
<li><p><u><strong>软件</strong></u>中断通知事件处理</p>
</li>
<li><p>Examples: SIGFPE, SIGKILL, SIGUSR1, SIGSTOP, SIGCONT</p>
</li>
<li><p>﻿接收到信号时会发生什么</p>
<ul>
<li>Catch:指定信号处理函数被调用</li>
<li>Ignore：依靠操作系统的默认操作</li>
</ul>
</li>
<li><p>﻿﻿Example: Abort, memory dump, suspend or resume process</p>
<ul>
<li>Mask：闭塞信号因此不会传送<ul>
<li>﻿可能是暂时的（当处理同样类型的信号）</li>
</ul>
</li>
</ul>
</li>
<li><p>﻿不足<br> 不能传输要交换的任何数据</p>
</li>
</ul>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>​		主要是为了 实现使一个进程的输出作为另一个进程的输入		(这两个进程都是shell进程的子进程，shell进程为它们之间的通信创建通道)</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>​		<a href="https://tangjiayang.github.io/2023/06/02/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">https://tangjiayang.github.io/2023/06/02/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</a></p>
<p>​		一种间接通信方式</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><ul>
<li><p>进程</p>
<ul>
<li>每个进程都有私有地址空间</li>
<li>在每个地址空间内，明确地设置了共享内存段</li>
</ul>
</li>
<li><p>﻿优点</p>
<ul>
<li>快速、方便地共享数据</li>
</ul>
</li>
<li><p>﻿不足</p>
<ul>
<li>必须同步数据访问</li>
</ul>
</li>
</ul>
<p>	</p>
<h2 id="Chapter13-文件系统"><a href="#Chapter13-文件系统" class="headerlink" title="Chapter13 文件系统"></a>Chapter13 文件系统</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="文件系统和文件"><a href="#文件系统和文件" class="headerlink" title="文件系统和文件"></a>文件系统和文件</h4><ul>
<li><p>文件系统：一种用于持久性存储的系统抽象</p>
<ul>
<li>在存储器上：组织、控制、导航、访问和检索数据</li>
<li>大多数计算机系统包含文件系统</li>
<li>个人电脑、服务器、笔记本电脑</li>
<li>iPod.Tivo &#x2F;机顶盒、手机&#x2F;掌上电脑</li>
<li>Google 可能是由一个文件系统构成的</li>
</ul>
</li>
<li><p>文件：文件系统中<strong>一个单元的相关数据在操作系统中的抽象</strong></p>
</li>
</ul>
<h5 id="文件系统的功能："><a href="#文件系统的功能：" class="headerlink" title="文件系统的功能："></a>文件系统的功能：</h5><ul>
<li>﻿分配文件磁盘空间<ul>
<li>管理<strong>文件块</strong>（哪一块属于哪一个文件）</li>
<li>管理<strong>空闲空间</strong>(哪一块是空闲的）</li>
<li>分配算法（策略）</li>
</ul>
</li>
<li>﻿管理文件集合<ul>
<li><strong>定位</strong>文件及其内容</li>
<li><strong>命名</strong>：通过名字找到文件的接口</li>
<li>最常见：分层文件系统</li>
<li>文件系统类型（组织文件的不同方式）</li>
</ul>
</li>
<li>﻿提供的便利及特征<ul>
<li><strong>保护</strong>：分层来保护数据安全</li>
<li><strong>可靠性&#x2F;持久性</strong>：保持文件的持久即使发生崩溃、媒体错误、攻击等</li>
</ul>
</li>
</ul>
<h5 id="文件和块："><a href="#文件和块：" class="headerlink" title="文件和块："></a>文件和块：</h5><ul>
<li>﻿文件属性：<ul>
<li>名称、类型、位置、大小，保护、创建者、创建时间、最近修改时间、…</li>
</ul>
</li>
<li>﻿文件头：<ul>
<li>在存储元数据中保存了每个文件的信息</li>
<li>保存文件的属性</li>
<li>跟踪哪一块存储块属于逻辑上文件结构的哪个偏移</li>
</ul>
</li>
</ul>
<h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><ul>
<li><p>需要元数据数据来管理打开文件：</p>
<ul>
<li>文件指针：<u>指向最近的一次读写位置</u>，每个打开了这个文件的进程都有这个指针</li>
<li>文件打开计数：记录文件打开的次数——当最后一个进程关闭了文件时，允许将其从打开文件表中移除</li>
<li>文件磁盘位置：缓存数据访问信息</li>
<li>访问权限：每个程序访问模式信息</li>
</ul>
</li>
<li><p>﻿用户怎么访问文件</p>
<ul>
<li>在系统层面需要知道用户的访问模式：</li>
<li>﻿顺序访问：按字节依次读取<ul>
<li>几乎所有的访问都是这种方式</li>
</ul>
</li>
<li>﻿随机访问：从中间读写<ul>
<li>不常用，但是仍然重要．例如，虚拟内存支持文件：内存页存储在文件中</li>
<li>更加快速 一 不希望获取文件中间的内容的时候也必须先获取块内所有字节。</li>
</ul>
</li>
<li>基于内容访问：通过特征<ul>
<li>许多系统不提供此种访问方式，相反，数据库是建立在索引内容的磁盘访问上（需要高效的随机访问)</li>
</ul>
</li>
</ul>
</li>
<li><p>﻿﻿多用户系统中的文件共享：</p>
<ul>
<li>﻿访问控制<ul>
<li>谁能够获得哪些文件的哪些访问权限</li>
<li>访问模式：读、写、执行、删除、列举等</li>
</ul>
</li>
<li>﻿文件访问控制列表 (ACL)<ul>
<li>&lt;文件实体，权限&gt;</li>
</ul>
</li>
<li>﻿Unix 模式<ul>
<li>〈用户|组|所有人，读|写|可执行〉</li>
<li>用户ID识别用户，表明每个用户所允许的权限及保护模式</li>
<li>组ID允许用户组成组，并指定了组访问权限</li>
</ul>
</li>
<li>﻿指定多用户&#x2F;客户如何同时访问共享文件<ul>
<li>和过程同步算法相似</li>
<li>因磁盘I&#x2F;0和网络延迟而设计简单</li>
</ul>
</li>
<li>﻿﻿Unix 文件系统(UFS) 语义<ul>
<li>对打开文件的写入内容立即对其他打开同一文件的其他用户可见</li>
<li>共享文件指针允许多用户同时读取和写入文件</li>
</ul>
</li>
<li>﻿会话语义<ul>
<li>写入内容只有当文件关闭时可见</li>
</ul>
</li>
<li>﻿锁<ul>
<li>一些操作系统和文件系统提供该功能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul>
<li><p>文件以目录的方式组织起来</p>
</li>
<li><p>目录是一类特殊的文件</p>
<ul>
<li>每个目录都包含了一张表&lt;name, pointer to file header&gt;</li>
</ul>
</li>
<li><p>目录和文件的树型结构</p>
<ul>
<li>早期的文件系统是扁平的 （只有一层目录）</li>
</ul>
</li>
<li><p>﻿典型操作</p>
<ul>
<li>搜索文件</li>
<li>创建文件</li>
<li>删除文件</li>
<li>枚举目录</li>
<li>重命名文件</li>
<li>在文件系统中遍历一个路径</li>
</ul>
</li>
<li><p>﻿操作系统应该只允许内核模式修改目录</p>
<ul>
<li>确保映射的完整性</li>
<li>应用程序能够读目录 （如1s)</li>
</ul>
</li>
<li><p>﻿名字解析：逻辑名字转换成物理资源（如文件）的过程</p>
<ul>
<li>在文件系统中：到实际文件的文件名（路径）</li>
<li>遍历文件目录直到找到目标文件</li>
</ul>
</li>
<li><p>﻿举例：解析 “&#x2F;bin&#x2F;ls”</p>
<ul>
<li>读取root的文件头（在磁盘固定位置）</li>
<li>读取root的数据块：搜索 “bin” 项</li>
<li>读取bin的文件头</li>
<li>读取bin的数据块：搜索 “ls” 项</li>
<li>读取ls的文件头</li>
</ul>
</li>
<li><p>﻿当前工作目录</p>
<ul>
<li>每个进程都会指向一个文件目录用于解析文件名</li>
<li>允许用户指定相对路径来代替绝对路径</li>
</ul>
</li>
</ul>
<h4 id="文件别名"><a href="#文件别名" class="headerlink" title="文件别名"></a>文件别名</h4><h5 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h5><ul>
<li><p>两个或多个文件名关联同一个文件</p>
</li>
<li><p>﻿硬链接：<strong>多个文件项指向一个文件</strong></p>
</li>
<li><p>﻿软链接：以“快捷方式”指向其他文件(**“<u>快捷方式文件的内容是另一个文件的路径名</u>**”)</p>
</li>
<li><p>﻿通过存储真实文件的逻辑名称来实现</p>
</li>
</ul>
<h4 id="文件系统种类"><a href="#文件系统种类" class="headerlink" title="文件系统种类"></a>文件系统种类</h4><ul>
<li><p>﻿磁盘文件系统</p>
<ul>
<li>文件存储在数据存储设备上，如磁盘。</li>
<li>例如：FAT, NTFS, ext2&#x2F;3， IS09660，等</li>
</ul>
</li>
<li><p>﻿数据库文件系统</p>
<ul>
<li>文件根据其特征是可被寻址（辨识）的</li>
<li>例如：winFS</li>
</ul>
</li>
<li><p>﻿日志文件系统</p>
<ul>
<li>记录文件系统的修改&#x2F;事件</li>
<li>例如：journaling file system</li>
</ul>
</li>
<li><p>﻿网络&#x2F;分布式文件系统</p>
<ul>
<li><p>﻿文件可以通过网络被共享</p>
<ul>
<li>文件位于远程服务器</li>
<li>客户端远程挂载服务器文件系统</li>
<li>标准系统文件访问被转换成远程访问</li>
<li>标准文件共享协议：NFS for Unix, CIFS for windows</li>
</ul>
</li>
<li><p>﻿分布式文件系统的问题</p>
<ul>
<li>客户端和客户端上的用户辨别起来很复杂</li>
<li>例如，NFS是不安全的</li>
<li><strong>一致性问题</strong></li>
<li>错误处理模式</li>
</ul>
</li>
<li><p>例如：NFS, SMB, AFS, GFS</p>
</li>
</ul>
</li>
<li><p>﻿特殊&#x2F;虚拟文件系统</p>
</li>
</ul>
<h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><ul>
<li><p>分层结构</p>
<ul>
<li>上层：虚拟(逻辑)文件系统</li>
<li>底层：特定文件系统模块</li>
</ul>
</li>
<li><p>﻿目的</p>
<ul>
<li>对所有不同文件系统的抽象(让上层使用统一的接口对不同的文件系统进行统一管理)</li>
</ul>
</li>
<li><p>﻿功能</p>
<ul>
<li>提供相同的文件和文件系统接口</li>
<li>管理所有文件和文件系统关联的数据结构</li>
<li>高效查询例程，遍历文件系统</li>
<li>与特定文件系统模块的交互</li>
</ul>
</li>
<li><p>实现</p>
<ul>
<li>﻿卷控制块 (Unix: “superblock”）<ul>
<li>每个文件系统一个</li>
<li>文件系统详细信息</li>
<li>块、块大小，空余块、计数&#x2F;指针等</li>
</ul>
</li>
<li>﻿文件控制块 (Unix： ”vnode” or “inode”）<ul>
<li>每个文件一个</li>
<li>文件详细信息</li>
<li>许可、拥有者、大小、数据库位置等</li>
</ul>
</li>
<li>﻿目录节点 (Linux: ”dentry”）<ul>
<li>每个目录项一个（目录和文件）</li>
<li>将目录项数据结构及树型布局编码成树型数据结构</li>
<li>指向文件控制块、父节点、项目列表等</li>
</ul>
</li>
</ul>
</li>
<li><p>文件系统数据结构</p>
<ul>
<li>卷控制块（每个文件系统一个）</li>
<li>文件控制块（每个文件一个）</li>
<li>目录节点(每个目录项一个)</li>
</ul>
</li>
<li><p>﻿持续存储在二级存储中</p>
<ul>
<li>分配在存储设备中的数据块中</li>
</ul>
</li>
<li><p>﻿当需要时加载进内存</p>
<ul>
<li>卷控制模块 ：当文件系统挂载时进入内存</li>
<li>文件控制块：当文件被访问时进入内存</li>
<li>目录节点：在遍历一个文件路径时进入内存</li>
</ul>
</li>
</ul>
<h3 id="数据块缓存"><a href="#数据块缓存" class="headerlink" title="数据块缓存"></a>数据块缓存</h3><ul>
<li>﻿数据块按需读入内存<ul>
<li>提供 read() 操作</li>
<li>预读：预选读取后面的数据块</li>
</ul>
</li>
<li>﻿数据块使用后被缓存<ul>
<li>假设数据将会再次被使用</li>
<li>写操作可能被缓存和延迟写入</li>
</ul>
</li>
<li>﻿两种数据块缓存方式<ul>
<li>普通缓冲区缓存</li>
<li>页缓存：统一缓存数据块和内存页<ul>
<li>﻿分页要求<ul>
<li>当需要一个页时才格其载入内存</li>
</ul>
</li>
<li>﻿支持存储<ul>
<li>一个页（在虚拟地址空间中）可以被映射到一个本地文件中（在二级存储中）</li>
</ul>
</li>
<li>文件数据块的页缓存<ul>
<li>在虚拟内存中文件数据块被映射成页</li>
<li>文件的读&#x2F;写操作被转换成对内存的访问</li>
<li>可能导致缺页和&#x2F;或设置为脏页</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="打开文件的数据结构"><a href="#打开文件的数据结构" class="headerlink" title="打开文件的数据结构"></a>打开文件的数据结构</h3><ul>
<li>﻿打开文件描述<ul>
<li>文件状态信息</li>
<li>目录项、当前文件指针、文件操作设置等</li>
</ul>
</li>
<li>﻿打开文件表<ul>
<li>一个进程一个</li>
<li>系统级</li>
<li>每个卷控制块也会保存一个列表</li>
<li>所以如果有文件被打开将不能被卸载</li>
</ul>
</li>
</ul>
<h3 id="文件分配"><a href="#文件分配" class="headerlink" title="文件分配"></a>文件分配</h3><ul>
<li><p>﻿大多数文件都很小</p>
<ul>
<li>需要对小文件提供强力的支持</li>
<li>块空间不能太大</li>
</ul>
</li>
<li><p>﻿﻿一些文件非常大</p>
<ul>
<li>必须支持大文件 （64-bit 文件偏移）</li>
<li>大文件访问需要相当高效</li>
</ul>
</li>
<li><p>﻿如何为一个文件分配数据块</p>
<ul>
<li>﻿分配方式<ul>
<li>连续分配<ul>
<li>优点：<ul>
<li>文件读取表现好</li>
<li>高效的顺序和随机访问</li>
</ul>
</li>
<li>缺点：<ul>
<li>碎片</li>
<li>如文件增大，则不好处理</li>
</ul>
</li>
</ul>
</li>
<li>链式分配<ul>
<li>文件以数据块链表的方式存储</li>
<li>文件头包含了从第一块到最后一块的指针</li>
<li>优点：<ul>
<li>创建、增大、缩小容易</li>
<li>没有碎片</li>
</ul>
</li>
<li>缺点：<ul>
<li>不可能进行真正的随机访问(链表，所以只能串型访问)</li>
<li>可靠性(中途断电，导致链表被破坏)</li>
</ul>
</li>
</ul>
</li>
<li>索引分配<ul>
<li>﻿为每个文件创建一个名为索引数据块的非数据数据块<ul>
<li>到文件数据块的指针列表</li>
</ul>
</li>
<li>﻿文件头包含了索引数据块</li>
<li>﻿优点：<ul>
<li>创建、增大、缩小很容易</li>
<li>没有碎片</li>
<li>支持直接访问</li>
</ul>
</li>
<li>缺点：<ul>
<li>当文件很小时，存储索引的开销</li>
<li>如何处理大文件？</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>﻿指标<ul>
<li>高效：如存储利用 （外部碎片）</li>
<li>表现：如访问速度</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="空闲空间列表"><a href="#空闲空间列表" class="headerlink" title="空闲空间列表"></a>空闲空间列表</h3><p>……</p>
<h3 id="多磁盘管理-RAID"><a href="#多磁盘管理-RAID" class="headerlink" title="多磁盘管理 -RAID"></a>多磁盘管理 -RAID</h3><p>磁盘阵列（Redundant Arrays of Independent Disks，RAID），”数块独立磁盘构成具有冗余能力的阵列”</p>
<p>磁盘阵列是<strong>由很多块独立的磁盘，组合成一个容量巨大的磁盘组</strong>，<u>利用个别磁盘提供数据所产生加成效果提升整个磁盘系统效能</u>。利用这项技术，<strong>将数据切割成许多区段，分别存放在各个硬盘上</strong>。</p>
<ul>
<li><p>﻿分区：硬件磁盘的一种适合操作系统指定格式的划分</p>
</li>
<li><p>﻿卷：一个拥有一个文件系统实例的可访问的存储空间</p>
<ul>
<li>通常常驻在磁盘的单个分区上</li>
</ul>
</li>
<li><p>﻿使用多个并行磁盘来增加</p>
<ul>
<li>吞吐量（通过并行)</li>
<li>可靠性和可用性（通过冗余，多存几份，防备意外）</li>
</ul>
</li>
<li><p>﻿RAID 一 冗余磁盘阵列</p>
<ul>
<li>各种磁盘管理技术</li>
<li>RAID levels：不同RAID 分类（如，RATD-0， RAID-1, RATD-5)</li>
</ul>
</li>
<li><p>﻿实现</p>
<ul>
<li>在操作系统内核：存储&#x2F;卷管理</li>
<li>RAID硬件控制器 (I&#x2F;0)</li>
</ul>
</li>
</ul>
<h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><ul>
<li>﻿读取或写入时，磁头必须被定位在期望的磁道，并从所期望的扇区的开始</li>
<li>﻿寻道时间<ul>
<li>定位到期望的磁道所花费的时间</li>
</ul>
</li>
<li>﻿旋转延迟<ul>
<li>从扇区的开始处到到达目的处花费的时间</li>
</ul>
</li>
</ul>
<h4 id="SCAN"><a href="#SCAN" class="headerlink" title="SCAN"></a>SCAN</h4><p>对于扫描算法，磁臂从磁盘的一端开始，向另一端移动；在移过每个柱面时，处理请求。当到达磁盘的另一端时，磁头移动方向反转，并继续处理。磁头连续来回扫描磁盘。SCAN 算法有时称为电梯算法，因为磁头的行为就像大楼里面的电梯，先处理所有向上的请求，然后再处理相反方向的请求。</p>
<h4 id="C-LOOK"><a href="#C-LOOK" class="headerlink" title="C-LOOK"></a>C-LOOK</h4><p>基于SCAN算法，C-LOOK移动磁头从磁盘一端到磁盘另一端（磁臂只需移到一个方向的最远请求为止），并且处理行程上的请求，然而，当磁头到达另一端时，它立即返回到磁盘<strong>另一端</strong>最远的请求，而并不处理任何回程上的请求，然后从该最远的请求开始，继续往同一方向移动磁盘处理请求。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://Tangjiayang.github.io">donn</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://tangjiayang.github.io/2023/06/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">https://tangjiayang.github.io/2023/06/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/07/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" title="软件工程"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">软件工程</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/02/Redis/" title="Redis"><img class="cover" src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727134719639.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Redis</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/06/20/Linux/" title="Linux"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-20</div><div class="title">Linux</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81ODUzNy8zNTAwMA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/bg.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">donn</div><div class="author-info__description">欢迎访问donn的博客!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Tangjiayang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Tangjiayang" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">小站成立于2023-5-27！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter1-%E6%A6%82%E8%BF%B0"><span class="toc-text">Chapter1 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFOS%EF%BC%9F"><span class="toc-text">什么是OS？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%A7%92%E5%BA%A6%EF%BC%9A"><span class="toc-text">用户角度：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E8%A7%92%E5%BA%A6%EF%BC%9A"><span class="toc-text">资源角度：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kernel%E5%B1%82%E5%86%85%E9%83%A8%E7%BB%84%E4%BB%B6%EF%BC%9A"><span class="toc-text">Kernel层内部组件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OS-Kernel%E7%9A%84%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="toc-text">OS Kernel的特征：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="toc-text">Chapter2 操作系统基础操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="toc-text">2.1 操作系统的启动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E6%9C%BA%E9%A1%BA%E5%BA%8F%EF%BC%9A"><span class="toc-text">开机顺序：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">2.2 中断、异常和系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD-from-%E5%A4%96%E8%AE%BE"><span class="toc-text">中断(from 外设)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">中断的处理过程：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%EF%BC%9A"><span class="toc-text">硬件：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%EF%BC%9A"><span class="toc-text">软件：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8-from-%E4%B8%8D%E8%89%AF%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-text">异常(from 不良的应用程序)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">异常的处理过程：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-from-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-text">系统调用(from 应用程序)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">系统调用的处理过程：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E8%B6%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BE%B9%E7%95%8C%E7%9A%84%E5%BC%80%E9%94%80-%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">跨越操作系统边界的开销(中断、异常、系统调用)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter3-%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">Chapter3 连续式内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E5%86%85%E5%AD%98%E5%88%86%E5%B1%82%E4%BD%93%E7%B3%BB"><span class="toc-text">计算机体系结构及内存分层体系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E9%9D%A2%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%9B%AE%E6%A0%87"><span class="toc-text">操作系统的内存管理方面的四个目标</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%9C%B0%E5%9D%80%E7%94%9F%E6%88%90"><span class="toc-text">地址空间与地址生成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%AE%9A%E4%B9%89"><span class="toc-text">1.地址空间定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9C%B0%E5%9D%80%E7%94%9F%E6%88%90"><span class="toc-text">2.地址生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9C%B0%E5%9D%80%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5"><span class="toc-text">3.地址安全检查</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%9A%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E4%B8%8E%E5%88%86%E5%8C%BA%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-text">连续内存分配：内存碎片与分区的动态分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98"><span class="toc-text">内存碎片问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-text">分区的动态分配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-text">常见分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%80%82%E9%85%8D"><span class="toc-text">第一适配</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E9%80%82%E9%85%8D"><span class="toc-text">最佳适配</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%80%E5%B7%AE%E9%80%82%E9%85%8D"><span class="toc-text">最差适配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%BC%8F%E7%A2%8E%E7%89%87%E6%95%B4%E7%90%86"><span class="toc-text">压缩式碎片整理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E5%BC%8F%E7%A2%8E%E7%89%87%E6%95%B4%E7%90%86"><span class="toc-text">交换式碎片整理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter4-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">Chapter4 非连续式内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">连续内存分配的缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">非连续内存分配的优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">非连续内存分配的缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5"><span class="toc-text">分段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%AE%B5%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-text">程序的分段地址空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%AF%BB%E5%9D%80%E6%96%B9%E6%A1%88"><span class="toc-text">分段寻址方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AE%B5%E8%AE%BF%E9%97%AE%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-text">段访问机制：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5"><span class="toc-text">分页</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-text">分页地址空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E5%AF%BB%E5%9D%80%E6%96%B9%E6%A1%88%E2%80%94%E2%80%94%E9%A1%B5%E8%A1%A8"><span class="toc-text">页寻址方案——页表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">分页机制性能问题：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83%E9%9C%80%E8%A6%812%E6%AC%A1%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE"><span class="toc-text">访问一个内存单元需要2次内存访问</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E5%8F%AF%E8%83%BD%E9%9D%9E%E5%B8%B8%E5%A4%A7"><span class="toc-text">页表可能非常大</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">如何解决？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-text">缓存</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E8%AE%BF%E9%97%AE"><span class="toc-text">间接访问</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E9%A1%B5%E8%A1%A8-%E8%AF%B4%E5%AE%9E%E8%AF%9D%E6%B2%A1%E5%90%AC%E6%98%8E%E7%99%BD%EF%BC%8C%E5%85%88%E6%8C%96%E4%B8%AA%E5%9D%91%EF%BC%8C%E5%9B%9E%E9%A1%BE%E6%97%B6%E5%A1%AB%E4%B8%8A"><span class="toc-text">反向页表(说实话没听明白，先挖个坑，回顾时填上)</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter5-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-text">Chapter5 虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF%EF%BC%9A"><span class="toc-text">覆盖技术：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-text">原理:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%EF%BC%9A"><span class="toc-text">交换技术：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-text">原理:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">问题：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%9A"><span class="toc-text">覆盖与交换的比较：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%AD%98%E6%8A%80%E6%9C%AF%EF%BC%9A"><span class="toc-text">虚存技术：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86-principle-of-locality"><span class="toc-text">程序的局部性原理(principle of locality):</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-text">基本概念：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="toc-text">基本特征：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A"><span class="toc-text">虚拟页式内存管理：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E8%A1%A8%E9%A1%B9%E9%9C%80%E8%A6%81%E5%A2%9E%E5%8A%A0%EF%BC%9A"><span class="toc-text">页表表项需要增加：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">缺页中断处理过程：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E5%A4%87%E5%AD%98%E5%82%A8-Backing-Store"><span class="toc-text">后备存储 Backing Store</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-text">概念：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter6-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">Chapter6 页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">局部页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%9B%AE%E6%A0%87"><span class="toc-text">功能与目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1%E6%9C%80%E4%BC%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">6.1最优页面置换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2FIFO%E7%AE%97%E6%B3%95"><span class="toc-text">6.2FIFO算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95-LRU"><span class="toc-text">6.3最近最久未使用算法(LRU)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4%E6%97%B6%E9%92%9F%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">6.4时钟页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-text">基本思路：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5%E4%BA%8C%E6%AC%A1%E6%9C%BA%E4%BC%9A%E6%B3%95"><span class="toc-text">6.5二次机会法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6%E6%9C%80%E4%B8%8D%E5%B8%B8%E7%94%A8%E6%B3%95"><span class="toc-text">6.6最不常用法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF%EF%BC%9A-1"><span class="toc-text">基本思路：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7Belady%E7%8E%B0%E8%B1%A1"><span class="toc-text">6.7Belady现象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8%E5%B1%80%E9%83%A8%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%81%E5%B7%A5%E4%BD%9C%E9%9B%86%E6%A8%A1%E5%9E%8B"><span class="toc-text">6.8局部页面替换算法的问题、工作集模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-text">全局页面置换算法：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B7%A5%E4%BD%9C%E9%9B%86%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">1.工作集页面置换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BC%BA%E9%A1%B5%E7%8E%87%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">2.缺页率页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E9%85%8D%E7%AD%96%E8%B7%AF%EF%BC%9A"><span class="toc-text">可变分配策路：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%96%E5%8A%A8%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">抖动问题：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter7-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-text">Chapter7 进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1%E8%BF%9B%E7%A8%8B-process-%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="toc-text">7.1进程(process)的描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-text">进程定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84%E6%88%90%EF%BC%9A"><span class="toc-text">进程组成：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%81%94%E7%B3%BB%EF%BC%9A"><span class="toc-text">进程与程序的联系：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">进程与程序的区别：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">进程的特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-text">进程控制结构：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#PCB%E4%B8%AD%E5%8C%85%E5%90%AB%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%9A"><span class="toc-text">PCB中包含的内容：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PCB%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-text">PCB的组织方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-text">7.2进程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="toc-text">进程生命周期管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-text">进程创建</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%95%E8%B5%B7%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E4%B8%89%E4%B8%AA%E4%B8%BB%E8%A6%81%E4%BA%8B%E4%BB%B6%EF%BC%9A"><span class="toc-text">引起进程创建的三个主要事件：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C"><span class="toc-text">进程运行</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E9%80%89%E6%8B%A9%E4%B8%80%E4%B8%AA%E5%B0%B1%E7%BB%AA%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%8C%E8%AE%A9%E5%AE%83%E5%8D%A0%E7%94%A8%E5%A4%84%E7%90%86%E6%9C%BA%E5%B9%B6%E6%89%A7%E8%A1%8C"><span class="toc-text">内核选择一个就绪的进程，让它占用处理机并执行</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85"><span class="toc-text">进程等待</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%A5%E4%B8%8B%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85%EF%BC%9A"><span class="toc-text">以下情况下，进程等待：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%94%A4%E9%86%92"><span class="toc-text">进程唤醒</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%94%A4%E9%86%92%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="toc-text">唤醒进程的原因：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9D%9F"><span class="toc-text">进程结束</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%A8%E4%BB%A5%E4%B8%8B%E5%9B%9B%E7%A7%8D%E6%83%85%E5%BD%A2%E4%B8%8B%EF%BC%8C%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9D%9F%EF%BC%9A"><span class="toc-text">在以下四种情形下，进程结束：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E6%A8%A1%E5%9E%8B"><span class="toc-text">进程状态变化模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-text">进程的三种基本状态：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%85%B6%E5%AE%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-text">进程其它的基本状态：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8C%82%E8%B5%B7%E6%A8%A1%E5%9E%8B"><span class="toc-text">进程挂起模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-text">挂起状态：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7-Suspend%EF%BC%89%EF%BC%9A%E6%8A%8A%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%BB%8E%E5%86%85%E5%AD%98%E8%BD%AC%E5%88%B0%E5%A4%96%E5%AD%98%EF%BC%9B%E5%8F%AF%E8%83%BD%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A"><span class="toc-text">挂起 (Suspend）：把一个进程从内存转到外存；可能有以下几种情况：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E5%A4%96%E5%AD%98%E6%97%B6%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%EF%BC%9A"><span class="toc-text">在外存时的状态转换：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%8C%82-x2F-%E6%BF%80%E6%B4%BB-Activate%EF%BC%89%EF%BC%9A%E6%8A%8A%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%BB%8E%E5%A4%96%E5%AD%98%E8%BD%AC%E5%88%B0%E5%86%85%E5%AD%98%EF%BC%9B%E5%8F%AF%E8%83%BD%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A"><span class="toc-text">解挂&#x2F;激活 (Activate）：把一个进程从外存转到内存；可能有以下几种情况：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#OS%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87PCB%E5%AE%8C%E6%88%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%EF%BC%9F"><span class="toc-text">OS如何通过PCB完成进程的调度？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%F0%9F%8C%9F%E7%8A%B6%E6%80%81%E9%98%9F%E5%88%97"><span class="toc-text">🌟状态队列</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3%E7%BA%BF%E7%A8%8B"><span class="toc-text">7.3线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-text">为什么需要线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-text">什么是线程？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">线程的优点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">线程的缺点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%89%80%E9%9C%80%E7%9A%84%E8%B5%84%E6%BA%90%EF%BC%9A"><span class="toc-text">线程所需的资源：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">线程与进程的比较</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-text">线程的实现：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%8C%9F%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%EF%BC%9A"><span class="toc-text">🌟用户线程：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">用户线程的优点：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">用户线程的缺点：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%8C%9F%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%EF%BC%9A"><span class="toc-text">🌟内核线程：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%8C%9F%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%BF%9B%E7%A8%8B-%E4%BA%86%E8%A7%A3"><span class="toc-text">🌟轻量级进程(了解)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-text">7.4上下文切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">7.5进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="toc-text">创建进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C%E8%BF%9B%E7%A8%8B"><span class="toc-text">加载和执行进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E5%92%8C%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B"><span class="toc-text">等待和终止进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE%EF%BC%9A"><span class="toc-text">进程状态图：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter8-CPU%E8%B0%83%E5%BA%A6"><span class="toc-text">Chapter8 CPU调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1%E8%83%8C%E6%99%AF"><span class="toc-text">8.1背景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU%E8%B0%83%E5%BA%A6"><span class="toc-text">CPU调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU%E8%B0%83%E5%BA%A6%E6%97%B6%E9%97%B4"><span class="toc-text">CPU调度时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2%E8%B0%83%E5%BA%A6%E5%87%86%E5%88%99"><span class="toc-text">8.2调度准则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-text">调度策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B"><span class="toc-text">程序执行模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E5%87%86%E5%88%99"><span class="toc-text">比较调度算法的准则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-CPU%E4%BD%BF%E7%94%A8%E7%8E%87"><span class="toc-text">1.CPU使用率</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-text">2.吞吐量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%91%A8%E8%BD%AC%E6%97%B6%E9%97%B4"><span class="toc-text">3.周转时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4"><span class="toc-text">4.等待时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4"><span class="toc-text">5.响应时间</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8Fvs%E5%BB%B6%E8%BF%9F"><span class="toc-text">吞吐量vs延迟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-text">公平的目标</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">8.3调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-FCFS"><span class="toc-text">1.先来先服务(FCFS)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-1"><span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%9F%AD%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88-x2F-%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="toc-text">2.短进程优先&#x2F;短剩余时间优先</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-1"><span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-2"><span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9C%80%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88"><span class="toc-text">3.最高响应比优先</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-2"><span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-3"><span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%BD%AE%E8%AF%A2-RR"><span class="toc-text">4.轮询(RR)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97"><span class="toc-text">5.多级反馈队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-3"><span class="toc-text">优点：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%85%AC%E5%B9%B3%E5%85%B1%E4%BA%AB%E9%98%9F%E5%88%97"><span class="toc-text">6.公平共享队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="toc-text">8.4实时调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-text">背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%87%86%E5%88%99"><span class="toc-text">调度准则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6"><span class="toc-text">8.5多处理器调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC"><span class="toc-text">8.6优先级反转</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter9-%E5%90%8C%E6%AD%A5"><span class="toc-text">Chapter9 同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%EF%BC%9A"><span class="toc-text">背景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-text">一些概念：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-text">原子操作：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Critical-section-%EF%BC%88%E4%B8%B4%E7%95%8C%E5%8C%BA%EF%BC%89"><span class="toc-text">Critical section （临界区）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mutual-exclusion-%EF%BC%88%E4%BA%92%E6%96%A5%EF%BC%89"><span class="toc-text">Mutual exclusion （互斥）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dead-lock-%EF%BC%88%E6%AD%BB%E9%94%81%EF%BC%89"><span class="toc-text">Dead lock （死锁）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Starvation%EF%BC%88%E9%A5%A5%E9%A5%BF%EF%BC%89"><span class="toc-text">Starvation（饥饿）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Critical-section-%E4%B8%B4%E7%95%8C%E5%8C%BA%EF%BC%89"><span class="toc-text">Critical section  (临界区）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mutual-exclusion%EF%BC%88%E4%BA%92%E6%96%A5%EF%BC%89"><span class="toc-text">Mutual exclusion（互斥）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%AF%B9%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BF%9D%E6%8A%A4"><span class="toc-text">实现对临界区代码的保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%881%E2%80%94%E2%80%94%E7%A6%81%E7%94%A8%E7%A1%AC%E4%BB%B6%E4%B8%AD%E6%96%AD%EF%BC%9A"><span class="toc-text">方案1——禁用硬件中断：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-4"><span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%882%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">方案2——基于软件的解决方案:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%883%E2%80%94%E2%80%94%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E6%8A%BD%E8%B1%A1%EF%BC%9A"><span class="toc-text">方案3——更高级的抽象：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-4"><span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-5"><span class="toc-text">缺点：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter10-%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8C%E7%AE%A1%E7%A8%8B"><span class="toc-text">Chapter10 信号量和管程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%EF%BC%9A-1"><span class="toc-text">背景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%9A"><span class="toc-text">信号量：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">信号量缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B"><span class="toc-text">管程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-text">经典同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E8%80%85%E2%80%94%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">读者—写者问题：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E8%80%85%E4%BC%98%E5%85%88%E5%AE%9E%E7%8E%B0-%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%96%B9%E5%BC%8F-%EF%BC%9A"><span class="toc-text">读者优先实现(使用信号量方式)：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">哲学家就餐问题：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter11-%E6%AD%BB%E9%94%81"><span class="toc-text">Chapter11 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">死锁问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B%EF%BC%9A"><span class="toc-text">系统模型：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-text">可重复使用的资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%B5%84%E6%BA%90"><span class="toc-text">使用资源</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="toc-text">死锁特征：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81-%E4%BA%92%E6%96%A5%EF%BC%9A"><span class="toc-text">1、 互斥：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%8D%A0%E7%94%A8%E5%B9%B6%E7%AD%89%E5%BE%85%EF%BC%9A"><span class="toc-text">2、占用并等待：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%97%A0%E6%8A%A2%E5%8D%A0"><span class="toc-text">3、无抢占:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85"><span class="toc-text">4、循环等待:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">死锁处理方法：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2%EF%BC%9A"><span class="toc-text">死锁预防：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D%EF%BC%9A"><span class="toc-text">死锁避免：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95-%E9%80%9A%E8%BF%87%E5%90%88%E7%90%86%E5%88%86%E9%85%8D%E8%B5%84%E6%BA%90%E4%BD%BF%E5%BE%97%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="toc-text">银行家算法(通过合理分配资源使得死锁避免)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%EF%BC%9A"><span class="toc-text">死锁检测：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D%EF%BC%9A"><span class="toc-text">死锁恢复：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter12%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-IPC%E2%80%94%E2%80%94Inter-Process-Communication"><span class="toc-text">Chapter12进程间通信(IPC——Inter Process Communication)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B"><span class="toc-text">通信模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E4%B8%8E%E9%97%B4%E6%8E%A5%E9%80%9A%E4%BF%A1"><span class="toc-text">直接与间接通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E9%80%9A%E4%BF%A1"><span class="toc-text">直接通信:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E9%80%9A%E4%BF%A1"><span class="toc-text">间接通信:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%9A"><span class="toc-text">阻塞与非阻塞：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E7%BC%93%E5%86%B2%EF%BC%9A"><span class="toc-text">通信链路缓冲：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-text">信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-text">管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-text">共享内存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter13-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">Chapter13 文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E6%96%87%E4%BB%B6"><span class="toc-text">文件系统和文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="toc-text">文件系统的功能：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E5%9D%97%EF%BC%9A"><span class="toc-text">文件和块：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-text">文件描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-text">目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D"><span class="toc-text">文件别名</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-text">基本概念</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%8D%E7%B1%BB"><span class="toc-text">文件系统种类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">虚拟文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%9D%97%E7%BC%93%E5%AD%98"><span class="toc-text">数据块缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">打开文件的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D"><span class="toc-text">文件分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E5%88%97%E8%A1%A8"><span class="toc-text">空闲空间列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86-RAID"><span class="toc-text">多磁盘管理 -RAID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6"><span class="toc-text">磁盘调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SCAN"><span class="toc-text">SCAN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-LOOK"><span class="toc-text">C-LOOK</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/09/02/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93-%E4%B8%BB%E7%AE%A1%E9%9D%A2%E9%97%AE%E9%A2%98/" title="2023秋招总结-主管面问题"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2023秋招总结-主管面问题"/></a><div class="content"><a class="title" href="/2023/09/02/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93-%E4%B8%BB%E7%AE%A1%E9%9D%A2%E9%97%AE%E9%A2%98/" title="2023秋招总结-主管面问题">2023秋招总结-主管面问题</a><time datetime="2023-09-02T02:58:52.000Z" title="Created 2023-09-02 10:58:52">2023-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/02/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93-%E5%9C%BA%E6%99%AF%E9%A2%98/" title="2023秋招总结-场景题"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2023秋招总结-场景题"/></a><div class="content"><a class="title" href="/2023/09/02/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93-%E5%9C%BA%E6%99%AF%E9%A2%98/" title="2023秋招总结-场景题">2023秋招总结-场景题</a><time datetime="2023-09-02T02:58:18.000Z" title="Created 2023-09-02 10:58:18">2023-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/18/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93-%E5%85%AB%E8%82%A1/" title="2023秋招总结-八股"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2023秋招总结-八股"/></a><div class="content"><a class="title" href="/2023/08/18/2023%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93-%E5%85%AB%E8%82%A1/" title="2023秋招总结-八股">2023秋招总结-八股</a><time datetime="2023-08-18T07:55:02.000Z" title="Created 2023-08-18 15:55:02">2023-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/15/Redis%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/" title="Redis原理学习"><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230727134719639.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis原理学习"/></a><div class="content"><a class="title" href="/2023/08/15/Redis%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/" title="Redis原理学习">Redis原理学习</a><time datetime="2023-08-15T08:10:37.000Z" title="Created 2023-08-15 16:10:37">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/10/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/" title="java基础复习"><img src="https://cdn.jsdelivr.net/gh/Tangjiayang/picodemo/img/image-20230810141014749.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java基础复习"/></a><div class="content"><a class="title" href="/2023/08/10/java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/" title="java基础复习">java基础复习</a><time datetime="2023-08-10T06:08:10.000Z" title="Created 2023-08-10 14:08:10">2023-08-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 By donn</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">很高兴认识你🤪</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>